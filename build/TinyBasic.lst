ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 1.
Hexadecimal [24-Bits]



                                      1 ;;
                                      2 ; Copyright Jacques Deschênes 2019,2020 
                                      3 ; This file is part of PABasic 
                                      4 ;
                                      5 ;     PABasic is free software: you can redistribute it and/or modify
                                      6 ;     it under the terms of the GNU General Public License as published by
                                      7 ;     the Free Software Foundation, either version 3 of the License, or
                                      8 ;     (at your option) any later version.
                                      9 ;
                                     10 ;     PABasic is distributed in the hope that it will be useful,
                                     11 ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                     12 ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                     13 ;     GNU General Public License for more details.
                                     14 ;
                                     15 ;     You should have received a copy of the GNU General Public License
                                     16 ;     along with PABasic.  If not, see <http://www.gnu.org/licenses/>.
                                     17 ;;
                                     18 ;--------------------------------------
                                     19 ;   Implementation of Tiny BASIC
                                     20 ;   REF: https://en.wikipedia.org/wiki/Li-Chen_Wang#Palo_Alto_Tiny_BASIC
                                     21 ;   Palo Alto BASIC is 4th version of TinyBasic
                                     22 ;   DATE: 2019-12-17
                                     23 ;
                                     24 ;--------------------------------------------------
                                     25 
                                     26     .module STM8_TBI
                                     27 
                                        	.include "inc/nucleo_8s208.inc"
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of MONA 
                                        ;
                                        ;     MONA is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     MONA is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with MONA.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ; NUCLEO-8S208RB board specific definitions
                                        ; Date: 2019/10/29
                                        ; author: Jacques Deschênes, copyright 2018,2019
                                        ; licence: GPLv3
                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        
                                        ; mcu on board is stm8s208rbt6
                                        
                                        ; crystal on board is 8Mhz
                                 
                                        
                                        ; LED2 is user LED
                                        ; connected to PC5 via Q2 -> 2N7002 MOSFET
                                 
                                 
                                 
                                        
                                        ; B1 on schematic is user button
                                        ; connected to PE4
                                        ; external pullup resistor R6 4k7 and debounce capacitor C5 100nF
                                 
                                 
                                 
                                        
                                        
                                        	.include "inc/stm8s208.inc"
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of MONA 
                                        ;
                                        ;     MONA is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     MONA is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with MONA.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ; 2019/10/18
                                        ; STM8S208RB µC registers map
                                        ; sdas source file
                                        ; author: Jacques Deschênes, copyright 2018,2019
                                        ; licence: GPLv3
                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        	.module stm8s208rb
                                        
                                        ;;;;;;;;;;;;
                                        ; bits
                                        ;;;;;;;;;;;;
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                         	
                                        ;;;;;;;;;;;;
                                        ; bits masks
                                        ;;;;;;;;;;;;
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; HSI oscillator frequency 16Mhz
                                 
                                        ; LSI oscillator frequency 128Khz
                                 
                                        
                                        ; controller memory regions
                                 
                                 
                                        ; STM8S208RB have 128K flash
                                 
                                        ; erase block size 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; options bytes
                                        ; this one can be programmed only from SWIM  (ICP)
                                 
                                        ; these can be programmed at runtime (IAP)
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; option registers usage
                                        ; read out protection, value 0xAA enable ROP
                                 
                                        ; user boot code, {0..0x3e} 512 bytes row
                                 
                                 
                                        ; alternate function register
                                 
                                 
                                        ; miscelinous options
                                 
                                 
                                        ; clock options
                                 
                                 
                                        ; HSE clock startup delay
                                 
                                 
                                        ; flash wait state
                                 
                                 
                                        
                                        ; watchdog options bits
                                 
                                 
                                 
                                 
                                        ; NWDGOPT bits
                                 
                                 
                                 
                                 
                                        
                                        ; CLKOPT bits
                                 
                                 
                                 
                                 
                                        
                                        ; AFR option, remapable functions
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; device ID = (read only)
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        
                                 
                                 
                                        ; PORTS SFR OFFSET
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; GPIO
                                        ; gpio register offset to base
                                 
                                 
                                 
                                 
                                 
                                 
                                         
                                        ; port A
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port B
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port C
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port D
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port E
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port F
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port G
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port H not present on LQFP48/LQFP64 package
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port I ; only bit 0 on LQFP64 package, not present on LQFP48
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; input modes CR1
                                 
                                 
                                        ; output mode CR1
                                 
                                 
                                        ; input modes CR2
                                 
                                 
                                        ; output speed CR2
                                 
                                 
                                        
                                        
                                        ; Flash memory
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; data memory unlock keys
                                 
                                 
                                        ; flash memory unlock keys
                                 
                                 
                                        ; FLASH_CR1 bits
                                 
                                 
                                 
                                 
                                        ; FLASH_CR2 bits
                                 
                                 
                                 
                                 
                                 
                                        ; FLASH_FPR bits
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; FLASH_NFPR bits
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; FLASH_IAPSR bits
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Interrupt control
                                 
                                 
                                        
                                        ; Reset Status
                                 
                                        
                                        ; Clock Registers
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Peripherals clock gating
                                        ; CLK_PCKENR1 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; CLK_PCKENR2
                                 
                                 
                                 
                                        
                                        ; Clock bits
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                        ; clock source
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Watchdog
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                         
                                 
                                 
                                 
                                 
                                        
                                        
                                        
                                        ; Beeper
                                        ; beeper output is alternate function AFR7 on PD4
                                        ; connected to CN9-6
                                 
                                 
                                 
                                 
                                        
                                        ; SPI
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; SPI_CR1 bit fields 
                                 
                                 
                                 
                                 
                                 
                                 
                                          
                                        ; SPI_CR2 bit fields 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; SPI_SR bit fields 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; I2C
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                        
                                        ; Precalculated values, all in KHz
                                 
                                 
                                        ;
                                        ; Fast I2C mode max rise time = 300ns
                                        ; I2C_FREQR = 16 = (MHz) => tMASTER = 1/16 = 62.5 ns
                                        ; TRISER = = (300/62.5) + 1 = floor(4.8) + 1 = 5.
                                        
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                        ;
                                        ; Standard I2C mode max rise time = 1000ns
                                        ; I2C_FREQR = 16 = (MHz) => tMASTER = 1/16 = 62.5 ns
                                        ; TRISER = = (1000/62.5) + 1 = floor(16) + 1 = 17.
                                        
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                        
                                        ; baudrate constant for brr_value table access
                                        ; to be used by uart_init 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; UART registers offset from
                                        ; base address 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; uart identifier
                                        ; to be used by uart_init
                                 
                                 
                                        
                                        ; pins used by uart 
                                 
                                 
                                 
                                 
                                        ; uart port base address 
                                 
                                 
                                        
                                        ; UART1 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; UART3
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; UART Status Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Uart Control Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        ; LIN mode config register
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; TIMERS
                                        ; Timer 1 - 16-bit timer with complementary PWM outputs
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Control Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Slave Mode Control bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer External Trigger Enable bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Interrupt Enable bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Status Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Event Generation Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 1 - channel configured in output
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 1 - channel configured in input
                                 
                                 
                                 
                                 
                                 
                                 
                                        ;  TIM1_CCMR1_CC1S1 = (1)
                                 
                                        
                                        ; Capture/Compare Mode Register 2 - channel configured in output
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 2 - channel configured in input
                                 
                                 
                                 
                                 
                                 
                                 
                                        ;  TIM1_CCMR2_CC2S1 = (1)
                                 
                                        
                                        ; Capture/Compare Mode Register 3 - channel configured in output
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 3 - channel configured in input
                                 
                                 
                                 
                                 
                                 
                                 
                                        ;  TIM1_CCMR3_CC3S1 = (1)
                                 
                                        
                                        ; Capture/Compare Mode Register 4 - channel configured in output
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 4 - channel configured in input
                                 
                                 
                                 
                                 
                                 
                                 
                                        ;  TIM1_CCMR4_CC4S1 = (1)
                                 
                                        
                                        ; Timer 2 - 16-bit timer
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; TIM2_CR1 bitfields
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; TIMER2_CCMR bitfields 
                                 
                                 
                                 
                                        
                                        ; TIMER2_CCER1 bitfields
                                 
                                 
                                 
                                 
                                        
                                        ; TIMER2_EGR bitfields
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer 3
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; TIM3_CR1  fields
                                 
                                 
                                 
                                 
                                 
                                        ; TIM3_CCR2  fields
                                 
                                 
                                 
                                        ; TIM3_CCER1 fields
                                 
                                 
                                 
                                 
                                        ; TIM3_CCER2 fields
                                 
                                 
                                        
                                        ; Timer 4
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer 4 bitmasks
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                        
                                 
                                        
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; ADC2
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                         
                                        ; ADC bitmasks
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                        
                                        ; beCAN
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        
                                        ; CPU
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; global configuration register
                                 
                                 
                                 
                                        
                                        ; interrupt control registers
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; SWIM, control and status register
                                 
                                        ; debug registers
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Interrupt Numbers
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Interrupt Vectors
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Condition code register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        	.include "inc/ascii.inc"
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of MONA 
                                        ;
                                        ;     MONA is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     MONA is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with MONA.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        
                                        ;-------------------------------------------------------
                                        ;     ASCII control  values
                                        ;     CTRL_x   are VT100 keyboard values  
                                        ; REF: https://en.wikipedia.org/wiki/ASCII    
                                        ;-------------------------------------------------------
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        	.include "inc/gen_macros.inc" 
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of STM8_NUCLEO 
                                        ;
                                        ;     STM8_NUCLEO is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     STM8_NUCLEO is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with STM8_NUCLEO.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        ;--------------------------------------
                                        ;   console Input/Output module
                                        ;   DATE: 2019-12-11
                                        ;    
                                        ;   General usage macros.   
                                        ;
                                        ;--------------------------------------
                                        
                                            ; reserve space on stack
                                            ; for local variabls
                                            .macro _vars n 
                                            
                                            ; free space on stack
                                            .macro _drop n 
                                        
                                            ; declare ARG_OFS for arguments 
                                            ; displacement on stack. This 
                                            ; value depend on local variables 
                                            ; size.
                                            .macro _argofs n 
                                        
                                            ; declare a function argument 
                                            ; position relative to stack pointer 
                                            ; _argofs must be called before it.
                                            .macro _arg name ofs 
                                        	.include "tbi_macros.inc" 
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of STM8_NUCLEO 
                                        ;
                                        ;     STM8_NUCLEO is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     STM8_NUCLEO is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with STM8_NUCLEO.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        ;--------------------------------------
                                 
                                 
                                                ; keyword types 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                        
                                        ;--------------------------------------
                                        ;   constantes related to Arduino 
                                        ;   API mapping 
                                        ;-------------------------------------
                                 
                                 
                                        
                                        ;--------------------------------------
                                        ;       token attribute
                                        ;--------------------------------------
                                                ; bits 4:5 identify token group 
                                                ; 0x0n -> miscelinous 
                                                ; 0x1n -> +|- operators 
                                                ; 0x2n -> *|/|% operators
                                                ; 0x3n -> relational operators 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                                ; don't change these token values 
                                                ; values chosen to be used as a mask.
                                                ; bit 7   1 for dictionary words else 0 
                                                ; bits 6  always 0 
                                                ; bits 5:4 identify group 
                                                ; bits 3:0 token identifier inside group  
                                 
                                 
                                 
                                 
                                 
                                 
                                                ; token groups 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ;--------------------------------------
                                        ;   error codes 
                                        ;--------------------------------------
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ;--------------------------------------
                                        ;   assembler flags 
                                        ;-------------------------------------
                                 
                                        
                                 
                                        
                                            .macro _usec_dly n 
                                            
                                            ; load X register with 
                                            ; entry point of dictionary
                                            ; before calling 'search_dict'
                                            .macro _ldx_dict dict_name
                                        
                                            ; reset BASIC pointer
                                            ; to beginning of last token
                                            ; parsed 
                                            .macro _unget_token 
                                        
                                        ;-------------------------------
                                        ;  macros used to help debugging
                                        ;-------------------------------
                                 
                                            .macro _dbg 
                                        
                                            .macro _nodbg
                                        
                                 
                                 
                                 
                                 
                                            .macro _dbg_save_regs 
                                        
                                            .macro _dbg_restore_regs 
                                        
                                            .macro _dbg_getc 
                                        
                                            .macro _dbg_putc 
                                        
                                            .macro _dbg_puts 
                                        
                                            .macro _dbg_prti24 
                                        
                                            .macro _dbg_prt_regs
                                        
                                            .macro _dbg_peek addr 
                                        
                                            .macro _dbg_parser_init 
                                        
                                            .macro _dbg_readln
                                        
                                            .macro _dbg_number
                                        
                                            .macro _dbg_nextword
                                        
                                            .macro _dbg_dots 
                                        
                                            .macro _dbg_trap
                                        
                                            .macro _dbg_mark n  
                                            
                                            .macro _dbg_prt_var var 
                                        
                                            .macro _dbg_show 
                                        
                                            ; software reset 
                                            .macro _swreset
                                        	.include "cmd_index.inc"
                                        ;;
                                        ; Copyright Jacques Deschênes 2019,2020 
                                        ; This file is part of PABasic 
                                        ;
                                        ;     PABasic is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     PABasic is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with PABasic.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        ;--------------------------------------
                                        
                                        ;---------------------------------------
                                        ; BASIC command and functions indexes
                                        ; for addressing 'code_addr' table
                                        ;--------------------------------------
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                     35     .list 
                                     36 
                                     37 ;_dbg 
                                     38 
                                     39 ;--------------------------------------
                                     40     .area DATA 
                                     41 ;--------------------------------------	
                                     42 
                           0000A0    43 	STACK_SIZE=160
                           0017FF    44 	STACK_EMPTY=RAM_SIZE-1  
                           000000    45 	FRUN=0 ; flags run code in variable flags
                           000001    46 	FTRAP=1 ; inside trap handler 
                           000002    47 	FLOOP=2 ; FOR loop in preparation 
                           000003    48 	FSLEEP=3 ; halt produit par la commande SLEEP 
                           000004    49 	FBREAK=4 ; break point flag 
                           000005    50 	FCOMP=5  ; compiling flags 
                           000006    51 	FAUTORUN=6; auto start program running 
                                     52 
                           004000    53 	AUTORUN_NAME=0x4000 ; address in EEPROM where auto run file name is saved 
                                     54 
                           000006    55     FIRST_DATA_ITEM=6 ; first DATA item offset on line.
                                     56 
                           007FFF    57 	MAX_LINENO=0x7fff; BASIC maximum line number 
                                     58 
                           000008    59 	RX_QUEUE_SIZE=8 
                                     60 
                                     61 
      000000                         62 in.w:  .blkb 1 ; parser position in text line high-byte 
      000001                         63 in:    .blkb 1 ; low byte of in.w 
      000002                         64 in.saved: .blkb 1 ; set by get_token before parsing next token, used by unget_token
      000003                         65 count:: .blkb 1 ; current BASIC line length and tib text length  
      000004                         66 basicptr::  .blkb 2  ; point to current BASIC line address.
      000006                         67 data_ptr:  .blkw 1  ; point to DATA address
      000008                         68 data_ofs:  .blkb 1  ; index to next data item 
      000009                         69 data_len:  .blkb 1  ; length of data line 
      00000A                         70 base:  .blkb 1 ; nemeric base used to print integer 
      00000B                         71 acc24:: .blkb 1 ; 24 bit accumulator upper-byte 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 2.
Hexadecimal [24-Bits]



      00000C                         72 acc16:: .blkb 1 ; 16 bit accumulator, acc24 high-byte
      00000D                         73 acc8::  .blkb 1 ;  8 bit accumulator, acc24 low-byte  
      00000E                         74 ticks: .blkw 1 ; milliseconds ticks counter (see Timer4UpdateHandler)
      000010                         75 timer: .blkw 1 ;  milliseconds count down timer 
      000012                         76 seedx: .blkw 1  ; xorshift 16 seed x  used by RND() function 
      000014                         77 seedy: .blkw 1  ; xorshift 16 seed y  used by RND() funcion
      000016                         78 farptr: .blkb 1 ; 24 bits pointer used by file system, upper-byte
      000017                         79 ptr16:  .blkb 1 ; 16 bits pointer , farptr high-byte 
      000018                         80 ptr8:   .blkb 1 ; 8 bits pointer, farptr low-byte  
      000019                         81 ffree: .blkb 3 ; flash free address ; file system free space pointer
      00001C                         82 txtbgn: .blkw 1 ; tokenized BASIC text beginning address 
      00001E                         83 txtend: .blkw 1 ; tokenized BASIC text end address 
      000020                         84 loop_depth: .blkb 1 ; level of nested loop. Conformity check   
      000021                         85 array_size: .blkw 1 ; array size, free RAM left after BASIC code.  
      000023                         86 flags: .blkb 1 ; various boolean flags
      000024                         87 tab_width: .blkb 1 ; print colon width (default 4)
      000025                         88 rx_queue: .ds RX_QUEUE_SIZE ; UART1 receive circular queue 
      00002D                         89 rx_head:  .blkb 1 ; rx_queue head pointer
      00002E                         90 rx_tail:   .blkb 1 ; rx_queue tail pointer  
      00002F                         91 vars: .blkw 26 ; BASIC variables A-Z, keep it as but last .
                                     92 ; keep 'free_ram' as last variable 
      000063                         93 free_ram: ; from here RAM free for BASIC text 
                                     94 
                                     95 ;;-----------------------------------
                                     96     .area SSEG (ABS)
                                     97 ;; working buffers and stack at end of RAM. 	
                                     98 ;;-----------------------------------
      001690                         99     .org RAM_SIZE-STACK_SIZE-TIB_SIZE-PAD_SIZE 
      001690                        100 tib:: .ds TIB_SIZE             ; transaction input buffer
      0016E0                        101 pad: .ds PAD_SIZE             ; working buffer
      001760                        102 stack_full: .ds STACK_SIZE   ; control stack 
      001800                        103 stack_unf: ; stack underflow ; control_stack bottom 
                                    104 
                                    105 ;;--------------------------------------
                                    106     .area HOME 
                                    107 ;; interrupt vector table at 0x8000
                                    108 ;;--------------------------------------
      000000 82 00 05 D8            109     int cold_start			; RESET vector 
                           000000   110 .if DEBUG
                                    111 	int TrapHandler 		;TRAP  software interrupt
                           000001   112 .else
      000004 82 00 00 00            113 	int NonHandledInterrupt ;TRAP  software interrupt
                                    114 .endif
      000008 82 00 00 00            115 	int NonHandledInterrupt ;int0 TLI   external top level interrupt
      00000C 82 00 00 01            116 	int AWUHandler          ;int1 AWU   auto wake up from halt
      000010 82 00 00 00            117 	int NonHandledInterrupt ;int2 CLK   clock controller
      000014 82 00 00 00            118 	int NonHandledInterrupt ;int3 EXTI0 gpio A external interrupts
      000018 82 00 00 00            119 	int NonHandledInterrupt ;int4 EXTI1 gpio B external interrupts
      00001C 82 00 00 00            120 	int NonHandledInterrupt ;int5 EXTI2 gpio C external interrupts
      000020 82 00 00 00            121 	int NonHandledInterrupt ;int6 EXTI3 gpio D external interrupts
      000024 82 00 00 65            122 	int UserButtonHandler   ;int7 EXTI4 gpio E external interrupts
      000028 82 00 00 00            123 	int NonHandledInterrupt ;int8 beCAN RX interrupt
      00002C 82 00 00 00            124 	int NonHandledInterrupt ;int9 beCAN TX/ER/SC interrupt
      000030 82 00 00 00            125 	int NonHandledInterrupt ;int10 SPI End of transfer
      000034 82 00 00 00            126 	int NonHandledInterrupt ;int11 TIM1 update/overflow/underflow/trigger/break
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 3.
Hexadecimal [24-Bits]



      000038 82 00 00 00            127 	int NonHandledInterrupt ;int12 TIM1 capture/compare
      00003C 82 00 00 00            128 	int NonHandledInterrupt ;int13 TIM2 update /overflow
      000040 82 00 00 00            129 	int NonHandledInterrupt ;int14 TIM2 capture/compare
      000044 82 00 00 00            130 	int NonHandledInterrupt ;int15 TIM3 Update/overflow
      000048 82 00 00 00            131 	int NonHandledInterrupt ;int16 TIM3 Capture/compare
      00004C 82 00 00 00            132 	int NonHandledInterrupt ;int17 UART1 TX completed
      000050 82 00 00 0F            133 	int Uart1RxHandler		;int18 UART1 RX full ; user communication channel.
      000054 82 00 00 00            134 	int NonHandledInterrupt ;int19 I2C 
      000058 82 00 00 00            135 	int NonHandledInterrupt ;int20 UART1 TX completed
      00005C 82 00 00 00            136 	int NonHandledInterrupt ;int21 UART1 RX full
      000060 82 00 00 00            137 	int NonHandledInterrupt ;int22 ADC2 end of conversion
      000064 82 00 00 4F            138 	int Timer4UpdateHandler	;int23 TIM4 update/overflow ; used as msec ticks counter
      000068 82 00 00 00            139 	int NonHandledInterrupt ;int24 flash writing EOP/WR_PG_DIS
      00006C 82 00 00 00            140 	int NonHandledInterrupt ;int25  not used
      000070 82 00 00 00            141 	int NonHandledInterrupt ;int26  not used
      000074 82 00 00 00            142 	int NonHandledInterrupt ;int27  not used
      000078 82 00 00 00            143 	int NonHandledInterrupt ;int28  not used
      00007C 82 00 00 00            144 	int NonHandledInterrupt ;int29  not used
                                    145 
                                    146 ;---------------------------------------
                                    147     .area CODE
                                    148 ;---------------------------------------
                           000000   149 .if DEBUG
                                    150 .asciz "STM8_TBI" ; I like to put module name here.
                                    151 .endif 
                                    152 
                                    153 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    154 ; non handled interrupt 
                                    155 ; reset MCU
                                    156 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
      000000                        157 NonHandledInterrupt:
      000000 71                     158     .byte 0x71  ; invalid opcode reinitialize MCU
                                    159 
                                    160 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    161 ; auto wakeup from halt
                                    162 ; at iret, program continue 
                                    163 ; after hatl instruction
                                    164 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      000001                        165 AWUHandler:
      000001 72 19 50 F0      [ 1]  166 	bres AWU_CSR,#AWU_CSR_AWUEN
      000005 55 00 3F 50 F1   [ 1]  167 	mov AWU_APR,0x3F
      00000A 72 5F 50 F2      [ 1]  168 	clr AWU_TBR 
      00000E 80               [11]  169 	iret
                                    170 
                                    171 ;--------------------------
                                    172 ; UART1 receive character
                                    173 ; CTRL-C (ASCII 3)
                                    174 ; cancel program execution
                                    175 ; and fall back to command line
                                    176 ;--------------------------
      00000F                        177 Uart1RxHandler:
      00000F 72 0B 52 30 FB   [ 2]  178 	btjf UART1_SR,#UART_SR_RXNE,.
      000014 C6 52 31         [ 1]  179 	ld a,UART1_DR 
      000017 A1 03            [ 1]  180 	cp a,#CTRL_C 
      000019 26 0B            [ 1]  181 	jrne 1$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 4.
Hexadecimal [24-Bits]



      00001B 72 5F 00 2D      [ 1]  182 	clr rx_head 
      00001F 72 5F 00 2E      [ 1]  183 	clr rx_tail 
      000023 CC 00 78         [ 2]  184 	jp user_interrupted
      000026                        185 1$:
      000026 A1 18            [ 1]  186 	cp a,#CAN ; CTRL_X 
      000028 26 03            [ 1]  187 	jrne 2$
      00002A CC 05 D8         [ 2]  188 	jp cold_start 	
      00002D                        189 2$: 
      00002D A1 1A            [ 1]  190 	cp a,#CTRL_Z
      00002F 26 06            [ 1]  191 	jrne 3$
      000031 CD 06 9A         [ 4]  192 	call cancel_autorun 
      000034 CC 05 D8         [ 2]  193 	jp cold_start 
      000037 AE 00 25         [ 2]  194 3$:	ldw x,#rx_queue  
      00003A 88               [ 1]  195 	push a 
      00003B 9F               [ 1]  196 	ld a,xl 
      00003C CB 00 2E         [ 1]  197 	add a,rx_tail 
      00003F 97               [ 1]  198 	ld xl,a
      000040 84               [ 1]  199 	pop a  
      000041 F7               [ 1]  200 	ld (x),a
      000042 72 5C 00 2E      [ 1]  201 	inc rx_tail 
      000046 A6 07            [ 1]  202 	ld a,#RX_QUEUE_SIZE-1
      000048 C4 00 2E         [ 1]  203 	and a,rx_tail 
      00004B C7 00 2E         [ 1]  204 	ld rx_tail,a  	
      00004E 80               [11]  205 	iret 
                                    206 
                                    207 ;------------------------------------
                                    208 ; software interrupt handler  
                                    209 ;------------------------------------
                           000000   210 .if DEBUG 
                                    211 TrapHandler:
                                    212 	bset flags,#FTRAP 
                                    213 	call print_registers
                                    214 	call cmd_itf
                                    215 	bres flags,#FTRAP 	
                                    216 	iret
                                    217 .endif 
                                    218 
                                    219 ;------------------------------
                                    220 ; TIMER 4 is used to maintain 
                                    221 ; a milliseconds 'ticks' counter
                                    222 ; and decrement 'timer' varaiable
                                    223 ;--------------------------------
      00004F                        224 Timer4UpdateHandler:
      00004F 72 5F 53 42      [ 1]  225 	clr TIM4_SR 
      000053 CE 00 0E         [ 2]  226 	ldw x,ticks
      000056 5C               [ 2]  227 	incw x
      000057 CF 00 0E         [ 2]  228 	ldw ticks,x 
      00005A CE 00 10         [ 2]  229 	ldw x,timer
      00005D 5D               [ 2]  230 	tnzw x 
      00005E 27 04            [ 1]  231 	jreq 1$
      000060 5A               [ 2]  232 	decw x 
      000061 CF 00 10         [ 2]  233 	ldw timer,x 
      000064                        234 1$:	
      000064 80               [11]  235 	iret 
                                    236 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 5.
Hexadecimal [24-Bits]



                                    237 
                                    238 ;------------------------------------
                                    239 ; Triggered by pressing USER UserButton 
                                    240 ; on NUCLEO card.
                                    241 ; This is used to abort a progam lock 
                                    242 ; in infinite loop. 
                                    243 ;------------------------------------
      000065                        244 UserButtonHandler:
                                    245 ; wait button release
      000065 5F               [ 1]  246 	clrw x
      000066 5A               [ 2]  247 1$: decw x 
      000067 26 FD            [ 1]  248 	jrne 1$
      000069 72 09 50 15 F8   [ 2]  249 	btjf USR_BTN_PORT,#USR_BTN_BIT, 1$
                                    250 ; if MCU suspended by SLEEP resume program
      00006E 72 07 00 23 05   [ 2]  251     btjf flags,#FSLEEP,2$
      000073 72 17 00 23      [ 1]  252 	bres flags,#FSLEEP 
      000077 80               [11]  253 	iret
      000078                        254 2$:	
      000078                        255 user_interrupted:
      000078 72 00 00 23 02   [ 2]  256     btjt flags,#FRUN,4$
      00007D 20 13            [ 2]  257 	jra UBTN_Handler_exit 
      00007F                        258 4$:	; program interrupted by user 
      00007F 72 11 00 23      [ 1]  259 	bres flags,#FRUN 
      000083 AE 00 9A         [ 2]  260 	ldw x,#USER_ABORT
      000086 CD 00 00         [ 4]  261 	call puts 
      000089 CE 00 04         [ 2]  262 	ldw x,basicptr 
      00008C C6 00 01         [ 1]  263 	ld a,in 
      00008F CD 14 DC         [ 4]  264 	call prt_basic_line
      000092                        265 UBTN_Handler_exit:
      000092 AE 17 FF         [ 2]  266     ldw x,#STACK_EMPTY 
      000095 94               [ 1]  267     ldw sp,x
      000096 9A               [ 1]  268 	rim 
      000097 CC 09 02         [ 2]  269 	jp warm_start
                                    270 
      00009A 0A 50 72 6F 67 72 61   271 USER_ABORT: .asciz "\nProgram aborted by user.\n"
             6D 20 61 62 6F 72 74
             65 64 20 62 79 20 75
             73 65 72 2E 0A 00
                                    272 
                                    273 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    274 ;    peripherals initialization
                                    275 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    276 
                                    277 ;----------------------------------------
                                    278 ; inialize MCU clock 
                                    279 ; input:
                                    280 ;   A 		source  HSI | 1 HSE 
                                    281 ;   XL      CLK_CKDIVR , clock divisor 
                                    282 ; output:
                                    283 ;   none 
                                    284 ;----------------------------------------
      0000B5                        285 clock_init:	
      0000B5 C1 50 C3         [ 1]  286 	cp a,CLK_CMSR 
      0000B8 27 0C            [ 1]  287 	jreq 2$ ; no switching required 
                                    288 ; select clock source 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 6.
Hexadecimal [24-Bits]



      0000BA 72 12 50 C5      [ 1]  289 	bset CLK_SWCR,#CLK_SWCR_SWEN
      0000BE C7 50 C4         [ 1]  290 	ld CLK_SWR,a
      0000C1 C1 50 C3         [ 1]  291 1$:	cp a,CLK_CMSR
      0000C4 26 FB            [ 1]  292 	jrne 1$
      0000C6                        293 2$: 	
                                    294 ; HSI and cpu clock divisor 
      0000C6 9F               [ 1]  295 	ld a,xl 
      0000C7 C7 50 C6         [ 1]  296 	ld CLK_CKDIVR,a  
      0000CA 81               [ 4]  297 	ret
                                    298 
                                    299 ;----------------------------------
                                    300 ; TIMER2 used as audio tone output 
                                    301 ; on port D:5.
                                    302 ; channel 1 configured as PWM mode 1 
                                    303 ;-----------------------------------  
                           00F424   304 TIM2_CLK_FREQ=62500
      0000CB                        305 timer2_init:
      0000CB 72 1A 50 C7      [ 1]  306 	bset CLK_PCKENR1,#CLK_PCKENR1_TIM2 ; enable TIMER2 clock 
      0000CF 35 60 53 05      [ 1]  307  	mov TIM2_CCMR1,#(6<<TIM2_CCMR_OCM) ; PWM mode 1 
      0000D3 35 08 53 0C      [ 1]  308 	mov TIM2_PSCR,#8 ; 16Mhz/256=62500
      0000D7 81               [ 4]  309 	ret 
                                    310 
                                    311 ;---------------------------------
                                    312 ; TIM4 is configured to generate an 
                                    313 ; interrupt every millisecond 
                                    314 ;----------------------------------
      0000D8                        315 timer4_init:
      0000D8 72 18 50 C7      [ 1]  316 	bset CLK_PCKENR1,#CLK_PCKENR1_TIM4
      0000DC 35 07 53 45      [ 1]  317 	mov TIM4_PSCR,#7 ; prescale 128  
      0000E0 35 7D 53 46      [ 1]  318 	mov TIM4_ARR,#125 ; set for 1msec.
      0000E4 35 05 53 40      [ 1]  319 	mov TIM4_CR1,#((1<<TIM4_CR1_CEN)|(1<<TIM4_CR1_URS))
      0000E8 72 10 53 41      [ 1]  320 	bset TIM4_IER,#TIM4_IER_UIE
      0000EC 81               [ 4]  321 	ret
                                    322 
                                    323 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    324 ;  routines to write to FLASH, EEPROM 
                                    325 ;  and OPTION 
                                    326 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    327 
                                    328 ;----------------------------------
                                    329 ; unlock EEPROM/OPT for writing/erasing
                                    330 ; wait endlessly for FLASH_IAPSR_DUL bit.
                                    331 ; input:
                                    332 ;  none
                                    333 ; output:
                                    334 ;  none 
                                    335 ;----------------------------------
      0000ED                        336 unlock_eeprom:
      0000ED 35 00 50 5B      [ 1]  337 	mov FLASH_CR2,#0 
      0000F1 35 FF 50 5C      [ 1]  338 	mov FLASH_NCR2,#0xFF 
      0000F5 35 AE 50 64      [ 1]  339 	mov FLASH_DUKR,#FLASH_DUKR_KEY1
      0000F9 35 56 50 64      [ 1]  340     mov FLASH_DUKR,#FLASH_DUKR_KEY2
      0000FD 72 07 50 5F FB   [ 2]  341 	btjf FLASH_IAPSR,#FLASH_IAPSR_DUL,.
      000102 81               [ 4]  342 	ret
                                    343 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 7.
Hexadecimal [24-Bits]



                                    344 ;----------------------------------
                                    345 ; unlock FLASH for writing/erasing
                                    346 ; wait endlessly for FLASH_IAPSR_PUL bit.
                                    347 ; input:
                                    348 ;  none
                                    349 ; output:
                                    350 ;  none
                                    351 ;----------------------------------
      000103                        352 unlock_flash:
      000103 35 00 50 5B      [ 1]  353 	mov FLASH_CR2,#0 
      000107 35 FF 50 5C      [ 1]  354 	mov FLASH_NCR2,#0xFF 
      00010B 35 56 50 62      [ 1]  355 	mov FLASH_PUKR,#FLASH_PUKR_KEY1
      00010F 35 AE 50 62      [ 1]  356 	mov FLASH_PUKR,#FLASH_PUKR_KEY2
      000113 72 03 50 5F FB   [ 2]  357 	btjf FLASH_IAPSR,#FLASH_IAPSR_PUL,.
      000118 81               [ 4]  358 	ret
                                    359 
                                    360 ;----------------------------
                                    361 ; erase block code must be 
                                    362 ; executed from RAM
                                    363 ; input:
                                    364 ;-----------------------------
      000119                        365 row_erase:
      000119 35 20 50 5B      [ 1]  366 	mov FLASH_CR2,#(1<<FLASH_CR2_ERASE) 
      00011D 35 DF 50 5C      [ 1]  367 	mov FLASH_NCR2,#~(1<<FLASH_CR2_ERASE)
      000121 4F               [ 1]  368 	clr a 
      000122 90 5F            [ 1]  369 	clrw y 
      000124 91 A7 00 16      [ 1]  370 	ldf ([farptr],y),a
      000128 90 5C            [ 2]  371     incw y
      00012A 91 A7 00 16      [ 1]  372 	ldf ([farptr],y),a
      00012E 90 5C            [ 2]  373     incw y
      000130 91 A7 00 16      [ 1]  374 	ldf ([farptr],y),a
      000134 90 5C            [ 2]  375     incw y
      000136 91 A7 00 16      [ 1]  376 	ldf ([farptr],y),a
      00013A 72 05 50 5F FB   [ 2]  377 	btjf FLASH_IAPSR,#FLASH_IAPSR_EOP,.
      00013F 81               [ 4]  378 	ret
      000140                        379 row_erase_end:
                                    380 
                                    381 ; copy erase_start in RAM 
      000140                        382 move_erase_to_ram:
      000140 AE 01 40         [ 2]  383 	ldw x,#row_erase_end 
      000143 1D 01 19         [ 2]  384 	subw x,#row_erase
      000146 CF 00 0C         [ 2]  385 	ldw acc16,x 
      000149 AE 16 90         [ 2]  386 	ldw x,#tib 
      00014C 90 AE 01 19      [ 2]  387 	ldw y,#row_erase 
      000150 CD 03 C2         [ 4]  388 	call move 
      000153 81               [ 4]  389 	ret 
                                    390 
                                    391 ;-----------------------------------
                                    392 ; block programming must be 
                                    393 ; executed from RAM 
                                    394 ; initial contidions: 
                                    395 ; 	memory unlocked
                                    396 ;   bit PRG set in 
                                    397 ; input:
                                    398 ;   x        128 bytes row to program 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 8.
Hexadecimal [24-Bits]



                                    399 ;   farptr   row address 
                                    400 ; output:
                                    401 ;   none 
                                    402 ;----------------------------------
                           000001   403 	BCNT=1 
      000154                        404 program_row:
      000154 4B 80            [ 1]  405 	push #BLOCK_SIZE  
                                    406 ;enable block programming 
      000156 72 10 50 5B      [ 1]  407 	bset FLASH_CR2,#FLASH_CR2_PRG 
      00015A 72 11 50 5C      [ 1]  408 	bres FLASH_NCR2,#FLASH_CR2_PRG
      00015E 90 5F            [ 1]  409 	clrw y 
      000160 F6               [ 1]  410 1$:	ld a,(x)
      000161 91 A7 00 16      [ 1]  411 	ldf ([farptr],y),a
      000165 5C               [ 2]  412 	incw x 
      000166 90 5C            [ 2]  413 	incw y 
      000168 0A 01            [ 1]  414 	dec (BCNT,sp)
      00016A 26 F4            [ 1]  415 	jrne 1$
                                    416 ; wait EOP bit 
      00016C 72 05 50 5F FB   [ 2]  417 	btjf FLASH_IAPSR,#FLASH_IAPSR_EOP,. 
      000171                        418 	_drop 1 
      000171 5B 01            [ 2]    1     addw sp,#1 
      000173 81               [ 4]  419 	ret 
      000174                        420 program_row_end:
                                    421 
                                    422 ;-------------------------
                                    423 ; move program_row to RAM 
                                    424 ; at txtubound address 
                                    425 ;------------------------
      000174                        426 move_prg_to_ram:
      000174 AE 01 74         [ 2]  427 	ldw x,#program_row_end 
      000177 1D 01 54         [ 2]  428 	subw x,#program_row 
      00017A CF 00 0C         [ 2]  429 	ldw acc16,x 
      00017D AE 16 90         [ 2]  430 	ldw x,#tib 
      000180 90 AE 01 54      [ 2]  431 	ldw y,#program_row 
      000184 CD 03 C2         [ 4]  432 	call move 
      000187 81               [ 4]  433 	ret 
                                    434 
                                    435 
                                    436 ;-----------------------------
                                    437 ; write a row in FLASH/EEPROM 
                                    438 ; input:
                                    439 ;    farptr   destination address 
                                    440 ;    x        source address 
                                    441 ;-----------------------------
      000188                        442 write_row:
      000188 89               [ 2]  443 	pushw x 
      000189 72 5D 00 16      [ 1]  444 	tnz farptr 
      00018D 26 1C            [ 1]  445 	jrne to_flash 
      00018F AE 80 00         [ 2]  446 	ldw x,#FLASH_BASE 
      000192 C3 00 17         [ 2]  447 	cpw x,farptr+1 
      000195 24 14            [ 1]  448 	jruge to_flash 
      000197                        449 to_eeprom:
      000197 AE 40 00         [ 2]  450 	ldw x,#EEPROM_BASE 
      00019A C3 00 17         [ 2]  451 	cpw x,farptr+1 
      00019D 24 01            [ 1]  452 	jruge 1$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 9.
Hexadecimal [24-Bits]



      00019F 81               [ 4]  453 	ret ; bad address 
      0001A0 AE 47 FF         [ 2]  454 1$: ldw x,#EEPROM_END 
      0001A3 23 01            [ 2]  455 	jrule 2$ 
      0001A5 81               [ 4]  456 	ret ; bad address 
      0001A6 CD 00 ED         [ 4]  457 2$:	call unlock_eeprom
      0001A9 20 03            [ 2]  458 	jra do_programming
      0001AB                        459 to_flash:
      0001AB CD 01 03         [ 4]  460 	call unlock_flash 
      0001AE                        461 do_programming:
      0001AE 85               [ 2]  462 	popw x 
      0001AF CD 16 90         [ 4]  463 	call tib
      0001B2 72 13 50 5F      [ 1]  464 	bres FLASH_IAPSR,#FLASH_IAPSR_PUL 
      0001B6 72 17 50 5F      [ 1]  465 	bres FLASH_IAPSR,#FLASH_IAPSR_DUL  
      0001BA 81               [ 4]  466 	ret 
                                    467 
                                    468 
                                    469 ;-----------------------------------
                                    470 ; erase flash or EEPROM block
                                    471 ; a blow is 128 bytes 
                                    472 ; input:
                                    473 ;   farptr  address row begin
                                    474 ; output:
                                    475 ;   none
                                    476 ;--------------------------------------
      0001BB                        477 block_erase:
      0001BB CE 00 17         [ 2]  478 	ldw x,farptr+1
      0001BE A3 28 00         [ 2]  479 	cpw x,#user_space 
      0001C1 2A 17            [ 1]  480 	jrpl erase_flash 
                                    481 ; erase eeprom block
      0001C3 A3 40 00         [ 2]  482 	cpw x,#EEPROM_BASE 
      0001C6 24 01            [ 1]  483 	jruge 1$
      0001C8 81               [ 4]  484 	ret ; bad address 
      0001C9 AE 47 FF         [ 2]  485 1$: ldw x,#EEPROM_END 
      0001CC 23 01            [ 2]  486 	jrule 2$ 
      0001CE 81               [ 4]  487 	ret ; bad address 
      0001CF CD 00 ED         [ 4]  488 2$:	call unlock_eeprom 
      0001D2 CD 16 90         [ 4]  489 	call tib 
      0001D5 72 17 50 5F      [ 1]  490 	bres FLASH_IAPSR,#FLASH_IAPSR_DUL
      0001D9 81               [ 4]  491 	ret 
                                    492 ; erase flash block:
      0001DA                        493 erase_flash:
      0001DA CD 01 03         [ 4]  494 	call unlock_flash 
      0001DD CD 16 90         [ 4]  495 	call tib 
      0001E0 72 13 50 5F      [ 1]  496     bres FLASH_IAPSR,#FLASH_IAPSR_PUL
      0001E4 81               [ 4]  497 	ret 
                                    498 
                                    499 
                                    500 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                    501 ; write a byte to FLASH or EEPROM/OPTION  
                                    502 ; input:
                                    503 ;    a  		byte to write
                                    504 ;    farptr  	address
                                    505 ;    x          farptr[x]
                                    506 ; output:
                                    507 ;    none
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 10.
Hexadecimal [24-Bits]



                                    508 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    509 	; variables locales
                           000001   510 	BTW = 1   ; byte to write offset on stack
                           000002   511 	OPT = 2   ; OPTION flag offset on stack
                           000002   512 	VSIZE = 2
      0001E5                        513 write_byte:
      0001E5 90 89            [ 2]  514 	pushw y
      0001E7                        515 	_vars VSIZE
      0001E7 52 02            [ 2]    1     sub sp,#VSIZE 
      0001E9 6B 01            [ 1]  516 	ld (BTW,sp),a ; byte to write 
      0001EB 0F 02            [ 1]  517 	clr (OPT,sp)  ; OPTION flag
                                    518 ; put addr[15:0] in Y, for bounds check.
      0001ED 90 CE 00 17      [ 2]  519 	ldw y,farptr+1   ; Y=addr15:0
                                    520 ; check addr[23:16], if <> 0 then it is extened flash memory
      0001F1 72 5D 00 16      [ 1]  521 	tnz farptr 
      0001F5 26 14            [ 1]  522 	jrne write_flash
      0001F7 90 A3 28 00      [ 2]  523     cpw y,#user_space
      0001FB 24 0E            [ 1]  524     jruge write_flash
      0001FD 90 A3 40 00      [ 2]  525 	cpw y,#EEPROM_BASE  
      000201 25 52            [ 1]  526     jrult write_exit
      000203 90 A3 48 7F      [ 2]  527 	cpw y,#OPTION_END 
      000207 22 4C            [ 1]  528 	jrugt write_exit
      000209 20 16            [ 2]  529 	jra write_eeprom 
                                    530 ; write program memory
      00020B                        531 write_flash:
      00020B CD 01 03         [ 4]  532 	call unlock_flash 
      00020E 9B               [ 1]  533 1$:	sim 
      00020F 7B 01            [ 1]  534 	ld a,(BTW,sp)
      000211 92 A7 00 16      [ 4]  535 	ldf ([farptr],x),a ; farptr[x]=A
      000215 72 05 50 5F FB   [ 2]  536 	btjf FLASH_IAPSR,#FLASH_IAPSR_EOP,.
      00021A 9A               [ 1]  537     rim 
      00021B 72 13 50 5F      [ 1]  538     bres FLASH_IAPSR,#FLASH_IAPSR_PUL
      00021F 20 34            [ 2]  539     jra write_exit
                                    540 ; write eeprom and option
      000221                        541 write_eeprom:
      000221 CD 00 ED         [ 4]  542 	call unlock_eeprom
                                    543 	; check for data eeprom or option eeprom
      000224 90 A3 48 00      [ 2]  544 	cpw y,#OPTION_BASE
      000228 2B 08            [ 1]  545 	jrmi 1$
      00022A 90 A3 48 80      [ 2]  546 	cpw y,#OPTION_END+1
      00022E 2A 02            [ 1]  547 	jrpl 1$
      000230 03 02            [ 1]  548 	cpl (OPT,sp)
      000232                        549 1$: 
      000232 0D 02            [ 1]  550     tnz (OPT,sp)
      000234 27 08            [ 1]  551     jreq 2$
                                    552 	; pour modifier une option il faut modifier ces 2 bits
      000236 72 1E 50 5B      [ 1]  553     bset FLASH_CR2,#FLASH_CR2_OPT
      00023A 72 1F 50 5C      [ 1]  554     bres FLASH_NCR2,#FLASH_CR2_OPT 
      00023E                        555 2$: 
      00023E 7B 01            [ 1]  556     ld a,(BTW,sp)
      000240 92 A7 00 16      [ 4]  557     ldf ([farptr],x),a
      000244 0D 02            [ 1]  558     tnz (OPT,sp)
      000246 27 08            [ 1]  559     jreq 3$
      000248 5C               [ 2]  560     incw x
      000249 7B 01            [ 1]  561     ld a,(BTW,sp)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 11.
Hexadecimal [24-Bits]



      00024B 43               [ 1]  562     cpl a
      00024C 92 A7 00 16      [ 4]  563     ldf ([farptr],x),a
      000250 72 05 50 5F FB   [ 2]  564 3$: btjf FLASH_IAPSR,#FLASH_IAPSR_EOP,.
      000255                        565 write_exit:
      000255                        566 	_drop VSIZE 
      000255 5B 02            [ 2]    1     addw sp,#VSIZE 
      000257 90 85            [ 2]  567 	popw y
      000259 81               [ 4]  568     ret
                                    569 
                                    570 ;--------------------------------------------
                                    571 ; write a data block to eeprom or flash 
                                    572 ; input:
                                    573 ;   Y        source address   
                                    574 ;   X        array index  destination  farptr[x]
                                    575 ;   BSIZE    block size bytes 
                                    576 ;   farptr   write address , byte* 
                                    577 ; output:
                                    578 ;	X 		after last byte written 
                                    579 ;   Y 		after last byte read 
                                    580 ;  farptr   point after block
                                    581 ;---------------------------------------------
      00025A                        582 	_argofs 2 
                           000004     1     ARG_OFS=2+2 
      00025A                        583 	_arg BSIZE 1  ; block size
                           000005     1     BSIZE=ARG_OFS+1 
                                    584 	; local var 
                           000001   585 	XSAVE=1 
                           000002   586 	VSIZE=2 
      00025A                        587 write_block:
      00025A                        588 	_vars VSIZE
      00025A 52 02            [ 2]    1     sub sp,#VSIZE 
      00025C 1F 01            [ 2]  589 	ldw (XSAVE,sp),x 
      00025E 1E 05            [ 2]  590 	ldw x,(BSIZE,sp) 
      000260 27 13            [ 1]  591 	jreq 9$
      000262 1E 01            [ 2]  592 1$:	ldw x,(XSAVE,sp)
      000264 90 F6            [ 1]  593 	ld a,(y)
      000266 CD 01 E5         [ 4]  594 	call write_byte 
      000269 5C               [ 2]  595 	incw x 
      00026A 90 5C            [ 2]  596 	incw y 
      00026C 1F 01            [ 2]  597 	ldw (XSAVE,sp),x
      00026E 1E 05            [ 2]  598 	ldw x,(BSIZE,sp)
      000270 5A               [ 2]  599 	decw x
      000271 1F 05            [ 2]  600 	ldw (BSIZE,sp),x 
      000273 26 ED            [ 1]  601 	jrne 1$
      000275                        602 9$:
      000275 1E 01            [ 2]  603 	ldw x,(XSAVE,sp)
      000277 CD 19 ED         [ 4]  604 	call incr_farptr
      00027A                        605 	_drop VSIZE
      00027A 5B 02            [ 2]    1     addw sp,#VSIZE 
      00027C 81               [ 4]  606 	ret 
                                    607 
                                    608 
                                    609 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    610 ;;   UART1 subroutines
                                    611 ;;   used for user interface 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 12.
Hexadecimal [24-Bits]



                                    612 ;;   communication channel.
                                    613 ;;   settings: 
                                    614 ;;		115200 8N1 no flow control
                                    615 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    616 
                                    617 ;---------------------------------------------
                                    618 ; initialize UART1, 115200 8N1
                                    619 ; input:
                                    620 ;	none
                                    621 ; output:
                                    622 ;   none
                                    623 ;---------------------------------------------
      00027D                        624 uart1_init:
      00027D 72 1A 50 02      [ 1]  625     bset PA_DDR,#UART1_TX_PIN
      000281 72 1A 50 03      [ 1]  626     bset PA_CR1,#UART1_TX_PIN 
      000285 72 1A 50 04      [ 1]  627     bset PA_CR2,#UART1_TX_PIN 
                                    628 ; enable UART1 clock
      000289 72 14 50 C7      [ 1]  629 	bset CLK_PCKENR1,#CLK_PCKENR1_UART1	
      00028D                        630 uart1_set_baud: 
                                    631 ; baud rate 115200 Fmaster=8Mhz  8000000/115200=69=0x45
                                    632 ; 1) check clock source, HSI at 16Mhz or HSE at 8Mhz  
      00028D A6 E1            [ 1]  633 	ld a,#CLK_SWR_HSI
      00028F C1 50 C3         [ 1]  634 	cp a,CLK_CMSR 
      000292 27 0A            [ 1]  635 	jreq 2$ 
      000294                        636 1$: ; 8 Mhz 	
      000294 35 05 52 33      [ 1]  637 	mov UART1_BRR2,#0x05 ; must be loaded first
      000298 35 04 52 32      [ 1]  638 	mov UART1_BRR1,#0x4
      00029C 20 08            [ 2]  639 	jra 3$
      00029E                        640 2$: ; 16 Mhz 	
      00029E 35 0B 52 33      [ 1]  641 	mov UART1_BRR2,#0x0b ; must be loaded first
      0002A2 35 08 52 32      [ 1]  642 	mov UART1_BRR1,#0x08
      0002A6                        643 3$:
      0002A6 72 5F 52 31      [ 1]  644     clr UART1_DR
      0002AA 35 2C 52 35      [ 1]  645 	mov UART1_CR2,#((1<<UART_CR2_TEN)|(1<<UART_CR2_REN)|(1<<UART_CR2_RIEN));
      0002AE 72 10 52 35      [ 1]  646 	bset UART1_CR2,#UART_CR2_SBK
      0002B2 72 0D 52 30 FB   [ 2]  647     btjf UART1_SR,#UART_SR_TC,.
      0002B7 72 5F 00 2D      [ 1]  648     clr rx_head 
      0002BB 72 5F 00 2E      [ 1]  649 	clr rx_tail 
      0002BF 81               [ 4]  650 	ret
                                    651 
                                    652 ;---------------------------------
                                    653 ; send character to UART1 
                                    654 ; input:
                                    655 ;   A 
                                    656 ; output:
                                    657 ;   none 
                                    658 ;--------------------------------	
      0002C0                        659 putc::
      0002C0 72 0F 52 30 FB   [ 2]  660 	btjf UART1_SR,#UART_SR_TXE,.
      0002C5 C7 52 31         [ 1]  661 	ld UART1_DR,a 
      0002C8 81               [ 4]  662 	ret 
                                    663 
                                    664 ;---------------------------------
                                    665 ; wait character from UART1 
                                    666 ; input:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 13.
Hexadecimal [24-Bits]



                                    667 ;   none
                                    668 ; output:
                                    669 ;   A 			char  
                                    670 ;--------------------------------	
      0002C9                        671 getc::
      0002C9 C6 00 2D         [ 1]  672 	ld a,rx_head 
      0002CC C1 00 2E         [ 1]  673 1$:	cp a,rx_tail 
      0002CF 27 FB            [ 1]  674 	jreq 1$
      0002D1 89               [ 2]  675 	pushw x 
      0002D2 AE 00 25         [ 2]  676 	ldw x,#rx_queue
      0002D5 9F               [ 1]  677 	ld a,xl 
      0002D6 CB 00 2D         [ 1]  678 	add a,rx_head 
      0002D9 97               [ 1]  679 	ld xl,a 
      0002DA F6               [ 1]  680 	ld a,(x)
      0002DB 85               [ 2]  681 	popw x
      0002DC 88               [ 1]  682 	push a
      0002DD 72 5C 00 2D      [ 1]  683 	inc rx_head 
      0002E1 A6 07            [ 1]  684 	ld a,#RX_QUEUE_SIZE-1 
      0002E3 C4 00 2D         [ 1]  685 	and a,rx_head 
      0002E6 C7 00 2D         [ 1]  686 	ld rx_head,a 
      0002E9 84               [ 1]  687 	pop a  
      0002EA 81               [ 4]  688 	ret 
                                    689 
                                    690 ;----------------------
                                    691 ; print token id && value
                                    692 ; input:
                                    693 ;   A     token id 
                                    694 ;   X     token value 
                                    695 ;---------------------
                           000001   696 	BSAVE=1
                           000002   697 	AREG=2
                           000003   698 	XREG=3
                           000004   699 	VSIZE=4
      0002EB                        700 prt_tok:
      0002EB                        701 	_vars VSIZE 
      0002EB 52 04            [ 2]    1     sub sp,#VSIZE 
      0002ED 6B 02            [ 1]  702 	ld (AREG,sp),a 
      0002EF 1F 03            [ 2]  703 	ldw (XREG,sp),x 
      0002F1 C6 00 0A         [ 1]  704 	ld a, base
      0002F4 6B 01            [ 1]  705 	ld (BSAVE,sp),a 
      0002F6 35 10 00 0A      [ 1]  706 	mov base,#16  
      0002FA AE 03 22         [ 2]  707 	ldw x,#token_msg
      0002FD CD 00 00         [ 4]  708 	call puts 
      000300 5F               [ 1]  709 	clrw x 
      000301 7B 02            [ 1]  710 	ld a,(AREG,sp)
      000303 97               [ 1]  711 	ld xl,a 
      000304 CD 09 CA         [ 4]  712 	call print_int 
      000307 A6 20            [ 1]  713 	ld a,#SPACE
      000309 CD 02 C0         [ 4]  714 	call putc 
      00030C 1E 03            [ 2]  715 	ldw x,(XREG,sp)
      00030E CD 09 CA         [ 4]  716 	call print_int 
      000311 A6 0D            [ 1]  717 	ld a,#CR 
      000313 CD 02 C0         [ 4]  718 	call putc 
      000316 7B 01            [ 1]  719 	ld a,(BSAVE,sp)
      000318 C7 00 0A         [ 1]  720 	ld base,a 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 14.
Hexadecimal [24-Bits]



      00031B 7B 02            [ 1]  721 	ld a,(AREG,sp)
      00031D 1E 03            [ 2]  722 	ldw x,(XREG,sp)
      00031F                        723 	_drop VSIZE 
      00031F 5B 04            [ 2]    1     addw sp,#VSIZE 
      000321 81               [ 4]  724 	ret 
      000322 74 6F 6B 65 6E 3A 20   725 token_msg: .asciz "token: "
             00
                                    726 
                                    727 
                                    728 ;---------------------
                                    729 ; display n bytes row 
                                    730 ; from memory.
                                    731 ; input:
                                    732 ;   A   bytes to print 
                                    733 ;	X   start address 
                                    734 ; output:
                                    735 ;   X   address after last shown  
                                    736 ;---------------------
                           000001   737 	CNT=1 
                           000002   738 	ADR=2 
                           000003   739 	VSIZE=3 
      00032A                        740 show_row:
      00032A 4D               [ 1]  741 	tnz a 
      00032B 26 01            [ 1]  742 	jrne 1$
      00032D 81               [ 4]  743 	ret 
      00032E                        744 1$:	
      00032E 89               [ 2]  745 	pushw x  
      00032F 88               [ 1]  746 	push a 
      000330 35 04 00 24      [ 1]  747 	mov tab_width,#4 
      000334 CD 09 CA         [ 4]  748 	call print_int 
      000337 A6 20            [ 1]  749 	ld a,#SPACE  
      000339 CD 02 C0         [ 4]  750 	call putc
      00033C                        751 row_loop:
      00033C 1E 02            [ 2]  752 	ldw x,(ADR,sp)
      00033E F6               [ 1]  753 	ld a,(x)
      00033F 5F               [ 1]  754 	clrw x 
      000340 97               [ 1]  755 	ld xl,a 
      000341 CD 09 CA         [ 4]  756 	call print_int 
      000344 1E 02            [ 2]  757 	ldw x,(ADR,sp)
      000346 5C               [ 2]  758 	incw x 
      000347 1F 02            [ 2]  759 	ldw (ADR,sp),x 
      000349 0A 01            [ 1]  760 	dec (CNT,sp)
      00034B 26 EF            [ 1]  761 	jrne row_loop
      00034D                        762 	_drop VSIZE  		
      00034D 5B 03            [ 2]    1     addw sp,#VSIZE 
      00034F 35 04 00 24      [ 1]  763 	mov tab_width,#4
      000353 A6 0D            [ 1]  764 	ld a,#CR 
      000355 CD 02 C0         [ 4]  765 	call putc 
      000358 81               [ 4]  766 	ret 
                                    767 
                                    768 ;--------------------------
                                    769 ; print memory content 
                                    770 ; in hexadecimal format
                                    771 ;  input:
                                    772 ;    X    start address 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 15.
Hexadecimal [24-Bits]



                                    773 ;    Y    count 
                                    774 ;--------------------------
                           000001   775 	BCNT=1
                           000003   776 	BASE=3
                           000004   777 	TABW=4
                           000004   778 	VSIZE=4   
      000359                        779 hex_dump:
      000359                        780 	_vars VSIZE
      000359 52 04            [ 2]    1     sub sp,#VSIZE 
      00035B C6 00 0A         [ 1]  781 	ld a,base
      00035E 6B 03            [ 1]  782 	ld (BASE,sp),a 
      000360 35 10 00 0A      [ 1]  783 	mov base,#16
      000364 C6 00 24         [ 1]  784 	ld a,tab_width 
      000367 6B 04            [ 1]  785 	ld (TABW,sp),a
      000369 A6 0D            [ 1]  786 	ld a,#CR 
      00036B CD 02 C0         [ 4]  787 	call putc 
      00036E 17 01            [ 2]  788 1$: ldw (BCNT,sp),y
      000370 A6 10            [ 1]  789 	ld a,#16
      000372 90 A3 00 10      [ 2]  790 	cpw y,#16
      000376 2A 02            [ 1]  791 	jrpl 2$
      000378 90 9F            [ 1]  792 	ld a,yl
      00037A                        793 2$: 	
      00037A CD 03 2A         [ 4]  794 	call show_row 
      00037D 16 01            [ 2]  795 	ldw y,(BCNT,sp) 
      00037F 72 A2 00 10      [ 2]  796 	subw y,#16 
      000383 90 A3 00 01      [ 2]  797 	cpw y,#1
      000387 2A E5            [ 1]  798 	jrpl 1$
      000389 7B 03            [ 1]  799 	ld a,(BASE,sp)
      00038B C7 00 0A         [ 1]  800 	ld base,a
      00038E 7B 04            [ 1]  801 	ld a,(TABW,sp)
      000390 C7 00 24         [ 1]  802 	ld tab_width,a 
      000393                        803 	_drop VSIZE
      000393 5B 04            [ 2]    1     addw sp,#VSIZE 
      000395 81               [ 4]  804 	ret 
                                    805 
                                    806 ;-------------------------------------
                                    807 ; retrun string length
                                    808 ; input:
                                    809 ;   X         .asciz  pointer 
                                    810 ; output:
                                    811 ;   X         length 
                                    812 ;-------------------------------------
      000396                        813 strlen::
      000396 90 93            [ 1]  814 	ldw y,x 
      000398 5F               [ 1]  815 	clrw x 
      000399 90 7D            [ 1]  816 1$:	tnz (y) 
      00039B 27 05            [ 1]  817 	jreq 9$ 
      00039D 5C               [ 2]  818 	incw x
      00039E 90 5C            [ 2]  819 	incw y 
      0003A0 20 F7            [ 2]  820 	jra 1$ 
      0003A2 81               [ 4]  821 9$: ret 
                                    822 
                                    823 ;------------------------------------
                                    824 ; compare 2 strings
                                    825 ; input:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 16.
Hexadecimal [24-Bits]



                                    826 ;   X 		char* first string 
                                    827 ;   Y       char* second string 
                                    828 ; output:
                                    829 ;   A 		0|1 
                                    830 ;-------------------------------------
      0003A3                        831 strcmp:
      0003A3 F6               [ 1]  832 	ld a,(x)
      0003A4 27 0B            [ 1]  833 	jreq 5$ 
      0003A6 90 F1            [ 1]  834 	cp a,(y) 
      0003A8 26 05            [ 1]  835 	jrne 4$ 
      0003AA 5C               [ 2]  836 	incw x 
      0003AB 90 5C            [ 2]  837 	incw y 
      0003AD 20 F4            [ 2]  838 	jra strcmp 
      0003AF                        839 4$: ; not same  
      0003AF 4F               [ 1]  840 	clr a 
      0003B0 81               [ 4]  841 	ret 
      0003B1                        842 5$: ; same 
      0003B1 A6 01            [ 1]  843 	ld a,#1 
      0003B3 81               [ 4]  844 	ret 
                                    845 
                                    846 
                                    847 ;---------------------------------------
                                    848 ;  copy src to dest 
                                    849 ; input:
                                    850 ;   X 		dest 
                                    851 ;   Y 		src 
                                    852 ; output: 
                                    853 ;   X 		dest 
                                    854 ;----------------------------------
      0003B4                        855 strcpy:
      0003B4 89               [ 2]  856 	pushw x 
      0003B5 90 F6            [ 1]  857 1$: ld a,(y)
      0003B7 27 06            [ 1]  858 	jreq 9$ 
      0003B9 F7               [ 1]  859 	ld (x),a 
      0003BA 5C               [ 2]  860 	incw x 
      0003BB 90 5C            [ 2]  861 	incw y 
      0003BD 20 F6            [ 2]  862 	jra 1$ 
      0003BF 7F               [ 1]  863 9$:	clr (x)
      0003C0 85               [ 2]  864 	popw x 
      0003C1 81               [ 4]  865 	ret 
                                    866 
                                    867 ;---------------------------------------
                                    868 ; move memory block 
                                    869 ; input:
                                    870 ;   X 		destination 
                                    871 ;   Y 	    source 
                                    872 ;   acc16	bytes count 
                                    873 ; output:
                                    874 ;   none 
                                    875 ;--------------------------------------
                           000001   876 	INCR=1 ; increament high byte 
                           000002   877 	LB=2 ; increament low byte 
                           000002   878 	VSIZE=2
      0003C2                        879 move::
      0003C2                        880 	_vars VSIZE 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 17.
Hexadecimal [24-Bits]



      0003C2 52 02            [ 2]    1     sub sp,#VSIZE 
      0003C4 0F 01            [ 1]  881 	clr (INCR,sp)
      0003C6 0F 02            [ 1]  882 	clr (LB,sp)
      0003C8 90 89            [ 2]  883 	pushw y 
      0003CA 13 01            [ 2]  884 	cpw x,(1,sp) ; compare DEST to SRC 
      0003CC 90 85            [ 2]  885 	popw y 
      0003CE 27 31            [ 1]  886 	jreq move_exit ; x==y 
      0003D0 2B 0E            [ 1]  887 	jrmi move_down
      0003D2                        888 move_up: ; start from top address with incr=-1
      0003D2 72 BB 00 0C      [ 2]  889 	addw x,acc16
      0003D6 72 B9 00 0C      [ 2]  890 	addw y,acc16
      0003DA 03 01            [ 1]  891 	cpl (INCR,sp)
      0003DC 03 02            [ 1]  892 	cpl (LB,sp)   ; increment = -1 
      0003DE 20 05            [ 2]  893 	jra move_loop  
      0003E0                        894 move_down: ; start from bottom address with incr=1 
      0003E0 5A               [ 2]  895     decw x 
      0003E1 90 5A            [ 2]  896 	decw y
      0003E3 0C 02            [ 1]  897 	inc (LB,sp) ; incr=1 
      0003E5                        898 move_loop:	
      0003E5 C6 00 0C         [ 1]  899     ld a, acc16 
      0003E8 CA 00 0D         [ 1]  900 	or a, acc8
      0003EB 27 14            [ 1]  901 	jreq move_exit 
      0003ED 72 FB 01         [ 2]  902 	addw x,(INCR,sp)
      0003F0 72 F9 01         [ 2]  903 	addw y,(INCR,sp) 
      0003F3 90 F6            [ 1]  904 	ld a,(y)
      0003F5 F7               [ 1]  905 	ld (x),a 
      0003F6 89               [ 2]  906 	pushw x 
      0003F7 CE 00 0C         [ 2]  907 	ldw x,acc16 
      0003FA 5A               [ 2]  908 	decw x 
      0003FB CF 00 0C         [ 2]  909 	ldw acc16,x 
      0003FE 85               [ 2]  910 	popw x 
      0003FF 20 E4            [ 2]  911 	jra move_loop
      000401                        912 move_exit:
      000401                        913 	_drop VSIZE
      000401 5B 02            [ 2]    1     addw sp,#VSIZE 
      000403 81               [ 4]  914 	ret 	
                                    915 
                                    916 ;-------------------------------------
                                    917 ; search text area for a line#
                                    918 ; input:
                                    919 ;	X 			line# 
                                    920 ; output:
                                    921 ;   X 			addr of line | 0 
                                    922 ;   Y           line#|insert address if not found  
                                    923 ;-------------------------------------
                           000001   924 	LL=1 ; line length 
                           000002   925 	LB=2 ; line length low byte 
                           000002   926 	VSIZE=2 
      000404                        927 search_lineno::
      000404                        928 	_vars VSIZE
      000404 52 02            [ 2]    1     sub sp,#VSIZE 
      000406 0F 01            [ 1]  929 	clr (LL,sp)
      000408 90 CE 00 1C      [ 2]  930 	ldw y,txtbgn
      00040C                        931 search_ln_loop:
      00040C 90 C3 00 1E      [ 2]  932 	cpw y,txtend 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 18.
Hexadecimal [24-Bits]



      000410 2A 10            [ 1]  933 	jrpl 8$
      000412 90 F3            [ 1]  934 	cpw x,(y)
      000414 27 0E            [ 1]  935 	jreq 9$
      000416 2B 0A            [ 1]  936 	jrmi 8$ 
      000418 90 E6 02         [ 1]  937 	ld a,(2,y)
      00041B 6B 02            [ 1]  938 	ld (LB,sp),a 
      00041D 72 F9 01         [ 2]  939 	addw y,(LL,sp)
      000420 20 EA            [ 2]  940 	jra search_ln_loop 
      000422                        941 8$: 
      000422 5F               [ 1]  942 	clrw x 	
      000423 51               [ 1]  943 	exgw x,y 
      000424                        944 9$: _drop VSIZE
      000424 5B 02            [ 2]    1     addw sp,#VSIZE 
      000426 51               [ 1]  945 	exgw x,y   
      000427 81               [ 4]  946 	ret 
                                    947 
                                    948 ;-------------------------------------
                                    949 ; delete line at addr
                                    950 ; input:
                                    951 ;   X 		addr of line i.e DEST for move 
                                    952 ;-------------------------------------
                           000001   953 	LLEN=1
                           000003   954 	SRC=3
                           000004   955 	VSIZE=4
      000428                        956 del_line: 
      000428                        957 	_vars VSIZE 
      000428 52 04            [ 2]    1     sub sp,#VSIZE 
      00042A E6 02            [ 1]  958 	ld a,(2,x) ; line length
      00042C 6B 02            [ 1]  959 	ld (LLEN+1,sp),a 
      00042E 0F 01            [ 1]  960 	clr (LLEN,sp)
      000430 90 93            [ 1]  961 	ldw y,x  
      000432 72 F9 01         [ 2]  962 	addw y,(LLEN,sp) ;SRC  
      000435 17 03            [ 2]  963 	ldw (SRC,sp),y  ;save source 
      000437 90 CE 00 1E      [ 2]  964 	ldw y,txtend 
      00043B 72 F2 03         [ 2]  965 	subw y,(SRC,sp) ; y=count 
      00043E 90 CF 00 0C      [ 2]  966 	ldw acc16,y 
      000442 16 03            [ 2]  967 	ldw y,(SRC,sp)    ; source
      000444 CD 03 C2         [ 4]  968 	call move
      000447 90 CE 00 1E      [ 2]  969 	ldw y,txtend 
      00044B 72 F2 01         [ 2]  970 	subw y,(LLEN,sp)
      00044E 90 CF 00 1E      [ 2]  971 	ldw txtend,y  
      000452                        972 	_drop VSIZE     
      000452 5B 04            [ 2]    1     addw sp,#VSIZE 
      000454 81               [ 4]  973 	ret 
                                    974 
                                    975 ;---------------------------------------------
                                    976 ; create a gap in text area to 
                                    977 ; move new line in this gap
                                    978 ; input:
                                    979 ;    X 			addr gap start 
                                    980 ;    Y 			gap length 
                                    981 ; output:
                                    982 ;    X 			addr gap start 
                                    983 ;--------------------------------------------
                           000001   984 	DEST=1
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 19.
Hexadecimal [24-Bits]



                           000003   985 	SRC=3
                           000005   986 	LEN=5
                           000006   987 	VSIZE=6 
      000455                        988 create_gap:
      000455                        989 	_vars VSIZE
      000455 52 06            [ 2]    1     sub sp,#VSIZE 
      000457 1F 03            [ 2]  990 	ldw (SRC,sp),x 
      000459 17 05            [ 2]  991 	ldw (LEN,sp),y 
      00045B 90 CF 00 0C      [ 2]  992 	ldw acc16,y 
      00045F 90 93            [ 1]  993 	ldw y,x ; SRC
      000461 72 BB 00 0C      [ 2]  994 	addw x,acc16  
      000465 1F 01            [ 2]  995 	ldw (DEST,sp),x 
                                    996 ;compute size to move 	
      000467 CE 00 1E         [ 2]  997 	ldw x,txtend 
      00046A 72 F0 03         [ 2]  998 	subw x,(SRC,sp)
      00046D CF 00 0C         [ 2]  999 	ldw acc16,x ; size to move
      000470 1E 01            [ 2] 1000 	ldw x,(DEST,sp) 
      000472 CD 03 C2         [ 4] 1001 	call move
      000475 CE 00 1E         [ 2] 1002 	ldw x,txtend
      000478 72 FB 05         [ 2] 1003 	addw x,(LEN,sp)
      00047B CF 00 1E         [ 2] 1004 	ldw txtend,x
      00047E                       1005 9$:	_drop VSIZE 
      00047E 5B 06            [ 2]    1     addw sp,#VSIZE 
      000480 81               [ 4] 1006 	ret 
                                   1007 
                                   1008 ;--------------------------------------------
                                   1009 ; insert line in pad into text area 
                                   1010 ; first search for already existing 
                                   1011 ; replace existing 
                                   1012 ; if new line empty delete existing one. 
                                   1013 ; input:
                                   1014 ;   ptr16		pointer to tokenized line  
                                   1015 ; output:
                                   1016 ;   none
                                   1017 ;---------------------------------------------
                           000001  1018 	DEST=1  ; text area insertion address 
                           000003  1019 	SRC=3   ; str to insert address 
                           000005  1020 	LINENO=5 ; line number 
                           000007  1021 	LLEN=7 ; line length 
                           000008  1022 	VSIZE=8  
      000481                       1023 insert_line:
      000481                       1024 	_vars VSIZE 
      000481 52 08            [ 2]    1     sub sp,#VSIZE 
      000483 CE 00 1E         [ 2] 1025 	ldw x,txtend  
      000486 C3 00 1C         [ 2] 1026 	cpw x,txtbgn 
      000489 26 15            [ 1] 1027 	jrne 0$
                                   1028 ;first text line 
      00048B AE 00 02         [ 2] 1029 	ldw x,#2 
      00048E 72 D6 00 17      [ 4] 1030 	ld a,([ptr16],x)
      000492 5F               [ 1] 1031 	clrw x 
      000493 97               [ 1] 1032 	ld xl,a
      000494 1F 07            [ 2] 1033 	ldw (LLEN,sp),x 
      000496 CE 00 1C         [ 2] 1034 	ldw x,txtbgn
      000499 1F 01            [ 2] 1035 	ldw (DEST,sp),x 
      00049B CE 00 1E         [ 2] 1036 	ldw x,txtend 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 20.
Hexadecimal [24-Bits]



      00049E 20 37            [ 2] 1037 	jra 4$
      0004A0 72 CE 00 17      [ 5] 1038 0$:	ldw x,[ptr16]
                                   1039 ; line number
      0004A4 1F 05            [ 2] 1040 	ldw (LINENO,sp),x 
      0004A6 AE 00 02         [ 2] 1041 	ldw x,#2 
      0004A9 72 D6 00 17      [ 4] 1042 	ld a,([ptr16],x)
      0004AD 97               [ 1] 1043 	ld xl,a
                                   1044 ; line length
      0004AE 1F 07            [ 2] 1045 	ldw (LLEN,sp),x
                                   1046 ; check if that line number already exit 	
      0004B0 1E 05            [ 2] 1047 	ldw x,(LINENO,sp)
      0004B2 CD 04 04         [ 4] 1048 	call search_lineno 
      0004B5 5D               [ 2] 1049 	tnzw x 
      0004B6 26 04            [ 1] 1050 	jrne 2$
                                   1051 ; line doesn't exit
                                   1052 ; it will be inserted at this point.  	
      0004B8 17 01            [ 2] 1053 	ldw (DEST,sp),y 
      0004BA 20 05            [ 2] 1054 	jra 3$
                                   1055 ; line exit delete it.
                                   1056 ; it will be replaced by new one 	
      0004BC 1F 01            [ 2] 1057 2$: ldw (DEST,sp),x 
      0004BE CD 04 28         [ 4] 1058 	call del_line
      0004C1                       1059 3$: 
                                   1060 ; insert new line or leave if LLEN==3
                                   1061 ; LLEN==3 means empty line 
      0004C1 A6 03            [ 1] 1062 	ld a,#3
      0004C3 11 08            [ 1] 1063 	cp a,(LLEN+1,sp)
      0004C5 27 24            [ 1] 1064 	jreq insert_ln_exit ; empty line exit.
                                   1065 ; if insertion point at txtend 
                                   1066 ; move no need to create a gap 
      0004C7 1E 01            [ 2] 1067 	ldw x,(DEST,sp)
      0004C9 C3 00 1E         [ 2] 1068 	cpw x,txtend 
      0004CC 27 09            [ 1] 1069 	jreq 4$ 
                                   1070 ; must create a gap
                                   1071 ; at insertion point  
      0004CE 1E 01            [ 2] 1072 	ldw x,(DEST,sp)
      0004D0 16 07            [ 2] 1073 	ldw y,(LLEN,sp)
      0004D2 CD 04 55         [ 4] 1074 	call create_gap
      0004D5 20 06            [ 2] 1075 	jra 5$
      0004D7                       1076 4$: 
      0004D7 72 FB 07         [ 2] 1077 	addw x,(LLEN,sp)
      0004DA CF 00 1E         [ 2] 1078 	ldw txtend,x 	 
                                   1079 ; move new line in gap 
      0004DD 1E 07            [ 2] 1080 5$:	ldw x,(LLEN,sp)
      0004DF CF 00 0C         [ 2] 1081 	ldw acc16,x 
      0004E2 90 AE 16 E0      [ 2] 1082 	ldw y,#pad ;SRC 
      0004E6 1E 01            [ 2] 1083 	ldw x,(DEST,sp) ; dest address 
      0004E8 CD 03 C2         [ 4] 1084 	call move 
      0004EB                       1085 insert_ln_exit:	
      0004EB                       1086 	_drop VSIZE
      0004EB 5B 08            [ 2]    1     addw sp,#VSIZE 
      0004ED 81               [ 4] 1087 	ret
                                   1088 
                                   1089 ;-----------------------------------
                                   1090 ; create token list fromm text line 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 21.
Hexadecimal [24-Bits]



                                   1091 ; save this list in pad buffer 
                                   1092 ;  compiled line format: 
                                   1093 ;    line_no  2 bytes {0...32767}
                                   1094 ;    count    1 byte  
                                   1095 ;    tokens   variable length 
                                   1096 ;   
                                   1097 ; input:
                                   1098 ;   none
                                   1099 ; modified variables:
                                   1100 ;   basicptr     token list buffer address 
                                   1101 ;   in.w  		 3|count, i.e. index in buffer
                                   1102 ;   count        length of line | 0  
                                   1103 ;-----------------------------------
                           000001  1104 	XSAVE=1
                           000002  1105 	VSIZE=2
      0004EE                       1106 compile:
      0004EE                       1107 	_vars VSIZE 
      0004EE 52 02            [ 2]    1     sub sp,#VSIZE 
      0004F0 72 1A 00 23      [ 1] 1108 	bset flags,#FCOMP 
      0004F4 A6 00            [ 1] 1109 	ld a,#0
      0004F6 AE 00 00         [ 2] 1110 	ldw x,#0
      0004F9 CF 16 E0         [ 2] 1111 	ldw pad,x ; destination buffer 
      0004FC C7 16 E2         [ 1] 1112 	ld pad+2,a ; count 
      0004FF AE 16 E3         [ 2] 1113 	ldw x,#pad+3
      000502 72 5F 00 01      [ 1] 1114 	clr in 
      000506 CD 0B EE         [ 4] 1115 	call get_token
      000509 A1 84            [ 1] 1116 	cp a,#TK_INTGR
      00050B 26 11            [ 1] 1117 	jrne 2$
      00050D A3 00 01         [ 2] 1118 	cpw x,#1 
      000510 2A 05            [ 1] 1119 	jrpl 1$
      000512 A6 0A            [ 1] 1120 	ld a,#ERR_BAD_VALUE
      000514 CC 08 7D         [ 2] 1121 	jp tb_error
      000517 CF 16 E0         [ 2] 1122 1$:	ldw pad,x 
      00051A 90 AE 16 E3      [ 2] 1123 	ldw y,#pad+3 
      00051E 90 A3 17 60      [ 2] 1124 2$:	cpw y,#stack_full 
      000522 25 05            [ 1] 1125 	jrult 3$
      000524 A6 0F            [ 1] 1126 	ld a,#ERR_BUF_FULL 
      000526 CC 08 7D         [ 2] 1127 	jp tb_error 
      000529                       1128 3$:	
      000529 93               [ 1] 1129 	ldw x,y 
      00052A CD 0B EE         [ 4] 1130 	call get_token 
      00052D A1 00            [ 1] 1131 	cp a,#TK_NONE 
      00052F 26 ED            [ 1] 1132 	jrne 2$ 
                                   1133 ; compilation completed  
      000531 72 A2 16 E0      [ 2] 1134 	subw y,#pad
      000535 90 9F            [ 1] 1135     ld a,yl
      000537 AE 16 E0         [ 2] 1136 	ldw x,#pad 
      00053A CF 00 17         [ 2] 1137 	ldw ptr16,x 
      00053D E7 02            [ 1] 1138 	ld (2,x),a 
      00053F FE               [ 2] 1139 	ldw x,(x)
      000540 27 09            [ 1] 1140 	jreq 10$
      000542 CD 04 81         [ 4] 1141 	call insert_line
      000545 72 5F 00 03      [ 1] 1142 	clr  count 
      000549 20 0F            [ 2] 1143 	jra  11$ 
      00054B                       1144 10$: ; line# is zero 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 22.
Hexadecimal [24-Bits]



      00054B CE 00 17         [ 2] 1145 	ldw x,ptr16  
      00054E CF 00 04         [ 2] 1146 	ldw basicptr,x 
      000551 E6 02            [ 1] 1147 	ld a,(2,x)
      000553 C7 00 03         [ 1] 1148 	ld count,a 
      000556 35 03 00 01      [ 1] 1149 	mov in,#3 
      00055A                       1150 11$:
      00055A                       1151 	_drop VSIZE 
      00055A 5B 02            [ 2]    1     addw sp,#VSIZE 
      00055C 72 1B 00 23      [ 1] 1152 	bres flags,#FCOMP 
      000560 81               [ 4] 1153 	ret 
                                   1154 
                                   1155 ;------------------------------------
                                   1156 ;  set all variables to zero 
                                   1157 ; input:
                                   1158 ;   none 
                                   1159 ; output:
                                   1160 ;	none
                                   1161 ;------------------------------------
      000561                       1162 clear_vars:
      000561 AE 00 2F         [ 2] 1163 	ldw x,#vars 
      000564 90 AE 00 34      [ 2] 1164 	ldw y,#2*26 
      000568 7F               [ 1] 1165 1$:	clr (x)
      000569 5C               [ 2] 1166 	incw x 
      00056A 90 5A            [ 2] 1167 	decw y 
      00056C 26 FA            [ 1] 1168 	jrne 1$
      00056E 81               [ 4] 1169 	ret 
                                   1170 
                                   1171 ;-------------------------------------
                                   1172 ; check if A is a letter 
                                   1173 ; input:
                                   1174 ;   A 			character to test 
                                   1175 ; output:
                                   1176 ;   C flag      1 true, 0 false 
                                   1177 ;-------------------------------------
      00056F                       1178 is_alpha:
      00056F A1 41            [ 1] 1179 	cp a,#'A 
      000571 8C               [ 1] 1180 	ccf 
      000572 24 0B            [ 1] 1181 	jrnc 9$ 
      000574 A1 5B            [ 1] 1182 	cp a,#'Z+1 
      000576 25 07            [ 1] 1183 	jrc 9$ 
      000578 A1 61            [ 1] 1184 	cp a,#'a 
      00057A 8C               [ 1] 1185 	ccf 
      00057B 24 02            [ 1] 1186 	jrnc 9$
      00057D A1 7B            [ 1] 1187 	cp a,#'z+1
      00057F 81               [ 4] 1188 9$: ret 	
                                   1189 
                                   1190 ;------------------------------------
                                   1191 ; check if character in {'0'..'9'}
                                   1192 ; input:
                                   1193 ;    A  character to test
                                   1194 ; output:
                                   1195 ;    Carry  0 not digit | 1 digit
                                   1196 ;------------------------------------
      000580                       1197 is_digit:
      000580 A1 30            [ 1] 1198 	cp a,#'0
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 23.
Hexadecimal [24-Bits]



      000582 25 03            [ 1] 1199 	jrc 1$
      000584 A1 3A            [ 1] 1200     cp a,#'9+1
      000586 8C               [ 1] 1201 	ccf 
      000587 8C               [ 1] 1202 1$:	ccf 
      000588 81               [ 4] 1203     ret
                                   1204 
                                   1205 ;-------------------------------------
                                   1206 ; return true if character in  A 
                                   1207 ; is letter or digit.
                                   1208 ; input:
                                   1209 ;   A     ASCII character 
                                   1210 ; output:
                                   1211 ;   A     no change 
                                   1212 ;   Carry    0 false| 1 true 
                                   1213 ;--------------------------------------
      000589                       1214 is_alnum:
      000589 CD 05 80         [ 4] 1215 	call is_digit
      00058C 25 03            [ 1] 1216 	jrc 1$ 
      00058E CD 05 6F         [ 4] 1217 	call is_alpha
      000591 81               [ 4] 1218 1$:	ret 
                                   1219 
                                   1220 
                                   1221 ;-------------------------------------
                                   1222 ;  program initialization entry point 
                                   1223 ;-------------------------------------
                           000001  1224 	MAJOR=1
                           000000  1225 	MINOR=0
      000592 0A 0A 54 69 6E 79 20  1226 software: .asciz "\n\nTiny BASIC for STM8\nCopyright, Jacques Deschenes 2019,2020\nversion "
             42 41 53 49 43 20 66
             6F 72 20 53 54 4D 38
             0A 43 6F 70 79 72 69
             67 68 74 2C 20 4A 61
             63 71 75 65 73 20 44
             65 73 63 68 65 6E 65
             73 20 32 30 31 39 2C
             32 30 32 30 0A 76 65
             72 73 69 6F 6E 20 00
      0005D8                       1227 cold_start:
                                   1228 ;set stack 
      0005D8 AE 17 FF         [ 2] 1229 	ldw x,#STACK_EMPTY
      0005DB 94               [ 1] 1230 	ldw sp,x   
                                   1231 ; clear all ram 
      0005DC 7F               [ 1] 1232 0$: clr (x)
      0005DD 5A               [ 2] 1233 	decw x 
      0005DE 26 FC            [ 1] 1234 	jrne 0$
                                   1235 ; activate pull up on all inputs 
      0005E0 A6 FF            [ 1] 1236 	ld a,#255 
      0005E2 C7 50 03         [ 1] 1237 	ld PA_CR1,a 
      0005E5 C7 50 08         [ 1] 1238 	ld PB_CR1,a 
      0005E8 C7 50 0D         [ 1] 1239 	ld PC_CR1,a 
      0005EB C7 50 12         [ 1] 1240 	ld PD_CR1,a 
      0005EE C7 50 17         [ 1] 1241 	ld PE_CR1,a 
      0005F1 C7 50 1C         [ 1] 1242 	ld PF_CR1,a 
      0005F4 C7 50 21         [ 1] 1243 	ld PG_CR1,a 
      0005F7 C7 50 2B         [ 1] 1244 	ld PI_CR1,a
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 24.
Hexadecimal [24-Bits]



                                   1245 ; set LD2 pin as output and turn it on
      0005FA 72 1A 50 0D      [ 1] 1246     bset PC_CR1,#LED2_BIT
      0005FE 72 1A 50 0E      [ 1] 1247     bset PC_CR2,#LED2_BIT
      000602 72 1A 50 0C      [ 1] 1248     bset PC_DDR,#LED2_BIT
      000606 72 1A 50 0A      [ 1] 1249 	bset PC_ODR,#LED2_BIT 
                                   1250 ; disable schmitt triggers on Arduino CN4 analog inputs
      00060A 55 00 3F 54 07   [ 1] 1251 	mov ADC_TDRL,0x3f
                                   1252 ; disable peripherals clocks
                                   1253 ;	clr CLK_PCKENR1 
                                   1254 ;	clr CLK_PCKENR2
      00060F 72 5F 50 F2      [ 1] 1255 	clr AWU_TBR 
      000613 72 14 50 CA      [ 1] 1256 	bset CLK_PCKENR2,#CLK_PCKENR2_AWU ; enable LSI for AWU 
                                   1257 ; select internal clock no divisor: 16 Mhz 	
      000617 A6 E1            [ 1] 1258 	ld a,#CLK_SWR_HSI 
      000619 5F               [ 1] 1259 	clrw x  
      00061A CD 00 B5         [ 4] 1260     call clock_init 
      00061D CD 00 D8         [ 4] 1261 	call timer4_init
      000620 CD 00 CB         [ 4] 1262 	call timer2_init
                                   1263 ; UART1 at 115200 BAUD
      000623 CD 02 7D         [ 4] 1264 	call uart1_init
                                   1265 ; activate PE_4 (user button interrupt)
      000626 72 18 50 18      [ 1] 1266     bset PE_CR2,#USR_BTN_BIT 
                                   1267 ; display system information
      00062A AE 05 92         [ 2] 1268 	ldw x,#software 
      00062D CD 00 00         [ 4] 1269 	call puts 
      000630 A6 01            [ 1] 1270 	ld a,#MAJOR 
      000632 C7 00 0D         [ 1] 1271 	ld acc8,a 
      000635 5F               [ 1] 1272 	clrw x 
      000636 CF 00 0B         [ 2] 1273 	ldw acc24,x
      000639 72 5F 00 24      [ 1] 1274 	clr tab_width  
      00063D 35 0A 00 0A      [ 1] 1275 	mov base, #10 
      000641 CD 09 DA         [ 4] 1276 	call prti24 
      000644 A6 2E            [ 1] 1277 	ld a,#'.
      000646 CD 02 C0         [ 4] 1278 	call putc 
      000649 A6 00            [ 1] 1279 	ld a,#MINOR 
      00064B C7 00 0D         [ 1] 1280 	ld acc8,a 
      00064E 5F               [ 1] 1281 	clrw x 
      00064F CF 00 0B         [ 2] 1282 	ldw acc24,x 
      000652 CD 09 DA         [ 4] 1283 	call prti24
      000655 A6 0D            [ 1] 1284 	ld a,#CR 
      000657 CD 02 C0         [ 4] 1285 	call putc
      00065A CD 19 FB         [ 4] 1286 	call seek_fdrive 
      00065D 9A               [ 1] 1287 	rim 
      00065E 72 5C 00 15      [ 1] 1288 	inc seedy+1 
      000662 72 5C 00 13      [ 1] 1289 	inc seedx+1 
      000666 CD 06 E7         [ 4] 1290 	call clear_basic
      000669 CD 12 08         [ 4] 1291 	call ubound 
                                   1292 ;	jra 2$	
      00066C CD 18 49         [ 4] 1293 	call beep_1khz  
      00066F 72 1B 50 0A      [ 1] 1294 2$:	bres PC_ODR,#LED2_BIT	
      000673 CD 06 7C         [ 4] 1295 	call warm_init
      000676 CD 06 A9         [ 4] 1296 	call load_autorun
      000679 CC 09 05         [ 2] 1297     jp cmd_line  
                                   1298 
      00067C                       1299 warm_init:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 25.
Hexadecimal [24-Bits]



      00067C 72 5F 00 23      [ 1] 1300 	clr flags 
      000680 72 5F 00 20      [ 1] 1301 	clr loop_depth 
      000684 35 04 00 24      [ 1] 1302 	mov tab_width,#TAB_WIDTH 
      000688 35 0A 00 0A      [ 1] 1303 	mov base,#10 
      00068C AE 00 00         [ 2] 1304 	ldw x,#0 
      00068F CF 00 04         [ 2] 1305 	ldw basicptr,x 
      000692 CF 00 00         [ 2] 1306 	ldw in.w,x 
      000695 72 5F 00 03      [ 1] 1307 	clr count
      000699 81               [ 4] 1308 	ret 
                                   1309 
                                   1310 ;--------------------------
                                   1311 ; called by tb_error when
                                   1312 ; flag FAUTORUN is set.
                                   1313 ; There is a bug in autorun 
                                   1314 ; program so cancel it.
                                   1315 ;---------------------------
      00069A                       1316 cancel_autorun:
      00069A AE 40 00         [ 2] 1317 	ldw x,#AUTORUN_NAME 
      00069D CF 00 17         [ 2] 1318 	ldw farptr+1,x 
      0006A0 4F               [ 1] 1319 	clr a
      0006A1 5F               [ 1] 1320 	clrw x  
      0006A2 C7 00 16         [ 1] 1321 	ld farptr,a 
      0006A5 CD 01 E5         [ 4] 1322 	call write_byte 
      0006A8 81               [ 4] 1323 	ret 
                                   1324 
                                   1325 
                                   1326 ;--------------------------
                                   1327 ; if autorun file defined 
                                   1328 ; in eeprom address AUTORUN_NAME 
                                   1329 ; load and run it.
                                   1330 ;-------------------------
      0006A9                       1331 load_autorun:
      0006A9 90 AE 40 00      [ 2] 1332 	ldw y,#AUTORUN_NAME
      0006AD 90 F6            [ 1] 1333 	ld a,(y)
      0006AF 27 20            [ 1] 1334 	jreq 9$
      0006B1 CD 1A 61         [ 4] 1335 	call search_file
      0006B4 25 05            [ 1] 1336 	jrc 2$ 
                                   1337 ; if file doesn't exit
      0006B6 CD 06 9A         [ 4] 1338 	call cancel_autorun
      0006B9 20 16            [ 2] 1339 	jra 9$ 
      0006BB CD 1B 77         [ 4] 1340 2$:	call load_file
      0006BE AE 40 00         [ 2] 1341 	ldw x,#AUTORUN_NAME 
      0006C1 CD 00 00         [ 4] 1342 	call puts
      0006C4 AE 06 D2         [ 2] 1343 	ldw x,#autorun_msg 
      0006C7 CD 00 00         [ 4] 1344 	call puts 
      0006CA 72 1C 00 23      [ 1] 1345 	bset flags,#FAUTORUN 
      0006CE CC 18 1B         [ 2] 1346 	jp run_it    
      0006D1 81               [ 4] 1347 9$: ret 	
                                   1348 
      0006D2 20 6C 6F 61 64 65 64  1349 autorun_msg: .asciz " loaded and running\n"
             20 61 6E 64 20 72 75
             6E 6E 69 6E 67 0A 00
                                   1350 ;---------------------------
                                   1351 ; reset BASIC text variables 
                                   1352 ; and clear variables 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 26.
Hexadecimal [24-Bits]



                                   1353 ;---------------------------
      0006E7                       1354 clear_basic:
      0006E7 72 5F 00 03      [ 1] 1355 	clr count
      0006EB 72 5F 00 01      [ 1] 1356 	clr in  
      0006EF AE 00 63         [ 2] 1357 	ldw x,#free_ram 
      0006F2 CF 00 1C         [ 2] 1358 	ldw txtbgn,x 
      0006F5 CF 00 1E         [ 2] 1359 	ldw txtend,x 
      0006F8 CD 05 61         [ 4] 1360 	call clear_vars 
      0006FB 81               [ 4] 1361 	ret 
                                   1362 
                                   1363 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   1364 ;;   Tiny BASIC error messages     ;;
                                   1365 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      0006FC                       1366 err_msg:
      0006FC 00 00 07 1C 07 29 07  1367 	.word 0,err_mem_full, err_syntax, err_math_ovf, err_div0,err_no_line    
             37 07 50 07 5F
      000708 07 75 07 8B 07 A5 07  1368 	.word err_run_only,err_cmd_only,err_duplicate,err_not_file,err_bad_value
             B6 07 C7
      000712 07 D3 08 06 08 16 08  1369 	.word err_no_access,err_no_data,err_no_prog,err_no_fspace,err_buf_full    
             2A 08 3D
                                   1370 
      00071C 4D 65 6D 6F 72 79 20  1371 err_mem_full: .asciz "Memory full\n" 
             66 75 6C 6C 0A 00
      000729 73 79 6E 74 61 78 20  1372 err_syntax: .asciz "syntax error\n" 
             65 72 72 6F 72 0A 00
      000737 6D 61 74 68 20 6F 70  1373 err_math_ovf: .asciz "math operation overflow\n"
             65 72 61 74 69 6F 6E
             20 6F 76 65 72 66 6C
             6F 77 0A 00
      000750 64 69 76 69 73 69 6F  1374 err_div0: .asciz "division by 0\n" 
             6E 20 62 79 20 30 0A
             00
      00075F 69 6E 76 61 6C 69 64  1375 err_no_line: .asciz "invalid line number.\n"
             20 6C 69 6E 65 20 6E
             75 6D 62 65 72 2E 0A
             00
      000775 72 75 6E 20 74 69 6D  1376 err_run_only: .asciz "run time only usage.\n" 
             65 20 6F 6E 6C 79 20
             75 73 61 67 65 2E 0A
             00
      00078B 63 6F 6D 6D 61 6E 64  1377 err_cmd_only: .asciz "command line only usage.\n"
             20 6C 69 6E 65 20 6F
             6E 6C 79 20 75 73 61
             67 65 2E 0A 00
      0007A5 64 75 70 6C 69 63 61  1378 err_duplicate: .asciz "duplicate name.\n"
             74 65 20 6E 61 6D 65
             2E 0A 00
      0007B6 46 69 6C 65 20 6E 6F  1379 err_not_file: .asciz "File not found.\n"
             74 20 66 6F 75 6E 64
             2E 0A 00
      0007C7 62 61 64 20 76 61 6C  1380 err_bad_value: .asciz "bad value.\n"
             75 65 2E 0A 00
      0007D3 46 69 6C 65 20 69 6E  1381 err_no_access: .asciz "File in extended memory, can't be run from there.\n" 
             20 65 78 74 65 6E 64
             65 64 20 6D 65 6D 6F
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 27.
Hexadecimal [24-Bits]



             72 79 2C 20 63 61 6E
             27 74 20 62 65 20 72
             75 6E 20 66 72 6F 6D
             20 74 68 65 72 65 2E
             0A 00
      000806 4E 6F 20 64 61 74 61  1382 err_no_data: .asciz "No data found.\n"
             20 66 6F 75 6E 64 2E
             0A 00
      000816 4E 6F 20 70 72 6F 67  1383 err_no_prog: .asciz "No program in RAM!\n"
             72 61 6D 20 69 6E 20
             52 41 4D 21 0A 00
      00082A 46 69 6C 65 20 73 79  1384 err_no_fspace: .asciz "File system full.\n" 
             73 74 65 6D 20 66 75
             6C 6C 2E 0A 00
      00083D 42 75 66 66 65 72 20  1385 err_buf_full: .asciz "Buffer full\n"
             66 75 6C 6C 0A 00
                                   1386 
      00084A 72 75 6E 20 74 69 6D  1387 rt_msg: .asciz "run time error, "
             65 20 65 72 72 6F 72
             2C 20 00
      00085B 63 6F 6D 70 69 6C 65  1388 comp_msg: .asciz "compile error, "
             20 65 72 72 6F 72 2C
             20 00
      00086B 6C 61 73 74 20 74 6F  1389 tk_id: .asciz "last token id: "
             6B 65 6E 20 69 64 3A
             20 00
                                   1390 
      00087B                       1391 syntax_error:
      00087B A6 02            [ 1] 1392 	ld a,#ERR_SYNTAX 
                                   1393 
      00087D                       1394 tb_error:
      00087D 72 0A 00 23 47   [ 2] 1395 	btjt flags,#FCOMP,1$
      000882 88               [ 1] 1396 	push a 
      000883 AE 08 4A         [ 2] 1397 	ldw x, #rt_msg 
      000886 CD 00 00         [ 4] 1398 	call puts 
      000889 84               [ 1] 1399 	pop a 
      00088A AE 06 FC         [ 2] 1400 	ldw x, #err_msg 
      00088D 72 5F 00 0C      [ 1] 1401 	clr acc16 
      000891 48               [ 1] 1402 	sll a
      000892 72 59 00 0C      [ 1] 1403 	rlc acc16  
      000896 C7 00 0D         [ 1] 1404 	ld acc8, a 
      000899 72 BB 00 0C      [ 2] 1405 	addw x,acc16 
      00089D FE               [ 2] 1406 	ldw x,(x)
      00089E CD 00 00         [ 4] 1407 	call puts
      0008A1 CE 00 04         [ 2] 1408 	ldw x,basicptr
      0008A4 C6 00 01         [ 1] 1409 	ld a,in 
      0008A7 CD 14 DC         [ 4] 1410 	call prt_basic_line
      0008AA AE 08 6B         [ 2] 1411 	ldw x,#tk_id 
      0008AD CD 00 00         [ 4] 1412 	call puts 
      0008B0 C6 00 02         [ 1] 1413 	ld a,in.saved 
      0008B3 5F               [ 1] 1414 	clrw x 
      0008B4 97               [ 1] 1415 	ld xl,a 
      0008B5 72 BB 00 04      [ 2] 1416 	addw x,basicptr 
      0008B9 F6               [ 1] 1417 	ld a,(x)
      0008BA 5F               [ 1] 1418 	clrw x 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 28.
Hexadecimal [24-Bits]



      0008BB 97               [ 1] 1419 	ld xl,a 
      0008BC CD 09 CA         [ 4] 1420 	call print_int
      0008BF 72 0D 00 23 3A   [ 2] 1421 	btjf flags,#FAUTORUN ,6$
      0008C4 CD 06 9A         [ 4] 1422 	call cancel_autorun  
      0008C7 20 35            [ 2] 1423 	jra 6$
      0008C9                       1424 1$:	
      0008C9 88               [ 1] 1425 	push a 
      0008CA AE 08 5B         [ 2] 1426 	ldw x,#comp_msg
      0008CD CD 00 00         [ 4] 1427 	call puts 
      0008D0 84               [ 1] 1428 	pop a 
      0008D1 AE 06 FC         [ 2] 1429 	ldw x, #err_msg 
      0008D4 72 5F 00 0C      [ 1] 1430 	clr acc16 
      0008D8 48               [ 1] 1431 	sll a
      0008D9 72 59 00 0C      [ 1] 1432 	rlc acc16  
      0008DD C7 00 0D         [ 1] 1433 	ld acc8, a 
      0008E0 72 BB 00 0C      [ 2] 1434 	addw x,acc16 
      0008E4 FE               [ 2] 1435 	ldw x,(x)
      0008E5 CD 00 00         [ 4] 1436 	call puts
      0008E8 AE 16 90         [ 2] 1437 	ldw x,#tib
      0008EB CD 00 00         [ 4] 1438 	call puts 
      0008EE A6 0D            [ 1] 1439 	ld a,#CR 
      0008F0 CD 02 C0         [ 4] 1440 	call putc
      0008F3 CE 00 00         [ 2] 1441 	ldw x,in.w
      0008F6 CD 00 00         [ 4] 1442 	call spaces
      0008F9 A6 5E            [ 1] 1443 	ld a,#'^
      0008FB CD 02 C0         [ 4] 1444 	call putc 
      0008FE AE 17 FF         [ 2] 1445 6$: ldw x,#STACK_EMPTY 
      000901 94               [ 1] 1446     ldw sp,x
      000902                       1447 warm_start:
      000902 CD 06 7C         [ 4] 1448 	call warm_init
                                   1449 ;----------------------------
                                   1450 ;   BASIC interpreter
                                   1451 ;----------------------------
      000905                       1452 cmd_line: ; user interface 
      000905 A6 0D            [ 1] 1453 	ld a,#CR 
      000907 CD 02 C0         [ 4] 1454 	call putc 
      00090A A6 3E            [ 1] 1455 	ld a,#'> 
      00090C CD 02 C0         [ 4] 1456 	call putc
      00090F CD 00 00         [ 4] 1457 	call readln
      000912 72 5D 00 03      [ 1] 1458 	tnz count 
      000916 27 ED            [ 1] 1459 	jreq cmd_line
      000918 CD 04 EE         [ 4] 1460 	call compile
                                   1461 ; if text begin with a line number
                                   1462 ; the compiler set count to zero    
                                   1463 ; so code is not interpreted
      00091B 72 5D 00 03      [ 1] 1464 	tnz count 
      00091F 27 E4            [ 1] 1465 	jreq cmd_line
                                   1466 
                                   1467 ; if direct command 
                                   1468 ; it's ready to interpret 
                                   1469 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   1470 ;; This is the interpreter loop
                                   1471 ;; for each BASIC code line. 
                                   1472 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
      000921                       1473 interpreter: 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 29.
Hexadecimal [24-Bits]



      000921 C6 00 01         [ 1] 1474 	ld a,in 
      000924 C1 00 03         [ 1] 1475 	cp a,count 
      000927 2B 1D            [ 1] 1476 	jrmi interp_loop
      000929                       1477 next_line:
      000929 72 01 00 23 D7   [ 2] 1478 	btjf flags, #FRUN, cmd_line
      00092E CE 00 04         [ 2] 1479 	ldw x,basicptr
      000931 72 BB 00 00      [ 2] 1480 	addw x,in.w 
      000935 C3 00 1E         [ 2] 1481 	cpw x,txtend 
      000938 2A C8            [ 1] 1482 	jrpl warm_start
      00093A CF 00 04         [ 2] 1483 	ldw basicptr,x ; start of next line  
      00093D E6 02            [ 1] 1484 	ld a,(2,x)
      00093F C7 00 03         [ 1] 1485 	ld count,a 
      000942 35 03 00 01      [ 1] 1486 	mov in,#3 ; skip first 3 bytes of line 
      000946                       1487 interp_loop: 
      000946 CD 09 6D         [ 4] 1488 	call next_token
      000949 A1 00            [ 1] 1489 	cp a,#TK_NONE 
      00094B 27 DC            [ 1] 1490 	jreq next_line 
      00094D A1 80            [ 1] 1491 	cp a,#TK_CMD
      00094F 26 03            [ 1] 1492 	jrne 1$
      000951 FD               [ 4] 1493 	call (x) 
      000952 20 F2            [ 2] 1494 	jra interp_loop 
      000954                       1495 1$:	 
      000954 A1 85            [ 1] 1496 	cp a,#TK_VAR
      000956 26 05            [ 1] 1497 	jrne 2$
      000958 CD 12 3B         [ 4] 1498 	call let_var  
      00095B 20 E9            [ 2] 1499 	jra interp_loop 
      00095D                       1500 2$:	
      00095D A1 06            [ 1] 1501 	cp a,#TK_ARRAY 
      00095F 26 05            [ 1] 1502 	jrne 3$
      000961 CD 12 38         [ 4] 1503 	call let_array 
      000964 20 E0            [ 2] 1504 	jra interp_loop
      000966                       1505 3$:	
      000966 A1 01            [ 1] 1506 	cp a,#TK_COLON 
      000968 27 DC            [ 1] 1507 	jreq interp_loop 
      00096A CC 08 7B         [ 2] 1508 	jp syntax_error 
                                   1509 
                                   1510 		
                                   1511 ;--------------------------
                                   1512 ; extract next token from
                                   1513 ; token list 
                                   1514 ; basicptr -> base address 
                                   1515 ; in  -> offset in list array 
                                   1516 ; output:
                                   1517 ;   A 		token attribute
                                   1518 ;   X 		token value if there is one
                                   1519 ;----------------------------------------
      00096D                       1520 next_token:
      00096D 5F               [ 1] 1521 	clrw x 
      00096E C6 00 01         [ 1] 1522 	ld a,in 
      000971 C0 00 03         [ 1] 1523 	sub a,count ; don't replace sub by cp!  
      000974 2B 01            [ 1] 1524 	jrmi 0$
      000976 81               [ 4] 1525 	ret  ; end of BASIC line 
      000977                       1526 0$: 
      000977 55 00 01 00 02   [ 1] 1527 	mov in.saved,in 
      00097C 90 CE 00 04      [ 2] 1528 	ldw y,basicptr 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 30.
Hexadecimal [24-Bits]



      000980 91 D6 00         [ 4] 1529 	ld a,([in.w],y)
      000983 72 5C 00 01      [ 1] 1530 	inc in  
      000987 4D               [ 1] 1531 	tnz a 
      000988 2B 2B            [ 1] 1532 	jrmi 6$
      00098A A1 06            [ 1] 1533 	cp a,#TK_ARRAY
      00098C 2A 3B            [ 1] 1534 	jrpl 9$  ; no attribute for these
      00098E A1 01            [ 1] 1535 	cp a,#TK_COLON
      000990 27 37            [ 1] 1536 	jreq 9$  
      000992                       1537 1$: ; 
      000992 A1 03            [ 1] 1538 	cp a,#TK_CHAR
      000994 26 0B            [ 1] 1539 	jrne 2$
      000996 91 D6 00         [ 4] 1540 	ld a,([in.w],y)
      000999 72 5C 00 01      [ 1] 1541 	inc in 
      00099D 41               [ 1] 1542 	exg a,xl  
      00099E A6 03            [ 1] 1543 	ld a,#TK_CHAR
      0009A0 81               [ 4] 1544 	ret
      0009A1 A1 02            [ 1] 1545 2$:	cp a,#TK_QSTR 
      0009A3 26 24            [ 1] 1546 	jrne 9$
      0009A5 93               [ 1] 1547 	ldw x,y 
      0009A6 72 BB 00 00      [ 2] 1548 	addw x,in.w ; pointer to string 
                                   1549 ; move pointer after string 
      0009AA 91 6D 00         [ 4] 1550 3$:	tnz ([in.w],y)
      0009AD 27 16            [ 1] 1551 	jreq 8$
      0009AF 72 5C 00 01      [ 1] 1552 	inc in 
      0009B3 20 F5            [ 2] 1553 	jra 3$
      0009B5                       1554 6$: 
      0009B5 91 DE 00         [ 5] 1555 	ldw y,([in.w],y)
      0009B8 51               [ 1] 1556 	exgw x,y
      0009B9 A1 84            [ 1] 1557 	cp a,#TK_INTGR
      0009BB 2A 04            [ 1] 1558 	jrpl 7$
      0009BD 1C 26 B9         [ 2] 1559 	addw x,#code_addr
      0009C0 FE               [ 2] 1560 	ldw x,(x) 
      0009C1 72 5C 00 01      [ 1] 1561 7$:	inc in
      0009C5 72 5C 00 01      [ 1] 1562 8$:	inc in 
      0009C9                       1563 9$: 
      0009C9 81               [ 4] 1564 	ret	
                                   1565 
                                   1566 ;-----------------------------------
                                   1567 ; print a 16 bit integer 
                                   1568 ; using variable 'base' as conversion
                                   1569 ; format.
                                   1570 ; input:
                                   1571 ;   X       integer to print 
                                   1572 ;   'base'    conversion base 
                                   1573 ; output:
                                   1574 ;   none 
                                   1575 ;-----------------------------------
      0009CA                       1576 print_int:
      0009CA 72 5F 00 0B      [ 1] 1577 	clr acc24 
      0009CE CF 00 0C         [ 2] 1578 	ldw acc16,x 
      0009D1 72 0F 00 0C 04   [ 2] 1579 	btjf acc16,#7,prti24
      0009D6 72 53 00 0B      [ 1] 1580 	cpl acc24 
                                   1581 
                                   1582 ;------------------------------------
                                   1583 ; print integer in acc24 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 31.
Hexadecimal [24-Bits]



                                   1584 ; input:
                                   1585 ;	acc24 		integer to print 
                                   1586 ;	'base' 		numerical base for conversion 
                                   1587 ;   'tab_width' field width 
                                   1588 ;  output:
                                   1589 ;    A          string length
                                   1590 ;------------------------------------
      0009DA                       1591 prti24:
      0009DA CD 09 E6         [ 4] 1592     call itoa  ; conversion entier en  .asciz
      0009DD CD 12 F8         [ 4] 1593 	call right_align  
      0009E0 88               [ 1] 1594 	push a 
      0009E1 CD 00 00         [ 4] 1595 	call puts
      0009E4 84               [ 1] 1596 	pop a 
      0009E5 81               [ 4] 1597     ret	
                                   1598 
                                   1599 ;------------------------------------
                                   1600 ; convert integer in acc24 to string
                                   1601 ; input:
                                   1602 ;   'base'	conversion base 
                                   1603 ;	acc24	integer to convert
                                   1604 ; output:
                                   1605 ;   X  		pointer to first char of string
                                   1606 ;   A       string length
                                   1607 ;------------------------------------
                           000001  1608 	SIGN=1  ; integer sign 
                           000002  1609 	LEN=2 
                           000003  1610 	PSTR=3
                           000004  1611 	VSIZE=4 ;locals size
      0009E6                       1612 itoa:
      0009E6                       1613 	_vars VSIZE
      0009E6 52 04            [ 2]    1     sub sp,#VSIZE 
      0009E8 0F 02            [ 1] 1614 	clr (LEN,sp) ; string length  
      0009EA 0F 01            [ 1] 1615 	clr (SIGN,sp)    ; sign
      0009EC C6 00 0A         [ 1] 1616 	ld a,base 
      0009EF A1 0A            [ 1] 1617 	cp a,#10
      0009F1 26 0A            [ 1] 1618 	jrne 1$
                                   1619 	; base 10 string display with negative sign if bit 23==1
      0009F3 72 0F 00 0B 05   [ 2] 1620 	btjf acc24,#7,1$
      0009F8 03 01            [ 1] 1621 	cpl (SIGN,sp)
      0009FA CD 0A A2         [ 4] 1622 	call neg_acc24
      0009FD                       1623 1$:
                                   1624 ; initialize string pointer 
      0009FD AE 16 90         [ 2] 1625 	ldw x,#tib 
      000A00 1C 00 50         [ 2] 1626 	addw x,#TIB_SIZE
      000A03 5A               [ 2] 1627 	decw x 
      000A04 7F               [ 1] 1628 	clr (x)
      000A05                       1629 itoa_loop:
      000A05 C6 00 0A         [ 1] 1630     ld a,base
      000A08 1F 03            [ 2] 1631 	ldw (PSTR,sp),x 
      000A0A CD 0A 40         [ 4] 1632     call divu24_8 ; acc24/A 
      000A0D 1E 03            [ 2] 1633 	ldw x,(PSTR,sp)
      000A0F AB 30            [ 1] 1634     add a,#'0  ; remainder of division
      000A11 A1 3A            [ 1] 1635     cp a,#'9+1
      000A13 2B 02            [ 1] 1636     jrmi 2$
      000A15 AB 07            [ 1] 1637     add a,#7 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 32.
Hexadecimal [24-Bits]



      000A17                       1638 2$:	
      000A17 5A               [ 2] 1639 	decw x
      000A18 F7               [ 1] 1640     ld (x),a
      000A19 0C 02            [ 1] 1641 	inc (LEN,sp)
                                   1642 	; if acc24==0 conversion done
      000A1B C6 00 0B         [ 1] 1643 	ld a,acc24
      000A1E CA 00 0C         [ 1] 1644 	or a,acc16
      000A21 CA 00 0D         [ 1] 1645 	or a,acc8
      000A24 26 DF            [ 1] 1646     jrne itoa_loop
                                   1647 	;conversion done, next add '$' or '-' as required
      000A26 C6 00 0A         [ 1] 1648 	ld a,base 
      000A29 A1 10            [ 1] 1649 	cp a,#16
      000A2B 27 08            [ 1] 1650 	jreq 8$
      000A2D 7B 01            [ 1] 1651 	ld a,(SIGN,sp)
      000A2F 27 0A            [ 1] 1652     jreq 10$
      000A31 A6 2D            [ 1] 1653     ld a,#'-
      000A33 20 02            [ 2] 1654 	jra 9$ 
      000A35 A6 24            [ 1] 1655 8$: ld a,#'$ 
      000A37 5A               [ 2] 1656 9$: decw x
      000A38 F7               [ 1] 1657     ld (x),a
      000A39 0C 02            [ 1] 1658 	inc (LEN,sp)
      000A3B                       1659 10$:
      000A3B 7B 02            [ 1] 1660 	ld a,(LEN,sp)
      000A3D                       1661 	_drop VSIZE
      000A3D 5B 04            [ 2]    1     addw sp,#VSIZE 
      000A3F 81               [ 4] 1662 	ret
                                   1663 
                                   1664 ;-------------------------------------
                                   1665 ; divide uint24_t by uint8_t
                                   1666 ; used to convert uint24_t to string
                                   1667 ; input:
                                   1668 ;	acc24	dividend
                                   1669 ;   A 		divisor
                                   1670 ; output:
                                   1671 ;   acc24	quotient
                                   1672 ;   A		remainder
                                   1673 ;------------------------------------- 
                                   1674 ; offset  on sp of arguments and locals
                           000001  1675 	U8   = 1   ; divisor on stack
                           000001  1676 	VSIZE =1
      000A40                       1677 divu24_8:
      000A40 89               [ 2] 1678 	pushw x ; save x
      000A41 88               [ 1] 1679 	push a 
                                   1680 	; ld dividend UU:MM bytes in X
      000A42 C6 00 0B         [ 1] 1681 	ld a, acc24
      000A45 95               [ 1] 1682 	ld xh,a
      000A46 C6 00 0C         [ 1] 1683 	ld a,acc24+1
      000A49 97               [ 1] 1684 	ld xl,a
      000A4A 7B 01            [ 1] 1685 	ld a,(U8,SP) ; divisor
      000A4C 62               [ 2] 1686 	div x,a ; UU:MM/U8
      000A4D 88               [ 1] 1687 	push a  ;save remainder
      000A4E 9E               [ 1] 1688 	ld a,xh
      000A4F C7 00 0B         [ 1] 1689 	ld acc24,a
      000A52 9F               [ 1] 1690 	ld a,xl
      000A53 C7 00 0C         [ 1] 1691 	ld acc24+1,a
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 33.
Hexadecimal [24-Bits]



      000A56 84               [ 1] 1692 	pop a
      000A57 95               [ 1] 1693 	ld xh,a
      000A58 C6 00 0D         [ 1] 1694 	ld a,acc24+2
      000A5B 97               [ 1] 1695 	ld xl,a
      000A5C 7B 01            [ 1] 1696 	ld a,(U8,sp) ; divisor
      000A5E 62               [ 2] 1697 	div x,a  ; R:LL/U8
      000A5F 6B 01            [ 1] 1698 	ld (U8,sp),a ; save remainder
      000A61 9F               [ 1] 1699 	ld a,xl
      000A62 C7 00 0D         [ 1] 1700 	ld acc24+2,a
      000A65 84               [ 1] 1701 	pop a
      000A66 85               [ 2] 1702 	popw x
      000A67 81               [ 4] 1703 	ret
                                   1704 
                                   1705 ;--------------------------------------
                                   1706 ; unsigned multiply uint24_t by uint8_t
                                   1707 ; use to convert numerical string to uint24_t
                                   1708 ; input:
                                   1709 ;	acc24	uint24_t 
                                   1710 ;   A		uint8_t
                                   1711 ; output:
                                   1712 ;   acc24   A*acc24
                                   1713 ;-------------------------------------
                                   1714 ; local variables offset  on sp
                           000003  1715 	U8   = 3   ; A pushed on stack
                           000002  1716 	OVFL = 2  ; multiplicaton overflow low byte
                           000001  1717 	OVFH = 1  ; multiplication overflow high byte
                           000003  1718 	VSIZE = 3
      000A68                       1719 mulu24_8:
      000A68 89               [ 2] 1720 	pushw x    ; save X
                                   1721 	; local variables
      000A69 88               [ 1] 1722 	push a     ; U8
      000A6A 5F               [ 1] 1723 	clrw x     ; initialize overflow to 0
      000A6B 89               [ 2] 1724 	pushw x    ; multiplication overflow
                                   1725 ; multiply low byte.
      000A6C C6 00 0D         [ 1] 1726 	ld a,acc24+2
      000A6F 97               [ 1] 1727 	ld xl,a
      000A70 7B 03            [ 1] 1728 	ld a,(U8,sp)
      000A72 42               [ 4] 1729 	mul x,a
      000A73 9F               [ 1] 1730 	ld a,xl
      000A74 C7 00 0D         [ 1] 1731 	ld acc24+2,a
      000A77 9E               [ 1] 1732 	ld a, xh
      000A78 6B 02            [ 1] 1733 	ld (OVFL,sp),a
                                   1734 ; multipy middle byte
      000A7A C6 00 0C         [ 1] 1735 	ld a,acc24+1
      000A7D 97               [ 1] 1736 	ld xl,a
      000A7E 7B 03            [ 1] 1737 	ld a, (U8,sp)
      000A80 42               [ 4] 1738 	mul x,a
                                   1739 ; add overflow to this partial product
      000A81 72 FB 01         [ 2] 1740 	addw x,(OVFH,sp)
      000A84 9F               [ 1] 1741 	ld a,xl
      000A85 C7 00 0C         [ 1] 1742 	ld acc24+1,a
      000A88 4F               [ 1] 1743 	clr a
      000A89 A9 00            [ 1] 1744 	adc a,#0
      000A8B 6B 01            [ 1] 1745 	ld (OVFH,sp),a
      000A8D 9E               [ 1] 1746 	ld a,xh
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 34.
Hexadecimal [24-Bits]



      000A8E 6B 02            [ 1] 1747 	ld (OVFL,sp),a
                                   1748 ; multiply most signficant byte	
      000A90 C6 00 0B         [ 1] 1749 	ld a, acc24
      000A93 97               [ 1] 1750 	ld xl, a
      000A94 7B 03            [ 1] 1751 	ld a, (U8,sp)
      000A96 42               [ 4] 1752 	mul x,a
      000A97 72 FB 01         [ 2] 1753 	addw x, (OVFH,sp)
      000A9A 9F               [ 1] 1754 	ld a, xl
      000A9B C7 00 0B         [ 1] 1755 	ld acc24,a
      000A9E 5B 03            [ 2] 1756     addw sp,#VSIZE
      000AA0 85               [ 2] 1757 	popw x
      000AA1 81               [ 4] 1758 	ret
                                   1759 
                                   1760 ;------------------------------------
                                   1761 ;  two's complement acc24
                                   1762 ;  input:
                                   1763 ;		acc24 variable
                                   1764 ;  output:
                                   1765 ;		acc24 variable
                                   1766 ;-------------------------------------
      000AA2                       1767 neg_acc24:
      000AA2 72 53 00 0D      [ 1] 1768 	cpl acc24+2
      000AA6 72 53 00 0C      [ 1] 1769 	cpl acc24+1
      000AAA 72 53 00 0B      [ 1] 1770 	cpl acc24
      000AAE A6 01            [ 1] 1771 	ld a,#1
      000AB0 CB 00 0D         [ 1] 1772 	add a,acc24+2
      000AB3 C7 00 0D         [ 1] 1773 	ld acc24+2,a
      000AB6 4F               [ 1] 1774 	clr a
      000AB7 C9 00 0C         [ 1] 1775 	adc a,acc24+1
      000ABA C7 00 0C         [ 1] 1776 	ld acc24+1,a 
      000ABD 4F               [ 1] 1777 	clr a 
      000ABE C9 00 0B         [ 1] 1778 	adc a,acc24 
      000AC1 C7 00 0B         [ 1] 1779 	ld acc24,a 
      000AC4 81               [ 4] 1780 	ret
                                   1781 
                                   1782 
                                   1783 
                                   1784 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   1785 ;; compiler routines        ;;
                                   1786 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   1787 ;------------------------------------
                                   1788 ; parse quoted string 
                                   1789 ; input:
                                   1790 ;   Y 	pointer to tib 
                                   1791 ;   X   pointer to output buffer 
                                   1792 ; output:
                                   1793 ;	buffer   parsed string
                                   1794 ;------------------------------------
                           000001  1795 	PREV = 1
                           000002  1796 	CURR =2
                           000002  1797 	VSIZE=2
      000AC5                       1798 parse_quote: 
      000AC5                       1799 	_vars VSIZE 
      000AC5 52 02            [ 2]    1     sub sp,#VSIZE 
      000AC7 4F               [ 1] 1800 	clr a
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 35.
Hexadecimal [24-Bits]



      000AC8 6B 01            [ 1] 1801 1$:	ld (PREV,sp),a 
      000ACA                       1802 2$:	
      000ACA 91 D6 00         [ 4] 1803 	ld a,([in.w],y)
      000ACD 27 24            [ 1] 1804 	jreq 6$
      000ACF 72 5C 00 01      [ 1] 1805 	inc in 
      000AD3 6B 02            [ 1] 1806 	ld (CURR,sp),a 
      000AD5 A6 5C            [ 1] 1807 	ld a,#'\
      000AD7 11 01            [ 1] 1808 	cp a, (PREV,sp)
      000AD9 26 0A            [ 1] 1809 	jrne 3$
      000ADB 0F 01            [ 1] 1810 	clr (PREV,sp)
      000ADD 7B 02            [ 1] 1811 	ld a,(CURR,sp)
      000ADF AD 1C            [ 4] 1812 	callr convert_escape
      000AE1 F7               [ 1] 1813 	ld (x),a 
      000AE2 5C               [ 2] 1814 	incw x 
      000AE3 20 E5            [ 2] 1815 	jra 2$
      000AE5                       1816 3$:
      000AE5 7B 02            [ 1] 1817 	ld a,(CURR,sp)
      000AE7 A1 5C            [ 1] 1818 	cp a,#'\'
      000AE9 27 DD            [ 1] 1819 	jreq 1$
      000AEB A1 22            [ 1] 1820 	cp a,#'"
      000AED 27 04            [ 1] 1821 	jreq 6$ 
      000AEF F7               [ 1] 1822 	ld (x),a 
      000AF0 5C               [ 2] 1823 	incw x 
      000AF1 20 D7            [ 2] 1824 	jra 2$
      000AF3                       1825 6$:
      000AF3 7F               [ 1] 1826 	clr (x)
      000AF4 5C               [ 2] 1827 	incw x 
      000AF5 90 93            [ 1] 1828 	ldw y,x 
      000AF7 5F               [ 1] 1829 	clrw x 
      000AF8 A6 02            [ 1] 1830 	ld a,#TK_QSTR  
      000AFA                       1831 	_drop VSIZE
      000AFA 5B 02            [ 2]    1     addw sp,#VSIZE 
      000AFC 81               [ 4] 1832 	ret 
                                   1833 
                                   1834 ;---------------------------------------
                                   1835 ; called by parse_quote
                                   1836 ; subtitute escaped character 
                                   1837 ; by their ASCII value .
                                   1838 ; input:
                                   1839 ;   A  character following '\'
                                   1840 ; output:
                                   1841 ;   A  substitued char or same if not valid.
                                   1842 ;---------------------------------------
      000AFD                       1843 convert_escape:
      000AFD 89               [ 2] 1844 	pushw x 
      000AFE AE 0B 12         [ 2] 1845 	ldw x,#escaped 
      000B01 F1               [ 1] 1846 1$:	cp a,(x)
      000B02 27 06            [ 1] 1847 	jreq 2$
      000B04 7D               [ 1] 1848 	tnz (x)
      000B05 27 09            [ 1] 1849 	jreq 3$
      000B07 5C               [ 2] 1850 	incw x 
      000B08 20 F7            [ 2] 1851 	jra 1$
      000B0A 1D 0B 12         [ 2] 1852 2$: subw x,#escaped 
      000B0D 9F               [ 1] 1853 	ld a,xl 
      000B0E AB 07            [ 1] 1854 	add a,#7
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 36.
Hexadecimal [24-Bits]



      000B10 85               [ 2] 1855 3$:	popw x 
      000B11 81               [ 4] 1856 	ret 
                                   1857 
      000B12 61 62 74 6E 76 66 72  1858 escaped: .asciz "abtnvfr"
             00
                                   1859 
                                   1860 ;-------------------------
                                   1861 ; integer parser 
                                   1862 ; input:
                                   1863 ;   X 		point to output buffer  
                                   1864 ;   Y 		point to tib 
                                   1865 ;   A 	    first digit|'$' 
                                   1866 ; output:  
                                   1867 ;   X 		integer 
                                   1868 ;   A 		TK_INTGR
                                   1869 ;   acc24   24 bits integer 
                                   1870 ;-------------------------
                           000001  1871 	BASE=1
                           000002  1872 	TCHAR=2 
                           000003  1873 	XSAVE=3
                           000004  1874 	VSIZE=4 
      000B1A                       1875 parse_integer: ; { -- n }
      000B1A 89               [ 2] 1876 	pushw x 	
      000B1B 4B 00            [ 1] 1877 	push #0 ; TCHAR
      000B1D 4B 0A            [ 1] 1878 	push #10 ; BASE=10
      000B1F A1 24            [ 1] 1879 	cp a,#'$
      000B21 26 04            [ 1] 1880 	jrne 2$ 
      000B23                       1881     _drop #1
      000B23 5B 01            [ 2]    1     addw sp,##1 
      000B25 4B 10            [ 1] 1882 	push #16  ; BASE=16
      000B27 F7               [ 1] 1883 2$:	ld (x),a 
      000B28 5C               [ 2] 1884 	incw x 
      000B29 91 D6 00         [ 4] 1885 	ld a,([in.w],y)
      000B2C 72 5C 00 01      [ 1] 1886 	inc in 
      000B30 CD 0D AD         [ 4] 1887 	call to_upper 
      000B33 6B 02            [ 1] 1888 	ld (TCHAR,sp),a 
      000B35 CD 05 80         [ 4] 1889 	call is_digit 
      000B38 25 ED            [ 1] 1890 	jrc 2$
      000B3A A6 10            [ 1] 1891 	ld a,#16 
      000B3C 11 01            [ 1] 1892 	cp a,(BASE,sp)
      000B3E 26 0A            [ 1] 1893 	jrne 3$ 
      000B40 7B 02            [ 1] 1894 	ld a,(TCHAR,sp)
      000B42 A1 41            [ 1] 1895 	cp a,#'A 
      000B44 2B 04            [ 1] 1896 	jrmi 3$ 
      000B46 A1 47            [ 1] 1897 	cp a,#'G 
      000B48 2B DD            [ 1] 1898 	jrmi 2$ 
      000B4A 72 5A 00 01      [ 1] 1899 3$: dec in 	
      000B4E 7F               [ 1] 1900     clr (x)
      000B4F 1E 03            [ 2] 1901 	ldw x,(XSAVE,sp)
      000B51 CD 0D B9         [ 4] 1902 	call atoi24
      000B54 90 93            [ 1] 1903 	ldw y,x 
      000B56 CE 00 0C         [ 2] 1904 	ldw x,acc16 
      000B59 A6 84            [ 1] 1905 	ld a,#TK_INTGR
      000B5B 90 FF            [ 2] 1906 	ldw (y),x 
      000B5D 72 A9 00 02      [ 2] 1907 	addw y,#2
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 37.
Hexadecimal [24-Bits]



      000B61                       1908 	_drop VSIZE  
      000B61 5B 04            [ 2]    1     addw sp,#VSIZE 
      000B63 81               [ 4] 1909 	ret 	
                                   1910 
                                   1911 ;-------------------------
                                   1912 ; binary integer parser
                                   1913 ; build integer in acc24  
                                   1914 ; input:
                                   1915 ;   X 		point to output buffer  
                                   1916 ;   Y 		point to tib 
                                   1917 ;   A 	    '&' 
                                   1918 ; output:  
                                   1919 ;   buffer  TK_INTGR integer  
                                   1920 ;   X 		int16 
                                   1921 ;   A 		TK_INTGR
                                   1922 ;   acc24    int24 
                                   1923 ;-------------------------
                           000001  1924 	BINARY=1 ; 24 bits integer 
                           000003  1925 	VSIZE=3
      000B64                       1926 parse_binary: ; { -- n }
      000B64 4B 00            [ 1] 1927 	push #0
      000B66 4B 00            [ 1] 1928 	push #0
      000B68 4B 00            [ 1] 1929 	push #0
      000B6A                       1930 2$:	
      000B6A 91 D6 00         [ 4] 1931 	ld a,([in.w],y)
      000B6D 72 5C 00 01      [ 1] 1932 	inc in 
      000B71 A1 30            [ 1] 1933 	cp a,#'0 
      000B73 27 06            [ 1] 1934 	jreq 3$
      000B75 A1 31            [ 1] 1935 	cp a,#'1 
      000B77 27 02            [ 1] 1936 	jreq 3$ 
      000B79 20 0B            [ 2] 1937 	jra bin_exit 
      000B7B A0 30            [ 1] 1938 3$: sub a,#'0 
      000B7D 46               [ 1] 1939 	rrc a
      000B7E 09 03            [ 1] 1940 	rlc (BINARY+2,sp) 
      000B80 09 02            [ 1] 1941 	rlc (BINARY+1,sp)
      000B82 09 01            [ 1] 1942 	rlc (BINARY,sp) 
      000B84 20 E4            [ 2] 1943 	jra 2$  
      000B86                       1944 bin_exit:
      000B86 72 5A 00 01      [ 1] 1945 	dec in 
      000B8A 90 93            [ 1] 1946 	ldw y,x
      000B8C 7B 01            [ 1] 1947 	ld a,(BINARY,sp)
      000B8E C7 00 0B         [ 1] 1948 	ld acc24,a 
      000B91 1E 02            [ 2] 1949 	ldw x,(BINARY+1,sp)
      000B93 CF 00 0C         [ 2] 1950 	ldw acc16,x
      000B96 90 FF            [ 2] 1951 	ldw (y),x 
      000B98 72 A9 00 02      [ 2] 1952 	addw y,#2  
      000B9C A6 84            [ 1] 1953 	ld a,#TK_INTGR 	
      000B9E                       1954 	_drop VSIZE 
      000B9E 5B 03            [ 2]    1     addw sp,#VSIZE 
      000BA0 81               [ 4] 1955 	ret
                                   1956 
                                   1957 ;---------------------------
                                   1958 ;  token begin with a letter,
                                   1959 ;  is keyword or variable. 	
                                   1960 ; input:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 38.
Hexadecimal [24-Bits]



                                   1961 ;   X 		point to pad 
                                   1962 ;   Y 		point to text
                                   1963 ;   A 	    first letter  
                                   1964 ; output:
                                   1965 ;   X		exec_addr|var_addr 
                                   1966 ;   A 		TK_CMD|TK_IFUNC|TK_CFUNC  
                                   1967 ;   pad 	keyword|var_name  
                                   1968 ;--------------------------  
                           000001  1969 	XFIRST=1
                           000002  1970 	VSIZE=2
      000BA1                       1971 parse_keyword: 
      000BA1 89               [ 2] 1972 	pushw x 
      000BA2                       1973 kw_loop:	
      000BA2 CD 0D AD         [ 4] 1974 	call to_upper 
      000BA5 F7               [ 1] 1975 	ld (x),a 
      000BA6 5C               [ 2] 1976 	incw x 
      000BA7 91 D6 00         [ 4] 1977 	ld a,([in.w],y)
      000BAA 72 5C 00 01      [ 1] 1978 	inc in 
      000BAE CD 05 6F         [ 4] 1979 	call is_alpha 
      000BB1 25 EF            [ 1] 1980 	jrc kw_loop
      000BB3 72 5A 00 01      [ 1] 1981 	dec in   
      000BB7 7F               [ 1] 1982 1$: clr (x)
      000BB8 1E 01            [ 2] 1983 	ldw x,(XFIRST,sp) 
      000BBA E6 01            [ 1] 1984 	ld a,(1,x)
      000BBC 26 13            [ 1] 1985 	jrne 2$
                                   1986 ; one letter variable name 
      000BBE F6               [ 1] 1987 	ld a,(x) 
      000BBF A0 41            [ 1] 1988 	sub a,#'A 
      000BC1 48               [ 1] 1989 	sll a 
      000BC2 88               [ 1] 1990 	push a 
      000BC3 4B 00            [ 1] 1991 	push #0
      000BC5 AE 00 2F         [ 2] 1992 	ldw x,#vars 
      000BC8 72 FB 01         [ 2] 1993 	addw x,(1,sp) ; X=var address 
      000BCB                       1994 	_drop 2 
      000BCB 5B 02            [ 2]    1     addw sp,#2 
      000BCD A6 85            [ 1] 1995 	ld a,#TK_VAR 
      000BCF 20 0E            [ 2] 1996 	jra 4$ 
      000BD1                       1997 2$: ; check for keyword, otherwise syntax error.
      000BD1                       1998 	_ldx_dict kword_dict ; dictionary entry point
      000BD1 AE 26 B3         [ 2]    1     ldw x,#kword_dict+2
      000BD4 16 01            [ 2] 1999 	ldw y,(XFIRST,sp) ; name to search for
      000BD6 CD 0F B7         [ 4] 2000 	call search_dict
      000BD9 4D               [ 1] 2001 	tnz a
      000BDA 26 03            [ 1] 2002 	jrne 4$ 
      000BDC CC 08 7B         [ 2] 2003 	jp syntax_error
      000BDF                       2004 4$:	
      000BDF 16 01            [ 2] 2005 	ldw y,(XFIRST,sp)
      000BE1 90 F7            [ 1] 2006 	ld (y),a 
      000BE3 90 5C            [ 2] 2007 	incw y 
      000BE5 90 FF            [ 2] 2008 	ldw (y),x
      000BE7 72 A9 00 02      [ 2] 2009 	addw y,#2  
      000BEB                       2010 	_drop VSIZE 
      000BEB 5B 02            [ 2]    1     addw sp,#VSIZE 
      000BED 81               [ 4] 2011 	ret  	
                                   2012 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 39.
Hexadecimal [24-Bits]



                                   2013 
                                   2014 ;------------------------------------
                                   2015 ; scan text for next token
                                   2016 ; input: 
                                   2017 ;	X 		pointer to buffer where 
                                   2018 ;	        token id and value are copied 
                                   2019 ; use:
                                   2020 ;	Y   pointer to text in tib 
                                   2021 ; output:
                                   2022 ;   A       token attribute 
                                   2023 ;   X 		token value
                                   2024 ;   Y       updated position in output buffer   
                                   2025 ;------------------------------------
                                   2026 	; use to check special character 
                                   2027 	.macro _case c t  
                                   2028 	ld a,#c 
                                   2029 	cp a,(TCHAR,sp) 
                                   2030 	jrne t
                                   2031 	.endm 
                                   2032 
                           000001  2033 	TCHAR=1
                           000002  2034 	ATTRIB=2
                           000002  2035 	VSIZE=2
      000BEE                       2036 get_token: 
      000BEE                       2037 	_vars VSIZE
      000BEE 52 02            [ 2]    1     sub sp,#VSIZE 
                                   2038 ;	ld a,in 
                                   2039 ;	sub a,count
                                   2040 ;   jrmi 0$
                                   2041 ;	clr a 
                                   2042 ;	ret 
      000BF0                       2043 0$: 
      000BF0 90 AE 16 90      [ 2] 2044 	ldw y,#tib    	
      000BF4 A6 20            [ 1] 2045 	ld a,#SPACE
      000BF6 CD 0E 23         [ 4] 2046 	call skip
      000BF9 55 00 01 00 02   [ 1] 2047 	mov in.saved,in 
      000BFE 91 D6 00         [ 4] 2048 	ld a,([in.w],y)
      000C01 26 05            [ 1] 2049 	jrne 1$
      000C03 90 93            [ 1] 2050 	ldw y,x 
      000C05 CC 0D AA         [ 2] 2051 	jp token_exit ; end of line 
      000C08 72 5C 00 01      [ 1] 2052 1$:	inc in 
      000C0C CD 0D AD         [ 4] 2053 	call to_upper 
      000C0F 6B 01            [ 1] 2054 	ld (TCHAR,sp),a 
                                   2055 ; check for quoted string
      000C11                       2056 str_tst:  	
      000C11                       2057 	_case '"' nbr_tst
      000C11 A6 22            [ 1]    1 	ld a,#'"' 
      000C13 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000C15 26 0A            [ 1]    3 	jrne nbr_tst
      000C17 A6 02            [ 1] 2058 	ld a,#TK_QSTR
      000C19 F7               [ 1] 2059 	ld (x),a 
      000C1A 5C               [ 2] 2060 	incw x 
      000C1B CD 0A C5         [ 4] 2061 	call parse_quote
      000C1E CC 0D AA         [ 2] 2062 	jp token_exit
      000C21                       2063 nbr_tst:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 40.
Hexadecimal [24-Bits]



                                   2064 ; check for hexadecimal number 
      000C21 A6 24            [ 1] 2065 	ld a,#'$'
      000C23 11 01            [ 1] 2066 	cp a,(TCHAR,sp) 
      000C25 27 17            [ 1] 2067 	jreq 1$
                                   2068 ;check for binary number 
      000C27 A6 26            [ 1] 2069 	ld a,#'&
      000C29 11 01            [ 1] 2070 	cp a,(TCHAR,sp)
      000C2B 26 0A            [ 1] 2071 	jrne 0$
      000C2D A6 84            [ 1] 2072 	ld a,#TK_INTGR
      000C2F F7               [ 1] 2073 	ld (x),a 
      000C30 5C               [ 2] 2074 	incw x 
      000C31 CD 0B 64         [ 4] 2075 	call parse_binary ; expect binary integer 
      000C34 CC 0D AA         [ 2] 2076 	jp token_exit 
                                   2077 ; check for decimal number 	
      000C37 7B 01            [ 1] 2078 0$:	ld a,(TCHAR,sp)
      000C39 CD 05 80         [ 4] 2079 	call is_digit
      000C3C 24 0C            [ 1] 2080 	jrnc 3$
      000C3E A6 84            [ 1] 2081 1$:	ld a,#TK_INTGR 
      000C40 F7               [ 1] 2082 	ld (x),a 
      000C41 5C               [ 2] 2083 	incw x 
      000C42 7B 01            [ 1] 2084 	ld a,(TCHAR,sp)
      000C44 CD 0B 1A         [ 4] 2085 	call parse_integer 
      000C47 CC 0D AA         [ 2] 2086 	jp token_exit 
      000C4A                       2087 3$: 
      000C4A                       2088 	_case '(' bkslsh_tst 
      000C4A A6 28            [ 1]    1 	ld a,#'(' 
      000C4C 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000C4E 26 05            [ 1]    3 	jrne bkslsh_tst
      000C50 A6 07            [ 1] 2089 	ld a,#TK_LPAREN
      000C52 CC 0D A6         [ 2] 2090 	jp token_char   	
      000C55                       2091 bkslsh_tst: ; character token 
      000C55                       2092 	_case '\',rparnt_tst
      000C55 A6 5C            [ 1]    1 	ld a,#'\' 
      000C57 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000C59 26 16            [ 1]    3 	jrne rparnt_tst
      000C5B A6 03            [ 1] 2093 	ld a,#TK_CHAR 
      000C5D F7               [ 1] 2094 	ld (x),a 
      000C5E 5C               [ 2] 2095 	incw x 
      000C5F 91 D6 00         [ 4] 2096 	ld a,([in.w],y)
      000C62 F7               [ 1] 2097 	ld (x),a 
      000C63 5C               [ 2] 2098 	incw x
      000C64 90 93            [ 1] 2099 	ldw y,x 	 
      000C66 72 5C 00 01      [ 1] 2100 	inc in  
      000C6A 5F               [ 1] 2101 	clrw x 
      000C6B 97               [ 1] 2102 	ld xl,a 
      000C6C A6 03            [ 1] 2103 	ld a,#TK_CHAR 
      000C6E CC 0D AA         [ 2] 2104 	jp token_exit 
      000C71                       2105 rparnt_tst:		
      000C71                       2106 	_case ')' colon_tst 
      000C71 A6 29            [ 1]    1 	ld a,#')' 
      000C73 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000C75 26 05            [ 1]    3 	jrne colon_tst
      000C77 A6 08            [ 1] 2107 	ld a,#TK_RPAREN 
      000C79 CC 0D A6         [ 2] 2108 	jp token_char
      000C7C                       2109 colon_tst:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 41.
Hexadecimal [24-Bits]



      000C7C                       2110 	_case ':' comma_tst 
      000C7C A6 3A            [ 1]    1 	ld a,#':' 
      000C7E 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000C80 26 05            [ 1]    3 	jrne comma_tst
      000C82 A6 01            [ 1] 2111 	ld a,#TK_COLON 
      000C84 CC 0D A6         [ 2] 2112 	jp token_char  
      000C87                       2113 comma_tst:
      000C87                       2114 	_case COMMA sharp_tst 
      000C87 A6 2C            [ 1]    1 	ld a,#COMMA 
      000C89 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000C8B 26 05            [ 1]    3 	jrne sharp_tst
      000C8D A6 09            [ 1] 2115 	ld a,#TK_COMMA
      000C8F CC 0D A6         [ 2] 2116 	jp token_char
      000C92                       2117 sharp_tst:
      000C92                       2118 	_case SHARP dash_tst 
      000C92 A6 23            [ 1]    1 	ld a,#SHARP 
      000C94 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000C96 26 05            [ 1]    3 	jrne dash_tst
      000C98 A6 0A            [ 1] 2119 	ld a,#TK_SHARP
      000C9A CC 0D A6         [ 2] 2120 	jp token_char  	 	 
      000C9D                       2121 dash_tst: 	
      000C9D                       2122 	_case '-' at_tst 
      000C9D A6 2D            [ 1]    1 	ld a,#'-' 
      000C9F 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000CA1 26 05            [ 1]    3 	jrne at_tst
      000CA3 A6 11            [ 1] 2123 	ld a,#TK_MINUS  
      000CA5 CC 0D A6         [ 2] 2124 	jp token_char 
      000CA8                       2125 at_tst:
      000CA8                       2126 	_case '@' qmark_tst 
      000CA8 A6 40            [ 1]    1 	ld a,#'@' 
      000CAA 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000CAC 26 05            [ 1]    3 	jrne qmark_tst
      000CAE A6 06            [ 1] 2127 	ld a,#TK_ARRAY 
      000CB0 CC 0D A6         [ 2] 2128 	jp token_char
      000CB3                       2129 qmark_tst:
      000CB3                       2130 	_case '?' tick_tst 
      000CB3 A6 3F            [ 1]    1 	ld a,#'?' 
      000CB5 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000CB7 26 12            [ 1]    3 	jrne tick_tst
      000CB9 A6 80            [ 1] 2131 	ld a,#TK_CMD  
      000CBB F7               [ 1] 2132 	ld (x),a 
      000CBC 5C               [ 2] 2133 	incw x 
      000CBD 90 93            [ 1] 2134 	ldw y,x 
      000CBF AE 00 74         [ 2] 2135 	ldw x,#PRT_IDX 
      000CC2 90 FF            [ 2] 2136 	ldw (y),x 
      000CC4 72 A9 00 02      [ 2] 2137 	addw y,#2
      000CC8 CC 0D AA         [ 2] 2138 	jp token_exit
      000CCB                       2139 tick_tst: ; comment 
      000CCB                       2140 	_case TICK plus_tst 
      000CCB A6 27            [ 1]    1 	ld a,#TICK 
      000CCD 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000CCF 26 35            [ 1]    3 	jrne plus_tst
      000CD1 A6 80            [ 1] 2141 	ld a,#TK_CMD
      000CD3 F7               [ 1] 2142 	ld (x),a 
      000CD4 5C               [ 2] 2143 	incw x
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 42.
Hexadecimal [24-Bits]



      000CD5 90 AE 00 8E      [ 2] 2144 	ldw y,#REM_IDX
      000CD9 FF               [ 2] 2145 	ldw (x),y 
      000CDA 1C 00 02         [ 2] 2146 	addw x,#2  
      000CDD                       2147 copy_comment:
      000CDD 90 AE 16 90      [ 2] 2148 	ldw y,#tib 
      000CE1 72 B9 00 00      [ 2] 2149 	addw y,in.w
      000CE5 90 89            [ 2] 2150 	pushw y
      000CE7 CD 03 B4         [ 4] 2151 	call strcpy
      000CEA 72 F2 01         [ 2] 2152     subw y,(1,sp)
      000CED 90 9F            [ 1] 2153 	ld a,yl 
      000CEF CB 00 01         [ 1] 2154 	add a,in
      000CF2 C7 00 01         [ 1] 2155 	ld in,a 
      000CF5 1F 01            [ 2] 2156 	ldw (1,sp),x
      000CF7 72 F9 01         [ 2] 2157 	addw y,(1,sp)
      000CFA 90 5C            [ 2] 2158 	incw y 
      000CFC                       2159 	_drop 2 
      000CFC 5B 02            [ 2]    1     addw sp,#2 
      000CFE AE 00 8E         [ 2] 2160 	ldw x,#REM_IDX 
      000D01 A6 80            [ 1] 2161 	ld a,#TK_CMD 
      000D03 CC 0D AA         [ 2] 2162 	jp token_exit 
      000D06                       2163 plus_tst:
      000D06                       2164 	_case '+' star_tst 
      000D06 A6 2B            [ 1]    1 	ld a,#'+' 
      000D08 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000D0A 26 05            [ 1]    3 	jrne star_tst
      000D0C A6 10            [ 1] 2165 	ld a,#TK_PLUS  
      000D0E CC 0D A6         [ 2] 2166 	jp token_char 
      000D11                       2167 star_tst:
      000D11                       2168 	_case '*' slash_tst 
      000D11 A6 2A            [ 1]    1 	ld a,#'*' 
      000D13 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000D15 26 05            [ 1]    3 	jrne slash_tst
      000D17 A6 20            [ 1] 2169 	ld a,#TK_MULT 
      000D19 CC 0D A6         [ 2] 2170 	jp token_char 
      000D1C                       2171 slash_tst: 
      000D1C                       2172 	_case '/' prcnt_tst 
      000D1C A6 2F            [ 1]    1 	ld a,#'/' 
      000D1E 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000D20 26 05            [ 1]    3 	jrne prcnt_tst
      000D22 A6 21            [ 1] 2173 	ld a,#TK_DIV 
      000D24 CC 0D A6         [ 2] 2174 	jp token_char 
      000D27                       2175 prcnt_tst:
      000D27                       2176 	_case '%' eql_tst 
      000D27 A6 25            [ 1]    1 	ld a,#'%' 
      000D29 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000D2B 26 05            [ 1]    3 	jrne eql_tst
      000D2D A6 22            [ 1] 2177 	ld a,#TK_MOD
      000D2F CC 0D A6         [ 2] 2178 	jp token_char  
                                   2179 ; 1 or 2 character tokens 	
      000D32                       2180 eql_tst:
      000D32                       2181 	_case '=' gt_tst 		
      000D32 A6 3D            [ 1]    1 	ld a,#'=' 
      000D34 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000D36 26 05            [ 1]    3 	jrne gt_tst
      000D38 A6 32            [ 1] 2182 	ld a,#TK_EQUAL
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 43.
Hexadecimal [24-Bits]



      000D3A CC 0D A6         [ 2] 2183 	jp token_char 
      000D3D                       2184 gt_tst:
      000D3D                       2185 	_case '>' lt_tst 
      000D3D A6 3E            [ 1]    1 	ld a,#'>' 
      000D3F 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000D41 26 23            [ 1]    3 	jrne lt_tst
      000D43 A6 31            [ 1] 2186 	ld a,#TK_GT 
      000D45 6B 02            [ 1] 2187 	ld (ATTRIB,sp),a 
      000D47 72 5C 00 01      [ 1] 2188 	inc in 
      000D4B 91 D6 00         [ 4] 2189 	ld a,([in.w],y)
      000D4E A1 3D            [ 1] 2190 	cp a,#'=
      000D50 26 04            [ 1] 2191 	jrne 1$
      000D52 A6 33            [ 1] 2192 	ld a,#TK_GE 
      000D54 20 50            [ 2] 2193 	jra token_char  
      000D56 A1 3C            [ 1] 2194 1$: cp a,#'<
      000D58 26 04            [ 1] 2195 	jrne 2$
      000D5A A6 35            [ 1] 2196 	ld a,#TK_NE 
      000D5C 20 48            [ 2] 2197 	jra token_char 
      000D5E 72 5A 00 01      [ 1] 2198 2$: dec in
      000D62 7B 02            [ 1] 2199 	ld a,(ATTRIB,sp)
      000D64 20 40            [ 2] 2200 	jra token_char 	 
      000D66                       2201 lt_tst:
      000D66                       2202 	_case '<' other
      000D66 A6 3C            [ 1]    1 	ld a,#'<' 
      000D68 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000D6A 26 23            [ 1]    3 	jrne other
      000D6C A6 34            [ 1] 2203 	ld a,#TK_LT 
      000D6E 6B 02            [ 1] 2204 	ld (ATTRIB,sp),a 
      000D70 72 5C 00 01      [ 1] 2205 	inc in 
      000D74 91 D6 00         [ 4] 2206 	ld a,([in.w],y)
      000D77 A1 3D            [ 1] 2207 	cp a,#'=
      000D79 26 04            [ 1] 2208 	jrne 1$
      000D7B A6 36            [ 1] 2209 	ld a,#TK_LE 
      000D7D 20 27            [ 2] 2210 	jra token_char 
      000D7F A1 3E            [ 1] 2211 1$: cp a,#'>
      000D81 26 04            [ 1] 2212 	jrne 2$
      000D83 A6 35            [ 1] 2213 	ld a,#TK_NE 
      000D85 20 1F            [ 2] 2214 	jra token_char 
      000D87 72 5A 00 01      [ 1] 2215 2$: dec in 
      000D8B 7B 02            [ 1] 2216 	ld a,(ATTRIB,sp)
      000D8D 20 17            [ 2] 2217 	jra token_char 	
      000D8F                       2218 other: ; not a special character 	 
      000D8F 7B 01            [ 1] 2219 	ld a,(TCHAR,sp)
      000D91 CD 05 6F         [ 4] 2220 	call is_alpha 
      000D94 25 03            [ 1] 2221 	jrc 30$ 
      000D96 CC 08 7B         [ 2] 2222 	jp syntax_error 
      000D99                       2223 30$: 
      000D99 CD 0B A1         [ 4] 2224 	call parse_keyword
      000D9C A3 15 F9         [ 2] 2225 	cpw x,#remark 
      000D9F 26 09            [ 1] 2226 	jrne token_exit 
      000DA1 90 93            [ 1] 2227 	ldw y,x 
      000DA3 CC 0C DD         [ 2] 2228 	jp copy_comment 
      000DA6                       2229 token_char:
      000DA6 F7               [ 1] 2230 	ld (x),a 
      000DA7 5C               [ 2] 2231 	incw x
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 44.
Hexadecimal [24-Bits]



      000DA8 90 93            [ 1] 2232 	ldw y,x 
      000DAA                       2233 token_exit:
      000DAA                       2234 	_drop VSIZE 
      000DAA 5B 02            [ 2]    1     addw sp,#VSIZE 
      000DAC 81               [ 4] 2235 	ret
                                   2236 
                                   2237 
                                   2238 ;------------------------------------
                                   2239 ; convert alpha to uppercase
                                   2240 ; input:
                                   2241 ;    a  character to convert
                                   2242 ; output:
                                   2243 ;    a  uppercase character
                                   2244 ;------------------------------------
      000DAD                       2245 to_upper::
      000DAD A1 61            [ 1] 2246 	cp a,#'a
      000DAF 2A 01            [ 1] 2247 	jrpl 1$
      000DB1 81               [ 4] 2248 0$:	ret
      000DB2 A1 7A            [ 1] 2249 1$: cp a,#'z	
      000DB4 22 FB            [ 1] 2250 	jrugt 0$
      000DB6 A0 20            [ 1] 2251 	sub a,#32
      000DB8 81               [ 4] 2252 	ret
                                   2253 	
                                   2254 ;------------------------------------
                                   2255 ; convert pad content in integer
                                   2256 ; input:
                                   2257 ;    x		.asciz to convert
                                   2258 ; output:
                                   2259 ;    acc24      int24_t
                                   2260 ;------------------------------------
                                   2261 	; local variables
                           000001  2262 	SIGN=1 ; 1 byte, 
                           000002  2263 	BASE=2 ; 1 byte, numeric base used in conversion
                           000003  2264 	TEMP=3 ; 1 byte, temporary storage
                           000003  2265 	VSIZE=3 ; 3 bytes reserved for local storage
      000DB9                       2266 atoi24::
      000DB9 89               [ 2] 2267 	pushw x 
      000DBA                       2268 	_vars VSIZE
      000DBA 52 03            [ 2]    1     sub sp,#VSIZE 
                                   2269 	; acc24=0 
      000DBC 72 5F 00 0B      [ 1] 2270 	clr acc24    
      000DC0 72 5F 00 0C      [ 1] 2271 	clr acc16
      000DC4 72 5F 00 0D      [ 1] 2272 	clr acc8 
      000DC8 0F 01            [ 1] 2273 	clr (SIGN,sp)
      000DCA A6 0A            [ 1] 2274 	ld a,#10
      000DCC 6B 02            [ 1] 2275 	ld (BASE,sp),a ; default base decimal
      000DCE F6               [ 1] 2276 	ld a,(x)
      000DCF 27 47            [ 1] 2277 	jreq 9$  ; completed if 0
      000DD1 A1 2D            [ 1] 2278 	cp a,#'-
      000DD3 26 04            [ 1] 2279 	jrne 1$
      000DD5 03 01            [ 1] 2280 	cpl (SIGN,sp)
      000DD7 20 08            [ 2] 2281 	jra 2$
      000DD9 A1 24            [ 1] 2282 1$: cp a,#'$
      000DDB 26 06            [ 1] 2283 	jrne 3$
      000DDD A6 10            [ 1] 2284 	ld a,#16
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 45.
Hexadecimal [24-Bits]



      000DDF 6B 02            [ 1] 2285 	ld (BASE,sp),a
      000DE1 5C               [ 2] 2286 2$:	incw x
      000DE2 F6               [ 1] 2287 	ld a,(x)
      000DE3                       2288 3$:	
      000DE3 A1 61            [ 1] 2289 	cp a,#'a
      000DE5 2B 02            [ 1] 2290 	jrmi 4$
      000DE7 A0 20            [ 1] 2291 	sub a,#32
      000DE9 A1 30            [ 1] 2292 4$:	cp a,#'0
      000DEB 2B 2B            [ 1] 2293 	jrmi 9$
      000DED A0 30            [ 1] 2294 	sub a,#'0
      000DEF A1 0A            [ 1] 2295 	cp a,#10
      000DF1 2B 06            [ 1] 2296 	jrmi 5$
      000DF3 A0 07            [ 1] 2297 	sub a,#7
      000DF5 11 02            [ 1] 2298 	cp a,(BASE,sp)
      000DF7 2A 1F            [ 1] 2299 	jrpl 9$
      000DF9 6B 03            [ 1] 2300 5$:	ld (TEMP,sp),a
      000DFB 7B 02            [ 1] 2301 	ld a,(BASE,sp)
      000DFD CD 0A 68         [ 4] 2302 	call mulu24_8
      000E00 7B 03            [ 1] 2303 	ld a,(TEMP,sp)
      000E02 CB 00 0D         [ 1] 2304 	add a,acc24+2
      000E05 C7 00 0D         [ 1] 2305 	ld acc24+2,a
      000E08 4F               [ 1] 2306 	clr a
      000E09 C9 00 0C         [ 1] 2307 	adc a,acc24+1
      000E0C C7 00 0C         [ 1] 2308 	ld acc24+1,a
      000E0F 4F               [ 1] 2309 	clr a
      000E10 C9 00 0B         [ 1] 2310 	adc a,acc24
      000E13 C7 00 0B         [ 1] 2311 	ld acc24,a
      000E16 20 C9            [ 2] 2312 	jra 2$
      000E18 0D 01            [ 1] 2313 9$:	tnz (SIGN,sp)
      000E1A 27 03            [ 1] 2314     jreq atoi_exit
      000E1C CD 0A A2         [ 4] 2315     call neg_acc24
      000E1F                       2316 atoi_exit: 
      000E1F                       2317 	_drop VSIZE
      000E1F 5B 03            [ 2]    1     addw sp,#VSIZE 
      000E21 85               [ 2] 2318 	popw x ; restore x
      000E22 81               [ 4] 2319 	ret
                                   2320 
                                   2321 
                                   2322 ;------------------------------------
                                   2323 ; skip character c in text starting from 'in'
                                   2324 ; input:
                                   2325 ;	 y 		point to text buffer
                                   2326 ;    a 		character to skip
                                   2327 ; output:  
                                   2328 ;	'in' ajusted to new position
                                   2329 ;------------------------------------
                           000001  2330 	C = 1 ; local var
      000E23                       2331 skip:
      000E23 88               [ 1] 2332 	push a
      000E24 91 D6 00         [ 4] 2333 1$:	ld a,([in.w],y)
      000E27 27 0A            [ 1] 2334 	jreq 2$
      000E29 11 01            [ 1] 2335 	cp a,(C,sp)
      000E2B 26 06            [ 1] 2336 	jrne 2$
      000E2D 72 5C 00 01      [ 1] 2337 	inc in
      000E31 20 F1            [ 2] 2338 	jra 1$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 46.
Hexadecimal [24-Bits]



      000E33                       2339 2$: _drop 1 
      000E33 5B 01            [ 2]    1     addw sp,#1 
      000E35 81               [ 4] 2340 	ret
                                   2341 	
                                   2342 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2343 ;;   TINY BASIC  operators,
                                   2344 ;;   commands and functions 
                                   2345 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2346 
                                   2347 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2348 ;;  Arithmetic operators
                                   2349 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2350 
                                   2351 ;debug support
                           000001  2352 DEBUG_PRT=1
                           000001  2353 .if DEBUG_PRT 
      000E36                       2354 printxy:
      000E36 C6 00 0A         [ 1] 2355 	ld a,base 
      000E39 88               [ 1] 2356 	push a 
      000E3A 89               [ 2] 2357 	pushw x 
      000E3B 90 89            [ 2] 2358 	pushw y
      000E3D 35 10 00 0A      [ 1] 2359 	mov base,#16 
      000E41 CD 09 CA         [ 4] 2360 	call print_int
      000E44 A6 20            [ 1] 2361 	ld a,#SPACE 
      000E46 CD 02 C0         [ 4] 2362 	call putc  
      000E49 1E 01            [ 2] 2363 	ldw x,(1,sp)
      000E4B CD 09 CA         [ 4] 2364 	call print_int 
      000E4E A6 0D            [ 1] 2365 	ld a,#CR 
      000E50 CD 02 C0         [ 4] 2366 	call putc 
      000E53 90 85            [ 2] 2367 	popw y 
      000E55 85               [ 2] 2368 	popw x 
      000E56 84               [ 1] 2369 	pop a 
      000E57 C7 00 0A         [ 1] 2370 	ld base,a 
      000E5A 81               [ 4] 2371 	ret 
                                   2372 .endif 
                                   2373 
                                   2374 
                                   2375 ;--------------------------------------
                                   2376 ;  multiply 2 uint16_t return uint32_t
                                   2377 ;  input:
                                   2378 ;     x       uint16_t 
                                   2379 ;     y       uint16_t 
                                   2380 ;  output:
                                   2381 ;     x       product bits 15..0
                                   2382 ;     y       product bits 31..16 
                                   2383 ;---------------------------------------
                           000001  2384 		U1=1  ; uint16_t 
                           000003  2385 		DBL=3 ; uint32_t
                           000006  2386 		VSIZE=6
      000E5B                       2387 umstar:
      000E5B                       2388 	_vars VSIZE 
      000E5B 52 06            [ 2]    1     sub sp,#VSIZE 
      000E5D 1F 01            [ 2] 2389 	ldw (U1,sp),x 
                                   2390 ;initialize bits 31..16 of 
                                   2391 ;product to zero 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 47.
Hexadecimal [24-Bits]



      000E5F 0F 03            [ 1] 2392 	clr (DBL,sp)
      000E61 0F 04            [ 1] 2393 	clr (DBL+1,sp)
                                   2394 ; produc U1L*U2L 
      000E63 90 9F            [ 1] 2395 	ld a,yl 
      000E65 42               [ 4] 2396 	mul x,a 
      000E66 1F 05            [ 2] 2397 	ldw (DBL+2,sp),x
                                   2398 ; product U1H*U2L 
      000E68 7B 01            [ 1] 2399 	ld a,(U1,sp) ; xh 
      000E6A 93               [ 1] 2400 	ldw x,y
      000E6B 42               [ 4] 2401 	mul x,a 
      000E6C 4F               [ 1] 2402 	clr a 
      000E6D 72 FB 04         [ 2] 2403 	addw x,(DBL+1,sp) 
      000E70 4F               [ 1] 2404 	clr a 
      000E71 19 03            [ 1] 2405 	adc a,(DBL,sp) 
      000E73 6B 03            [ 1] 2406 	ld (DBL,sp),a ; bits 23..17 
      000E75 1F 04            [ 2] 2407 	ldw (DBL+1,sp),x ; bits 15..0 
                                   2408 ; product U1L*U2H
      000E77 90 5E            [ 1] 2409 	swapw y 
      000E79 93               [ 1] 2410 	ldw x,y
      000E7A 7B 02            [ 1] 2411 	ld a,(U1+1,sp)
      000E7C 42               [ 4] 2412 	mul x,a
      000E7D 72 FB 04         [ 2] 2413 	addw x,(DBL+1,sp)
      000E80 4F               [ 1] 2414 	clr a 
      000E81 19 03            [ 1] 2415 	adc a,(DBL,sp)
      000E83 6B 03            [ 1] 2416 	ld (DBL,sp),a 
      000E85 1F 04            [ 2] 2417 	ldw (DBL+1,sp),x 
                                   2418 ; product U1H*U2H 	
      000E87 7B 01            [ 1] 2419 	ld a,(U1,sp)
      000E89 93               [ 1] 2420 	ldw x,y  
      000E8A 42               [ 4] 2421 	mul x,a 
      000E8B 72 FB 03         [ 2] 2422 	addw x,(DBL,sp)
      000E8E 90 93            [ 1] 2423 	ldw y,x 
      000E90 1E 05            [ 2] 2424 	ldw x,(DBL+2,sp)
      000E92                       2425 	_drop VSIZE 
      000E92 5B 06            [ 2]    1     addw sp,#VSIZE 
      000E94 81               [ 4] 2426 	ret
                                   2427 
                                   2428 
                                   2429 ;-------------------------------------
                                   2430 ; multiply 2 integers
                                   2431 ; input:
                                   2432 ;  	x       n1 
                                   2433 ;   y 		n2 
                                   2434 ; output:
                                   2435 ;	X        N1*N2 bits 15..0
                                   2436 ;   Y        N1*N2 bits 31..16 
                                   2437 ;-------------------------------------
                           000001  2438 	SIGN=1
                           000001  2439 	VSIZE=1
      000E95                       2440 multiply:
      000E95                       2441 	_vars VSIZE 
      000E95 52 01            [ 2]    1     sub sp,#VSIZE 
      000E97 0F 01            [ 1] 2442 	clr (SIGN,sp)
      000E99 9E               [ 1] 2443 	ld a,xh 
      000E9A A4 80            [ 1] 2444 	and a,#0x80
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 48.
Hexadecimal [24-Bits]



      000E9C 2A 03            [ 1] 2445 	jrpl 1$
      000E9E 03 01            [ 1] 2446 	cpl (SIGN,sp)
      000EA0 50               [ 2] 2447 	negw x 
      000EA1                       2448 1$:	
      000EA1 90 9E            [ 1] 2449 	ld a,yh
      000EA3 A4 80            [ 1] 2450 	and a,#0x80  
      000EA5 2A 04            [ 1] 2451 	jrpl 2$ 
      000EA7 03 01            [ 1] 2452 	cpl (SIGN,sp)
      000EA9 90 50            [ 2] 2453 	negw y 
      000EAB                       2454 2$:	
      000EAB CD 0E 5B         [ 4] 2455 	call umstar
      000EAE 7B 01            [ 1] 2456 	ld a,(SIGN,sp)
      000EB0 27 03            [ 1] 2457 	jreq 3$
      000EB2 CD 0E E2         [ 4] 2458 	call dneg 
      000EB5                       2459 3$:	
      000EB5                       2460 	_drop VSIZE 
      000EB5 5B 01            [ 2]    1     addw sp,#VSIZE 
      000EB7 81               [ 4] 2461 	ret
                                   2462 
                                   2463 ;--------------------------------------
                                   2464 ; divide uint32_t/uint16_t
                                   2465 ; return:  quotient and remainder 
                                   2466 ; quotient expected to be uint16_t 
                                   2467 ; input:
                                   2468 ;   DBLDIVDND    on stack 
                                   2469 ;   X            divisor 
                                   2470 ; output:
                                   2471 ;   X            quotient 
                                   2472 ;   Y            remainder 
                                   2473 ;---------------------------------------
                           000003  2474 	VSIZE=3
      000EB8                       2475 	_argofs VSIZE 
                           000005     1     ARG_OFS=2+VSIZE 
      000EB8                       2476 	_arg DBLDIVDND 1
                           000006     1     DBLDIVDND=ARG_OFS+1 
                                   2477 	; local variables 
                           000001  2478 	DIVISOR=1 
                           000003  2479 	CNTR=3 
      000EB8                       2480 udiv32_16:
      000EB8                       2481 	_vars VSIZE 
      000EB8 52 03            [ 2]    1     sub sp,#VSIZE 
      000EBA 1F 01            [ 2] 2482 	ldw (DIVISOR,sp),x	; save divisor 
      000EBC 1E 08            [ 2] 2483 	ldw x,(DBLDIVDND+2,sp)  ; bits 15..0
      000EBE 16 06            [ 2] 2484 	ldw y,(DBLDIVDND,sp) ; bits 31..16
      000EC0 90 5D            [ 2] 2485 	tnzw y
      000EC2 26 06            [ 1] 2486 	jrne long_division 
      000EC4 16 01            [ 2] 2487 	ldw y,(DIVISOR,sp)
      000EC6 65               [ 2] 2488 	divw x,y
      000EC7                       2489 	_drop VSIZE 
      000EC7 5B 03            [ 2]    1     addw sp,#VSIZE 
      000EC9 81               [ 4] 2490 	ret
      000ECA                       2491 long_division:
      000ECA 51               [ 1] 2492 	exgw x,y ; hi in x, lo in y 
      000ECB A6 11            [ 1] 2493 	ld a,#17 
      000ECD 6B 03            [ 1] 2494 	ld (CNTR,sp),a
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 49.
Hexadecimal [24-Bits]



      000ECF                       2495 1$:
      000ECF 13 01            [ 2] 2496 	cpw x,(DIVISOR,sp)
      000ED1 2B 03            [ 1] 2497 	jrmi 2$
      000ED3 72 F0 01         [ 2] 2498 	subw x,(DIVISOR,sp)
      000ED6 8C               [ 1] 2499 2$:	ccf 
      000ED7 90 59            [ 2] 2500 	rlcw y 
      000ED9 59               [ 2] 2501 	rlcw x 
      000EDA 0A 03            [ 1] 2502 	dec (CNTR,sp)
      000EDC 26 F1            [ 1] 2503 	jrne 1$
      000EDE 51               [ 1] 2504 	exgw x,y 
      000EDF                       2505 	_drop VSIZE 
      000EDF 5B 03            [ 2]    1     addw sp,#VSIZE 
      000EE1 81               [ 4] 2506 	ret
                                   2507 
                                   2508 ;-----------------------------
                                   2509 ; negate double int.
                                   2510 ; input:
                                   2511 ;   x     bits 15..0
                                   2512 ;   y     bits 31..16
                                   2513 ; output: 
                                   2514 ;   x     bits 15..0
                                   2515 ;   y     bits 31..16
                                   2516 ;-----------------------------
      000EE2                       2517 dneg:
      000EE2 53               [ 2] 2518 	cplw x 
      000EE3 90 53            [ 2] 2519 	cplw y 
      000EE5 1C 00 01         [ 2] 2520 	addw x,#1 
      000EE8 24 02            [ 1] 2521 	jrnc 1$
      000EEA 90 5C            [ 2] 2522 	incw y 
      000EEC 81               [ 4] 2523 1$: ret 
                                   2524 
                                   2525 
                                   2526 ;--------------------------------
                                   2527 ; sign extend single to double
                                   2528 ; input:
                                   2529 ;   x    int16_t
                                   2530 ; output:
                                   2531 ;   x    int32_t bits 15..0
                                   2532 ;   y    int32_t bits 31..16
                                   2533 ;--------------------------------
      000EED                       2534 dbl_sign_extend:
      000EED 90 5F            [ 1] 2535 	clrw y
      000EEF 9E               [ 1] 2536 	ld a,xh 
      000EF0 A4 80            [ 1] 2537 	and a,#0x80 
      000EF2 27 02            [ 1] 2538 	jreq 1$
      000EF4 90 53            [ 2] 2539 	cplw y
      000EF6 81               [ 4] 2540 1$: ret 	
                                   2541 
                                   2542 
                                   2543 ;----------------------------------
                                   2544 ;  euclidian divide dbl/n1 
                                   2545 ;  ref: https://en.wikipedia.org/wiki/Euclidean_division
                                   2546 ; input:
                                   2547 ;    dbl    int32_t on stack 
                                   2548 ;    x 		n1   int16_t  disivor  
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 50.
Hexadecimal [24-Bits]



                                   2549 ; output:
                                   2550 ;    X      dbl/x  int16_t 
                                   2551 ;    Y      remainder int16_t 
                                   2552 ;----------------------------------
                           000008  2553 	VSIZE=8
      000EF7                       2554 	_argofs VSIZE 
                           00000A     1     ARG_OFS=2+VSIZE 
      000EF7                       2555 	_arg DIVDNDHI 1 
                           00000B     1     DIVDNDHI=ARG_OFS+1 
      000EF7                       2556 	_arg DIVDNDLO 3
                           00000D     1     DIVDNDLO=ARG_OFS+3 
                                   2557 	; local variables
                           000001  2558 	DBLHI=1
                           000003  2559 	DBLLO=3 
                           000005  2560 	SDIVSR=5 ; sign divisor
                           000006  2561 	SQUOT=6 ; sign dividend 
                           000007  2562 	DIVISR=7 ; divisor 
      000EF7                       2563 div32_16:
      000EF7                       2564 	_vars VSIZE 
      000EF7 52 08            [ 2]    1     sub sp,#VSIZE 
      000EF9 0F 05            [ 1] 2565 	clr (SDIVSR,sp)
      000EFB 0F 06            [ 1] 2566 	clr (SQUOT,sp)
                                   2567 ; copy arguments 
      000EFD 16 0B            [ 2] 2568 	ldw y,(DIVDNDHI,sp)
      000EFF 17 01            [ 2] 2569 	ldw (DBLHI,sp),y
      000F01 16 0D            [ 2] 2570 	ldw y,(DIVDNDLO,sp)
      000F03 17 03            [ 2] 2571 	ldw (DBLLO,sp),y 
                                   2572 ; check for 0 divisor
      000F05 5D               [ 2] 2573 	tnzw x 
      000F06 26 05            [ 1] 2574     jrne 0$
      000F08 A6 04            [ 1] 2575 	ld a,#ERR_DIV0 
      000F0A CC 08 7D         [ 2] 2576 	jp tb_error 
                                   2577 ; check divisor sign 	
      000F0D 9E               [ 1] 2578 0$:	ld a,xh 
      000F0E A4 80            [ 1] 2579 	and a,#0x80 
      000F10 27 05            [ 1] 2580 	jreq 1$
      000F12 03 05            [ 1] 2581 	cpl (SDIVSR,sp)
      000F14 03 06            [ 1] 2582 	cpl (SQUOT,sp)
      000F16 50               [ 2] 2583 	negw x
      000F17 1F 07            [ 2] 2584 1$:	ldw (DIVISR,sp),x
                                   2585 ; check dividend sign 	 
      000F19 7B 01            [ 1] 2586  	ld a,(DBLHI,sp) 
      000F1B A4 80            [ 1] 2587 	and a,#0x80 
      000F1D 27 0D            [ 1] 2588 	jreq 2$ 
      000F1F 03 06            [ 1] 2589 	cpl (SQUOT,sp)
      000F21 1E 03            [ 2] 2590 	ldw x,(DBLLO,sp)
      000F23 16 01            [ 2] 2591 	ldw y,(DBLHI,sp)
      000F25 CD 0E E2         [ 4] 2592 	call dneg 
      000F28 1F 03            [ 2] 2593 	ldw (DBLLO,sp),x 
      000F2A 17 01            [ 2] 2594 	ldw (DBLHI,sp),y 
      000F2C 1E 07            [ 2] 2595 2$:	ldw x,(DIVISR,sp)
      000F2E CD 0E B8         [ 4] 2596 	call udiv32_16
      000F31 90 5D            [ 2] 2597 	tnzw y 
      000F33 27 11            [ 1] 2598 	jreq 3$ 
                                   2599 ; x=quotient 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 51.
Hexadecimal [24-Bits]



                                   2600 ; y=remainder 
                                   2601 ; if SDIVSR XOR SQUOT increment quotient and remainder.
      000F35 7B 06            [ 1] 2602 	ld a,(SQUOT,sp)
      000F37 18 05            [ 1] 2603 	xor a,(SDIVSR,sp)
      000F39 27 0B            [ 1] 2604 	jreq 3$
      000F3B 5C               [ 2] 2605 	incw x 
      000F3C 90 CF 00 0C      [ 2] 2606 	ldw acc16,y 
      000F40 16 07            [ 2] 2607 	ldw y,(DIVISR,sp)
      000F42 72 B2 00 0C      [ 2] 2608 	subw y,acc16
                                   2609 ; sign quotient
      000F46 7B 06            [ 1] 2610 3$:	ld a,(SQUOT,sp)
      000F48 27 01            [ 1] 2611 	jreq 4$
      000F4A 50               [ 2] 2612 	negw x 
      000F4B                       2613 4$:	
      000F4B                       2614 	_drop VSIZE 
      000F4B 5B 08            [ 2]    1     addw sp,#VSIZE 
      000F4D 81               [ 4] 2615 	ret 
                                   2616 
                                   2617 
                                   2618 
                                   2619 ;----------------------------------
                                   2620 ; division x/y 
                                   2621 ; input:
                                   2622 ;    X       dividend
                                   2623 ;    Y       divisor 
                                   2624 ; output:
                                   2625 ;    X       quotient
                                   2626 ;    Y       remainder 
                                   2627 ;-----------------------------------
                           000004  2628 	VSIZE=4 
                                   2629 	; local variables 
                           000001  2630 	DBLHI=1
                           000003  2631 	DBLLO=3
      000F4E                       2632 divide: 
      000F4E                       2633 	_vars VSIZE 
      000F4E 52 04            [ 2]    1     sub sp,#VSIZE 
      000F50 90 CF 00 0C      [ 2] 2634 	ldw acc16,y
      000F54 CD 0E ED         [ 4] 2635 	call dbl_sign_extend
      000F57 1F 03            [ 2] 2636 	ldw (DBLLO,sp),x 
      000F59 17 01            [ 2] 2637 	ldw (DBLHI,sp),y 
      000F5B CE 00 0C         [ 2] 2638 	ldw x,acc16 
      000F5E CD 0E F7         [ 4] 2639 	call div32_16 
      000F61                       2640 	_drop VSIZE 
      000F61 5B 04            [ 2]    1     addw sp,#VSIZE 
      000F63 81               [ 4] 2641 	ret
                                   2642 
                                   2643 
                                   2644 ;----------------------------------
                                   2645 ;  remainder resulting from euclidian 
                                   2646 ;  division of x/y 
                                   2647 ; input:
                                   2648 ;   x   	dividend int16_t 
                                   2649 ;   y 		divisor int16_t
                                   2650 ; output:
                                   2651 ;   X       n1%n2 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 52.
Hexadecimal [24-Bits]



                                   2652 ;----------------------------------
      000F64                       2653 modulo:
      000F64 CD 0F 4E         [ 4] 2654 	call divide
      000F67 93               [ 1] 2655 	ldw x,y 
      000F68 81               [ 4] 2656 	ret 
                                   2657 
                                   2658 ;----------------------------------
                                   2659 ; BASIC: MULDIV(expr1,expr2,expr3)
                                   2660 ; return expr1*expr2/expr3 
                                   2661 ; product result is int32_t and 
                                   2662 ; divisiont is int32_t/int16_t
                                   2663 ;----------------------------------
                           000004  2664 	DBL_SIZE=4 
      000F69                       2665 muldiv:
      000F69 CD 10 11         [ 4] 2666 	call func_args 
      000F6C A1 03            [ 1] 2667 	cp a,#3 
      000F6E 27 03            [ 1] 2668 	jreq 1$
      000F70 CC 08 7B         [ 2] 2669 	jp syntax_error
      000F73                       2670 1$: 
      000F73 1E 05            [ 2] 2671 	ldw x,(5,sp) ; expr1
      000F75 16 03            [ 2] 2672 	ldw y,(3,sp) ; expr2
      000F77 CD 0E 95         [ 4] 2673 	call multiply 
      000F7A 1F 05            [ 2] 2674 	ldw (5,sp),x  ;int32_t 15..0
      000F7C 17 03            [ 2] 2675 	ldw (3,sp),y  ;int32_t 31..16
      000F7E 85               [ 2] 2676 	popw x        ; expr3 
      000F7F CD 0E F7         [ 4] 2677 	call div32_16 ; int32_t/expr3 
      000F82                       2678 	_drop DBL_SIZE
      000F82 5B 04            [ 2]    1     addw sp,#DBL_SIZE 
      000F84 81               [ 4] 2679 	ret 
                                   2680 
                                   2681 
                                   2682 ;----------------------------------
                                   2683 ; search in kword_dict name
                                   2684 ; from its execution address 
                                   2685 ; input:
                                   2686 ;   X       	cmd_index 
                                   2687 ; output:
                                   2688 ;   X 			cstr*  | 0 
                                   2689 ;--------------------------------
                           000001  2690 	CMDX=1 
                           000003  2691 	LINK=3 
                           000004  2692 	VSIZE=4
      000F85                       2693 cmd_name:
      000F85                       2694 	_vars VSIZE 
      000F85 52 04            [ 2]    1     sub sp,#VSIZE 
      000F87 72 5F 00 0C      [ 1] 2695 	clr acc16 
      000F8B 1F 01            [ 2] 2696 	ldw (CMDX,sp),x  
      000F8D AE 26 B1         [ 2] 2697 	ldw x,#kword_dict	
      000F90 1F 03            [ 2] 2698 1$:	ldw (LINK,sp),x
      000F92 E6 02            [ 1] 2699 	ld a,(2,x)
      000F94 A4 0F            [ 1] 2700 	and a,#15 
      000F96 C7 00 0D         [ 1] 2701 	ld acc8,a 
      000F99 1C 00 03         [ 2] 2702 	addw x,#3
      000F9C 72 BB 00 0C      [ 2] 2703 	addw x,acc16
      000FA0 FE               [ 2] 2704 	ldw x,(x) ; command index  
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 53.
Hexadecimal [24-Bits]



      000FA1 13 01            [ 2] 2705 	cpw x,(CMDX,sp)
      000FA3 27 0A            [ 1] 2706 	jreq 2$
      000FA5 1E 03            [ 2] 2707 	ldw x,(LINK,sp)
      000FA7 FE               [ 2] 2708 	ldw x,(x) 
      000FA8 1D 00 02         [ 2] 2709 	subw x,#2  
      000FAB 26 E3            [ 1] 2710 	jrne 1$
      000FAD 20 05            [ 2] 2711 	jra 9$
      000FAF 1E 03            [ 2] 2712 2$: ldw x,(LINK,sp)
      000FB1 1C 00 02         [ 2] 2713 	addw x,#2 	
      000FB4                       2714 9$:	_drop VSIZE
      000FB4 5B 04            [ 2]    1     addw sp,#VSIZE 
      000FB6 81               [ 4] 2715 	ret
                                   2716 
                                   2717 
                                   2718 ;---------------------------------
                                   2719 ; dictionary search 
                                   2720 ; input:
                                   2721 ;	X 		dictionary entry point, name field  
                                   2722 ;   y		.asciz name to search 
                                   2723 ; output:
                                   2724 ;  A 		TK_CMD|TK_IFUNC|TK_NONE 
                                   2725 ;  X		cmd_index ; execution address | 0 
                                   2726 ;---------------------------------
                           000001  2727 	NLEN=1 ; cmd length 
                           000002  2728 	XSAVE=2
                           000004  2729 	YSAVE=4
                           000005  2730 	VSIZE=5 
      000FB7                       2731 search_dict:
      000FB7                       2732 	_vars VSIZE 
      000FB7 52 05            [ 2]    1     sub sp,#VSIZE 
                                   2733 
      000FB9 17 04            [ 2] 2734 	ldw (YSAVE,sp),y 
      000FBB                       2735 search_next:
      000FBB 1F 02            [ 2] 2736 	ldw (XSAVE,sp),x 
                                   2737 ; get name length in dictionary	
      000FBD F6               [ 1] 2738 	ld a,(x)
      000FBE A4 0F            [ 1] 2739 	and a,#0xf 
      000FC0 6B 01            [ 1] 2740 	ld (NLEN,sp),a  
      000FC2 16 04            [ 2] 2741 	ldw y,(YSAVE,sp) ; name pointer 
      000FC4 5C               [ 2] 2742 	incw x 
      000FC5                       2743 cp_loop:
      000FC5 90 F6            [ 1] 2744 	ld a,(y)
      000FC7 27 1B            [ 1] 2745 	jreq str_match 
      000FC9 0D 01            [ 1] 2746 	tnz (NLEN,sp)
      000FCB 27 0A            [ 1] 2747 	jreq no_match  
      000FCD F1               [ 1] 2748 	cp a,(x)
      000FCE 26 07            [ 1] 2749 	jrne no_match 
      000FD0 90 5C            [ 2] 2750 	incw y 
      000FD2 5C               [ 2] 2751 	incw x
      000FD3 0A 01            [ 1] 2752 	dec (NLEN,sp)
      000FD5 20 EE            [ 2] 2753 	jra cp_loop 
      000FD7                       2754 no_match:
      000FD7 1E 02            [ 2] 2755 	ldw x,(XSAVE,sp) 
      000FD9 1D 00 02         [ 2] 2756 	subw x,#2 ; move X to link field
      000FDC 4B 00            [ 1] 2757 	push #TK_NONE 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 54.
Hexadecimal [24-Bits]



      000FDE FE               [ 2] 2758 	ldw x,(x) ; next word link 
      000FDF 84               [ 1] 2759 	pop a ; TK_NONE 
      000FE0 27 1F            [ 1] 2760 	jreq search_exit  ; not found  
                                   2761 ;try next 
      000FE2 20 D7            [ 2] 2762 	jra search_next
      000FE4                       2763 str_match:
      000FE4 1E 02            [ 2] 2764 	ldw x,(XSAVE,sp)
      000FE6 F6               [ 1] 2765 	ld a,(X)
      000FE7 6B 01            [ 1] 2766 	ld (NLEN,sp),a ; needed to test keyword type  
      000FE9 A4 0F            [ 1] 2767 	and a,#0xf 
                                   2768 ; move x to procedure address field 	
      000FEB 4C               [ 1] 2769 	inc a 
      000FEC C7 00 0D         [ 1] 2770 	ld acc8,a 
      000FEF 72 5F 00 0C      [ 1] 2771 	clr acc16 
      000FF3 72 BB 00 0C      [ 2] 2772 	addw x,acc16 
      000FF7 FE               [ 2] 2773 	ldw x,(x) ; routine index  
                                   2774 ;determine keyword type bits 7:6 
      000FF8 7B 01            [ 1] 2775 	ld a,(NLEN,sp)
      000FFA 4E               [ 1] 2776 	swap a 
      000FFB A4 0C            [ 1] 2777 	and a,#0xc
      000FFD 44               [ 1] 2778 	srl a
      000FFE 44               [ 1] 2779 	srl a 
      000FFF AB 80            [ 1] 2780 	add a,#128
      001001                       2781 search_exit: 
      001001                       2782 	_drop VSIZE 	 
      001001 5B 05            [ 2]    1     addw sp,#VSIZE 
      001003 81               [ 4] 2783 	ret 
                                   2784 
                                   2785 ;---------------------
                                   2786 ; check if next token
                                   2787 ;  is of expected type 
                                   2788 ; input:
                                   2789 ;   A 		 expected token attribute
                                   2790 ;  ouput:
                                   2791 ;   none     if fail call syntax_error 
                                   2792 ;--------------------
      001004                       2793 expect:
      001004 88               [ 1] 2794 	push a 
      001005 CD 09 6D         [ 4] 2795 	call next_token 
      001008 11 01            [ 1] 2796 	cp a,(1,sp)
      00100A 27 03            [ 1] 2797 	jreq 1$
      00100C CC 08 7B         [ 2] 2798 	jp syntax_error
      00100F 84               [ 1] 2799 1$: pop a 
      001010 81               [ 4] 2800 	ret 
                                   2801 
                                   2802 ;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2803 ; parse arguments list 
                                   2804 ; between ()
                                   2805 ;;;;;;;;;;;;;;;;;;;;;;;;;;
      001011                       2806 func_args:
      001011 A6 07            [ 1] 2807 	ld a,#TK_LPAREN 
      001013 CD 10 04         [ 4] 2808 	call expect 
                                   2809 ; expected to continue in arg_list 
                                   2810 ; caller must check for TK_RPAREN 
                                   2811 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 55.
Hexadecimal [24-Bits]



                                   2812 ;-------------------------------
                                   2813 ; parse embedded BASIC routines 
                                   2814 ; arguments list.
                                   2815 ; arg_list::=  rel[','rel]*
                                   2816 ; all arguments are of integer type
                                   2817 ; and pushed on stack 
                                   2818 ; input:
                                   2819 ;   none
                                   2820 ; output:
                                   2821 ;   stack{n}   arguments pushed on stack
                                   2822 ;   A 	number of arguments pushed on stack  
                                   2823 ;--------------------------------
      001016                       2824 arg_list:
      001016 4B 00            [ 1] 2825 	push #0  
      001018 CD 11 58         [ 4] 2826 1$: call relation
      00101B A1 00            [ 1] 2827 	cp a,#TK_NONE 
      00101D 27 20            [ 1] 2828 	jreq 5$
      00101F A1 84            [ 1] 2829 	cp a,#TK_INTGR
      001021 26 13            [ 1] 2830 	jrne 4$
      001023                       2831 3$: 
                                   2832 ; swap return address with argument
      001023 84               [ 1] 2833 	pop a ; arg_count
      001024 90 85            [ 2] 2834 	popw y ; return address 
      001026 89               [ 2] 2835 	pushw x ; new argument 
      001027 90 89            [ 2] 2836 	pushw y 
      001029 4C               [ 1] 2837     inc a
      00102A 88               [ 1] 2838 	push a 
      00102B CD 09 6D         [ 4] 2839 	call next_token 
      00102E A1 09            [ 1] 2840 	cp a,#TK_COMMA 
      001030 27 E6            [ 1] 2841 	jreq 1$ 
      001032 A1 00            [ 1] 2842 	cp a,#TK_NONE 
      001034 27 09            [ 1] 2843 	jreq 5$ 
      001036 A1 08            [ 1] 2844 4$:	cp a,#TK_RPAREN 
      001038 27 05            [ 1] 2845 	jreq 5$
      00103A                       2846 	_unget_token 
      00103A 55 00 02 00 01   [ 1]    1     mov in,in.saved
      00103F 84               [ 1] 2847 5$:	pop a  
      001040 81               [ 4] 2848 	ret 
                                   2849 
                                   2850 ;--------------------------------
                                   2851 ;   BASIC commnands 
                                   2852 ;--------------------------------
                                   2853 
                                   2854 ;--------------------------------
                                   2855 ;  arithmetic and relational 
                                   2856 ;  routines
                                   2857 ;  operators precedence
                                   2858 ;  highest to lowest
                                   2859 ;  operators on same row have 
                                   2860 ;  same precedence and are executed
                                   2861 ;  from left to right.
                                   2862 ;	'*','/','%'
                                   2863 ;   '-','+'
                                   2864 ;   '=','>','<','>=','<=','<>','><'
                                   2865 ;   '<>' and '><' are equivalent for not equal.
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 56.
Hexadecimal [24-Bits]



                                   2866 ;--------------------------------
                                   2867 
                                   2868 ;---------------------
                                   2869 ; return array element
                                   2870 ; address from @(expr)
                                   2871 ; input:
                                   2872 ;   A 		TK_ARRAY
                                   2873 ; output:
                                   2874 ;   A 		TK_INTGR
                                   2875 ;	X 		element address 
                                   2876 ;----------------------
      001041                       2877 get_array_element:
      001041 CD 10 11         [ 4] 2878 	call func_args 
      001044 A1 01            [ 1] 2879 	cp a,#1
      001046 27 03            [ 1] 2880 	jreq 1$
      001048 CC 08 7B         [ 2] 2881 	jp syntax_error
      00104B 85               [ 2] 2882 1$: popw x 
                                   2883 	; check for bounds 
      00104C C3 00 21         [ 2] 2884 	cpw x,array_size 
      00104F 23 05            [ 2] 2885 	jrule 3$
                                   2886 ; bounds {1..array_size}	
      001051 A6 0A            [ 1] 2887 2$: ld a,#ERR_BAD_VALUE 
      001053 CC 08 7D         [ 2] 2888 	jp tb_error 
      001056 5D               [ 2] 2889 3$: tnzw  x
      001057 27 F8            [ 1] 2890 	jreq 2$ 
      001059 58               [ 2] 2891 	sllw x 
      00105A 89               [ 2] 2892 	pushw x 
      00105B AE 16 90         [ 2] 2893 	ldw x,#tib
      00105E 72 F0 01         [ 2] 2894 	subw x,(1,sp)
      001061                       2895 	_drop 2   
      001061 5B 02            [ 2]    1     addw sp,#2 
      001063 A6 84            [ 1] 2896 	ld a,#TK_INTGR
      001065 81               [ 4] 2897 	ret 
                                   2898 
                                   2899 
                                   2900 ;***********************************
                                   2901 ;   expression parse,execute 
                                   2902 ;***********************************
                                   2903 ;-----------------------------------
                                   2904 ; factor ::= ['+'|'-'|e]  var | @ |
                                   2905 ;			 integer | function |
                                   2906 ;			 '('relation')' 
                                   2907 ; output:
                                   2908 ;   A    token attribute 
                                   2909 ;   X 	 integer
                                   2910 ; ---------------------------------
                           000001  2911 	NEG=1
                           000001  2912 	VSIZE=1
      001066                       2913 factor:
      001066                       2914 	_vars VSIZE 
      001066 52 01            [ 2]    1     sub sp,#VSIZE 
      001068 CD 09 6D         [ 4] 2915 	call next_token
      00106B A1 02            [ 1] 2916 	cp a,#CMD_END 
      00106D 25 4E            [ 1] 2917 	jrult 20$
      00106F 6B 01            [ 1] 2918 1$:	ld (NEG,sp),a 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 57.
Hexadecimal [24-Bits]



      001071 A4 30            [ 1] 2919 	and a,#TK_GRP_MASK
      001073 A1 10            [ 1] 2920 	cp a,#TK_GRP_ADD 
      001075 27 04            [ 1] 2921 	jreq 2$
      001077 7B 01            [ 1] 2922 	ld a,(NEG,sp)
      001079 20 03            [ 2] 2923 	jra 4$  
      00107B                       2924 2$:	
      00107B CD 09 6D         [ 4] 2925 	call next_token 
      00107E                       2926 4$:	
      00107E A1 81            [ 1] 2927 	cp a,#TK_IFUNC 
      001080 26 03            [ 1] 2928 	jrne 5$ 
      001082 FD               [ 4] 2929 	call (x) 
      001083 20 2F            [ 2] 2930 	jra 18$ 
      001085                       2931 5$:
      001085 A1 84            [ 1] 2932 	cp a,#TK_INTGR
      001087 26 02            [ 1] 2933 	jrne 6$
      001089 20 29            [ 2] 2934 	jra 18$
      00108B                       2935 6$:
      00108B A1 06            [ 1] 2936 	cp a,#TK_ARRAY
      00108D 26 06            [ 1] 2937 	jrne 10$
      00108F CD 10 41         [ 4] 2938 	call get_array_element
      001092 FE               [ 2] 2939 	ldw x,(x)
      001093 20 1F            [ 2] 2940 	jra 18$ 
      001095                       2941 10$:
      001095 A1 85            [ 1] 2942 	cp a,#TK_VAR 
      001097 26 03            [ 1] 2943 	jrne 12$
      001099 FE               [ 2] 2944 	ldw x,(x)
      00109A 20 18            [ 2] 2945 	jra 18$
      00109C                       2946 12$:			
      00109C A1 07            [ 1] 2947 	cp a,#TK_LPAREN
      00109E 26 0C            [ 1] 2948 	jrne 16$
      0010A0 CD 11 58         [ 4] 2949 	call relation
      0010A3 89               [ 2] 2950 	pushw x 
      0010A4 A6 08            [ 1] 2951 	ld a,#TK_RPAREN 
      0010A6 CD 10 04         [ 4] 2952 	call expect
      0010A9 85               [ 2] 2953 	popw x 
      0010AA 20 08            [ 2] 2954 	jra 18$	
      0010AC                       2955 16$:
      0010AC                       2956 	_unget_token
      0010AC 55 00 02 00 01   [ 1]    1     mov in,in.saved
      0010B1 4F               [ 1] 2957 	clr a 
      0010B2 20 09            [ 2] 2958 	jra 20$ 
      0010B4                       2959 18$: 
      0010B4 A6 11            [ 1] 2960 	ld a,#TK_MINUS 
      0010B6 11 01            [ 1] 2961 	cp a,(NEG,sp)
      0010B8 26 01            [ 1] 2962 	jrne 19$
      0010BA 50               [ 2] 2963 	negw x
      0010BB                       2964 19$:
      0010BB A6 84            [ 1] 2965 	ld a,#TK_INTGR
      0010BD                       2966 20$:
      0010BD                       2967 	_drop VSIZE
      0010BD 5B 01            [ 2]    1     addw sp,#VSIZE 
      0010BF 81               [ 4] 2968 	ret
                                   2969 
                                   2970 ;-----------------------------------
                                   2971 ; term ::= factor [['*'|'/'|'%'] factor]* 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 58.
Hexadecimal [24-Bits]



                                   2972 ; output:
                                   2973 ;   A    	token attribute 
                                   2974 ;	X		integer
                                   2975 ;-----------------------------------
                           000001  2976 	N1=1   ; int16_t
                           000003  2977 	MULOP=3
                           000003  2978 	VSIZE=3
      0010C0                       2979 term:
      0010C0                       2980 	_vars VSIZE
      0010C0 52 03            [ 2]    1     sub sp,#VSIZE 
      0010C2 CD 10 66         [ 4] 2981 	call factor
      0010C5 A1 02            [ 1] 2982 	cp a,#CMD_END
      0010C7 25 43            [ 1] 2983 	jrult term_exit
      0010C9                       2984 term01:	 ; check for  operator 
      0010C9 1F 01            [ 2] 2985 	ldw (N1,sp),x  ; save first factor 
      0010CB CD 09 6D         [ 4] 2986 	call next_token
      0010CE A1 02            [ 1] 2987 	cp a,#CMD_END
      0010D0 25 36            [ 1] 2988 	jrult 9$
      0010D2 6B 03            [ 1] 2989 0$:	ld (MULOP,sp),a
      0010D4 A4 30            [ 1] 2990 	and a,#TK_GRP_MASK
      0010D6 A1 20            [ 1] 2991 	cp a,#TK_GRP_MULT
      0010D8 27 07            [ 1] 2992 	jreq 1$
      0010DA                       2993 	_unget_token 
      0010DA 55 00 02 00 01   [ 1]    1     mov in,in.saved
      0010DF 20 27            [ 2] 2994 	jra 9$
      0010E1                       2995 1$:	; got *|/|%
      0010E1 CD 10 66         [ 4] 2996 	call factor
      0010E4 A1 84            [ 1] 2997 	cp a,#TK_INTGR
      0010E6 27 03            [ 1] 2998 	jreq 2$ 
      0010E8 CC 08 7B         [ 2] 2999 	jp syntax_error
      0010EB 90 93            [ 1] 3000 2$:	ldw y,x 
      0010ED 1E 01            [ 2] 3001 	ldw x,(N1,sp)
      0010EF 7B 03            [ 1] 3002 	ld a,(MULOP,sp) 
      0010F1 A1 20            [ 1] 3003 	cp a,#TK_MULT 
      0010F3 26 05            [ 1] 3004 	jrne 3$
      0010F5 CD 0E 95         [ 4] 3005 	call multiply 
      0010F8 20 CF            [ 2] 3006 	jra term01
      0010FA A1 21            [ 1] 3007 3$: cp a,#TK_DIV 
      0010FC 26 05            [ 1] 3008 	jrne 4$ 
      0010FE CD 0F 4E         [ 4] 3009 	call divide 
      001101 20 C6            [ 2] 3010 	jra term01 
      001103 CD 0F 64         [ 4] 3011 4$: call modulo
      001106 20 C1            [ 2] 3012 	jra term01 
      001108 1E 01            [ 2] 3013 9$: ldw x,(N1,sp)
      00110A A6 84            [ 1] 3014 	ld a,#TK_INTGR 	
      00110C                       3015 term_exit:
      00110C                       3016 	_drop VSIZE 
      00110C 5B 03            [ 2]    1     addw sp,#VSIZE 
      00110E 81               [ 4] 3017 	ret 
                                   3018 
                                   3019 ;-------------------------------
                                   3020 ;  expr ::= term [['+'|'-'] term]*
                                   3021 ;  result range {-32768..32767}
                                   3022 ;  output:
                                   3023 ;   A    token attribute 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 59.
Hexadecimal [24-Bits]



                                   3024 ;   X	 integer   
                                   3025 ;-------------------------------
                           000001  3026 	N1=1 
                           000003  3027 	OP=3 
                           000003  3028 	VSIZE=3 
      00110F                       3029 expression:
      00110F                       3030 	_vars VSIZE 
      00110F 52 03            [ 2]    1     sub sp,#VSIZE 
      001111 CD 10 C0         [ 4] 3031 	call term
      001114 A1 02            [ 1] 3032 	cp a,#CMD_END 
      001116 25 3D            [ 1] 3033 	jrult expr_exit 
      001118 1F 01            [ 2] 3034 0$:	ldw (N1,sp),x 
      00111A CD 09 6D         [ 4] 3035 	call next_token
      00111D A1 02            [ 1] 3036 	cp a,#CMD_END 
      00111F 25 30            [ 1] 3037 	jrult 9$ 
      001121 6B 03            [ 1] 3038 1$:	ld (OP,sp),a  
      001123 A4 30            [ 1] 3039 	and a,#TK_GRP_MASK
      001125 A1 10            [ 1] 3040 	cp a,#TK_GRP_ADD 
      001127 27 07            [ 1] 3041 	jreq 2$ 
      001129                       3042 	_unget_token
      001129 55 00 02 00 01   [ 1]    1     mov in,in.saved
      00112E 20 21            [ 2] 3043 	jra 9$
      001130                       3044 2$: 
      001130 CD 10 C0         [ 4] 3045 	call term
      001133 A1 84            [ 1] 3046 	cp a,#TK_INTGR 
      001135 27 03            [ 1] 3047 	jreq 3$
      001137 CC 08 7B         [ 2] 3048 	jp syntax_error
      00113A CF 00 0C         [ 2] 3049 3$:	ldw acc16,x 
      00113D 1E 01            [ 2] 3050 	ldw x,(N1,sp)
      00113F 7B 03            [ 1] 3051 	ld a,(OP,sp)
      001141 A1 10            [ 1] 3052 	cp a,#TK_PLUS 
      001143 26 06            [ 1] 3053 	jrne 4$
      001145 72 BB 00 0C      [ 2] 3054 	addw x,acc16
      001149 20 CD            [ 2] 3055 	jra 0$ 
      00114B 72 B0 00 0C      [ 2] 3056 4$:	subw x,acc16
      00114F 20 C7            [ 2] 3057 	jra 0$
      001151 1E 01            [ 2] 3058 9$: ldw x,(N1,sp)
      001153 A6 84            [ 1] 3059 	ld a,#TK_INTGR	
      001155                       3060 expr_exit:
      001155                       3061 	_drop VSIZE 
      001155 5B 03            [ 2]    1     addw sp,#VSIZE 
      001157 81               [ 4] 3062 	ret 
                                   3063 
                                   3064 ;---------------------------------------------
                                   3065 ; rel ::= expr rel_op expr
                                   3066 ; rel_op ::=  '=','<','>','>=','<=','<>','><'
                                   3067 ;  relation return  integer , zero is false 
                                   3068 ;  output:
                                   3069 ;    A 		token attribute  
                                   3070 ;	 X		integer 
                                   3071 ;---------------------------------------------
                           000001  3072 	N1=1
                           000003  3073 	RELOP=3
                           000003  3074 	VSIZE=3 
      001158                       3075 relation: 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 60.
Hexadecimal [24-Bits]



      001158                       3076 	_vars VSIZE
      001158 52 03            [ 2]    1     sub sp,#VSIZE 
      00115A CD 11 0F         [ 4] 3077 	call expression
      00115D A1 02            [ 1] 3078 	cp a,#CMD_END  
      00115F 25 4F            [ 1] 3079 	jrult rel_exit 
                                   3080 	; expect rel_op or leave 
      001161 1F 01            [ 2] 3081 	ldw (N1,sp),x 
      001163 CD 09 6D         [ 4] 3082 	call next_token 
      001166 A1 02            [ 1] 3083 	cp a,#CMD_END 
      001168 25 42            [ 1] 3084 	jrult 9$
      00116A                       3085 1$:	
      00116A 6B 03            [ 1] 3086 	ld (RELOP,sp),a 
      00116C A4 30            [ 1] 3087 	and a,#TK_GRP_MASK
      00116E A1 30            [ 1] 3088 	cp a,#TK_GRP_RELOP 
      001170 27 07            [ 1] 3089 	jreq 2$
      001172                       3090 	_unget_token  
      001172 55 00 02 00 01   [ 1]    1     mov in,in.saved
      001177 20 33            [ 2] 3091 	jra 9$
      001179                       3092 2$:	; expect another expression or error 
      001179 CD 11 0F         [ 4] 3093 	call expression
      00117C A1 84            [ 1] 3094 	cp a,#TK_INTGR 
      00117E 27 03            [ 1] 3095 	jreq 3$
      001180 CC 08 7B         [ 2] 3096 	jp syntax_error 
      001183 CF 00 0C         [ 2] 3097 3$:	ldw acc16,x 
      001186 1E 01            [ 2] 3098 	ldw x,(N1,sp) 
      001188 72 B0 00 0C      [ 2] 3099 	subw x,acc16
      00118C 26 06            [ 1] 3100 	jrne 4$
      00118E 35 02 00 0D      [ 1] 3101 	mov acc8,#2 ; n1==n2
      001192 20 0C            [ 2] 3102 	jra 6$ 
      001194                       3103 4$: 
      001194 2C 06            [ 1] 3104 	jrsgt 5$  
      001196 35 04 00 0D      [ 1] 3105 	mov acc8,#4 ; n1<2 
      00119A 20 04            [ 2] 3106 	jra 6$
      00119C                       3107 5$:
      00119C 35 01 00 0D      [ 1] 3108 	mov acc8,#1 ; n1>n2 
      0011A0                       3109 6$:
      0011A0 5F               [ 1] 3110 	clrw x 
      0011A1 C6 00 0D         [ 1] 3111 	ld a, acc8  
      0011A4 14 03            [ 1] 3112 	and a,(RELOP,sp)
      0011A6 4D               [ 1] 3113 	tnz a 
      0011A7 27 05            [ 1] 3114 	jreq 10$
      0011A9 5C               [ 2] 3115 	incw x 
      0011AA                       3116 7$:	 
      0011AA 20 02            [ 2] 3117 	jra 10$  	
      0011AC 1E 01            [ 2] 3118 9$: ldw x,(N1,sp)
      0011AE                       3119 10$:
      0011AE A6 84            [ 1] 3120 	ld a,#TK_INTGR
      0011B0                       3121 rel_exit: 	 
      0011B0                       3122 	_drop VSIZE
      0011B0 5B 03            [ 2]    1     addw sp,#VSIZE 
      0011B2 81               [ 4] 3123 	ret 
                                   3124 
                                   3125 ;--------------------------------
                                   3126 ; BASIC: SHOW 
                                   3127 ; print stack content in hexadecimal bytes 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 61.
Hexadecimal [24-Bits]



                                   3128 ; 16 bytes per row 
                                   3129 ;--------------------------------
      0011B3                       3130 show:
      0011B3 AE 11 CD         [ 2] 3131 	ldw x,#cstk_prompt
      0011B6 CD 00 00         [ 4] 3132 	call puts 
      0011B9 96               [ 1] 3133 	ldw x,sp 
      0011BA 1C 00 03         [ 2] 3134 	addw x,#3 ; ignore return address
      0011BD 90 AE 18 00      [ 2] 3135 	ldw y,#RAM_SIZE  
      0011C1 CF 00 0C         [ 2] 3136 	ldw acc16,x 
      0011C4 72 B2 00 0C      [ 2] 3137 	subw y,acc16
      0011C8 CD 03 59         [ 4] 3138 	call hex_dump
      0011CB 4F               [ 1] 3139 	clr a 
      0011CC 81               [ 4] 3140 	ret
                                   3141 
      0011CD 0A 63 6F 6E 74 65 6E  3142 cstk_prompt: .asciz "\ncontent of stack from top to bottom:\n"
             74 20 6F 66 20 73 74
             61 63 6B 20 66 72 6F
             6D 20 74 6F 70 20 74
             6F 20 62 6F 74 74 6F
             6D 3A 0A 00
                                   3143 
                                   3144 
                                   3145 ;--------------------------------------------
                                   3146 ; BASIC: HEX 
                                   3147 ; select hexadecimal base for integer print
                                   3148 ;---------------------------------------------
      0011F4                       3149 hex_base:
      0011F4 35 10 00 0A      [ 1] 3150 	mov base,#16 
      0011F8 81               [ 4] 3151 	ret 
                                   3152 
                                   3153 ;--------------------------------------------
                                   3154 ; BASIC: DEC 
                                   3155 ; select decimal base for integer print
                                   3156 ;---------------------------------------------
      0011F9                       3157 dec_base:
      0011F9 35 0A 00 0A      [ 1] 3158 	mov base,#10
      0011FD 81               [ 4] 3159 	ret 
                                   3160 
                                   3161 ;------------------------
                                   3162 ; BASIC: SIZE 
                                   3163 ; return free size in text area
                                   3164 ; output:
                                   3165 ;   A 		TK_INTGR
                                   3166 ;   X 	    size integer
                                   3167 ;--------------------------
      0011FE                       3168 size:
      0011FE AE 16 90         [ 2] 3169 	ldw x,#tib 
      001201 72 B0 00 1E      [ 2] 3170 	subw x,txtend 
      001205 A6 84            [ 1] 3171 	ld a,#TK_INTGR
      001207 81               [ 4] 3172 	ret 
                                   3173 
                                   3174 
                                   3175 ;------------------------
                                   3176 ; BASIC: UBOUND  
                                   3177 ; return array variable size 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 62.
Hexadecimal [24-Bits]



                                   3178 ; output:
                                   3179 ;   A 		TK_INTGR
                                   3180 ;   X 	    array size 
                                   3181 ;--------------------------
      001208                       3182 ubound:
      001208 AE 16 90         [ 2] 3183 	ldw x,#tib
      00120B 72 B0 00 1E      [ 2] 3184 	subw x,txtend 
      00120F 90 CE 00 04      [ 2] 3185 	ldw y,basicptr 
      001213 90 C3 00 1E      [ 2] 3186 	cpw y,txtend 
      001217 25 0A            [ 1] 3187 	jrult 1$
      001219 3B 00 03         [ 1] 3188 	push count 
      00121C 4B 00            [ 1] 3189 	push #0 
      00121E 72 F0 01         [ 2] 3190 	subw x,(1,sp)
      001221                       3191 	_drop 2 
      001221 5B 02            [ 2]    1     addw sp,#2 
      001223 54               [ 2] 3192 1$:	srlw x 
      001224 CF 00 21         [ 2] 3193 	ldw array_size,x
      001227 A6 84            [ 1] 3194 	ld a,#TK_INTGR
      001229 81               [ 4] 3195 	ret 
                                   3196 
                                   3197 ;-----------------------------
                                   3198 ; BASIC: LET var=expr 
                                   3199 ; variable assignement 
                                   3200 ; output:
                                   3201 ;   A 		TK_NONE 
                                   3202 ;-----------------------------
      00122A                       3203 let:
      00122A CD 09 6D         [ 4] 3204 	call next_token 
      00122D A1 85            [ 1] 3205 	cp a,#TK_VAR 
      00122F 27 0A            [ 1] 3206 	jreq let_var
      001231 A1 06            [ 1] 3207 	cp a,#TK_ARRAY 
      001233 27 03            [ 1] 3208 	jreq  let_array
      001235 CC 08 7B         [ 2] 3209 	jp syntax_error
      001238                       3210 let_array:
      001238 CD 10 41         [ 4] 3211 	call get_array_element
      00123B                       3212 let_var:
      00123B 89               [ 2] 3213 	pushw x  
      00123C CD 09 6D         [ 4] 3214 	call next_token 
      00123F A1 32            [ 1] 3215 	cp a,#TK_EQUAL
      001241 27 03            [ 1] 3216 	jreq 1$
      001243 CC 08 7B         [ 2] 3217 	jp syntax_error
      001246                       3218 1$:	
      001246 CD 11 58         [ 4] 3219 	call relation   
      001249 A1 84            [ 1] 3220 	cp a,#TK_INTGR 
      00124B 27 03            [ 1] 3221 	jreq 2$
      00124D CC 08 7B         [ 2] 3222 	jp syntax_error
      001250                       3223 2$:	
      001250 90 93            [ 1] 3224 	ldw y,x 
      001252 85               [ 2] 3225 	popw x   
      001253 FF               [ 2] 3226 	ldw (x),y   
      001254 81               [ 4] 3227 	ret 
                                   3228 
                                   3229 ;----------------------------
                                   3230 ; BASIC: LIST [[start][,end]]
                                   3231 ; list program lines 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 63.
Hexadecimal [24-Bits]



                                   3232 ; form start to end 
                                   3233 ; if empty argument list then 
                                   3234 ; list all.
                                   3235 ;----------------------------
                           000001  3236 	FIRST=1
                           000003  3237 	LAST=3 
                           000005  3238 	LN_PTR=5
                           000006  3239 	VSIZE=6 
      001255                       3240 list:
      001255 CE 00 1C         [ 2] 3241 	ldw x,txtbgn 
      001258 C3 00 1E         [ 2] 3242 	cpw x,txtend 
      00125B 2B 01            [ 1] 3243 	jrmi 1$
      00125D 81               [ 4] 3244 	ret 
      00125E                       3245 1$:	
      00125E                       3246 	_vars VSIZE
      00125E 52 06            [ 2]    1     sub sp,#VSIZE 
      001260 1F 05            [ 2] 3247 	ldw (LN_PTR,sp),x 
      001262 FE               [ 2] 3248 	ldw x,(x) 
      001263 1F 01            [ 2] 3249 	ldw (FIRST,sp),x ; list from first line 
      001265 AE 7F FF         [ 2] 3250 	ldw x,#MAX_LINENO ; biggest line number 
      001268 1F 03            [ 2] 3251 	ldw (LAST,sp),x 
      00126A CD 10 16         [ 4] 3252 	call arg_list
      00126D 4D               [ 1] 3253 	tnz a
      00126E 27 31            [ 1] 3254 	jreq list_loop 
      001270 A1 02            [ 1] 3255 	cp a,#2 
      001272 27 07            [ 1] 3256 	jreq 4$
      001274 A1 01            [ 1] 3257 	cp a,#1 
      001276 27 06            [ 1] 3258 	jreq first_line 
      001278 CC 08 7B         [ 2] 3259 	jp syntax_error 
      00127B 85               [ 2] 3260 4$:	popw x 
      00127C 1F 05            [ 2] 3261 	ldw (LAST+2,sp),x 
      00127E                       3262 first_line:
      00127E 85               [ 2] 3263 	popw x
      00127F 1F 01            [ 2] 3264 	ldw (FIRST,sp),x 
      001281                       3265 lines_skip:
      001281 CE 00 1C         [ 2] 3266 	ldw x,txtbgn
      001284 1F 05            [ 2] 3267 2$:	ldw (LN_PTR,sp),x 
      001286 C3 00 1E         [ 2] 3268 	cpw x,txtend 
      001289 2A 38            [ 1] 3269 	jrpl list_exit 
      00128B FE               [ 2] 3270 	ldw x,(x) ;line# 
      00128C 13 01            [ 2] 3271 	cpw x,(FIRST,sp)
      00128E 2A 11            [ 1] 3272 	jrpl list_loop 
      001290 1E 05            [ 2] 3273 	ldw x,(LN_PTR,sp) 
      001292 E6 02            [ 1] 3274 	ld a,(2,x)
      001294 C7 00 0D         [ 1] 3275 	ld acc8,a 
      001297 72 5F 00 0C      [ 1] 3276 	clr acc16 
      00129B 72 BB 00 0C      [ 2] 3277 	addw x,acc16
      00129F 20 E3            [ 2] 3278 	jra 2$ 
                                   3279 ; print loop
      0012A1                       3280 list_loop:
      0012A1 1E 05            [ 2] 3281 	ldw x,(LN_PTR,sp)
      0012A3 E6 02            [ 1] 3282 	ld a,(2,x) 
      0012A5 CD 14 DC         [ 4] 3283 	call prt_basic_line
      0012A8 1E 05            [ 2] 3284 	ldw x,(LN_PTR,sp)
      0012AA E6 02            [ 1] 3285 	ld a,(2,x)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 64.
Hexadecimal [24-Bits]



      0012AC C7 00 0D         [ 1] 3286 	ld acc8,a 
      0012AF 72 5F 00 0C      [ 1] 3287 	clr acc16 
      0012B3 72 BB 00 0C      [ 2] 3288 	addw x,acc16
      0012B7 C3 00 1E         [ 2] 3289 	cpw x,txtend 
      0012BA 2A 07            [ 1] 3290 	jrpl list_exit
      0012BC 1F 05            [ 2] 3291 	ldw (LN_PTR,sp),x
      0012BE FE               [ 2] 3292 	ldw x,(x)
      0012BF 13 03            [ 2] 3293 	cpw x,(LAST,sp)  
      0012C1 2F DE            [ 1] 3294 	jrslt list_loop
      0012C3                       3295 list_exit:
      0012C3 55 00 03 00 01   [ 1] 3296 	mov in,count 
      0012C8 AE 16 E0         [ 2] 3297 	ldw x,#pad 
      0012CB CF 00 04         [ 2] 3298 	ldw basicptr,x 
      0012CE                       3299 	_drop VSIZE 
      0012CE 5B 06            [ 2]    1     addw sp,#VSIZE 
      0012D0 81               [ 4] 3300 	ret
                                   3301 
                                   3302 ;-------------------------
                                   3303 ; copy command name to buffer  
                                   3304 ; input:
                                   3305 ;   X 	name address 
                                   3306 ;   Y   destination buffer 
                                   3307 ; output:
                                   3308 ;   Y   point after name  
                                   3309 ;--------------------------
      0012D1                       3310 cpy_cmd_name:
      0012D1 F6               [ 1] 3311 	ld a,(x)
      0012D2 5C               [ 2] 3312 	incw x
      0012D3 A4 0F            [ 1] 3313 	and a,#15  
      0012D5 88               [ 1] 3314 	push a 
      0012D6 0D 01            [ 1] 3315     tnz (1,sp) 
      0012D8 27 0A            [ 1] 3316 	jreq 9$
      0012DA F6               [ 1] 3317 1$:	ld a,(x)
      0012DB 90 F7            [ 1] 3318 	ld (y),a  
      0012DD 5C               [ 2] 3319 	incw x
      0012DE 90 5C            [ 2] 3320 	incw y 
      0012E0 0A 01            [ 1] 3321 	dec (1,sp)	 
      0012E2 26 F6            [ 1] 3322 	jrne 1$
      0012E4 84               [ 1] 3323 9$: pop a 
      0012E5 81               [ 4] 3324 	ret	
                                   3325 
                                   3326 ;--------------------------
                                   3327 ; add a space after letter or 
                                   3328 ; digit.
                                   3329 ; input:
                                   3330 ;   Y     pointer to buffer 
                                   3331 ; output:
                                   3332 ;   Y    moved to end 
                                   3333 ;--------------------------
      0012E6                       3334 add_space:
      0012E6 90 5A            [ 2] 3335 	decw y 
      0012E8 90 F6            [ 1] 3336 	ld a,(y)
      0012EA 90 5C            [ 2] 3337 	incw y
      0012EC CD 05 89         [ 4] 3338 	call is_alnum 
      0012EF 24 06            [ 1] 3339 	jrnc 1$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 65.
Hexadecimal [24-Bits]



      0012F1 A6 20            [ 1] 3340 	ld a,#SPACE 
      0012F3 90 F7            [ 1] 3341 	ld (y),a 
      0012F5 90 5C            [ 2] 3342 	incw y 
      0012F7 81               [ 4] 3343 1$: ret 
                                   3344 
                                   3345 ;--------------------------
                                   3346 ;  align text in buffer 
                                   3347 ;  to tab_width padding 
                                   3348 ;  left with  SPACE 
                                   3349 ; input:
                                   3350 ;   X      str*
                                   3351 ;   A      str_length 
                                   3352 ; output:
                                   3353 ;   X      ajusted
                                   3354 ;--------------------------
      0012F8                       3355 right_align:
      0012F8 88               [ 1] 3356 	push a 
      0012F9 7B 01            [ 1] 3357 0$: ld a,(1,sp)
      0012FB C1 00 24         [ 1] 3358 	cp a,tab_width 
      0012FE 2A 08            [ 1] 3359 	jrpl 1$
      001300 A6 20            [ 1] 3360 	ld a,#SPACE 
      001302 5A               [ 2] 3361 	decw x
      001303 F7               [ 1] 3362 	ld (x),a  
      001304 0C 01            [ 1] 3363 	inc (1,sp)
      001306 20 F1            [ 2] 3364 	jra 0$ 
      001308 84               [ 1] 3365 1$: pop a 	
      001309 81               [ 4] 3366 	ret 
                                   3367 
                                   3368 ;--------------------------
                                   3369 ; print TK_QSTR
                                   3370 ; converting control character
                                   3371 ; to backslash sequence
                                   3372 ; input:
                                   3373 ;   X        char *
                                   3374 ;   Y        dest. buffer 
                                   3375 ; output:
                                   3376 ;   X        moved forward 
                                   3377 ;   Y        moved forward 
                                   3378 ;-----------------------------
      00130A                       3379 cpy_quote:
      00130A A6 22            [ 1] 3380 	ld a,#'"
      00130C 90 F7            [ 1] 3381 	ld (y),a 
      00130E 90 5C            [ 2] 3382 	incw y 
      001310 F6               [ 1] 3383 1$:	ld a,(x)
      001311 27 30            [ 1] 3384 	jreq 9$
      001313 5C               [ 2] 3385 	incw x 
      001314 A1 20            [ 1] 3386 	cp a,#SPACE 
      001316 25 0E            [ 1] 3387 	jrult 3$
      001318 90 F7            [ 1] 3388 	ld (y),a
      00131A 90 5C            [ 2] 3389 	incw y 
      00131C A1 5C            [ 1] 3390 	cp a,#'\ 
      00131E 26 F0            [ 1] 3391 	jrne 1$ 
      001320                       3392 2$:
      001320 90 F7            [ 1] 3393 	ld (y),a
      001322 90 5C            [ 2] 3394 	incw y  
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 66.
Hexadecimal [24-Bits]



      001324 20 EA            [ 2] 3395 	jra 1$
      001326 88               [ 1] 3396 3$: push a 
      001327 A6 5C            [ 1] 3397 	ld a,#'\
      001329 90 F7            [ 1] 3398 	ld (y),a 
      00132B 90 5C            [ 2] 3399 	incw y  
      00132D 84               [ 1] 3400 	pop a 
      00132E A0 07            [ 1] 3401 	sub a,#7
      001330 C7 00 0D         [ 1] 3402 	ld acc8,a 
      001333 72 5F 00 0C      [ 1] 3403 	clr acc16
      001337 89               [ 2] 3404 	pushw x
      001338 AE 0B 12         [ 2] 3405 	ldw x,#escaped 
      00133B 72 BB 00 0C      [ 2] 3406 	addw x,acc16 
      00133F F6               [ 1] 3407 	ld a,(x)
      001340 85               [ 2] 3408 	popw x
      001341 20 DD            [ 2] 3409 	jra 2$
      001343 A6 22            [ 1] 3410 9$: ld a,#'"
      001345 90 F7            [ 1] 3411 	ld (y),a 
      001347 90 5C            [ 2] 3412 	incw y  
      001349 5C               [ 2] 3413 	incw x 
      00134A 81               [ 4] 3414 	ret
                                   3415 
                                   3416 ;--------------------------
                                   3417 ; return variable name 
                                   3418 ; from its address.
                                   3419 ; input:
                                   3420 ;   X    variable address
                                   3421 ; output:
                                   3422 ;   A     variable letter
                                   3423 ;--------------------------
      00134B                       3424 var_name:
      00134B 1D 00 2F         [ 2] 3425 		subw x,#vars 
      00134E 9F               [ 1] 3426 		ld a,xl 
      00134F 44               [ 1] 3427 		srl a 
      001350 AB 41            [ 1] 3428 		add a,#'A 
      001352 81               [ 4] 3429 		ret 
                                   3430 
                                   3431 ;-----------------------------
                                   3432 ; return cmd  idx from its 
                                   3433 ; code address 
                                   3434 ; input:
                                   3435 ;   X      code address 
                                   3436 ; output:
                                   3437 ;   X      cmd_idx
                                   3438 ;-----------------------------
      001353                       3439 get_cmd_idx:
      001353 90 89            [ 2] 3440 	pushw y
      001355 90 AE 26 B9      [ 2] 3441 	ldw y,#code_addr 
      001359 90 CF 00 17      [ 2] 3442 	ldw ptr16,y 
      00135D 90 5F            [ 1] 3443 	clrw y 
      00135F 91 D3 17         [ 5] 3444 1$:	cpw x,([ptr16],y)
      001362 27 0C            [ 1] 3445 	jreq 3$ 
      001364 90 5C            [ 2] 3446 	incw y 
      001366 91 D6 17         [ 4] 3447 	ld a,([ptr16],y)
      001369 90 5C            [ 2] 3448 	incw y
      00136B 91 DA 17         [ 4] 3449 	or a,([ptr16],y)	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 67.
Hexadecimal [24-Bits]



      00136E 26 EF            [ 1] 3450 	jrne 1$
      001370 93               [ 1] 3451 3$: ldw x,y 
      001371 90 85            [ 2] 3452 	popw y 
      001373 81               [ 4] 3453 	ret
                                   3454 
                                   3455 ;-------------------------------------
                                   3456 ; decompile tokens list 
                                   3457 ; to original text line 
                                   3458 ; input:
                                   3459 ;   [basicptr]  pointer at line 
                                   3460 ;   Y           destination buffer
                                   3461 ; output:
                                   3462 ;   A           length 
                                   3463 ;   Y           after string  
                                   3464 ;------------------------------------
                           000001  3465 	BASE_SAV=1
                           000002  3466 	WIDTH_SAV=2
                           000003  3467 	STR=3
                           000004  3468 	VSIZE=4 
      001374                       3469 decompile::
      001374                       3470 	_vars VSIZE
      001374 52 04            [ 2]    1     sub sp,#VSIZE 
      001376 C6 00 0A         [ 1] 3471 	ld a,base
      001379 6B 01            [ 1] 3472 	ld (BASE_SAV,sp),a  
      00137B C6 00 24         [ 1] 3473 	ld a,tab_width 
      00137E 6B 02            [ 1] 3474 	ld (WIDTH_SAV,sp),a 
      001380 17 03            [ 2] 3475 	ldw (STR,sp),y   
      001382 72 CE 00 04      [ 5] 3476 	ldw x,[basicptr] ; line number 
      001386 35 0A 00 0A      [ 1] 3477 	mov base,#10
      00138A 35 05 00 24      [ 1] 3478 	mov tab_width,#5
      00138E 72 5F 00 0B      [ 1] 3479 	clr acc24 
      001392 CF 00 0C         [ 2] 3480 	ldw acc16,x
      001395 CD 09 E6         [ 4] 3481 	call itoa  
      001398 CD 12 F8         [ 4] 3482 	call right_align 
      00139B 88               [ 1] 3483 	push a 
      00139C 90 93            [ 1] 3484 1$:	ldw y,x ; source
      00139E 1E 04            [ 2] 3485 	ldw x,(STR+1,sp) ; destination
      0013A0 CD 03 B4         [ 4] 3486 	call strcpy 
      0013A3 90 5F            [ 1] 3487 	clrw y 
      0013A5 84               [ 1] 3488 	pop a 
      0013A6 90 97            [ 1] 3489 	ld yl,a 
      0013A8 72 F9 03         [ 2] 3490 	addw y,(STR,sp)
      0013AB A6 20            [ 1] 3491 	ld a,#SPACE 
      0013AD 90 F7            [ 1] 3492 	ld (y),a 
      0013AF 90 5C            [ 2] 3493 	incw y 
      0013B1 72 5F 00 24      [ 1] 3494 	clr tab_width
      0013B5 AE 00 03         [ 2] 3495 	ldw x,#3
      0013B8 CF 00 00         [ 2] 3496 	ldw in.w,x 
      0013BB                       3497 decomp_loop:
      0013BB 90 89            [ 2] 3498 	pushw y
      0013BD CD 09 6D         [ 4] 3499 	call next_token 
      0013C0 90 85            [ 2] 3500 	popw y 
      0013C2 4D               [ 1] 3501 	tnz a  
      0013C3 26 03            [ 1] 3502 	jrne 1$
      0013C5 CC 14 A1         [ 2] 3503 	jp 20$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 68.
Hexadecimal [24-Bits]



      0013C8 2A 6F            [ 1] 3504 1$:	jrpl 6$
                                   3505 ;; TK_CMD|TK_IFUNC|TK_CFUNC|TK_CONST|TK_VAR|TK_INTGR
      0013CA A1 85            [ 1] 3506 	cp a,#TK_VAR 
      0013CC 26 0C            [ 1] 3507 	jrne 3$
                                   3508 ;; TK_VAR 
      0013CE CD 12 E6         [ 4] 3509 	call add_space  
      0013D1 CD 13 4B         [ 4] 3510 	call var_name
      0013D4 90 F7            [ 1] 3511 	ld (y),a 
      0013D6 90 5C            [ 2] 3512 	incw y  
      0013D8 20 E1            [ 2] 3513 	jra decomp_loop
      0013DA                       3514 3$:
      0013DA A1 84            [ 1] 3515 	cp a,#TK_INTGR
      0013DC 26 22            [ 1] 3516 	jrne 4$
                                   3517 ;; TK_INTGR
      0013DE CD 12 E6         [ 4] 3518 	call add_space
      0013E1 72 5F 00 0B      [ 1] 3519 	clr acc24 
      0013E5 CF 00 0C         [ 2] 3520 	ldw acc16,x 
      0013E8 90 89            [ 2] 3521 	pushw y 
      0013EA CD 09 E6         [ 4] 3522 	call itoa  
      0013ED 16 01            [ 2] 3523 	ldw y,(1,sp) 
      0013EF 88               [ 1] 3524 	push a 
      0013F0 51               [ 1] 3525 	exgw x,y 
      0013F1 CD 03 B4         [ 4] 3526 	call strcpy 
      0013F4 90 5F            [ 1] 3527 	clrw y
      0013F6 84               [ 1] 3528 	pop a  
      0013F7 90 97            [ 1] 3529 	ld yl,a 
      0013F9 72 F9 01         [ 2] 3530 	addw y,(1,sp)
      0013FC                       3531 	_drop 2 
      0013FC 5B 02            [ 2]    1     addw sp,#2 
      0013FE 20 BB            [ 2] 3532 	jra decomp_loop
                                   3533 ;; dictionary keyword 
      001400                       3534 4$:	
      001400 CD 13 53         [ 4] 3535 	call get_cmd_idx 
      001403 A3 00 8E         [ 2] 3536 	cpw x,#REM_IDX
      001406 26 22            [ 1] 3537 	jrne 5$
      001408 CE 00 04         [ 2] 3538 	ldw x,basicptr 
                                   3539 ; copy comment to buffer 
      00140B CD 12 E6         [ 4] 3540 	call add_space
      00140E A6 27            [ 1] 3541 	ld a,#''
      001410 90 F7            [ 1] 3542 	ld (y),a 
      001412 90 5C            [ 2] 3543 	incw y 
      001414                       3544 41$:
      001414 72 D6 00 00      [ 4] 3545 	ld a,([in.w],x)
      001418 72 5C 00 01      [ 1] 3546 	inc in  
      00141C 90 F7            [ 1] 3547 	ld (y),a 
      00141E 90 5C            [ 2] 3548 	incw y 
      001420 C6 00 01         [ 1] 3549 	ld a,in 
      001423 C1 00 03         [ 1] 3550 	cp a,count 
      001426 2B EC            [ 1] 3551 	jrmi 41$
      001428 20 77            [ 2] 3552 	jra 20$  
                                   3553 ; insert command name 
      00142A                       3554 5$:
      00142A CD 12 E6         [ 4] 3555 	call add_space  
      00142D 90 89            [ 2] 3556 	pushw y
      00142F CD 0F 85         [ 4] 3557 	call cmd_name
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 69.
Hexadecimal [24-Bits]



      001432 90 85            [ 2] 3558 	popw y 
      001434 CD 12 D1         [ 4] 3559 	call cpy_cmd_name
      001437 20 82            [ 2] 3560 	jra decomp_loop 
      001439                       3561 6$:
      001439 A1 02            [ 1] 3562 	cp a,#TK_QSTR 
      00143B 26 06            [ 1] 3563 	jrne 7$
                                   3564 ;; TK_QSTR
      00143D CD 13 0A         [ 4] 3565 	call cpy_quote  
      001440 CC 13 BB         [ 2] 3566 	jp decomp_loop
      001443                       3567 7$:
      001443 A1 03            [ 1] 3568 	cp a,#TK_CHAR 
      001445 26 0E            [ 1] 3569 	jrne 8$
                                   3570 ;; TK_CHAR 
      001447 A6 5C            [ 1] 3571 	ld a,#'\ 
      001449 90 F7            [ 1] 3572 	ld (y),a 
      00144B 90 5C            [ 2] 3573 	incw y 
      00144D 9F               [ 1] 3574 	ld a,xl 
      00144E 90 F7            [ 1] 3575 	ld (y),a 
      001450 90 5C            [ 2] 3576 	incw y 
      001452 CC 13 BB         [ 2] 3577 	jp decomp_loop
      001455 A1 01            [ 1] 3578 8$: cp a,#TK_COLON 
      001457 26 09            [ 1] 3579 	jrne 9$
      001459 A6 3A            [ 1] 3580 	ld a,#':
      00145B                       3581 81$:
      00145B 90 F7            [ 1] 3582 	ld (y),a 
      00145D 90 5C            [ 2] 3583 	incw y 
      00145F                       3584 82$:
      00145F CC 13 BB         [ 2] 3585 	jp decomp_loop
      001462                       3586 9$: 
      001462 A1 0A            [ 1] 3587 	cp a,#TK_SHARP
      001464 22 0A            [ 1] 3588 	jrugt 10$ 
      001466 A0 06            [ 1] 3589 	sub a,#TK_ARRAY 
      001468 5F               [ 1] 3590 	clrw x 
      001469 97               [ 1] 3591 	ld xl,a
      00146A 1C 14 B7         [ 2] 3592 	addw x,#single_char 
      00146D F6               [ 1] 3593 	ld a,(x)
      00146E 20 EB            [ 2] 3594 	jra 81$ 
      001470                       3595 10$: 
      001470 A1 11            [ 1] 3596 	cp a,#TK_MINUS 
      001472 22 0A            [ 1] 3597 	jrugt 11$
      001474 A0 10            [ 1] 3598 	sub a,#TK_PLUS 
      001476 5F               [ 1] 3599 	clrw x 
      001477 97               [ 1] 3600 	ld xl,a 
      001478 1C 14 BC         [ 2] 3601 	addw x,#add_char 
      00147B F6               [ 1] 3602 	ld a,(x)
      00147C 20 DD            [ 2] 3603 	jra 81$
      00147E                       3604 11$:
      00147E A1 22            [ 1] 3605     cp a,#TK_MOD 
      001480 22 0A            [ 1] 3606 	jrugt 12$
      001482 A0 20            [ 1] 3607 	sub a,#TK_MULT
      001484 5F               [ 1] 3608 	clrw x 
      001485 97               [ 1] 3609 	ld xl,a 
      001486 1C 14 BE         [ 2] 3610 	addw x,#mul_char
      001489 F6               [ 1] 3611 	ld a,(x)
      00148A 20 CF            [ 2] 3612 	jra 81$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 70.
Hexadecimal [24-Bits]



      00148C                       3613 12$:
      00148C A0 31            [ 1] 3614 	sub a,#TK_GT  
      00148E 48               [ 1] 3615 	sll a 
      00148F 5F               [ 1] 3616 	clrw x 
      001490 97               [ 1] 3617 	ld xl,a 
      001491 1C 14 C1         [ 2] 3618 	addw x,#relop_str 
      001494 FE               [ 2] 3619 	ldw x,(x)
      001495 F6               [ 1] 3620 	ld a,(x)
      001496 5C               [ 2] 3621 	incw x 
      001497 90 F7            [ 1] 3622 	ld (y),a
      001499 90 5C            [ 2] 3623 	incw y 
      00149B F6               [ 1] 3624 	ld a,(x)
      00149C 26 BD            [ 1] 3625 	jrne 81$
      00149E CC 13 BB         [ 2] 3626 	jp decomp_loop 
      0014A1                       3627 20$: 
      0014A1 90 7F            [ 1] 3628 	clr (y)
      0014A3 1E 03            [ 2] 3629 	ldw x,(STR,sp)
      0014A5 7B 01            [ 1] 3630 	ld a,(BASE_SAV,sp)
      0014A7 C7 00 0A         [ 1] 3631 	ld base,a 
      0014AA 7B 02            [ 1] 3632 	ld a,(WIDTH_SAV,sp)
      0014AC C7 00 24         [ 1] 3633 	ld tab_width,a
      0014AF 72 F2 03         [ 2] 3634 	subw y,(STR,sp) 
      0014B2 90 9F            [ 1] 3635 	ld a,yl 
      0014B4                       3636 	_drop VSIZE 
      0014B4 5B 04            [ 2]    1     addw sp,#VSIZE 
      0014B6 81               [ 4] 3637 	ret 
                                   3638 
      0014B7 40 28 29 2C 23        3639 single_char: .byte '@','(',')',',','#'
      0014BC 2B 2D                 3640 add_char: .byte '+','-'
      0014BE 2A 2F 25              3641 mul_char: .byte '*','/','%'
      0014C1 14 CD 14 CF 14 D1 14  3642 relop_str: .word gt,equal,ge,lt,le,ne 
             D4 14 D6 14 D9
      0014CD 3E 00                 3643 gt: .asciz ">"
      0014CF 3D 00                 3644 equal: .asciz "="
      0014D1 3E 3D 00              3645 ge: .asciz ">="
      0014D4 3C 00                 3646 lt: .asciz "<"
      0014D6 3C 3D 00              3647 le: .asciz "<="
      0014D9 3C 3E 00              3648 ne:  .asciz "<>"
                                   3649 
                                   3650 
                                   3651 ;--------------------------
                                   3652 ; decompile line from token list
                                   3653 ; and print it. 
                                   3654 ; input:
                                   3655 ;   A       stop at this position 
                                   3656 ;   X 		pointer at line
                                   3657 ; output:
                                   3658 ;   none 
                                   3659 ;--------------------------	
      0014DC                       3660 prt_basic_line:
      0014DC C7 00 03         [ 1] 3661 	ld count,a 
      0014DF E6 02            [ 1] 3662 	ld a,(2,x)
      0014E1 C1 00 03         [ 1] 3663 	cp a,count 
      0014E4 2A 03            [ 1] 3664 	jrpl 1$ 
      0014E6 C7 00 03         [ 1] 3665 	ld count,a 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 71.
Hexadecimal [24-Bits]



      0014E9 CF 00 04         [ 2] 3666 1$:	ldw basicptr,x 
      0014EC 90 AE 16 90      [ 2] 3667 	ldw y,#tib  
      0014F0 CD 13 74         [ 4] 3668 	call decompile 
      0014F3 CD 00 00         [ 4] 3669 	call puts 
      0014F6 A6 0D            [ 1] 3670 	ld a,#CR 
      0014F8 CD 02 C0         [ 4] 3671 	call putc 
      0014FB 81               [ 4] 3672 	ret 
                                   3673 
                                   3674 
                                   3675 
                                   3676 ;---------------------------------
                                   3677 ; BASIC: PRINT|? arg_list 
                                   3678 ; print values from argument list
                                   3679 ;----------------------------------
                           000001  3680 	COMMA=1
                           000001  3681 	VSIZE=1
      0014FC                       3682 print:
      0014FC 4B 00            [ 1] 3683 push #0 ; local variable COMMA 
      0014FE                       3684 reset_comma:
      0014FE 0F 01            [ 1] 3685 	clr (COMMA,sp)
      001500                       3686 prt_loop:
      001500 CD 09 6D         [ 4] 3687 	call next_token
      001503 A1 02            [ 1] 3688 	cp a,#CMD_END 
      001505 25 5A            [ 1] 3689 	jrult print_exit ; colon or end of line 
      001507 A1 02            [ 1] 3690 	cp a,#TK_QSTR
      001509 27 12            [ 1] 3691 	jreq 1$
      00150B A1 03            [ 1] 3692 	cp a,#TK_CHAR 
      00150D 27 13            [ 1] 3693 	jreq 2$ 
      00150F A1 82            [ 1] 3694 	cp a,#TK_CFUNC 
      001511 27 15            [ 1] 3695 	jreq 3$
      001513 A1 09            [ 1] 3696 	cp a,#TK_COMMA 
      001515 27 18            [ 1] 3697 	jreq 4$
      001517 A1 0A            [ 1] 3698 	cp a,#TK_SHARP 
      001519 27 1B            [ 1] 3699 	jreq 5$
      00151B 20 2B            [ 2] 3700 	jra 7$ 
      00151D                       3701 1$:	; print string 
      00151D CD 00 00         [ 4] 3702 	call puts
      001520 20 DC            [ 2] 3703 	jra reset_comma
      001522                       3704 2$:	; print character 
      001522 9F               [ 1] 3705 	ld a,xl 
      001523 CD 02 C0         [ 4] 3706 	call putc 
      001526 20 D6            [ 2] 3707 	jra reset_comma 
      001528                       3708 3$: ; print character function value  	
      001528 FD               [ 4] 3709 	call (x)
      001529 9F               [ 1] 3710 	ld a,xl 
      00152A CD 02 C0         [ 4] 3711 	call putc
      00152D 20 CF            [ 2] 3712 	jra reset_comma 
      00152F                       3713 4$: ; set comma state 
      00152F A6 FF            [ 1] 3714 	ld a,#255 
      001531 6B 01            [ 1] 3715 	ld (COMMA,sp),a  
      001533 CC 15 00         [ 2] 3716 	jp prt_loop   
      001536                       3717 5$: ; # character must be followed by an integer   
      001536 CD 09 6D         [ 4] 3718 	call next_token
      001539 A1 84            [ 1] 3719 	cp a,#TK_INTGR 
      00153B 27 03            [ 1] 3720 	jreq 6$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 72.
Hexadecimal [24-Bits]



      00153D CC 08 7B         [ 2] 3721 	jp syntax_error 
      001540                       3722 6$: ; set tab width
      001540 9F               [ 1] 3723 	ld a,xl 
      001541 A4 0F            [ 1] 3724 	and a,#15 
      001543 C7 00 24         [ 1] 3725 	ld tab_width,a 
      001546 20 B6            [ 2] 3726 	jra reset_comma 
      001548                       3727 7$:	
      001548                       3728 	_unget_token
      001548 55 00 02 00 01   [ 1]    1     mov in,in.saved
      00154D CD 11 58         [ 4] 3729 	call relation 
      001550 A1 84            [ 1] 3730 	cp a,#TK_INTGR
      001552 27 08            [ 1] 3731 	jreq 8$
      001554                       3732 	_unget_token
      001554 55 00 02 00 01   [ 1]    1     mov in,in.saved
      001559 CC 15 61         [ 2] 3733 	jp print_exit 
      00155C CD 09 CA         [ 4] 3734 8$: call print_int 
      00155F 20 9D            [ 2] 3735 	jra reset_comma 
      001561                       3736 print_exit:
      001561 0D 01            [ 1] 3737 	tnz (COMMA,sp)
      001563 26 05            [ 1] 3738 	jrne 9$
      001565 A6 0D            [ 1] 3739 	ld a,#CR 
      001567 CD 02 C0         [ 4] 3740     call putc 
      00156A                       3741 9$:	_drop VSIZE 
      00156A 5B 01            [ 2]    1     addw sp,#VSIZE 
      00156C 81               [ 4] 3742 	ret 
                                   3743 
                                   3744 ;----------------------
                                   3745 ; 'save_context' and
                                   3746 ; 'rest_context' must be 
                                   3747 ; called at the same 
                                   3748 ; call stack depth 
                                   3749 ; i.e. SP must have the 
                                   3750 ; save value at  
                                   3751 ; entry point of both 
                                   3752 ; routine. 
                                   3753 ;---------------------
                           000004  3754 	CTXT_SIZE=4 ; size of saved data 
                                   3755 ;--------------------
                                   3756 ; save current BASIC
                                   3757 ; interpreter context 
                                   3758 ; on stack 
                                   3759 ;--------------------
      00156D                       3760 	_argofs 0 
                           000002     1     ARG_OFS=2+0 
      00156D                       3761 	_arg BPTR 1
                           000003     1     BPTR=ARG_OFS+1 
      00156D                       3762 	_arg IN 3
                           000005     1     IN=ARG_OFS+3 
      00156D                       3763 	_arg CNT 4
                           000006     1     CNT=ARG_OFS+4 
      00156D                       3764 save_context:
      00156D CE 00 04         [ 2] 3765 	ldw x,basicptr 
      001570 1F 03            [ 2] 3766 	ldw (BPTR,sp),x
      001572 C6 00 01         [ 1] 3767 	ld a,in 
      001575 6B 05            [ 1] 3768 	ld (IN,sp),a
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 73.
Hexadecimal [24-Bits]



      001577 C6 00 03         [ 1] 3769 	ld a,count 
      00157A 6B 06            [ 1] 3770 	ld (CNT,sp),a  
      00157C 81               [ 4] 3771 	ret
                                   3772 
                                   3773 ;-----------------------
                                   3774 ; restore previously saved 
                                   3775 ; BASIC interpreter context 
                                   3776 ; from stack 
                                   3777 ;-------------------------
      00157D                       3778 rest_context:
      00157D 1E 03            [ 2] 3779 	ldw x,(BPTR,sp)
      00157F CF 00 04         [ 2] 3780 	ldw basicptr,x 
      001582 7B 05            [ 1] 3781 	ld a,(IN,sp)
      001584 C7 00 01         [ 1] 3782 	ld in,a
      001587 7B 06            [ 1] 3783 	ld a,(CNT,sp)
      001589 C7 00 03         [ 1] 3784 	ld count,a  
      00158C 81               [ 4] 3785 	ret
                                   3786 
                                   3787 
                                   3788 
                                   3789 ;------------------------------------------
                                   3790 ; BASIC: INPUT [string]var[,[string]var]
                                   3791 ; input value in variables 
                                   3792 ; [string] optionally can be used as prompt 
                                   3793 ;-----------------------------------------
                           000001  3794 	CX_BPTR=1
                           000003  3795 	CX_IN=3
                           000004  3796 	CX_CNT=4
                           000005  3797 	SKIP=5
                           000006  3798 	VAR_ADDR=6
                           000007  3799 	VSIZE=7
      00158D                       3800 input_var:
      00158D                       3801 	_vars VSIZE 
      00158D 52 07            [ 2]    1     sub sp,#VSIZE 
      00158F                       3802 input_loop:
      00158F 0F 05            [ 1] 3803 	clr (SKIP,sp)
      001591 CD 09 6D         [ 4] 3804 	call next_token 
      001594 A1 02            [ 1] 3805 	cp a,#TK_QSTR 
      001596 26 08            [ 1] 3806 	jrne 1$ 
      001598 CD 00 00         [ 4] 3807 	call puts 
      00159B 03 05            [ 1] 3808 	cpl (SKIP,sp)
      00159D CD 09 6D         [ 4] 3809 	call next_token 
      0015A0 A1 85            [ 1] 3810 1$: cp a,#TK_VAR  
      0015A2 27 03            [ 1] 3811 	jreq 2$ 
      0015A4 CC 08 7B         [ 2] 3812 	jp syntax_error
      0015A7 1F 06            [ 2] 3813 2$:	ldw (VAR_ADDR,sp),x 
      0015A9 0D 05            [ 1] 3814 	tnz (SKIP,sp)
      0015AB 26 06            [ 1] 3815 	jrne 21$ 
      0015AD CD 13 4B         [ 4] 3816 	call var_name 
      0015B0 CD 02 C0         [ 4] 3817 	call putc   
      0015B3                       3818 21$:
      0015B3 A6 3A            [ 1] 3819 	ld a,#':
      0015B5 CD 02 C0         [ 4] 3820 	call putc 
      0015B8 CD 15 6D         [ 4] 3821 	call save_context 
      0015BB 72 5F 00 03      [ 1] 3822 	clr count  
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 74.
Hexadecimal [24-Bits]



      0015BF CD 00 00         [ 4] 3823 	call readln 
      0015C2 AE 16 90         [ 2] 3824 	ldw x,#tib 
      0015C5 3B 00 03         [ 1] 3825 	push count
      0015C8 4B 00            [ 1] 3826 	push #0 
      0015CA 72 FB 01         [ 2] 3827 	addw x,(1,sp)
      0015CD 5C               [ 2] 3828 	incw x 
      0015CE                       3829 	_drop 2 
      0015CE 5B 02            [ 2]    1     addw sp,#2 
      0015D0 72 5F 00 01      [ 1] 3830 	clr in 
      0015D4 CD 0B EE         [ 4] 3831 	call get_token
      0015D7 A1 84            [ 1] 3832 	cp a,#TK_INTGR
      0015D9 27 06            [ 1] 3833 	jreq 3$ 
      0015DB CD 15 7D         [ 4] 3834 	call rest_context 
      0015DE CC 08 7B         [ 2] 3835 	jp syntax_error
      0015E1 16 06            [ 2] 3836 3$: ldw y,(VAR_ADDR,sp) 
      0015E3 90 FF            [ 2] 3837 	ldw (y),x 
      0015E5 CD 15 7D         [ 4] 3838 	call rest_context
      0015E8 CD 09 6D         [ 4] 3839 	call next_token 
      0015EB A1 09            [ 1] 3840 	cp a,#TK_COMMA 
      0015ED 27 A0            [ 1] 3841 	jreq input_loop 
      0015EF A1 01            [ 1] 3842 	cp a,#TK_COLON 
      0015F1 23 03            [ 2] 3843     jrule input_exit 
      0015F3 CC 08 7B         [ 2] 3844 	jp syntax_error 
      0015F6                       3845 input_exit:
      0015F6                       3846 	_drop VSIZE 
      0015F6 5B 07            [ 2]    1     addw sp,#VSIZE 
      0015F8 81               [ 4] 3847 	ret 
                                   3848 
                                   3849 
                                   3850 ;---------------------
                                   3851 ; BASIC: REMARK | ' 
                                   3852 ; skip comment to end of line 
                                   3853 ;---------------------- 
      0015F9                       3854 remark:
      0015F9 55 00 03 00 01   [ 1] 3855 	mov in,count 
      0015FE 81               [ 4] 3856  	ret 
                                   3857 
                                   3858 
                                   3859 ;---------------------
                                   3860 ; BASIC: WAIT addr,mask[,xor_mask] 
                                   3861 ; read in loop 'addr'  
                                   3862 ; apply & 'mask' to value 
                                   3863 ; loop while result==0.  
                                   3864 ; 'xor_mask' is used to 
                                   3865 ; invert the wait logic.
                                   3866 ; i.e. loop while not 0.
                                   3867 ;---------------------
                           000001  3868 	XMASK=1 
                           000002  3869 	MASK=2
                           000003  3870 	ADDR=3
                           000004  3871 	VSIZE=4
      0015FF                       3872 wait: 
      0015FF                       3873 	_vars VSIZE
      0015FF 52 04            [ 2]    1     sub sp,#VSIZE 
      001601 0F 01            [ 1] 3874 	clr (XMASK,sp) 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 75.
Hexadecimal [24-Bits]



      001603 CD 10 16         [ 4] 3875 	call arg_list 
      001606 A1 02            [ 1] 3876 	cp a,#2
      001608 24 03            [ 1] 3877 	jruge 0$
      00160A CC 08 7B         [ 2] 3878 	jp syntax_error 
      00160D A1 03            [ 1] 3879 0$:	cp a,#3
      00160F 25 04            [ 1] 3880 	jrult 1$
      001611 85               [ 2] 3881 	popw x 
      001612 9F               [ 1] 3882 	ld a,xl
      001613 6B 01            [ 1] 3883 	ld (XMASK,sp),a 
      001615 85               [ 2] 3884 1$: popw x ; mask 
      001616 9F               [ 1] 3885 	ld a,xl 
      001617 6B 02            [ 1] 3886 	ld (MASK,sp),a 
      001619 85               [ 2] 3887 	popw x ; address 
      00161A F6               [ 1] 3888 2$:	ld a,(x)
      00161B 14 02            [ 1] 3889 	and a,(MASK,sp)
      00161D 18 01            [ 1] 3890 	xor a,(XMASK,sp)
      00161F 27 F9            [ 1] 3891 	jreq 2$ 
      001621                       3892 	_drop VSIZE 
      001621 5B 04            [ 2]    1     addw sp,#VSIZE 
      001623 81               [ 4] 3893 	ret 
                                   3894 
                                   3895 ;---------------------
                                   3896 ; BASIC: BSET addr,mask
                                   3897 ; set bits at 'addr' corresponding 
                                   3898 ; to those of 'mask' that are at 1.
                                   3899 ; arguments:
                                   3900 ; 	addr 		memory address RAM|PERIPHERAL 
                                   3901 ;   mask        mask|addr
                                   3902 ; output:
                                   3903 ;	none 
                                   3904 ;--------------------------
      001624                       3905 bit_set:
      001624 CD 10 16         [ 4] 3906 	call arg_list 
      001627 A1 02            [ 1] 3907 	cp a,#2	 
      001629 27 03            [ 1] 3908 	jreq 1$ 
      00162B CC 08 7B         [ 2] 3909 	jp syntax_error
      00162E                       3910 1$: 
      00162E 85               [ 2] 3911 	popw x ; mask 
      00162F 9F               [ 1] 3912 	ld a,xl 
      001630 85               [ 2] 3913 	popw x ; addr  
      001631 FA               [ 1] 3914 	or a,(x)
      001632 F7               [ 1] 3915 	ld (x),a
      001633 81               [ 4] 3916 	ret 
                                   3917 
                                   3918 ;---------------------
                                   3919 ; BASIC: BRES addr,mask
                                   3920 ; reset bits at 'addr' corresponding 
                                   3921 ; to those of 'mask' that are at 1.
                                   3922 ; arguments:
                                   3923 ; 	addr 		memory address RAM|PERIPHERAL 
                                   3924 ;   mask	    ~mask&*addr  
                                   3925 ; output:
                                   3926 ;	none 
                                   3927 ;--------------------------
      001634                       3928 bit_reset:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 76.
Hexadecimal [24-Bits]



      001634 CD 10 16         [ 4] 3929 	call arg_list 
      001637 A1 02            [ 1] 3930 	cp a,#2  
      001639 27 03            [ 1] 3931 	jreq 1$ 
      00163B CC 08 7B         [ 2] 3932 	jp syntax_error
      00163E                       3933 1$: 
      00163E 85               [ 2] 3934 	popw x ; mask 
      00163F 9F               [ 1] 3935 	ld a,xl 
      001640 43               [ 1] 3936 	cpl a 
      001641 85               [ 2] 3937 	popw x ; addr  
      001642 F4               [ 1] 3938 	and a,(x)
      001643 F7               [ 1] 3939 	ld (x),a 
      001644 81               [ 4] 3940 	ret 
                                   3941 
                                   3942 ;---------------------
                                   3943 ; BASIC: BTOGL addr,mask
                                   3944 ; toggle bits at 'addr' corresponding 
                                   3945 ; to those of 'mask' that are at 1.
                                   3946 ; arguments:
                                   3947 ; 	addr 		memory address RAM|PERIPHERAL 
                                   3948 ;   mask	    mask^*addr  
                                   3949 ; output:
                                   3950 ;	none 
                                   3951 ;--------------------------
      001645                       3952 bit_toggle:
      001645 CD 10 16         [ 4] 3953 	call arg_list 
      001648 A1 02            [ 1] 3954 	cp a,#2 
      00164A 27 03            [ 1] 3955 	jreq 1$ 
      00164C CC 08 7B         [ 2] 3956 	jp syntax_error
      00164F 85               [ 2] 3957 1$: popw x ; mask 
      001650 9F               [ 1] 3958 	ld a,xl 
      001651 85               [ 2] 3959 	popw x ; addr  
      001652 F8               [ 1] 3960 	xor a,(x)
      001653 F7               [ 1] 3961 	ld (x),a 
      001654 81               [ 4] 3962 	ret 
                                   3963 
                                   3964 
                                   3965 ;---------------------
                                   3966 ; BASIC: BTEST(addr,bit)
                                   3967 ; return bit value at 'addr' 
                                   3968 ; bit is in range {0..7}.
                                   3969 ; arguments:
                                   3970 ; 	addr 		memory address RAM|PERIPHERAL 
                                   3971 ;   bit 	    bit position {0..7}  
                                   3972 ; output:
                                   3973 ;	none 
                                   3974 ;--------------------------
      001655                       3975 bit_test:
      001655 CD 10 11         [ 4] 3976 	call func_args 
      001658 A1 02            [ 1] 3977 	cp a,#2
      00165A 27 03            [ 1] 3978 	jreq 0$
      00165C CC 08 7B         [ 2] 3979 	jp syntax_error
      00165F                       3980 0$:	
      00165F 85               [ 2] 3981 	popw x 
      001660 9F               [ 1] 3982 	ld a,xl 
      001661 A4 07            [ 1] 3983 	and a,#7
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 77.
Hexadecimal [24-Bits]



      001663 88               [ 1] 3984 	push a   
      001664 A6 01            [ 1] 3985 	ld a,#1 
      001666 0D 01            [ 1] 3986 1$: tnz (1,sp)
      001668 27 05            [ 1] 3987 	jreq 2$
      00166A 48               [ 1] 3988 	sll a 
      00166B 0A 01            [ 1] 3989 	dec (1,sp)
      00166D 20 F7            [ 2] 3990 	jra 1$
      00166F                       3991 2$: _drop 1 
      00166F 5B 01            [ 2]    1     addw sp,#1 
      001671 85               [ 2] 3992 	popw x 
      001672 F4               [ 1] 3993 	and a,(x)
      001673 27 02            [ 1] 3994 	jreq 3$
      001675 A6 01            [ 1] 3995 	ld a,#1 
      001677 5F               [ 1] 3996 3$:	clrw x 
      001678 97               [ 1] 3997 	ld xl,a 
      001679 A6 84            [ 1] 3998 	ld a,#TK_INTGR
      00167B 81               [ 4] 3999 	ret
                                   4000 
                                   4001 
                                   4002 ;--------------------
                                   4003 ; BASIC: POKE addr,byte
                                   4004 ; put a byte at addr 
                                   4005 ;--------------------
      00167C                       4006 poke:
      00167C CD 10 16         [ 4] 4007 	call arg_list 
      00167F A1 02            [ 1] 4008 	cp a,#2
      001681 27 03            [ 1] 4009 	jreq 1$
      001683 CC 08 7B         [ 2] 4010 	jp syntax_error
      001686                       4011 1$:	
      001686 85               [ 2] 4012 	popw x  
      001687 9F               [ 1] 4013     ld a,xl 
      001688 85               [ 2] 4014 	popw x 
      001689 F7               [ 1] 4015 	ld (x),a 
      00168A 81               [ 4] 4016 	ret 
                                   4017 
                                   4018 ;-----------------------
                                   4019 ; BASIC: PEEK(addr)
                                   4020 ; get the byte at addr 
                                   4021 ; input:
                                   4022 ;	none 
                                   4023 ; output:
                                   4024 ;	X 		value 
                                   4025 ;-----------------------
      00168B                       4026 peek:
      00168B CD 10 11         [ 4] 4027 	call func_args
      00168E A1 01            [ 1] 4028 	cp a,#1 
      001690 27 03            [ 1] 4029 	jreq 1$
      001692 CC 08 7B         [ 2] 4030 	jp syntax_error
      001695 85               [ 2] 4031 1$: popw x 
      001696 F6               [ 1] 4032 	ld a,(x)
      001697 5F               [ 1] 4033 	clrw x 
      001698 97               [ 1] 4034 	ld xl,a 
      001699 A6 84            [ 1] 4035 	ld a,#TK_INTGR
      00169B 81               [ 4] 4036 	ret 
                                   4037 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 78.
Hexadecimal [24-Bits]



                                   4038 ;---------------------------
                                   4039 ; BASIC IF expr : instructions
                                   4040 ; evaluate expr and if true 
                                   4041 ; execute instructions on same line. 
                                   4042 ;----------------------------
      00169C                       4043 if: 
      00169C CD 11 58         [ 4] 4044 	call relation 
      00169F A1 84            [ 1] 4045 	cp a,#TK_INTGR
      0016A1 27 03            [ 1] 4046 	jreq 1$ 
      0016A3 CC 08 7B         [ 2] 4047 	jp syntax_error
      0016A6 4F               [ 1] 4048 1$:	clr a 
      0016A7 5D               [ 2] 4049 	tnzw x 
      0016A8 26 05            [ 1] 4050 	jrne 9$  
                                   4051 ;skip to next line
      0016AA 55 00 03 00 01   [ 1] 4052 	mov in,count
      0016AF 81               [ 4] 4053 9$:	ret 
                                   4054 
                                   4055 ;------------------------
                                   4056 ; BASIC: FOR var=expr 
                                   4057 ; set variable to expression 
                                   4058 ; leave variable address 
                                   4059 ; on stack and set
                                   4060 ; FLOOP bit in 'flags'
                                   4061 ;-----------------
                           000001  4062 	RETL1=1 ; return address  
                           000003  4063 	FSTEP=3  ; variable increment
                           000005  4064 	LIMIT=5 ; loop limit 
                           000007  4065 	CVAR=7   ; control variable 
                           000009  4066 	INW=9   ;  in.w saved
                           00000B  4067 	BPTR=11 ; baseptr saved
                           00000A  4068 	VSIZE=10  
      0016B0                       4069 for: ; { -- var_addr }
      0016B0 85               [ 2] 4070 	popw x ; call return address 
      0016B1                       4071 	_vars VSIZE 
      0016B1 52 0A            [ 2]    1     sub sp,#VSIZE 
      0016B3 89               [ 2] 4072 	pushw x  ; RETL1 
      0016B4 A6 85            [ 1] 4073 	ld a,#TK_VAR 
      0016B6 CD 10 04         [ 4] 4074 	call expect
      0016B9 1F 07            [ 2] 4075 	ldw (CVAR,sp),x  ; control variable 
      0016BB CD 12 3B         [ 4] 4076 	call let_var 
      0016BE 72 14 00 23      [ 1] 4077 	bset flags,#FLOOP 
                                   4078 ; open space on stack for loop data 
      0016C2 5F               [ 1] 4079 	clrw x 
      0016C3 1F 0B            [ 2] 4080 	ldw (BPTR,sp),x 
      0016C5 1F 09            [ 2] 4081 	ldw (INW,sp),x 
      0016C7 CD 09 6D         [ 4] 4082 	call next_token 
      0016CA A1 80            [ 1] 4083 	cp a,#TK_CMD 
      0016CC 27 03            [ 1] 4084 	jreq 1$
      0016CE CC 08 7B         [ 2] 4085 	jp syntax_error
      0016D1                       4086 1$:  
      0016D1 A3 16 D9         [ 2] 4087 	cpw x,#to 
      0016D4 27 03            [ 1] 4088 	jreq to
      0016D6 CC 08 7B         [ 2] 4089 	jp syntax_error 
                                   4090 
                                   4091 ;-----------------------------------
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 79.
Hexadecimal [24-Bits]



                                   4092 ; BASIC: TO expr 
                                   4093 ; second part of FOR loop initilization
                                   4094 ; leave limit on stack and set 
                                   4095 ; FTO bit in 'flags'
                                   4096 ;-----------------------------------
      0016D9                       4097 to: ; { var_addr -- var_addr limit step }
      0016D9 72 04 00 23 03   [ 2] 4098 	btjt flags,#FLOOP,1$
      0016DE CC 08 7B         [ 2] 4099 	jp syntax_error
      0016E1 CD 11 58         [ 4] 4100 1$: call relation  
      0016E4 A1 84            [ 1] 4101 	cp a,#TK_INTGR 
      0016E6 27 03            [ 1] 4102 	jreq 2$ 
      0016E8 CC 08 7B         [ 2] 4103 	jp syntax_error
      0016EB 1F 05            [ 2] 4104 2$: ldw (LIMIT,sp),x
                                   4105 ;	ldw x,in.w 
      0016ED CD 09 6D         [ 4] 4106 	call next_token
      0016F0 A1 00            [ 1] 4107 	cp a,#TK_NONE  
      0016F2 27 0E            [ 1] 4108 	jreq 4$ 
      0016F4 A1 80            [ 1] 4109 	cp a,#TK_CMD
      0016F6 26 05            [ 1] 4110 	jrne 3$
      0016F8 A3 17 09         [ 2] 4111 	cpw x,#step 
      0016FB 27 0C            [ 1] 4112 	jreq step
      0016FD                       4113 3$:	
      0016FD                       4114 	_unget_token   	 
      0016FD 55 00 02 00 01   [ 1]    1     mov in,in.saved
      001702                       4115 4$:	
      001702 AE 00 01         [ 2] 4116 	ldw x,#1   ; default step  
      001705 1F 03            [ 2] 4117 	ldw (FSTEP,sp),x 
      001707 20 14            [ 2] 4118 	jra store_loop_addr 
                                   4119 
                                   4120 
                                   4121 ;----------------------------------
                                   4122 ; BASIC: STEP expr 
                                   4123 ; optional third par of FOR loop
                                   4124 ; initialization. 	
                                   4125 ;------------------------------------
      001709                       4126 step: ; {var limit -- var limit step}
      001709 72 04 00 23 03   [ 2] 4127 	btjt flags,#FLOOP,1$
      00170E CC 08 7B         [ 2] 4128 	jp syntax_error
      001711 CD 11 58         [ 4] 4129 1$: call relation
      001714 A1 84            [ 1] 4130 	cp a,#TK_INTGR
      001716 27 03            [ 1] 4131 	jreq 2$
      001718 CC 08 7B         [ 2] 4132 	jp syntax_error
      00171B 1F 03            [ 2] 4133 2$:	ldw (FSTEP,sp),x ; step
                                   4134 ; leave loop back entry point on cstack 
                                   4135 ; cstack is 1 call deep from interpreter
      00171D                       4136 store_loop_addr:
      00171D CE 00 04         [ 2] 4137 	ldw x,basicptr  
      001720 1F 0B            [ 2] 4138 	ldw (BPTR,sp),x 
      001722 CE 00 00         [ 2] 4139 	ldw x,in.w 
      001725 1F 09            [ 2] 4140 	ldw (INW,sp),x   
      001727 72 15 00 23      [ 1] 4141 	bres flags,#FLOOP 
      00172B 72 5C 00 20      [ 1] 4142 	inc loop_depth  
      00172F 81               [ 4] 4143 	ret 
                                   4144 
                                   4145 ;--------------------------------
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 80.
Hexadecimal [24-Bits]



                                   4146 ; BASIC: NEXT var 
                                   4147 ; FOR loop control 
                                   4148 ; increment variable with step 
                                   4149 ; and compare with limit 
                                   4150 ; loop if threshold not crossed.
                                   4151 ; else stack. 
                                   4152 ; and decrement 'loop_depth' 
                                   4153 ;--------------------------------
      001730                       4154 next: ; {var limit step retl1 -- [var limit step ] }
      001730 72 5D 00 20      [ 1] 4155 	tnz loop_depth 
      001734 26 03            [ 1] 4156 	jrne 1$ 
      001736 CC 08 7B         [ 2] 4157 	jp syntax_error 
      001739                       4158 1$: 
      001739 A6 85            [ 1] 4159 	ld a,#TK_VAR 
      00173B CD 10 04         [ 4] 4160 	call expect
                                   4161 ; check for good variable after NEXT 	 
      00173E 13 07            [ 2] 4162 	cpw x,(CVAR,sp)
      001740 27 03            [ 1] 4163 	jreq 2$  
      001742 CC 08 7B         [ 2] 4164 	jp syntax_error ; not the good one 
      001745                       4165 2$: ; increment variable 
      001745 FE               [ 2] 4166 	ldw x,(x)  ; get var value 
      001746 72 FB 03         [ 2] 4167 	addw x,(FSTEP,sp) ; var+step 
      001749 16 07            [ 2] 4168 	ldw y,(CVAR,sp)
      00174B 90 FF            [ 2] 4169 	ldw (y),x ; save var new value 
                                   4170 ; check sign of STEP  
      00174D A6 80            [ 1] 4171 	ld a,#0x80
      00174F 15 03            [ 1] 4172 	bcp a,(FSTEP,sp)
      001751 2A 06            [ 1] 4173 	jrpl 4$
                                   4174 ;negative step 
      001753 13 05            [ 2] 4175 	cpw x,(LIMIT,sp)
      001755 2F 1B            [ 1] 4176 	jrslt loop_done
      001757 20 04            [ 2] 4177 	jra loop_back 
      001759                       4178 4$: ; positive step
      001759 13 05            [ 2] 4179 	cpw x,(LIMIT,sp)
      00175B 2C 15            [ 1] 4180 	jrsgt loop_done
      00175D                       4181 loop_back:
      00175D 1E 0B            [ 2] 4182 	ldw x,(BPTR,sp)
      00175F CF 00 04         [ 2] 4183 	ldw basicptr,x 
      001762 72 01 00 23 05   [ 2] 4184 	btjf flags,#FRUN,1$ 
      001767 E6 02            [ 1] 4185 	ld a,(2,x)
      001769 C7 00 03         [ 1] 4186 	ld count,a
      00176C 1E 09            [ 2] 4187 1$:	ldw x,(INW,sp)
      00176E CF 00 00         [ 2] 4188 	ldw in.w,x 
      001771 81               [ 4] 4189 	ret 
      001772                       4190 loop_done:
                                   4191 	; remove loop data from stack  
      001772 85               [ 2] 4192 	popw x
      001773                       4193 	_drop VSIZE 
      001773 5B 0A            [ 2]    1     addw sp,#VSIZE 
      001775 72 5A 00 20      [ 1] 4194 	dec loop_depth 
                                   4195 ;	pushw x 
                                   4196 ;	ret 
      001779 FC               [ 2] 4197 	jp (x)
                                   4198 
                                   4199 ;----------------------------
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 81.
Hexadecimal [24-Bits]



                                   4200 ; called by goto/gosub
                                   4201 ; to get target line number 
                                   4202 ;---------------------------
      00177A                       4203 get_target_line:
      00177A CD 11 58         [ 4] 4204 	call relation 
      00177D A1 84            [ 1] 4205 	cp a,#TK_INTGR
      00177F 27 03            [ 1] 4206 	jreq 1$
      001781 CC 08 7B         [ 2] 4207 	jp syntax_error
      001784 CD 04 04         [ 4] 4208 1$:	call search_lineno  
      001787 5D               [ 2] 4209 	tnzw x 
      001788 26 05            [ 1] 4210 	jrne 2$ 
      00178A A6 05            [ 1] 4211 	ld a,#ERR_NO_LINE 
      00178C CC 08 7D         [ 2] 4212 	jp tb_error 
      00178F 81               [ 4] 4213 2$:	ret 
                                   4214 
                                   4215 ;------------------------
                                   4216 ; BASIC: GOTO line# 
                                   4217 ; jump to line# 
                                   4218 ; here cstack is 2 call deep from interpreter 
                                   4219 ;------------------------
      001790                       4220 goto:
      001790 72 00 00 23 06   [ 2] 4221 	btjt flags,#FRUN,0$ 
      001795 A6 06            [ 1] 4222 	ld a,#ERR_RUN_ONLY
      001797 CC 08 7D         [ 2] 4223 	jp tb_error 
      00179A 81               [ 4] 4224 	ret 
      00179B CD 17 7A         [ 4] 4225 0$:	call get_target_line
      00179E                       4226 jp_to_target:
      00179E CF 00 04         [ 2] 4227 	ldw basicptr,x 
      0017A1 E6 02            [ 1] 4228 	ld a,(2,x)
      0017A3 C7 00 03         [ 1] 4229 	ld count,a 
      0017A6 35 03 00 01      [ 1] 4230 	mov in,#3 
      0017AA 81               [ 4] 4231 	ret 
                                   4232 
                                   4233 
                                   4234 ;--------------------
                                   4235 ; BASIC: GOSUB line#
                                   4236 ; basic subroutine call
                                   4237 ; actual line# and basicptr 
                                   4238 ; are saved on cstack
                                   4239 ; here cstack is 2 call deep from interpreter 
                                   4240 ;--------------------
                           000003  4241 	RET_ADDR=3
                           000005  4242 	RET_INW=5
                           000004  4243 	VSIZE=4  
      0017AB                       4244 gosub:
      0017AB 72 00 00 23 06   [ 2] 4245 	btjt flags,#FRUN,0$ 
      0017B0 A6 06            [ 1] 4246 	ld a,#ERR_RUN_ONLY
      0017B2 CC 08 7D         [ 2] 4247 	jp tb_error 
      0017B5 81               [ 4] 4248 	ret 
      0017B6 85               [ 2] 4249 0$:	popw x 
      0017B7                       4250 	_vars VSIZE  
      0017B7 52 04            [ 2]    1     sub sp,#VSIZE 
      0017B9 89               [ 2] 4251 	pushw x 
      0017BA CE 00 04         [ 2] 4252 	ldw x,basicptr
      0017BD 1F 03            [ 2] 4253 	ldw (RET_ADDR,sp),x 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 82.
Hexadecimal [24-Bits]



      0017BF CD 17 7A         [ 4] 4254 	call get_target_line  
      0017C2 89               [ 2] 4255 	pushw x 
      0017C3 CE 00 00         [ 2] 4256 	ldw x,in.w 
      0017C6 1F 07            [ 2] 4257 	ldw (RET_INW+2,sp),x
      0017C8 85               [ 2] 4258 	popw x 
      0017C9 20 D3            [ 2] 4259 	jra jp_to_target
                                   4260 
                                   4261 ;------------------------
                                   4262 ; BASIC: RETURN 
                                   4263 ; exit from a subroutine 
                                   4264 ; 
                                   4265 ;------------------------
      0017CB                       4266 return:
      0017CB 72 00 00 23 05   [ 2] 4267 	btjt flags,#FRUN,0$ 
      0017D0 A6 06            [ 1] 4268 	ld a,#ERR_RUN_ONLY
      0017D2 CC 08 7D         [ 2] 4269 	jp tb_error 
      0017D5                       4270 0$:	
      0017D5 1E 03            [ 2] 4271 	ldw x,(RET_ADDR,sp) 
      0017D7 CF 00 04         [ 2] 4272 	ldw basicptr,x
      0017DA E6 02            [ 1] 4273 	ld a,(2,x)
      0017DC C7 00 03         [ 1] 4274 	ld count,a  
      0017DF 1E 05            [ 2] 4275 	ldw x,(RET_INW,sp)
      0017E1 CF 00 00         [ 2] 4276 	ldw in.w,x 
      0017E4 85               [ 2] 4277 	popw x 
      0017E5                       4278 	_drop VSIZE 
      0017E5 5B 04            [ 2]    1     addw sp,#VSIZE 
      0017E7 89               [ 2] 4279 	pushw x
      0017E8 81               [ 4] 4280 	ret  
                                   4281 
                                   4282 
                                   4283 ;----------------------------------
                                   4284 ; BASIC: RUN
                                   4285 ; run BASIC program in RAM
                                   4286 ;----------------------------------- 
      0017E9                       4287 run: 
      0017E9 72 01 00 23 02   [ 2] 4288 	btjf flags,#FRUN,0$  
      0017EE 4F               [ 1] 4289 	clr a 
      0017EF 81               [ 4] 4290 	ret
      0017F0                       4291 0$: 
      0017F0 72 09 00 23 12   [ 2] 4292 	btjf flags,#FBREAK,1$
      0017F5                       4293 	_drop 2 
      0017F5 5B 02            [ 2]    1     addw sp,#2 
      0017F7 CD 15 7D         [ 4] 4294 	call rest_context
      0017FA                       4295 	_drop CTXT_SIZE 
      0017FA 5B 04            [ 2]    1     addw sp,#CTXT_SIZE 
      0017FC 72 19 00 23      [ 1] 4296 	bres flags,#FBREAK 
      001800 72 10 00 23      [ 1] 4297 	bset flags,#FRUN 
      001804 CC 09 21         [ 2] 4298 	jp interpreter 
      001807 CE 00 1C         [ 2] 4299 1$:	ldw x,txtbgn
      00180A C3 00 1E         [ 2] 4300 	cpw x,txtend 
      00180D 2B 0C            [ 1] 4301 	jrmi run_it 
      00180F AE 08 16         [ 2] 4302 	ldw x,#err_no_prog
      001812 CD 00 00         [ 4] 4303 	call puts 
      001815 55 00 03 00 01   [ 1] 4304 	mov in,count
      00181A 81               [ 4] 4305 	ret 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 83.
Hexadecimal [24-Bits]



      00181B                       4306 run_it:	 
      00181B CD 12 08         [ 4] 4307     call ubound 
      00181E                       4308 	_drop 2 ; drop return address 
      00181E 5B 02            [ 2]    1     addw sp,#2 
                                   4309 ; clear data pointer 
      001820 5F               [ 1] 4310 	clrw x 
      001821 CF 00 06         [ 2] 4311 	ldw data_ptr,x 
      001824 72 5F 00 08      [ 1] 4312 	clr data_ofs 
      001828 72 5F 00 09      [ 1] 4313 	clr data_len 
                                   4314 ; initialize BASIC pointer 
      00182C CE 00 1C         [ 2] 4315 	ldw x,txtbgn 
      00182F CF 00 04         [ 2] 4316 	ldw basicptr,x 
      001832 E6 02            [ 1] 4317 	ld a,(2,x)
      001834 C7 00 03         [ 1] 4318 	ld count,a
      001837 35 03 00 01      [ 1] 4319 	mov in,#3	
      00183B 72 10 00 23      [ 1] 4320 	bset flags,#FRUN 
      00183F CC 09 21         [ 2] 4321 	jp interpreter 
                                   4322 
                                   4323 
                                   4324 ;----------------------
                                   4325 ; BASIC: END
                                   4326 ; end running program
                                   4327 ;---------------------- 
      001842                       4328 cmd_end: 
                                   4329 ; clean stack 
      001842 AE 17 FF         [ 2] 4330 	ldw x,#STACK_EMPTY
      001845 94               [ 1] 4331 	ldw sp,x 
      001846 CC 09 02         [ 2] 4332 	jp warm_start
                                   4333 
                                   4334 ;-----------------
                                   4335 ; 1 Khz beep 
                                   4336 ;-----------------
      001849                       4337 beep_1khz:: 
      001849 AE 00 64         [ 2] 4338 	ldw x,#100
      00184C 90 AE 03 E8      [ 2] 4339 	ldw y,#1000
      001850 20 0D            [ 2] 4340 	jra beep
                                   4341 
                                   4342 ;-----------------------
                                   4343 ; BASIC: TONE expr1,expr2
                                   4344 ; used TIMER2 channel 1
                                   4345 ; to produce a tone 
                                   4346 ; arguments:
                                   4347 ;    expr1   frequency 
                                   4348 ;    expr2   duration msec.
                                   4349 ;---------------------------
      001852                       4350 tone:
      001852 CD 10 16         [ 4] 4351 	call arg_list 
      001855 A1 02            [ 1] 4352 	cp a,#2 
      001857 27 03            [ 1] 4353 	jreq 1$
      001859 CC 08 7B         [ 2] 4354 	jp syntax_error 
      00185C                       4355 1$: 
      00185C 85               [ 2] 4356 	popw x ; duration
      00185D 90 85            [ 2] 4357 	popw y ; frequency 
      00185F                       4358 beep:  
      00185F 89               [ 2] 4359 	pushw x 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 84.
Hexadecimal [24-Bits]



      001860 AE F4 24         [ 2] 4360 	ldw x,#TIM2_CLK_FREQ
      001863 65               [ 2] 4361 	divw x,y 
                                   4362 ; round to nearest integer 
      001864 90 A3 7A 12      [ 2] 4363 	cpw y,#TIM2_CLK_FREQ/2
      001868 2B 01            [ 1] 4364 	jrmi 2$
      00186A 5C               [ 2] 4365 	incw x 
      00186B                       4366 2$:	 
      00186B 9E               [ 1] 4367 	ld a,xh 
      00186C C7 53 0D         [ 1] 4368 	ld TIM2_ARRH,a 
      00186F 9F               [ 1] 4369 	ld a,xl 
      001870 C7 53 0E         [ 1] 4370 	ld TIM2_ARRL,a 
                                   4371 ; 50% duty cycle 
      001873 8C               [ 1] 4372 	ccf 
      001874 56               [ 2] 4373 	rrcw x 
      001875 9E               [ 1] 4374 	ld a,xh 
      001876 C7 53 0F         [ 1] 4375 	ld TIM2_CCR1H,a 
      001879 9F               [ 1] 4376 	ld a,xl
      00187A C7 53 10         [ 1] 4377 	ld TIM2_CCR1L,a
      00187D 72 10 53 08      [ 1] 4378 	bset TIM2_CCER1,#TIM2_CCER1_CC1E
      001881 72 10 53 00      [ 1] 4379 	bset TIM2_CR1,#TIM2_CR1_CEN
      001885 72 10 53 04      [ 1] 4380 	bset TIM2_EGR,#TIM2_EGR_UG
      001889 85               [ 2] 4381 	popw x 
      00188A CD 1E 02         [ 4] 4382 	call pause02
      00188D 72 11 53 08      [ 1] 4383 	bres TIM2_CCER1,#TIM2_CCER1_CC1E
      001891 72 11 53 00      [ 1] 4384 	bres TIM2_CR1,#TIM2_CR1_CEN 
      001895 81               [ 4] 4385 	ret 
                                   4386 
                                   4387 ;-------------------------------
                                   4388 ; BASIC: ADCON 0|1 [,divisor]  
                                   4389 ; disable/enanble ADC 
                                   4390 ;-------------------------------
                           000003  4391 	ONOFF=3 
                           000001  4392 	DIVSOR=1
                           000004  4393 	VSIZE=4 
      001896                       4394 power_adc:
      001896 CD 10 16         [ 4] 4395 	call arg_list 
      001899 A1 02            [ 1] 4396 	cp a,#2	
      00189B 27 0B            [ 1] 4397 	jreq 1$
      00189D A1 01            [ 1] 4398 	cp a,#1 
      00189F 27 03            [ 1] 4399 	jreq 0$ 
      0018A1 CC 08 7B         [ 2] 4400 	jp syntax_error 
      0018A4 AE 00 00         [ 2] 4401 0$: ldw x,#0
      0018A7 89               [ 2] 4402 	pushw x  ; divisor 
      0018A8 1E 03            [ 2] 4403 1$: ldw x,(ONOFF,sp)
      0018AA 5D               [ 2] 4404 	tnzw x 
      0018AB 27 1A            [ 1] 4405 	jreq 2$ 
      0018AD 1E 01            [ 2] 4406 	ldw x,(DIVSOR,sp) ; divisor 
      0018AF 9F               [ 1] 4407 	ld a,xl
      0018B0 A4 07            [ 1] 4408 	and a,#7
      0018B2 4E               [ 1] 4409 	swap a 
      0018B3 C7 54 01         [ 1] 4410 	ld ADC_CR1,a
      0018B6 72 16 50 CA      [ 1] 4411 	bset CLK_PCKENR2,#CLK_PCKENR2_ADC
      0018BA 72 10 54 01      [ 1] 4412 	bset ADC_CR1,#ADC_CR1_ADON 
      0018BE                       4413 	_usec_dly 7 
      0018BE AE 00 1B         [ 2]    1     ldw x,#(16*7-2)/4
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 85.
Hexadecimal [24-Bits]



      0018C1 5A               [ 2]    2     decw x
      0018C2 9D               [ 1]    3     nop 
      0018C3 26 FA            [ 1]    4     jrne .-4
      0018C5 20 08            [ 2] 4414 	jra 3$
      0018C7 72 11 54 01      [ 1] 4415 2$: bres ADC_CR1,#ADC_CR1_ADON
      0018CB 72 17 50 CA      [ 1] 4416 	bres CLK_PCKENR2,#CLK_PCKENR2_ADC
      0018CF                       4417 3$:	_drop VSIZE 
      0018CF 5B 04            [ 2]    1     addw sp,#VSIZE 
      0018D1 81               [ 4] 4418 	ret
                                   4419 
                                   4420 ;-----------------------------
                                   4421 ; BASIC: ADCREAD (channel)
                                   4422 ; read adc channel {0..5}
                                   4423 ; output:
                                   4424 ;   A 		TK_INTGR 
                                   4425 ;   X 		value 
                                   4426 ;-----------------------------
      0018D2                       4427 analog_read:
      0018D2 CD 10 11         [ 4] 4428 	call func_args 
      0018D5 A1 01            [ 1] 4429 	cp a,#1 
      0018D7 27 03            [ 1] 4430 	jreq 1$
      0018D9 CC 08 7B         [ 2] 4431 	jp syntax_error
      0018DC 85               [ 2] 4432 1$: popw x 
      0018DD A3 00 05         [ 2] 4433 	cpw x,#5 
      0018E0 23 05            [ 2] 4434 	jrule 2$
      0018E2 A6 0A            [ 1] 4435 	ld a,#ERR_BAD_VALUE
      0018E4 CC 08 7D         [ 2] 4436 	jp tb_error 
      0018E7 9F               [ 1] 4437 2$: ld a,xl
      0018E8 C7 00 0D         [ 1] 4438 	ld acc8,a 
      0018EB A6 05            [ 1] 4439 	ld a,#5
      0018ED C0 00 0D         [ 1] 4440 	sub a,acc8 
      0018F0 C7 54 00         [ 1] 4441 	ld ADC_CSR,a
      0018F3 72 16 54 02      [ 1] 4442 	bset ADC_CR2,#ADC_CR2_ALIGN
      0018F7 72 10 54 01      [ 1] 4443 	bset ADC_CR1,#ADC_CR1_ADON
      0018FB 72 0F 54 00 FB   [ 2] 4444 	btjf ADC_CSR,#ADC_CSR_EOC,.
      001900 CE 54 04         [ 2] 4445 	ldw x,ADC_DRH
      001903 A6 84            [ 1] 4446 	ld a,#TK_INTGR
      001905 81               [ 4] 4447 	ret 
                                   4448 
                                   4449 ;-----------------------
                                   4450 ; BASIC: DREAD(pin)
                                   4451 ; Arduino pins 
                                   4452 ; read state of a digital pin 
                                   4453 ; pin# {0..15}
                                   4454 ; output:
                                   4455 ;    A 		TK_INTGR
                                   4456 ;    X      0|1 
                                   4457 ;-------------------------
                           000001  4458 	PINNO=1
                           000001  4459 	VSIZE=1
      001906                       4460 digital_read:
      001906                       4461 	_vars VSIZE 
      001906 52 01            [ 2]    1     sub sp,#VSIZE 
      001908 CD 10 11         [ 4] 4462 	call func_args
      00190B A1 01            [ 1] 4463 	cp a,#1
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 86.
Hexadecimal [24-Bits]



      00190D 27 03            [ 1] 4464 	jreq 1$
      00190F CC 08 7B         [ 2] 4465 	jp syntax_error
      001912 85               [ 2] 4466 1$: popw x 
      001913 A3 00 0F         [ 2] 4467 	cpw x,#15 
      001916 23 05            [ 2] 4468 	jrule 2$
      001918 A6 0A            [ 1] 4469 	ld a,#ERR_BAD_VALUE
      00191A CC 08 7D         [ 2] 4470 	jp tb_error 
      00191D CD 1F 35         [ 4] 4471 2$:	call select_pin 
      001920 6B 01            [ 1] 4472 	ld (PINNO,sp),a
      001922 E6 01            [ 1] 4473 	ld a,(GPIO_IDR,x)
      001924 0D 01            [ 1] 4474 	tnz (PINNO,sp)
      001926 27 05            [ 1] 4475 	jreq 8$
      001928 44               [ 1] 4476 3$: srl a 
      001929 0A 01            [ 1] 4477 	dec (PINNO,sp)
      00192B 26 FB            [ 1] 4478 	jrne 3$ 
      00192D A4 01            [ 1] 4479 8$: and a,#1 
      00192F 5F               [ 1] 4480 	clrw x 
      001930 97               [ 1] 4481 	ld xl,a 
      001931 A6 84            [ 1] 4482 	ld a,#TK_INTGR
      001933                       4483 	_drop VSIZE
      001933 5B 01            [ 2]    1     addw sp,#VSIZE 
      001935 81               [ 4] 4484 	ret
                                   4485 
                                   4486 ;-----------------------
                                   4487 ; BASIC: DWRITE pin,0|1
                                   4488 ; Arduino pins 
                                   4489 ; write to a digital pin 
                                   4490 ; pin# {0..15}
                                   4491 ; output:
                                   4492 ;    A 		TK_INTGR
                                   4493 ;    X      0|1 
                                   4494 ;-------------------------
                           000001  4495 	PINNO=1
                           000002  4496 	PINVAL=2
                           000002  4497 	VSIZE=2
      001936                       4498 digital_write:
      001936                       4499 	_vars VSIZE 
      001936 52 02            [ 2]    1     sub sp,#VSIZE 
      001938 CD 10 16         [ 4] 4500 	call arg_list  
      00193B A1 02            [ 1] 4501 	cp a,#2 
      00193D 27 03            [ 1] 4502 	jreq 1$
      00193F CC 08 7B         [ 2] 4503 	jp syntax_error
      001942 85               [ 2] 4504 1$: popw x 
      001943 9F               [ 1] 4505 	ld a,xl 
      001944 6B 02            [ 1] 4506 	ld (PINVAL,sp),a
      001946 85               [ 2] 4507 	popw x 
      001947 A3 00 0F         [ 2] 4508 	cpw x,#15 
      00194A 23 05            [ 2] 4509 	jrule 2$
      00194C A6 0A            [ 1] 4510 	ld a,#ERR_BAD_VALUE
      00194E CC 08 7D         [ 2] 4511 	jp tb_error 
      001951 CD 1F 35         [ 4] 4512 2$:	call select_pin 
      001954 6B 01            [ 1] 4513 	ld (PINNO,sp),a 
      001956 A6 01            [ 1] 4514 	ld a,#1
      001958 0D 01            [ 1] 4515 	tnz (PINNO,sp)
      00195A 27 05            [ 1] 4516 	jreq 4$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 87.
Hexadecimal [24-Bits]



      00195C 48               [ 1] 4517 3$: sll a
      00195D 0A 01            [ 1] 4518 	dec (PINNO,sp)
      00195F 26 FB            [ 1] 4519 	jrne 3$
      001961 0D 02            [ 1] 4520 4$: tnz (PINVAL,sp)
      001963 26 05            [ 1] 4521 	jrne 5$
      001965 43               [ 1] 4522 	cpl a 
      001966 E4 00            [ 1] 4523 	and a,(GPIO_ODR,x)
      001968 20 02            [ 2] 4524 	jra 8$
      00196A EA 00            [ 1] 4525 5$: or a,(GPIO_ODR,x)
      00196C E7 00            [ 1] 4526 8$: ld (GPIO_ODR,x),a 
      00196E                       4527 	_drop VSIZE 
      00196E 5B 02            [ 2]    1     addw sp,#VSIZE 
      001970 81               [ 4] 4528 	ret
                                   4529 
                                   4530 
                                   4531 ;-----------------------
                                   4532 ; BASIC: STOP
                                   4533 ; stop progam execution  
                                   4534 ; without resetting pointers 
                                   4535 ; the program is resumed
                                   4536 ; with RUN 
                                   4537 ;-------------------------
      001971                       4538 stop:
      001971 72 00 00 23 02   [ 2] 4539 	btjt flags,#FRUN,2$
      001976 4F               [ 1] 4540 	clr a
      001977 81               [ 4] 4541 	ret 
      001978                       4542 2$:	 
                                   4543 ; create space on cstack to save context 
      001978 AE 19 9F         [ 2] 4544 	ldw x,#break_point 
      00197B CD 00 00         [ 4] 4545 	call puts 
      00197E                       4546 	_drop 2 ;drop return address 
      00197E 5B 02            [ 2]    1     addw sp,#2 
      001980                       4547 	_vars CTXT_SIZE ; context size 
      001980 52 04            [ 2]    1     sub sp,#CTXT_SIZE 
      001982 CD 15 6D         [ 4] 4548 	call save_context 
      001985 AE 16 90         [ 2] 4549 	ldw x,#tib 
      001988 CF 00 04         [ 2] 4550 	ldw basicptr,x
      00198B 7F               [ 1] 4551 	clr (x)
      00198C 72 5F 00 03      [ 1] 4552 	clr count  
      001990 5F               [ 1] 4553 	clrw x 
      001991 CF 00 00         [ 2] 4554 	ldw in.w,x
      001994 72 11 00 23      [ 1] 4555 	bres flags,#FRUN 
      001998 72 18 00 23      [ 1] 4556 	bset flags,#FBREAK
      00199C CC 09 21         [ 2] 4557 	jp interpreter 
      00199F 0A 62 72 65 61 6B 20  4558 break_point: .asciz "\nbreak point, RUN to resume.\n"
             70 6F 69 6E 74 2C 20
             52 55 4E 20 74 6F 20
             72 65 73 75 6D 65 2E
             0A 00
                                   4559 
                                   4560 ;-----------------------
                                   4561 ; BASIC: NEW
                                   4562 ; from command line only 
                                   4563 ; free program memory
                                   4564 ; and clear variables 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 88.
Hexadecimal [24-Bits]



                                   4565 ;------------------------
      0019BD                       4566 new: 
      0019BD 72 01 00 23 01   [ 2] 4567 	btjf flags,#FRUN,0$ 
      0019C2 81               [ 4] 4568 	ret 
      0019C3                       4569 0$:	
      0019C3 CD 06 E7         [ 4] 4570 	call clear_basic 
      0019C6 81               [ 4] 4571 	ret 
                                   4572 	 
                                   4573 ;;;;;;;;;;;;;;;;;;;;;;;;;
                                   4574 ;  file system routines
                                   4575 ;  MCU flash memory from
                                   4576 ;  0x10000-0x27fff is 
                                   4577 ;  used to store BASIC 
                                   4578 ;  program files. 
                                   4579 ;  use 128 bytes sectors
                                   4580 ;  because this is the MCU 
                                   4581 ;  row size.
                                   4582 ;  file entry aligned to row
                                   4583 ;  	name  variable length
                                   4584 ;  	size  2 bytes  
                                   4585 ; 	data  variable length 
                                   4586 ;;;;;;;;;;;;;;;;;;;;;;;;;
                                   4587 
                                   4588 ;---------------------------
                                   4589 ; fill pad with zeros 
                                   4590 ;--------------------------
      0019C7                       4591 zero_pad:
      0019C7 AE 16 E0         [ 2] 4592 	ldw x,#pad 
      0019CA A6 80            [ 1] 4593 	ld a,#PAD_SIZE 
      0019CC 7F               [ 1] 4594 1$:	clr (x)
      0019CD 5C               [ 2] 4595 	incw x 
      0019CE 4A               [ 1] 4596 	dec a 
      0019CF 26 FB            [ 1] 4597 	jrne 1$
      0019D1 81               [ 4] 4598 	ret 
                                   4599 
                                   4600 ;--------------------------
                                   4601 ; align farptr to BLOCK_SIZE 
                                   4602 ;---------------------------
      0019D2                       4603 row_align:
      0019D2 A6 7F            [ 1] 4604 	ld a,#0x7f 
      0019D4 C4 00 18         [ 1] 4605 	and a,farptr+2 
      0019D7 27 13            [ 1] 4606 	jreq 1$ 
      0019D9 CE 00 17         [ 2] 4607 	ldw x,farptr+1 
      0019DC 1C 00 80         [ 2] 4608 	addw x,#BLOCK_SIZE 
      0019DF 24 04            [ 1] 4609 	jrnc 0$
      0019E1 72 5C 00 16      [ 1] 4610 	inc farptr 
      0019E5 9F               [ 1] 4611 0$: ld a,xl 
      0019E6 A4 80            [ 1] 4612 	and a,#0x80
      0019E8 97               [ 1] 4613 	ld xl,a
      0019E9 CF 00 17         [ 2] 4614 	ldw farptr+1,x  	
      0019EC 81               [ 4] 4615 1$:	ret
                                   4616 
                                   4617 ;--------------------
                                   4618 ; input:
                                   4619 ;   X     increment 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 89.
Hexadecimal [24-Bits]



                                   4620 ; output:
                                   4621 ;   farptr  incremented 
                                   4622 ;---------------------
      0019ED                       4623 incr_farptr:
      0019ED 72 BB 00 17      [ 2] 4624 	addw x,farptr+1 
      0019F1 24 04            [ 1] 4625 	jrnc 1$
      0019F3 72 5C 00 16      [ 1] 4626 	inc farptr 
      0019F7 CF 00 17         [ 2] 4627 1$:	ldw farptr+1,x  
      0019FA 81               [ 4] 4628 	ret 
                                   4629 
                                   4630 ;------------------------------
                                   4631 ; extended flash memory used as FLASH_DRIVE 
                                   4632 ; seek end of used flash drive   
                                   4633 ; starting at 0x10000 address.
                                   4634 ; 4 consecutives 0 bytes signal free space. 
                                   4635 ; input:
                                   4636 ;	none
                                   4637 ; output:
                                   4638 ;   ffree     free_addr| 0 if memory full.
                                   4639 ;------------------------------
      0019FB                       4640 seek_fdrive:
                                   4641 ; start scan at 0x10000 address 
      0019FB A6 01            [ 1] 4642 	ld a,#1
      0019FD C7 00 16         [ 1] 4643 	ld farptr,a 
      001A00 5F               [ 1] 4644 	clrw x 
      001A01 CF 00 17         [ 2] 4645 	ldw farptr+1,x 
      001A04                       4646 1$:
      001A04 AE 00 03         [ 2] 4647 	ldw x,#3  
      001A07 92 AF 00 16      [ 5] 4648 2$:	ldf a,([farptr],x) 
      001A0B 26 05            [ 1] 4649 	jrne 3$
      001A0D 5A               [ 2] 4650 	decw x
      001A0E 2A F7            [ 1] 4651 	jrpl 2$
      001A10 20 0E            [ 2] 4652 	jra 4$ 
      001A12 AE 00 80         [ 2] 4653 3$:	ldw x,#BLOCK_SIZE 
      001A15 CD 19 ED         [ 4] 4654 	call incr_farptr
      001A18 AE 02 80         [ 2] 4655 	ldw x,#0x280  
      001A1B C3 00 16         [ 2] 4656 	cpw x,farptr
      001A1E 2B E4            [ 1] 4657 	jrmi 1$
      001A20                       4658 4$: ; copy farptr to ffree	 
      001A20 CE 00 16         [ 2] 4659 	ldw x,farptr 
      001A23 C6 00 18         [ 1] 4660 	ld a,farptr+2 
      001A26 CF 00 19         [ 2] 4661 	ldw ffree,x 
      001A29 C7 00 1B         [ 1] 4662 	ld ffree+2,a  
      001A2C 81               [ 4] 4663 	ret 
                                   4664 
                                   4665 ;-----------------------
                                   4666 ; return amount of free 
                                   4667 ; space on flash drive
                                   4668 ; input:
                                   4669 ;   none
                                   4670 ; output:
                                   4671 ;   acc24   free space 
                                   4672 ;-----------------------
      001A2D                       4673 disk_free:
      001A2D AE 80 00         [ 2] 4674 	ldw x,#0x8000
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 90.
Hexadecimal [24-Bits]



      001A30 72 B0 00 1A      [ 2] 4675 	subw x,ffree+1
      001A34 A6 02            [ 1] 4676 	ld a,#2
      001A36 C2 00 19         [ 1] 4677 	sbc a,ffree 
      001A39 C7 00 0B         [ 1] 4678 	ld acc24,a 
      001A3C CF 00 0C         [ 2] 4679 	ldw acc16,x 
      001A3F 81               [ 4] 4680 	ret 
                                   4681 
                                   4682 ;-----------------------
                                   4683 ; compare file name 
                                   4684 ; with name pointed by Y  
                                   4685 ; input:
                                   4686 ;   farptr   file name 
                                   4687 ;   Y        target name 
                                   4688 ; output:
                                   4689 ;   farptr 	 at file_name
                                   4690 ;   X 		 farptr[x] point at size field  
                                   4691 ;   Carry    0|1 no match|match  
                                   4692 ;----------------------
      001A40                       4693 cmp_name:
      001A40 5F               [ 1] 4694 	clrw x
      001A41 92 AF 00 16      [ 5] 4695 1$:	ldf a,([farptr],x)
      001A45 90 F1            [ 1] 4696 	cp a,(y)
      001A47 26 08            [ 1] 4697 	jrne 4$
      001A49 4D               [ 1] 4698 	tnz a 
      001A4A 27 12            [ 1] 4699 	jreq 9$ 
      001A4C 5C               [ 2] 4700     incw x 
      001A4D 90 5C            [ 2] 4701 	incw y 
      001A4F 20 F0            [ 2] 4702 	jra 1$
      001A51                       4703 4$: ;no match 
      001A51 4D               [ 1] 4704 	tnz a 
      001A52 27 07            [ 1] 4705 	jreq 5$
      001A54 5C               [ 2] 4706 	incw x 
      001A55 92 AF 00 16      [ 5] 4707 	ldf a,([farptr],x)
      001A59 20 F6            [ 2] 4708 	jra 4$  
      001A5B 5C               [ 2] 4709 5$:	incw x ; farptr[x] point at 'size' field 
      001A5C 98               [ 1] 4710 	rcf 
      001A5D 81               [ 4] 4711 	ret
      001A5E                       4712 9$: ; match  
      001A5E 5C               [ 2] 4713 	incw x  ; farptr[x] at 'size' field 
      001A5F 99               [ 1] 4714 	scf 
      001A60 81               [ 4] 4715 	ret 
                                   4716 
                                   4717 ;-----------------------
                                   4718 ; search file in 
                                   4719 ; flash memory 
                                   4720 ; input:
                                   4721 ;   Y       file name  
                                   4722 ; output:
                                   4723 ;   farptr  addr at name|0
                                   4724 ;   X       offset to size field
                                   4725 ;-----------------------
                           000001  4726 	FSIZE=1
                           000003  4727 	YSAVE=3
                           000004  4728 	VSIZE=4 
      001A61                       4729 search_file: 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 91.
Hexadecimal [24-Bits]



      001A61                       4730 	_vars VSIZE
      001A61 52 04            [ 2]    1     sub sp,#VSIZE 
      001A63 17 03            [ 2] 4731 	ldw (YSAVE,sp),y  
      001A65 5F               [ 1] 4732 	clrw x 
      001A66 CF 00 17         [ 2] 4733 	ldw farptr+1,x 
      001A69 35 01 00 16      [ 1] 4734 	mov farptr,#1
      001A6D                       4735 1$:	
                                   4736 ; check if farptr is after any file 
                                   4737 ; if  0 then so.
      001A6D 92 BC 00 16      [ 5] 4738 	ldf a,[farptr]
      001A71 27 27            [ 1] 4739 	jreq 6$
      001A73 5F               [ 1] 4740 2$: clrw x 	
      001A74 16 03            [ 2] 4741 	ldw y,(YSAVE,sp) 
      001A76 CD 1A 40         [ 4] 4742 	call cmp_name
      001A79 25 2F            [ 1] 4743 	jrc 9$
      001A7B 92 AF 00 16      [ 5] 4744 	ldf a,([farptr],x)
      001A7F 6B 01            [ 1] 4745 	ld (FSIZE,sp),a 
      001A81 5C               [ 2] 4746 	incw x 
      001A82 92 AF 00 16      [ 5] 4747 	ldf a,([farptr],x)
      001A86 6B 02            [ 1] 4748 	ld (FSIZE+1,sp),a 
      001A88 5C               [ 2] 4749 	incw x 
      001A89 72 FB 01         [ 2] 4750 	addw x,(FSIZE,sp) ; skip over file data
      001A8C CD 19 ED         [ 4] 4751 	call incr_farptr
      001A8F CD 19 D2         [ 4] 4752 	call row_align  
      001A92 AE 02 80         [ 2] 4753 	ldw x,#0x280
      001A95 C3 00 16         [ 2] 4754 	cpw x,farptr 
      001A98 2A D3            [ 1] 4755 	jrpl 1$
      001A9A                       4756 6$: ; file not found 
      001A9A 72 5F 00 16      [ 1] 4757 	clr farptr
      001A9E 72 5F 00 17      [ 1] 4758 	clr farptr+1 
      001AA2 72 5F 00 18      [ 1] 4759 	clr farptr+2 
      001AA6                       4760 	_drop VSIZE 
      001AA6 5B 04            [ 2]    1     addw sp,#VSIZE 
      001AA8 98               [ 1] 4761 	rcf
      001AA9 81               [ 4] 4762 	ret
      001AAA                       4763 9$: ; file found  farptr[0] at 'name_field',farptr[x] at 'file_size' 
      001AAA                       4764 	_drop VSIZE 
      001AAA 5B 04            [ 2]    1     addw sp,#VSIZE 
      001AAC 99               [ 1] 4765 	scf 	
      001AAD 81               [ 4] 4766 	ret
                                   4767 
                                   4768 ;--------------------------------
                                   4769 ; BASIC: SAVE "name" 
                                   4770 ; save text program in 
                                   4771 ; flash memory used as permanent
                                   4772 ; storage from address 0x10000-0x27fff 
                                   4773 ;--------------------------------
                           000001  4774 	BSIZE=1
                           000003  4775 	NAMEPTR=3
                           000005  4776 	XSAVE=5
                           000007  4777 	YSAVE=7
                           000008  4778 	VSIZE=8 
      001AAE                       4779 save:
      001AAE 72 01 00 23 05   [ 2] 4780 	btjf flags,#FRUN,0$ 
      001AB3 A6 07            [ 1] 4781 	ld a,#ERR_CMD_ONLY 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 92.
Hexadecimal [24-Bits]



      001AB5 CC 08 7D         [ 2] 4782 	jp tb_error
      001AB8                       4783 0$:	 
      001AB8 CE 00 1E         [ 2] 4784 	ldw x,txtend 
      001ABB 72 B0 00 1C      [ 2] 4785 	subw x,txtbgn
      001ABF 26 0C            [ 1] 4786 	jrne 1$
                                   4787 ; nothing to save 
      001AC1 AE 08 16         [ 2] 4788 	ldw x,#err_no_prog 
      001AC4 CD 00 00         [ 4] 4789 	call puts 
      001AC7 55 00 03 00 01   [ 1] 4790 	mov in,count 
      001ACC 81               [ 4] 4791 	ret  	
      001ACD                       4792 1$:	
      001ACD                       4793 	_vars VSIZE 
      001ACD 52 08            [ 2]    1     sub sp,#VSIZE 
      001ACF 1F 01            [ 2] 4794 	ldw (BSIZE,sp),x 
      001AD1 CD 09 6D         [ 4] 4795 	call next_token	
      001AD4 A1 02            [ 1] 4796 	cp a,#TK_QSTR
      001AD6 27 03            [ 1] 4797 	jreq 2$
      001AD8 CC 08 7B         [ 2] 4798 	jp syntax_error
      001ADB                       4799 2$: 
      001ADB 1F 03            [ 2] 4800 	ldw (NAMEPTR,sp),x  
      001ADD CD 01 74         [ 4] 4801 	call move_prg_to_ram ; move flashing program to 'tib' buffer 
                                   4802 ; check if enough free space 
      001AE0 CD 03 96         [ 4] 4803 	call strlen 
      001AE3 1C 00 03         [ 2] 4804 	addw x,#3 
      001AE6 72 FB 01         [ 2] 4805 	addw x,(BSIZE,sp)
      001AE9 4F               [ 1] 4806 	clr a 
      001AEA 72 BB 00 1A      [ 2] 4807 	addw x,ffree+1 
      001AEE C9 00 19         [ 1] 4808 	adc a,ffree 
      001AF1 A1 02            [ 1] 4809 	cp a,#2
      001AF3 2B 0A            [ 1] 4810 	jrmi 21$
      001AF5 A3 80 00         [ 2] 4811 	cpw x,#0x8000
      001AF8 2B 05            [ 1] 4812 	jrmi 21$
      001AFA A6 0E            [ 1] 4813 	ld a,#ERR_NO_FSPACE  
      001AFC CC 08 7D         [ 2] 4814 	jp tb_error
      001AFF                       4815 21$: 
                                   4816 ; check for existing file of that name 
      001AFF 16 03            [ 2] 4817 	ldw y,(NAMEPTR,sp)	
      001B01 CD 1A 61         [ 4] 4818 	call search_file 
      001B04 24 05            [ 1] 4819 	jrnc 3$ 
      001B06 A6 08            [ 1] 4820 	ld a,#ERR_DUPLICATE 
      001B08 CC 08 7D         [ 2] 4821 	jp tb_error 
      001B0B                       4822 3$:	; initialize farptr 
      001B0B CE 00 19         [ 2] 4823 	ldw x,ffree 
      001B0E C6 00 1B         [ 1] 4824 	ld a,ffree+2 
      001B11 CF 00 16         [ 2] 4825 	ldw farptr,x 
      001B14 C7 00 18         [ 1] 4826 	ld farptr+2,a 
                                   4827 ;** write file name to row buffer **	
      001B17 16 03            [ 2] 4828 	ldw y,(NAMEPTR,sp)  
      001B19 AE 16 E0         [ 2] 4829 	ldw x,#pad 
      001B1C CD 03 B4         [ 4] 4830 	call strcpy
      001B1F CD 03 96         [ 4] 4831 	call strlen 
      001B22 5C               [ 2] 4832 	incw  x
      001B23 1C 16 E0         [ 2] 4833 	addw x,#pad 
                                   4834 ; ** write file size to row buffer 
      001B26 16 01            [ 2] 4835 	ldw y,(BSIZE,sp)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 93.
Hexadecimal [24-Bits]



      001B28 FF               [ 2] 4836 	ldw (x),y 
      001B29 1C 00 02         [ 2] 4837 	addw x,#2 
                                   4838 ; ** write file data to row buffer 
      001B2C 90 CE 00 1C      [ 2] 4839 	ldw y,txtbgn 
      001B30 90 F6            [ 1] 4840 6$:	ld a,(y)
      001B32 90 5C            [ 2] 4841 	incw y
      001B34 F7               [ 1] 4842 	ld (x),a 
      001B35 5C               [ 2] 4843 	incw x
      001B36 90 C3 00 1E      [ 2] 4844 	cpw y,txtend 
      001B3A 27 05            [ 1] 4845 	jreq 12$
      001B3C A3 17 60         [ 2] 4846 	cpw x,#stack_full 
      001B3F 2B EF            [ 1] 4847 	jrmi 6$
      001B41                       4848 12$:
      001B41 17 07            [ 2] 4849 	ldw (YSAVE,sp),y 
      001B43                       4850 14$: ; zero buffer end 
      001B43 A3 17 60         [ 2] 4851 	cpw x,#stack_full
      001B46 27 04            [ 1] 4852 	jreq 16$
      001B48 7F               [ 1] 4853 	clr (x)
      001B49 5C               [ 2] 4854 	incw x 
      001B4A 20 F7            [ 2] 4855 	jra 14$
      001B4C                       4856 16$:
      001B4C AE 16 E0         [ 2] 4857 	ldw x,#pad 
      001B4F CD 01 88         [ 4] 4858 	call write_row 
      001B52 AE 00 80         [ 2] 4859 	ldw x,#BLOCK_SIZE 
      001B55 CD 19 ED         [ 4] 4860 	call incr_farptr
      001B58 AE 16 E0         [ 2] 4861 	ldw x,#pad 
      001B5B 16 07            [ 2] 4862 	ldw y,(YSAVE,sp)
      001B5D 90 C3 00 1E      [ 2] 4863 	cpw y,txtend 
      001B61 2B CD            [ 1] 4864 	jrmi 6$
                                   4865 ; save farptr in ffree
      001B63 CE 00 16         [ 2] 4866 	ldw x,farptr 
      001B66 C6 00 18         [ 1] 4867 	ld a,farptr+2 
      001B69 CF 00 19         [ 2] 4868 	ldw ffree,x 
      001B6C C7 00 1B         [ 1] 4869 	ld ffree+2,a
                                   4870 ; print file size 	
      001B6F 1E 01            [ 2] 4871 	ldw x,(BSIZE,sp) 
      001B71 CD 09 CA         [ 4] 4872 	call print_int 
      001B74                       4873 	_drop VSIZE 
      001B74 5B 08            [ 2]    1     addw sp,#VSIZE 
      001B76 81               [ 4] 4874 	ret 
                                   4875 
                                   4876 ;----------------------
                                   4877 ; load file in RAM memory
                                   4878 ; input:
                                   4879 ;    farptr point at file size 
                                   4880 ; output:
                                   4881 ;   y point after BASIC program in RAM.
                                   4882 ;------------------------
      001B77                       4883 load_file:
      001B77 CD 19 ED         [ 4] 4884 	call incr_farptr  
      001B7A CD 06 E7         [ 4] 4885 	call clear_basic  
      001B7D 5F               [ 1] 4886 	clrw x
      001B7E 92 AF 00 16      [ 5] 4887 	ldf a,([farptr],x)
      001B82 90 95            [ 1] 4888 	ld yh,a 
      001B84 5C               [ 2] 4889 	incw x  
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 94.
Hexadecimal [24-Bits]



      001B85 92 AF 00 16      [ 5] 4890 	ldf a,([farptr],x)
      001B89 5C               [ 2] 4891 	incw x 
      001B8A 90 97            [ 1] 4892 	ld yl,a 
      001B8C 72 B9 00 1C      [ 2] 4893 	addw y,txtbgn
      001B90 90 CF 00 1E      [ 2] 4894 	ldw txtend,y
      001B94 90 CE 00 1C      [ 2] 4895 	ldw y,txtbgn
      001B98                       4896 3$:	; load BASIC text 	
      001B98 92 AF 00 16      [ 5] 4897 	ldf a,([farptr],x)
      001B9C 90 F7            [ 1] 4898 	ld (y),a 
      001B9E 5C               [ 2] 4899 	incw x 
      001B9F 90 5C            [ 2] 4900 	incw y 
      001BA1 90 C3 00 1E      [ 2] 4901 	cpw y,txtend 
      001BA5 2B F1            [ 1] 4902 	jrmi 3$
      001BA7 81               [ 4] 4903 	ret 
                                   4904 
                                   4905 ;------------------------
                                   4906 ; BASIC: LOAD "file" 
                                   4907 ; load file to RAM 
                                   4908 ; for execution 
                                   4909 ;------------------------
      001BA8                       4910 load:
      001BA8 72 01 00 23 07   [ 2] 4911 	btjf flags,#FRUN,0$ 
      001BAD 27 05            [ 1] 4912 	jreq 0$ 
      001BAF A6 07            [ 1] 4913 	ld a,#ERR_CMD_ONLY 
      001BB1 CC 08 7D         [ 2] 4914 	jp tb_error 
      001BB4                       4915 0$:	
      001BB4 CD 09 6D         [ 4] 4916 	call next_token 
      001BB7 A1 02            [ 1] 4917 	cp a,#TK_QSTR
      001BB9 27 03            [ 1] 4918 	jreq 1$
      001BBB CC 08 7B         [ 2] 4919 	jp syntax_error 
      001BBE 90 93            [ 1] 4920 1$:	ldw y,x 
      001BC0 CD 1A 61         [ 4] 4921 	call search_file 
      001BC3 25 05            [ 1] 4922 	jrc 2$ 
      001BC5 A6 09            [ 1] 4923 	ld a,#ERR_NOT_FILE
      001BC7 CC 08 7D         [ 2] 4924 	jp tb_error  
      001BCA                       4925 2$:
      001BCA CD 1B 77         [ 4] 4926 	call load_file
                                   4927 ; print loaded size 	 
      001BCD CE 00 1E         [ 2] 4928 	ldw x,txtend 
      001BD0 72 B0 00 1C      [ 2] 4929 	subw x,txtbgn
      001BD4 CD 09 CA         [ 4] 4930 	call print_int 
      001BD7 81               [ 4] 4931 	ret 
                                   4932 
                                   4933 ;-----------------------------------
                                   4934 ; BASIC: FORGET ["file_name"] 
                                   4935 ; erase file_name and all others 
                                   4936 ; after it. 
                                   4937 ; without argument erase all files 
                                   4938 ;-----------------------------------
                           000001  4939 	NEW_FREE=1 
                           000003  4940 	VSIZE=3 
      001BD8                       4941 forget:
      001BD8                       4942 	_vars VSIZE 
      001BD8 52 03            [ 2]    1     sub sp,#VSIZE 
      001BDA CD 09 6D         [ 4] 4943 	call next_token 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 95.
Hexadecimal [24-Bits]



      001BDD A1 00            [ 1] 4944 	cp a,#TK_NONE 
      001BDF 27 20            [ 1] 4945 	jreq 3$ 
      001BE1 A1 02            [ 1] 4946 	cp a,#TK_QSTR
      001BE3 27 03            [ 1] 4947 	jreq 1$
      001BE5 CC 08 7B         [ 2] 4948 	jp syntax_error
      001BE8 90 93            [ 1] 4949 1$: ldw y,x 
      001BEA 55 00 03 00 01   [ 1] 4950 	mov in,count 
      001BEF CD 1A 61         [ 4] 4951 	call search_file
      001BF2 25 05            [ 1] 4952 	jrc 2$
      001BF4 A6 09            [ 1] 4953 	ld a,#ERR_NOT_FILE 
      001BF6 CC 08 7D         [ 2] 4954 	jp tb_error 
      001BF9                       4955 2$: 
      001BF9 CE 00 16         [ 2] 4956 	ldw x,farptr
      001BFC C6 00 18         [ 1] 4957 	ld a,farptr+2
      001BFF 20 0A            [ 2] 4958 	jra 4$ 
      001C01                       4959 3$: ; forget all files 
      001C01 AE 01 00         [ 2] 4960 	ldw x,#0x100
      001C04 4F               [ 1] 4961 	clr a 
      001C05 CF 00 16         [ 2] 4962 	ldw farptr,x 
      001C08 C7 00 18         [ 1] 4963 	ld farptr+2,a 
      001C0B                       4964 4$:	; save new free address 
      001C0B 1F 01            [ 2] 4965 	ldw (NEW_FREE,sp),x
      001C0D 6B 03            [ 1] 4966 	ld (NEW_FREE+2,sp),a 
      001C0F CD 01 40         [ 4] 4967 	call move_erase_to_ram
      001C12 CD 01 BB         [ 4] 4968 5$: call block_erase 
      001C15 AE 00 80         [ 2] 4969 	ldw x,#BLOCK_SIZE 
      001C18 CD 19 ED         [ 4] 4970 	call incr_farptr 
      001C1B CD 19 D2         [ 4] 4971 	call row_align 
                                   4972 ; check if all blocks erased
      001C1E C6 00 18         [ 1] 4973 	ld a,farptr+2  
      001C21 C0 00 1B         [ 1] 4974 	sub a,ffree+2
      001C24 C6 00 17         [ 1] 4975 	ld a,farptr+1 
      001C27 C2 00 1A         [ 1] 4976 	sbc a,ffree+1 
      001C2A C6 00 16         [ 1] 4977 	ld a,farptr 
      001C2D C2 00 19         [ 1] 4978 	sbc a,ffree 
      001C30 2B E0            [ 1] 4979 	jrmi 5$ 
      001C32 7B 03            [ 1] 4980 	ld a,(NEW_FREE+2,sp)
      001C34 1E 01            [ 2] 4981 	ldw x,(NEW_FREE,sp)
      001C36 C7 00 1B         [ 1] 4982 	ld ffree+2,a 
      001C39 CF 00 19         [ 2] 4983 	ldw ffree,x 
      001C3C                       4984 	_drop VSIZE 
      001C3C 5B 03            [ 2]    1     addw sp,#VSIZE 
      001C3E 81               [ 4] 4985 	ret 
                                   4986 
                                   4987 ;----------------------
                                   4988 ; BASIC: DIR 
                                   4989 ; list saved files 
                                   4990 ;----------------------
                           000001  4991 	COUNT=1 ; files counter 
                           000002  4992 	VSIZE=2 
      001C3F                       4993 directory:
      001C3F                       4994 	_vars VSIZE 
      001C3F 52 02            [ 2]    1     sub sp,#VSIZE 
      001C41 5F               [ 1] 4995 	clrw x 
      001C42 1F 01            [ 2] 4996 	ldw (COUNT,sp),x 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 96.
Hexadecimal [24-Bits]



      001C44 CF 00 17         [ 2] 4997 	ldw farptr+1,x 
      001C47 35 01 00 16      [ 1] 4998 	mov farptr,#1 
      001C4B                       4999 dir_loop:
      001C4B 5F               [ 1] 5000 	clrw x 
      001C4C 92 AF 00 16      [ 5] 5001 	ldf a,([farptr],x)
      001C50 27 3B            [ 1] 5002 	jreq 8$ 
      001C52                       5003 1$: ;name loop 	
      001C52 92 AF 00 16      [ 5] 5004 	ldf a,([farptr],x)
      001C56 27 06            [ 1] 5005 	jreq 2$ 
      001C58 CD 02 C0         [ 4] 5006 	call putc 
      001C5B 5C               [ 2] 5007 	incw x 
      001C5C 20 F4            [ 2] 5008 	jra 1$
      001C5E 5C               [ 2] 5009 2$: incw x ; skip ending 0. 
      001C5F A6 20            [ 1] 5010 	ld a,#SPACE 
      001C61 CD 02 C0         [ 4] 5011 	call putc 
                                   5012 ; get file size 	
      001C64 92 AF 00 16      [ 5] 5013 	ldf a,([farptr],x)
      001C68 90 95            [ 1] 5014 	ld yh,a 
      001C6A 5C               [ 2] 5015 	incw x 
      001C6B 92 AF 00 16      [ 5] 5016 	ldf a,([farptr],x)
      001C6F 5C               [ 2] 5017 	incw x 
      001C70 90 97            [ 1] 5018 	ld yl,a 
      001C72 90 89            [ 2] 5019 	pushw y 
      001C74 72 FB 01         [ 2] 5020 	addw x,(1,sp)
                                   5021 ; skip to next file 
      001C77 CD 19 ED         [ 4] 5022 	call incr_farptr
      001C7A CD 19 D2         [ 4] 5023 	call row_align
                                   5024 ; print file size 
      001C7D 85               [ 2] 5025 	popw x ; file size 
      001C7E CD 09 CA         [ 4] 5026 	call print_int 
      001C81 A6 0D            [ 1] 5027 	ld a,#CR 
      001C83 CD 02 C0         [ 4] 5028 	call putc
      001C86 1E 01            [ 2] 5029 	ldw x,(COUNT,sp)
      001C88 5C               [ 2] 5030 	incw x
      001C89 1F 01            [ 2] 5031 	ldw (COUNT,sp),x  
      001C8B 20 BE            [ 2] 5032 	jra dir_loop
      001C8D                       5033 8$: ; print number of files 
      001C8D 1E 01            [ 2] 5034 	ldw x,(COUNT,sp)
      001C8F CD 09 CA         [ 4] 5035 	call print_int 
      001C92 AE 1C AC         [ 2] 5036 	ldw x,#file_count 
      001C95 CD 00 00         [ 4] 5037 	call puts  
                                   5038 ; print drive free space 	
      001C98 CD 1A 2D         [ 4] 5039 	call disk_free
      001C9B 5F               [ 1] 5040 	clrw x  
      001C9C 35 0A 00 0A      [ 1] 5041 	mov base,#10 
      001CA0 CD 09 DA         [ 4] 5042 	call prti24 
      001CA3 AE 1C B4         [ 2] 5043 	ldw x,#drive_free
      001CA6 CD 00 00         [ 4] 5044 	call puts 
      001CA9                       5045 	_drop VSIZE 
      001CA9 5B 02            [ 2]    1     addw sp,#VSIZE 
      001CAB 81               [ 4] 5046 	ret
      001CAC 20 66 69 6C 65 73 0A  5047 file_count: .asciz " files\n"
             00
      001CB4 20 62 79 74 65 73 20  5048 drive_free: .asciz " bytes free\n" 
             66 72 65 65 0A 00
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 97.
Hexadecimal [24-Bits]



                                   5049 
                                   5050 ;---------------------
                                   5051 ; BASIC: WRITE expr1,expr2[,expr]* 
                                   5052 ; write 1 or more byte to FLASH or EEPROM
                                   5053 ; starting at address  
                                   5054 ; input:
                                   5055 ;   expr1  	is address 
                                   5056 ;   expr2,...,exprn   are bytes to write
                                   5057 ; output:
                                   5058 ;   none 
                                   5059 ;---------------------
                           000001  5060 	ADDR=1
                           000002  5061 	VSIZ=2 
      001CC1                       5062 write:
      001CC1                       5063 	_vars VSIZE 
      001CC1 52 02            [ 2]    1     sub sp,#VSIZE 
      001CC3 72 5F 00 16      [ 1] 5064 	clr farptr ; expect 16 bits address 
      001CC7 CD 11 0F         [ 4] 5065 	call expression
      001CCA A1 84            [ 1] 5066 	cp a,#TK_INTGR 
      001CCC 27 03            [ 1] 5067 	jreq 0$
      001CCE CC 08 7B         [ 2] 5068 	jp syntax_error
      001CD1 1F 01            [ 2] 5069 0$: ldw (ADDR,sp),x 
      001CD3 CD 09 6D         [ 4] 5070 	call next_token 
      001CD6 A1 09            [ 1] 5071 	cp a,#TK_COMMA 
      001CD8 27 02            [ 1] 5072 	jreq 1$ 
      001CDA 20 19            [ 2] 5073 	jra 9$ 
      001CDC CD 11 0F         [ 4] 5074 1$:	call expression
      001CDF A1 84            [ 1] 5075 	cp a,#TK_INTGR
      001CE1 27 03            [ 1] 5076 	jreq 2$
      001CE3 CC 08 7B         [ 2] 5077 	jp syntax_error
      001CE6 9F               [ 1] 5078 2$:	ld a,xl 
      001CE7 1E 01            [ 2] 5079 	ldw x,(ADDR,sp) 
      001CE9 CF 00 17         [ 2] 5080 	ldw farptr+1,x 
      001CEC 5F               [ 1] 5081 	clrw x 
      001CED CD 01 E5         [ 4] 5082 	call write_byte
      001CF0 1E 01            [ 2] 5083 	ldw x,(ADDR,sp)
      001CF2 5C               [ 2] 5084 	incw x 
      001CF3 20 DC            [ 2] 5085 	jra 0$ 
      001CF5                       5086 9$:
      001CF5                       5087 	_drop VSIZE
      001CF5 5B 02            [ 2]    1     addw sp,#VSIZE 
      001CF7 81               [ 4] 5088 	ret 
                                   5089 
                                   5090 
                                   5091 ;---------------------
                                   5092 ;BASIC: CHAR(expr)
                                   5093 ; évaluate expression 
                                   5094 ; and take the 7 least 
                                   5095 ; bits as ASCII character
                                   5096 ;---------------------
      001CF8                       5097 char:
      001CF8 CD 10 11         [ 4] 5098 	call func_args 
      001CFB A1 01            [ 1] 5099 	cp a,#1
      001CFD 27 03            [ 1] 5100 	jreq 1$
      001CFF CC 08 7B         [ 2] 5101 	jp syntax_error
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 98.
Hexadecimal [24-Bits]



      001D02 85               [ 2] 5102 1$:	popw x 
      001D03 9F               [ 1] 5103 	ld a,xl 
      001D04 A4 7F            [ 1] 5104 	and a,#0x7f 
      001D06 97               [ 1] 5105 	ld xl,a
      001D07 A6 03            [ 1] 5106 	ld a,#TK_CHAR
      001D09 81               [ 4] 5107 	ret
                                   5108 
                                   5109 ;---------------------
                                   5110 ; BASIC: ASC(string|char)
                                   5111 ; extract first character 
                                   5112 ; of string argument 
                                   5113 ; return it as TK_INTGR 
                                   5114 ;---------------------
      001D0A                       5115 ascii:
      001D0A A6 07            [ 1] 5116 	ld a,#TK_LPAREN
      001D0C CD 10 04         [ 4] 5117 	call expect 
      001D0F CD 09 6D         [ 4] 5118 	call next_token 
      001D12 A1 02            [ 1] 5119 	cp a,#TK_QSTR 
      001D14 27 07            [ 1] 5120 	jreq 1$
      001D16 A1 03            [ 1] 5121 	cp a,#TK_CHAR 
      001D18 27 06            [ 1] 5122 	jreq 2$ 
      001D1A CC 08 7B         [ 2] 5123 	jp syntax_error
      001D1D                       5124 1$: 
      001D1D F6               [ 1] 5125 	ld a,(x) 
      001D1E 5F               [ 1] 5126 	clrw x
      001D1F 97               [ 1] 5127 	ld xl,a 
      001D20                       5128 2$: 
      001D20 89               [ 2] 5129 	pushw x 
      001D21 A6 08            [ 1] 5130 	ld a,#TK_RPAREN 
      001D23 CD 10 04         [ 4] 5131 	call expect
      001D26 85               [ 2] 5132 	popw x 
      001D27 A6 84            [ 1] 5133 	ld a,#TK_INTGR 
      001D29 81               [ 4] 5134 	ret 
                                   5135 
                                   5136 ;---------------------
                                   5137 ;BASIC: KEY
                                   5138 ; wait for a character 
                                   5139 ; received from STDIN 
                                   5140 ; input:
                                   5141 ;	none 
                                   5142 ; output:
                                   5143 ;	X 		ASCII character 
                                   5144 ;---------------------
      001D2A                       5145 key:
      001D2A CD 02 C9         [ 4] 5146 	call getc 
      001D2D 5F               [ 1] 5147 	clrw x 
      001D2E 97               [ 1] 5148 	ld xl,a 
      001D2F A6 84            [ 1] 5149 	ld a,#TK_INTGR
      001D31 81               [ 4] 5150 	ret
                                   5151 
                                   5152 ;----------------------
                                   5153 ; BASIC: QKEY
                                   5154 ; Return true if there 
                                   5155 ; is a character in 
                                   5156 ; waiting in STDIN 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 99.
Hexadecimal [24-Bits]



                                   5157 ; input:
                                   5158 ;  none 
                                   5159 ; output:
                                   5160 ;   X 		0|-1 
                                   5161 ;-----------------------
      001D32                       5162 qkey:: 
      001D32 5F               [ 1] 5163 	clrw x 
      001D33 C6 00 2D         [ 1] 5164 	ld a,rx_head
      001D36 C1 00 2E         [ 1] 5165 	cp a,rx_tail 
      001D39 27 01            [ 1] 5166 	jreq 9$ 
      001D3B 53               [ 2] 5167 	cplw x 
      001D3C A6 84            [ 1] 5168 9$: ld a,#TK_INTGR
      001D3E 81               [ 4] 5169 	ret 
                                   5170 
                                   5171 ;---------------------
                                   5172 ; BASIC: GPIO(expr,reg)
                                   5173 ; return gpio address 
                                   5174 ; expr {0..8}
                                   5175 ; input:
                                   5176 ;   none 
                                   5177 ; output:
                                   5178 ;   X 		gpio register address
                                   5179 ;----------------------------
                           000003  5180 	PORT=3
                           000001  5181 	REG=1 
                           000004  5182 	VSIZE=4 
      001D3F                       5183 gpio:
      001D3F CD 10 11         [ 4] 5184 	call func_args 
      001D42 A1 02            [ 1] 5185 	cp a,#2
      001D44 27 03            [ 1] 5186 	jreq 1$
      001D46 CC 08 7B         [ 2] 5187 	jp syntax_error  
      001D49                       5188 1$:	
      001D49 1E 03            [ 2] 5189 	ldw x,(PORT,sp)
      001D4B 2B 17            [ 1] 5190 	jrmi bad_port
      001D4D A3 00 09         [ 2] 5191 	cpw x,#9
      001D50 2A 12            [ 1] 5192 	jrpl bad_port
      001D52 A6 05            [ 1] 5193 	ld a,#5
      001D54 42               [ 4] 5194 	mul x,a
      001D55 1C 50 00         [ 2] 5195 	addw x,#GPIO_BASE 
      001D58 1F 03            [ 2] 5196 	ldw (PORT,sp),x  
      001D5A 1E 01            [ 2] 5197 	ldw x,(REG,sp) 
      001D5C 72 FB 03         [ 2] 5198 	addw x,(PORT,sp)
      001D5F A6 84            [ 1] 5199 	ld a,#TK_INTGR
      001D61                       5200 	_drop VSIZE 
      001D61 5B 04            [ 2]    1     addw sp,#VSIZE 
      001D63 81               [ 4] 5201 	ret
      001D64                       5202 bad_port:
      001D64 A6 0A            [ 1] 5203 	ld a,#ERR_BAD_VALUE
      001D66 CC 08 7D         [ 2] 5204 	jp tb_error
                                   5205 
                                   5206 
                                   5207 ;-------------------------
                                   5208 ; BASIC: UFLASH 
                                   5209 ; return user flash address
                                   5210 ; input:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 100.
Hexadecimal [24-Bits]



                                   5211 ;  none 
                                   5212 ; output:
                                   5213 ;	A		TK_INTGR
                                   5214 ;   X 		user address 
                                   5215 ;---------------------------
      001D69                       5216 uflash:
      001D69 AE 28 00         [ 2] 5217 	ldw x,#user_space 
      001D6C A6 84            [ 1] 5218 	ld a,#TK_INTGR 
      001D6E 81               [ 4] 5219 	ret 
                                   5220 
                                   5221 
                                   5222 ;---------------------
                                   5223 ; BASIC: USR(addr[,arg])
                                   5224 ; execute a function written 
                                   5225 ; in binary code.
                                   5226 ; binary fonction should 
                                   5227 ; return token attribute in A 
                                   5228 ; and value in X. 
                                   5229 ; input:
                                   5230 ;   addr	routine address 
                                   5231 ;   arg 	is an optional argument 
                                   5232 ; output:
                                   5233 ;   A 		token attribute 
                                   5234 ;   X       returned value 
                                   5235 ;---------------------
      001D6F                       5236 usr:
      001D6F 90 89            [ 2] 5237 	pushw y 	
      001D71 CD 10 11         [ 4] 5238 	call func_args 
      001D74 A1 01            [ 1] 5239 	cp a,#1 
      001D76 27 07            [ 1] 5240 	jreq 2$
      001D78 A1 02            [ 1] 5241 	cp a,#2
      001D7A 27 03            [ 1] 5242 	jreq 2$  
      001D7C CC 08 7B         [ 2] 5243 	jp syntax_error 
      001D7F 90 85            [ 2] 5244 2$: popw y  ; arg|addr 
      001D81 A1 01            [ 1] 5245 	cp a,#1
      001D83 27 02            [ 1] 5246 	jreq 3$
      001D85 85               [ 2] 5247 	popw x ; addr
      001D86 51               [ 1] 5248 	exgw x,y 
      001D87 90 FD            [ 4] 5249 3$: call (y)
      001D89 90 85            [ 2] 5250 	popw y 
      001D8B 81               [ 4] 5251 	ret 
                                   5252 
                                   5253 ;------------------------------
                                   5254 ; BASIC: BYE 
                                   5255 ; halt mcu in its lowest power mode 
                                   5256 ; wait for reset or external interrupt
                                   5257 ; do a cold start on wakeup.
                                   5258 ;------------------------------
      001D8C                       5259 bye:
      001D8C 72 0D 52 30 FB   [ 2] 5260 	btjf UART1_SR,#UART_SR_TC,.
      001D91 8E               [10] 5261 	halt
      001D92 CC 05 D8         [ 2] 5262 	jp cold_start  
                                   5263 
                                   5264 ;----------------------------------
                                   5265 ; BASIC: AUTORUN ["file_name"] 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 101.
Hexadecimal [24-Bits]



                                   5266 ; record in eeprom at adrress AUTORUN_NAME
                                   5267 ; the name of file to load and execute
                                   5268 ; at startup. 
                                   5269 ; empty string delete autorun name 
                                   5270 ; no argument display autorun name  
                                   5271 ; input:
                                   5272 ;   file_name   file to execute 
                                   5273 ; output:
                                   5274 ;   none
                                   5275 ;-----------------------------------
      001D95                       5276 autorun: 
      001D95 72 01 00 23 07   [ 2] 5277 	btjf flags,#FRUN,0$ 
      001D9A 27 05            [ 1] 5278 	jreq 0$ 
      001D9C A6 07            [ 1] 5279 	ld a,#ERR_CMD_ONLY 
      001D9E CC 08 7D         [ 2] 5280 	jp tb_error 
      001DA1                       5281 0$:	
      001DA1 CD 09 6D         [ 4] 5282 	call next_token
      001DA4 26 08            [ 1] 5283 	jrne 1$
      001DA6 AE 40 00         [ 2] 5284 	ldw x,#AUTORUN_NAME
      001DA9 CD 00 00         [ 4] 5285 	call puts 
      001DAC 4F               [ 1] 5286 	clr a 
      001DAD 81               [ 4] 5287 	ret 
      001DAE                       5288 1$:
      001DAE A1 02            [ 1] 5289 	cp a,#TK_QSTR
      001DB0 27 03            [ 1] 5290 	jreq 2$
      001DB2 CC 08 7B         [ 2] 5291 	jp syntax_error 
      001DB5                       5292 2$:	
      001DB5 7D               [ 1] 5293 	tnz (x) 
      001DB6 26 09            [ 1] 5294 	jrne 3$
                                   5295 ; empty string, delete autorun 	
      001DB8 CD 06 9A         [ 4] 5296 	call cancel_autorun
      001DBB 55 00 03 00 01   [ 1] 5297 	mov in,count 
      001DC0 81               [ 4] 5298 	ret 
      001DC1 89               [ 2] 5299 3$:	pushw x 
      001DC2 90 93            [ 1] 5300 	ldw y,x  
      001DC4 CD 1A 61         [ 4] 5301 	call search_file 
      001DC7 25 05            [ 1] 5302 	jrc 4$ 
      001DC9 A6 09            [ 1] 5303 	ld a,#ERR_NOT_FILE
      001DCB CC 08 7D         [ 2] 5304 	jp tb_error  
      001DCE                       5305 4$: 
      001DCE 55 00 03 00 01   [ 1] 5306 	mov in,count 
      001DD3 72 5F 00 16      [ 1] 5307 	clr farptr 
      001DD7 AE 40 00         [ 2] 5308 	ldw x,#AUTORUN_NAME
      001DDA CF 00 17         [ 2] 5309 	ldw farptr+1,x 
      001DDD 1E 01            [ 2] 5310 	ldw x,(1,sp)  
      001DDF CD 03 96         [ 4] 5311 	call strlen  ; return length in X 
      001DE2 5C               [ 2] 5312 	incw x 
      001DE3 90 85            [ 2] 5313 	popw y 
      001DE5 89               [ 2] 5314 	pushw x 
      001DE6 5F               [ 1] 5315 	clrw x 
      001DE7 CD 02 5A         [ 4] 5316 	call write_block 
      001DEA                       5317 	_drop 2 
      001DEA 5B 02            [ 2]    1     addw sp,#2 
      001DEC 81               [ 4] 5318 	ret 
                                   5319 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 102.
Hexadecimal [24-Bits]



                                   5320 ;----------------------------------
                                   5321 ; BASIC: SLEEP 
                                   5322 ; halt mcu until reset or external
                                   5323 ; interrupt.
                                   5324 ; Resume progam after SLEEP command
                                   5325 ;----------------------------------
      001DED                       5326 sleep:
      001DED 72 0D 52 30 FB   [ 2] 5327 	btjf UART1_SR,#UART_SR_TC,.
      001DF2 72 16 00 23      [ 1] 5328 	bset flags,#FSLEEP
      001DF6 8E               [10] 5329 	halt 
      001DF7 81               [ 4] 5330 	ret 
                                   5331 
                                   5332 ;-------------------------------
                                   5333 ; BASIC: PAUSE expr 
                                   5334 ; suspend execution for n msec.
                                   5335 ; input:
                                   5336 ;	none
                                   5337 ; output:
                                   5338 ;	none 
                                   5339 ;------------------------------
      001DF8                       5340 pause:
      001DF8 CD 11 0F         [ 4] 5341 	call expression
      001DFB A1 84            [ 1] 5342 	cp a,#TK_INTGR
      001DFD 27 03            [ 1] 5343 	jreq pause02 
      001DFF CC 08 7B         [ 2] 5344 	jp syntax_error
      001E02                       5345 pause02: 
      001E02 5D               [ 2] 5346 1$: tnzw x 
      001E03 27 04            [ 1] 5347 	jreq 2$
      001E05 8F               [10] 5348 	wfi 
      001E06 5A               [ 2] 5349 	decw x 
      001E07 26 F9            [ 1] 5350 	jrne 1$
      001E09 4F               [ 1] 5351 2$:	clr a 
      001E0A 81               [ 4] 5352 	ret 
                                   5353 
                                   5354 ;------------------------------
                                   5355 ; BASIC: AWU expr
                                   5356 ; halt mcu for 'expr' milliseconds
                                   5357 ; use Auto wakeup peripheral
                                   5358 ; all oscillators stopped except LSI
                                   5359 ; range: 1ms - 511ms
                                   5360 ; input:
                                   5361 ;  none
                                   5362 ; output:
                                   5363 ;  none:
                                   5364 ;------------------------------
      001E0B                       5365 awu:
      001E0B CD 11 0F         [ 4] 5366   call expression
      001E0E A1 84            [ 1] 5367   cp a,#TK_INTGR
      001E10 27 03            [ 1] 5368   jreq awu02
      001E12 CC 08 7B         [ 2] 5369   jp syntax_error
      001E15                       5370 awu02:
      001E15 A3 14 00         [ 2] 5371   cpw x,#5120
      001E18 2B 0C            [ 1] 5372   jrmi 1$ 
      001E1A 35 0F 50 F2      [ 1] 5373   mov AWU_TBR,#15 
      001E1E A6 1E            [ 1] 5374   ld a,#30
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 103.
Hexadecimal [24-Bits]



      001E20 62               [ 2] 5375   div x,a
      001E21 A6 10            [ 1] 5376   ld a,#16
      001E23 62               [ 2] 5377   div x,a 
      001E24 20 1E            [ 2] 5378   jra 4$
      001E26                       5379 1$: 
      001E26 A3 08 00         [ 2] 5380   cpw x,#2048
      001E29 2B 09            [ 1] 5381   jrmi 2$ 
      001E2B 35 0E 50 F2      [ 1] 5382   mov AWU_TBR,#14
      001E2F A6 50            [ 1] 5383   ld a,#80
      001E31 62               [ 2] 5384   div x,a 
      001E32 20 10            [ 2] 5385   jra 4$   
      001E34                       5386 2$:
      001E34 35 07 50 F2      [ 1] 5387   mov AWU_TBR,#7
      001E38                       5388 3$:  
                                   5389 ; while X > 64  divide by 2 and increment AWU_TBR 
      001E38 A3 00 40         [ 2] 5390   cpw x,#64 
      001E3B 23 07            [ 2] 5391   jrule 4$ 
      001E3D 72 5C 50 F2      [ 1] 5392   inc AWU_TBR 
      001E41 54               [ 2] 5393   srlw x 
      001E42 20 F4            [ 2] 5394   jra 3$ 
      001E44                       5395 4$:
      001E44 9F               [ 1] 5396   ld a, xl
      001E45 4A               [ 1] 5397   dec a 
      001E46 27 01            [ 1] 5398   jreq 5$
      001E48 4A               [ 1] 5399   dec a 	
      001E49                       5400 5$: 
      001E49 A4 3E            [ 1] 5401   and a,#0x3e 
      001E4B C7 50 F1         [ 1] 5402   ld AWU_APR,a 
      001E4E 72 18 50 F0      [ 1] 5403   bset AWU_CSR,#AWU_CSR_AWUEN
      001E52 8E               [10] 5404   halt 
                                   5405 
      001E53 81               [ 4] 5406   ret 
                                   5407 
                                   5408 ;------------------------------
                                   5409 ; BASIC: TICKS
                                   5410 ; return msec ticks counter value 
                                   5411 ; input:
                                   5412 ; 	none 
                                   5413 ; output:
                                   5414 ;	X 		TK_INTGR
                                   5415 ;-------------------------------
      001E54                       5416 get_ticks:
      001E54 CE 00 0E         [ 2] 5417 	ldw x,ticks 
      001E57 A6 84            [ 1] 5418 	ld a,#TK_INTGR
      001E59 81               [ 4] 5419 	ret 
                                   5420 
                                   5421 
                                   5422 
                                   5423 ;------------------------------
                                   5424 ; BASIC: ABS(expr)
                                   5425 ; return absolute value of expr.
                                   5426 ; input:
                                   5427 ;   none
                                   5428 ; output:
                                   5429 ;   X     	positive integer
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 104.
Hexadecimal [24-Bits]



                                   5430 ;-------------------------------
      001E5A                       5431 abs:
      001E5A CD 10 11         [ 4] 5432 	call func_args 
      001E5D A1 01            [ 1] 5433 	cp a,#1 
      001E5F 27 03            [ 1] 5434 	jreq 0$ 
      001E61 CC 08 7B         [ 2] 5435 	jp syntax_error
      001E64                       5436 0$:  
      001E64 85               [ 2] 5437     popw x   
      001E65 9E               [ 1] 5438 	ld a,xh 
      001E66 A5 80            [ 1] 5439 	bcp a,#0x80 
      001E68 27 01            [ 1] 5440 	jreq 2$ 
      001E6A 50               [ 2] 5441 	negw x 
      001E6B A6 84            [ 1] 5442 2$: ld a,#TK_INTGR 
      001E6D 81               [ 4] 5443 	ret 
                                   5444 
                                   5445 ;------------------------------
                                   5446 ; BASIC: AND(expr1,expr2)
                                   5447 ; Apply bit AND relation between
                                   5448 ; the 2 arguments, i.e expr1 & expr2 
                                   5449 ; output:
                                   5450 ; 	A 		TK_INTGR
                                   5451 ;   X 		result 
                                   5452 ;------------------------------
      001E6E                       5453 bit_and:
      001E6E CD 10 11         [ 4] 5454 	call func_args 
      001E71 A1 02            [ 1] 5455 	cp a,#2
      001E73 27 03            [ 1] 5456 	jreq 1$
      001E75 CC 08 7B         [ 2] 5457 	jp syntax_error 
      001E78 85               [ 2] 5458 1$:	popw x 
      001E79 9E               [ 1] 5459 	ld a,xh 
      001E7A 14 01            [ 1] 5460 	and a,(1,sp)
      001E7C 95               [ 1] 5461 	ld xh,a 
      001E7D 9F               [ 1] 5462 	ld a,xl
      001E7E 14 02            [ 1] 5463 	and a,(2,sp)
      001E80 97               [ 1] 5464 	ld xl,a 
      001E81                       5465 	_drop 2 
      001E81 5B 02            [ 2]    1     addw sp,#2 
      001E83 A6 84            [ 1] 5466 	ld a,#TK_INTGR
      001E85 81               [ 4] 5467 	ret
                                   5468 
                                   5469 ;------------------------------
                                   5470 ; BASIC: OR(expr1,expr2)
                                   5471 ; Apply bit OR relation between
                                   5472 ; the 2 arguments, i.e expr1 | expr2 
                                   5473 ; output:
                                   5474 ; 	A 		TK_INTGR
                                   5475 ;   X 		result 
                                   5476 ;------------------------------
      001E86                       5477 bit_or:
      001E86 CD 10 11         [ 4] 5478 	call func_args 
      001E89 A1 02            [ 1] 5479 	cp a,#2
      001E8B 27 03            [ 1] 5480 	jreq 1$
      001E8D CC 08 7B         [ 2] 5481 	jp syntax_error 
      001E90                       5482 1$: 
      001E90 85               [ 2] 5483 	popw x 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 105.
Hexadecimal [24-Bits]



      001E91 9E               [ 1] 5484 	ld a,xh 
      001E92 1A 01            [ 1] 5485 	or a,(1,sp)
      001E94 95               [ 1] 5486 	ld xh,a 
      001E95 9F               [ 1] 5487 	ld a,xl 
      001E96 1A 02            [ 1] 5488 	or a,(2,sp)
      001E98 97               [ 1] 5489 	ld xl,a 
      001E99                       5490 	_drop 2 
      001E99 5B 02            [ 2]    1     addw sp,#2 
      001E9B A6 84            [ 1] 5491 	ld a,#TK_INTGR 
      001E9D 81               [ 4] 5492 	ret
                                   5493 
                                   5494 ;------------------------------
                                   5495 ; BASIC: XOR(expr1,expr2)
                                   5496 ; Apply bit XOR relation between
                                   5497 ; the 2 arguments, i.e expr1 ^ expr2 
                                   5498 ; output:
                                   5499 ; 	A 		TK_INTGR
                                   5500 ;   X 		result 
                                   5501 ;------------------------------
      001E9E                       5502 bit_xor:
      001E9E CD 10 11         [ 4] 5503 	call func_args 
      001EA1 A1 02            [ 1] 5504 	cp a,#2
      001EA3 27 03            [ 1] 5505 	jreq 1$
      001EA5 CC 08 7B         [ 2] 5506 	jp syntax_error 
      001EA8                       5507 1$: 
      001EA8 85               [ 2] 5508 	popw x 
      001EA9 9E               [ 1] 5509 	ld a,xh 
      001EAA 18 01            [ 1] 5510 	xor a,(1,sp)
      001EAC 95               [ 1] 5511 	ld xh,a 
      001EAD 9F               [ 1] 5512 	ld a,xl 
      001EAE 18 02            [ 1] 5513 	xor a,(2,sp)
      001EB0 97               [ 1] 5514 	ld xl,a 
      001EB1                       5515 	_drop 2 
      001EB1 5B 02            [ 2]    1     addw sp,#2 
      001EB3 A6 84            [ 1] 5516 	ld a,#TK_INTGR 
      001EB5 81               [ 4] 5517 	ret 
                                   5518 
                                   5519 ;------------------------------
                                   5520 ; BASIC: LSHIFT(expr1,expr2)
                                   5521 ; logical shift left expr1 by 
                                   5522 ; expr2 bits 
                                   5523 ; output:
                                   5524 ; 	A 		TK_INTGR
                                   5525 ;   X 		result 
                                   5526 ;------------------------------
      001EB6                       5527 lshift:
      001EB6 CD 10 11         [ 4] 5528 	call func_args
      001EB9 A1 02            [ 1] 5529 	cp a,#2 
      001EBB 27 03            [ 1] 5530 	jreq 1$
      001EBD CC 08 7B         [ 2] 5531 	jp syntax_error
      001EC0 90 85            [ 2] 5532 1$: popw y   
      001EC2 85               [ 2] 5533 	popw x 
      001EC3 90 5D            [ 2] 5534 	tnzw y 
      001EC5 27 05            [ 1] 5535 	jreq 4$
      001EC7 58               [ 2] 5536 2$:	sllw x 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 106.
Hexadecimal [24-Bits]



      001EC8 90 5A            [ 2] 5537 	decw y 
      001ECA 26 FB            [ 1] 5538 	jrne 2$
      001ECC                       5539 4$:  
      001ECC A6 84            [ 1] 5540 	ld a,#TK_INTGR
      001ECE 81               [ 4] 5541 	ret
                                   5542 
                                   5543 ;------------------------------
                                   5544 ; BASIC: RSHIFT(expr1,expr2)
                                   5545 ; logical shift right expr1 by 
                                   5546 ; expr2 bits.
                                   5547 ; output:
                                   5548 ; 	A 		TK_INTGR
                                   5549 ;   X 		result 
                                   5550 ;------------------------------
      001ECF                       5551 rshift:
      001ECF CD 10 11         [ 4] 5552 	call func_args
      001ED2 A1 02            [ 1] 5553 	cp a,#2 
      001ED4 27 03            [ 1] 5554 	jreq 1$
      001ED6 CC 08 7B         [ 2] 5555 	jp syntax_error
      001ED9 90 85            [ 2] 5556 1$: popw y  
      001EDB 85               [ 2] 5557 	popw x
      001EDC 90 5D            [ 2] 5558 	tnzw y 
      001EDE 27 05            [ 1] 5559 	jreq 4$
      001EE0 54               [ 2] 5560 2$:	srlw x 
      001EE1 90 5A            [ 2] 5561 	decw y 
      001EE3 26 FB            [ 1] 5562 	jrne 2$
      001EE5                       5563 4$:  
      001EE5 A6 84            [ 1] 5564 	ld a,#TK_INTGR
      001EE7 81               [ 4] 5565 	ret
                                   5566 
                                   5567 ;--------------------------
                                   5568 ; BASIC: FCPU integer
                                   5569 ; set CPU frequency 
                                   5570 ;-------------------------- 
                                   5571 
      001EE8                       5572 fcpu:
      001EE8 A6 84            [ 1] 5573 	ld a,#TK_INTGR
      001EEA CD 10 04         [ 4] 5574 	call expect 
      001EED 9F               [ 1] 5575 	ld a,xl 
      001EEE A4 07            [ 1] 5576 	and a,#7 
      001EF0 C7 50 C6         [ 1] 5577 	ld CLK_CKDIVR,a 
      001EF3 81               [ 4] 5578 	ret 
                                   5579 
                                   5580 ;------------------------------
                                   5581 ; BASIC: PMODE pin#, mode 
                                   5582 ; Arduino pin. 
                                   5583 ; define pin as input or output
                                   5584 ; pin#: {0..15}
                                   5585 ; mode: INPUT|OUTPUT  
                                   5586 ;------------------------------
                           000001  5587 	PINNO=1
                           000001  5588 	VSIZE=1
      001EF4                       5589 pin_mode:
      001EF4                       5590 	_vars VSIZE 
      001EF4 52 01            [ 2]    1     sub sp,#VSIZE 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 107.
Hexadecimal [24-Bits]



      001EF6 CD 10 16         [ 4] 5591 	call arg_list 
      001EF9 A1 02            [ 1] 5592 	cp a,#2 
      001EFB 27 03            [ 1] 5593 	jreq 1$
      001EFD CC 08 7B         [ 2] 5594 	jp syntax_error 
      001F00 90 85            [ 2] 5595 1$: popw y ; mode 
      001F02 85               [ 2] 5596 	popw x ; Dx pin 
      001F03 CD 1F 35         [ 4] 5597 	call select_pin 
      001F06 6B 01            [ 1] 5598 	ld (PINNO,sp),a  
      001F08 A6 01            [ 1] 5599 	ld a,#1 
      001F0A 0D 01            [ 1] 5600 	tnz (PINNO,sp)
      001F0C 27 0B            [ 1] 5601 	jreq 4$
      001F0E 48               [ 1] 5602 2$:	sll a 
      001F0F 0A 01            [ 1] 5603 	dec (PINNO,sp)
      001F11 26 FB            [ 1] 5604 	jrne 2$ 
      001F13 6B 01            [ 1] 5605 	ld (PINNO,sp),a
      001F15 EA 03            [ 1] 5606 	or a,(GPIO_CR1,x) ;if input->pull-up else push-pull 
      001F17 E7 03            [ 1] 5607 	ld (GPIO_CR1,x),a 
      001F19 90 A3 00 01      [ 2] 5608 4$:	cpw y,#OUTP 
      001F1D 27 07            [ 1] 5609 	jreq 6$
                                   5610 ; input mode
      001F1F 7B 01            [ 1] 5611 	ld a,(PINNO,sp)
      001F21 43               [ 1] 5612 	cpl a 
      001F22 E4 02            [ 1] 5613 	and a,(GPIO_DDR,x)	; bit==0 for input. 
      001F24 20 0A            [ 2] 5614 	jra 9$
      001F26                       5615 6$: ;output mode  
      001F26 7B 01            [ 1] 5616 	ld a,(PINNO,sp)
      001F28 EA 04            [ 1] 5617 	or a,(GPIO_CR2,x) ;port speed 10 Mhz 
      001F2A E7 04            [ 1] 5618 	ld (GPIO_CR2,x),a 
      001F2C 7B 01            [ 1] 5619 	ld a,(PINNO,sp)
      001F2E EA 02            [ 1] 5620 	or a,(GPIO_DDR,x) ; bit==1 for output 
      001F30 E7 02            [ 1] 5621 9$:	ld (GPIO_DDR,x),a 
      001F32                       5622 	_drop VSIZE 
      001F32 5B 01            [ 2]    1     addw sp,#VSIZE 
      001F34 81               [ 4] 5623 	ret
                                   5624 
                                   5625 ;------------------------
                                   5626 ; select Arduino pin 
                                   5627 ; input:
                                   5628 ;   X 	 {0..15} Arduino Dx 
                                   5629 ; output:
                                   5630 ;   A     stm8s208 pin 
                                   5631 ;   X     base address s208 GPIO port 
                                   5632 ;---------------------------
      001F35                       5633 select_pin:
      001F35 58               [ 2] 5634 	sllw x 
      001F36 1C 1F 45         [ 2] 5635 	addw x,#arduino_to_8s208 
      001F39 FE               [ 2] 5636 	ldw x,(x)
      001F3A 9F               [ 1] 5637 	ld a,xl 
      001F3B 88               [ 1] 5638 	push a 
      001F3C 5E               [ 1] 5639 	swapw x 
      001F3D A6 05            [ 1] 5640 	ld a,#5 
      001F3F 42               [ 4] 5641 	mul x,a 
      001F40 1C 50 00         [ 2] 5642 	addw x,#GPIO_BASE 
      001F43 84               [ 1] 5643 	pop a 
      001F44 81               [ 4] 5644 	ret 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 108.
Hexadecimal [24-Bits]



                                   5645 ; translation from Arduino D0..D15 to stm8s208rb 
      001F45                       5646 arduino_to_8s208:
      001F45 03 06                 5647 .byte 3,6 ; D0 
      001F47 03 05                 5648 .byte 3,5 ; D1 
      001F49 04 00                 5649 .byte 4,0 ; D2 
      001F4B 02 01                 5650 .byte 2,1 ; D3
      001F4D 06 00                 5651 .byte 6,0 ; D4
      001F4F 02 02                 5652 .byte 2,2 ; D5
      001F51 02 03                 5653 .byte 2,3 ; D6
      001F53 03 01                 5654 .byte 3,1 ; D7
      001F55 03 03                 5655 .byte 3,3 ; D8
      001F57 02 04                 5656 .byte 2,4 ; D9
      001F59 04 05                 5657 .byte 4,5 ; D10
      001F5B 02 06                 5658 .byte 2,6 ; D11
      001F5D 02 07                 5659 .byte 2,7 ; D12
      001F5F 02 05                 5660 .byte 2,5 ; D13
      001F61 04 02                 5661 .byte 4,2 ; D14
      001F63 04 01                 5662 .byte 4,1 ; D15
                                   5663 
                                   5664 
                                   5665 ;------------------------------
                                   5666 ; BASIC: RND(expr)
                                   5667 ; return random number 
                                   5668 ; between 1 and expr inclusive
                                   5669 ; xorshift16 ref: http://b2d-f9r.blogspot.com/2010/08/16-bit-xorshift-rng-now-with-more.html
                                   5670 ; input:
                                   5671 ; 	none 
                                   5672 ; output:
                                   5673 ;	X 		random positive integer 
                                   5674 ;------------------------------
      001F65                       5675 random:
      001F65 CD 10 11         [ 4] 5676 	call func_args 
      001F68 A1 01            [ 1] 5677 	cp a,#1
      001F6A 27 03            [ 1] 5678 	jreq 1$
      001F6C CC 08 7B         [ 2] 5679 	jp syntax_error
      001F6F                       5680 1$:  
      001F6F A6 80            [ 1] 5681 	ld a,#0x80 
      001F71 15 01            [ 1] 5682 	bcp a,(1,sp)
      001F73 27 05            [ 1] 5683 	jreq 2$
      001F75 A6 0A            [ 1] 5684 	ld a,#ERR_BAD_VALUE
      001F77 CC 08 7D         [ 2] 5685 	jp tb_error
      001F7A                       5686 2$: 
                                   5687 ; acc16=(x<<5)^x 
      001F7A CE 00 12         [ 2] 5688 	ldw x,seedx 
      001F7D 58               [ 2] 5689 	sllw x 
      001F7E 58               [ 2] 5690 	sllw x 
      001F7F 58               [ 2] 5691 	sllw x 
      001F80 58               [ 2] 5692 	sllw x 
      001F81 58               [ 2] 5693 	sllw x 
      001F82 9E               [ 1] 5694 	ld a,xh 
      001F83 C8 00 12         [ 1] 5695 	xor a,seedx 
      001F86 C7 00 0C         [ 1] 5696 	ld acc16,a 
      001F89 9F               [ 1] 5697 	ld a,xl 
      001F8A C8 00 13         [ 1] 5698 	xor a,seedx+1 
      001F8D C7 00 0D         [ 1] 5699 	ld acc8,a 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 109.
Hexadecimal [24-Bits]



                                   5700 ; seedx=seedy 
      001F90 CE 00 14         [ 2] 5701 	ldw x,seedy 
      001F93 CF 00 12         [ 2] 5702 	ldw seedx,x  
                                   5703 ; seedy=seedy^(seedy>>1)
      001F96 90 54            [ 2] 5704 	srlw y 
      001F98 90 9E            [ 1] 5705 	ld a,yh 
      001F9A C8 00 14         [ 1] 5706 	xor a,seedy 
      001F9D C7 00 14         [ 1] 5707 	ld seedy,a  
      001FA0 90 9F            [ 1] 5708 	ld a,yl 
      001FA2 C8 00 15         [ 1] 5709 	xor a,seedy+1 
      001FA5 C7 00 15         [ 1] 5710 	ld seedy+1,a 
                                   5711 ; acc16>>3 
      001FA8 CE 00 0C         [ 2] 5712 	ldw x,acc16 
      001FAB 54               [ 2] 5713 	srlw x 
      001FAC 54               [ 2] 5714 	srlw x 
      001FAD 54               [ 2] 5715 	srlw x 
                                   5716 ; x=acc16^x 
      001FAE 9E               [ 1] 5717 	ld a,xh 
      001FAF C8 00 0C         [ 1] 5718 	xor a,acc16 
      001FB2 95               [ 1] 5719 	ld xh,a 
      001FB3 9F               [ 1] 5720 	ld a,xl 
      001FB4 C8 00 0D         [ 1] 5721 	xor a,acc8 
      001FB7 97               [ 1] 5722 	ld xl,a 
                                   5723 ; seedy=x^seedy 
      001FB8 C8 00 15         [ 1] 5724 	xor a,seedy+1
      001FBB 97               [ 1] 5725 	ld xl,a 
      001FBC 9E               [ 1] 5726 	ld a,xh 
      001FBD C8 00 14         [ 1] 5727 	xor a,seedy
      001FC0 95               [ 1] 5728 	ld xh,a 
      001FC1 CF 00 14         [ 2] 5729 	ldw seedy,x 
                                   5730 ; return seedy modulo expr + 1 
      001FC4 90 85            [ 2] 5731 	popw y 
      001FC6 65               [ 2] 5732 	divw x,y 
      001FC7 93               [ 1] 5733 	ldw x,y 
      001FC8 5C               [ 2] 5734 	incw x 
      001FC9                       5735 10$:
      001FC9 A6 84            [ 1] 5736 	ld a,#TK_INTGR
      001FCB 81               [ 4] 5737 	ret 
                                   5738 
                                   5739 ;---------------------------------
                                   5740 ; BASIC: WORDS 
                                   5741 ; affiche la listes des mots du
                                   5742 ; dictionnaire ainsi que le nombre
                                   5743 ; de mots.
                                   5744 ;---------------------------------
                           000001  5745 	WLEN=1 ; word length
                           000002  5746 	LLEN=2 ; character sent to console
                           000003  5747 	WCNT=3 ; count words printed 
                           000003  5748 	VSIZE=3 
      001FCC                       5749 words:
      001FCC                       5750 	_vars VSIZE
      001FCC 52 03            [ 2]    1     sub sp,#VSIZE 
      001FCE 0F 02            [ 1] 5751 	clr (LLEN,sp)
      001FD0 0F 03            [ 1] 5752 	clr (WCNT,sp)
      001FD2 90 AE 26 B3      [ 2] 5753 	ldw y,#kword_dict+2
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 110.
Hexadecimal [24-Bits]



      001FD6 93               [ 1] 5754 0$:	ldw x,y
      001FD7 F6               [ 1] 5755 	ld a,(x)
      001FD8 A4 0F            [ 1] 5756 	and a,#15 
      001FDA 6B 01            [ 1] 5757 	ld (WLEN,sp),a 
      001FDC 0C 03            [ 1] 5758 	inc (WCNT,sp)
      001FDE 5C               [ 2] 5759 1$:	incw x 
      001FDF F6               [ 1] 5760 	ld a,(x)
      001FE0 CD 02 C0         [ 4] 5761 	call putc 
      001FE3 0C 02            [ 1] 5762 	inc (LLEN,sp)
      001FE5 0A 01            [ 1] 5763 	dec (WLEN,sp)
      001FE7 26 F5            [ 1] 5764 	jrne 1$
      001FE9 A6 46            [ 1] 5765 	ld a,#70
      001FEB 11 02            [ 1] 5766 	cp a,(LLEN,sp)
      001FED 2B 09            [ 1] 5767 	jrmi 2$   
      001FEF A6 20            [ 1] 5768 	ld a,#SPACE 
      001FF1 CD 02 C0         [ 4] 5769 	call putc 
      001FF4 0C 02            [ 1] 5770 	inc (LLEN,sp) 
      001FF6 20 07            [ 2] 5771 	jra 3$
      001FF8 A6 0D            [ 1] 5772 2$: ld a,#CR 
      001FFA CD 02 C0         [ 4] 5773 	call putc 
      001FFD 0F 02            [ 1] 5774 	clr (LLEN,sp)
      001FFF 72 A2 00 02      [ 2] 5775 3$:	subw y,#2 
      002003 90 FE            [ 2] 5776 	ldw y,(y)
      002005 26 CF            [ 1] 5777 	jrne 0$ 
      002007 A6 0D            [ 1] 5778 	ld a,#CR 
      002009 CD 02 C0         [ 4] 5779 	call putc  
      00200C 5F               [ 1] 5780 	clrw x 
      00200D 7B 03            [ 1] 5781 	ld a,(WCNT,sp)
      00200F 97               [ 1] 5782 	ld xl,a 
      002010 CD 09 CA         [ 4] 5783 	call print_int 
      002013 AE 20 1C         [ 2] 5784 	ldw x,#words_count_msg
      002016 CD 00 00         [ 4] 5785 	call puts 
      002019                       5786 	_drop VSIZE 
      002019 5B 03            [ 2]    1     addw sp,#VSIZE 
      00201B 81               [ 4] 5787 	ret 
      00201C 20 77 6F 72 64 73 20  5788 words_count_msg: .asciz " words in dictionary\n"
             69 6E 20 64 69 63 74
             69 6F 6E 61 72 79 0A
             00
                                   5789 
                                   5790 
                                   5791 ;-----------------------------
                                   5792 ; BASIC: TIMER expr 
                                   5793 ; initialize count down timer 
                                   5794 ;-----------------------------
      002032                       5795 set_timer:
      002032 CD 10 16         [ 4] 5796 	call arg_list
      002035 A1 01            [ 1] 5797 	cp a,#1 
      002037 27 03            [ 1] 5798 	jreq 1$
      002039 CC 08 7B         [ 2] 5799 	jp syntax_error
      00203C                       5800 1$: 
      00203C 85               [ 2] 5801 	popw x 
      00203D CF 00 10         [ 2] 5802 	ldw timer,x 
      002040 81               [ 4] 5803 	ret 
                                   5804 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 111.
Hexadecimal [24-Bits]



                                   5805 ;------------------------------
                                   5806 ; BASIC: TIMEOUT 
                                   5807 ; return state of timer 
                                   5808 ;------------------------------
      002041                       5809 timeout:
      002041 CE 00 10         [ 2] 5810 	ldw x,timer 
      002044                       5811 logical_complement:
      002044 53               [ 2] 5812 	cplw x 
      002045 A3 FF FF         [ 2] 5813 	cpw x,#-1
      002048 27 01            [ 1] 5814 	jreq 2$
      00204A 5F               [ 1] 5815 	clrw x 
      00204B A6 84            [ 1] 5816 2$:	ld a,#TK_INTGR
      00204D 81               [ 4] 5817 	ret 
                                   5818 
                                   5819 ;--------------------------------
                                   5820 ; BASIC NOT(expr) 
                                   5821 ; return logical complement of expr
                                   5822 ;--------------------------------
      00204E                       5823 func_not:
      00204E CD 10 11         [ 4] 5824 	call func_args  
      002051 A1 01            [ 1] 5825 	cp a,#1
      002053 27 03            [ 1] 5826 	jreq 1$
      002055 CC 08 7B         [ 2] 5827 	jp syntax_error
      002058 85               [ 2] 5828 1$:	popw x 
      002059 20 E9            [ 2] 5829 	jra logical_complement
                                   5830 
                                   5831 
                                   5832 
                                   5833 ;-----------------------------------
                                   5834 ; BASIC: IWDGEN expr1 
                                   5835 ; enable independant watchdog timer
                                   5836 ; expr1 is delay in multiple of 62.5µsec
                                   5837 ; expr1 -> {1..16383}
                                   5838 ;-----------------------------------
      00205B                       5839 enable_iwdg:
      00205B CD 10 16         [ 4] 5840 	call arg_list
      00205E A1 01            [ 1] 5841 	cp a,#1 
      002060 27 03            [ 1] 5842 	jreq 1$
      002062 CC 08 7B         [ 2] 5843 	jp syntax_error 
      002065 85               [ 2] 5844 1$: popw x 
      002066 4B 00            [ 1] 5845 	push #0
      002068 35 CC 50 E0      [ 1] 5846 	mov IWDG_KR,#IWDG_KEY_ENABLE
      00206C 9E               [ 1] 5847 	ld a,xh 
      00206D A4 3F            [ 1] 5848 	and a,#0x3f
      00206F 95               [ 1] 5849 	ld xh,a  
      002070 A3 00 FF         [ 2] 5850 2$:	cpw x,#255
      002073 23 06            [ 2] 5851 	jrule 3$
      002075 0C 01            [ 1] 5852 	inc (1,sp)
      002077 98               [ 1] 5853 	rcf 
      002078 56               [ 2] 5854 	rrcw x 
      002079 20 F5            [ 2] 5855 	jra 2$
      00207B 35 55 50 E0      [ 1] 5856 3$:	mov IWDG_KR,#IWDG_KEY_ACCESS 
      00207F 84               [ 1] 5857 	pop a  
      002080 C7 50 E1         [ 1] 5858 	ld IWDG_PR,a 
      002083 9F               [ 1] 5859 	ld a,xl
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 112.
Hexadecimal [24-Bits]



      002084 4A               [ 1] 5860 	dec a 
      002085 35 55 50 E0      [ 1] 5861 	mov IWDG_KR,#IWDG_KEY_ACCESS 
      002089 C7 50 E2         [ 1] 5862 	ld IWDG_RLR,a 
      00208C 35 AA 50 E0      [ 1] 5863 	mov IWDG_KR,#IWDG_KEY_REFRESH
      002090 81               [ 4] 5864 	ret 
                                   5865 
                                   5866 
                                   5867 ;-----------------------------------
                                   5868 ; BASIC: IWDGREF  
                                   5869 ; refresh independant watchdog count down 
                                   5870 ; timer before it reset MCU. 
                                   5871 ;-----------------------------------
      002091                       5872 refresh_iwdg:
      002091 35 AA 50 E0      [ 1] 5873 	mov IWDG_KR,#IWDG_KEY_REFRESH 
      002095 81               [ 4] 5874 	ret 
                                   5875 
                                   5876 
                                   5877 ;-------------------------------------
                                   5878 ; BASIC: LOG(expr)
                                   5879 ; return logarithm base 2 of expr 
                                   5880 ; this is the position of most significant
                                   5881 ; bit set. 
                                   5882 ; input: 
                                   5883 ; output:
                                   5884 ;   X     log2 
                                   5885 ;   A     TK_INTGR 
                                   5886 ;*********************************
      002096                       5887 log2:
      002096 CD 10 11         [ 4] 5888 	call func_args 
      002099 A1 01            [ 1] 5889 	cp a,#1 
      00209B 27 03            [ 1] 5890 	jreq 1$
      00209D CC 08 7B         [ 2] 5891 	jp syntax_error 
      0020A0 85               [ 2] 5892 1$: popw x 
      0020A1                       5893 leading_one:
      0020A1 5D               [ 2] 5894 	tnzw x 
      0020A2 27 0A            [ 1] 5895 	jreq 4$
      0020A4 A6 0F            [ 1] 5896 	ld a,#15 
      0020A6 59               [ 2] 5897 2$: rlcw x 
      0020A7 25 03            [ 1] 5898     jrc 3$
      0020A9 4A               [ 1] 5899 	dec a 
      0020AA 20 FA            [ 2] 5900 	jra 2$
      0020AC 5F               [ 1] 5901 3$: clrw x 
      0020AD 97               [ 1] 5902     ld xl,a
      0020AE A6 84            [ 1] 5903 4$:	ld a,#TK_INTGR
      0020B0 81               [ 4] 5904 	ret 
                                   5905 
                                   5906 ;-----------------------------------
                                   5907 ; BASIC: BIT(expr) 
                                   5908 ; expr ->{0..15}
                                   5909 ; return 2^expr 
                                   5910 ; output:
                                   5911 ;    x    2^expr 
                                   5912 ;-----------------------------------
      0020B1                       5913 bitmask:
      0020B1 CD 10 11         [ 4] 5914     call func_args 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 113.
Hexadecimal [24-Bits]



      0020B4 A1 01            [ 1] 5915 	cp a,#1
      0020B6 27 03            [ 1] 5916 	jreq 1$
      0020B8 CC 08 7B         [ 2] 5917 	jp syntax_error 
      0020BB 85               [ 2] 5918 1$: popw x 
      0020BC 9F               [ 1] 5919 	ld a,xl 
      0020BD A4 0F            [ 1] 5920 	and a,#15
      0020BF 5F               [ 1] 5921 	clrw x 
      0020C0 5C               [ 2] 5922 	incw x 
      0020C1 4D               [ 1] 5923 2$: tnz a 
      0020C2 27 04            [ 1] 5924 	jreq 3$
      0020C4 58               [ 2] 5925 	slaw x 
      0020C5 4A               [ 1] 5926 	dec a 
      0020C6 20 F9            [ 2] 5927 	jra 2$ 
      0020C8 A6 84            [ 1] 5928 3$: ld a,#TK_INTGR
      0020CA 81               [ 4] 5929 	ret 
                                   5930 
                                   5931 ;------------------------------
                                   5932 ; BASIC: INVERT(expr)
                                   5933 ; 1's complement 
                                   5934 ;--------------------------------
      0020CB                       5935 invert:
      0020CB CD 10 11         [ 4] 5936 	call func_args
      0020CE A1 01            [ 1] 5937 	cp a,#1 
      0020D0 27 03            [ 1] 5938 	jreq 1$
      0020D2 CC 08 7B         [ 2] 5939 	jp syntax_error
      0020D5 85               [ 2] 5940 1$: popw x  
      0020D6 53               [ 2] 5941 	cplw x 
      0020D7 A6 84            [ 1] 5942 	ld a,#TK_INTGR 
      0020D9 81               [ 4] 5943 	ret 
                                   5944 
                                   5945 ;------------------------------
                                   5946 ; BASIC: DO 
                                   5947 ; initiate a DO ... UNTIL loop 
                                   5948 ;------------------------------
                           000003  5949 	DOLP_ADR=3 
                           000005  5950 	DOLP_INW=5
                           000004  5951 	VSIZE=4 
      0020DA                       5952 do_loop:
      0020DA 85               [ 2] 5953 	popw x 
      0020DB                       5954 	_vars VSIZE 
      0020DB 52 04            [ 2]    1     sub sp,#VSIZE 
      0020DD 89               [ 2] 5955 	pushw x 
      0020DE 90 CE 00 04      [ 2] 5956 	ldw y,basicptr 
      0020E2 17 03            [ 2] 5957 	ldw (DOLP_ADR,sp),y
      0020E4 90 CE 00 00      [ 2] 5958 	ldw y,in.w 
      0020E8 17 05            [ 2] 5959 	ldw (DOLP_INW,sp),y
      0020EA 72 5C 00 20      [ 1] 5960 	inc loop_depth 
      0020EE 81               [ 4] 5961 	ret 
                                   5962 
                                   5963 ;--------------------------------
                                   5964 ; BASIC: UNTIL expr 
                                   5965 ; loop if exprssion is false 
                                   5966 ; else terminate loop
                                   5967 ;--------------------------------
      0020EF                       5968 until: 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 114.
Hexadecimal [24-Bits]



      0020EF 72 5D 00 20      [ 1] 5969 	tnz loop_depth 
      0020F3 26 03            [ 1] 5970 	jrne 1$ 
      0020F5 CC 08 7B         [ 2] 5971 	jp syntax_error 
      0020F8                       5972 1$: 
      0020F8 CD 11 58         [ 4] 5973 	call relation 
      0020FB A1 84            [ 1] 5974 	cp a,#TK_INTGR
      0020FD 27 03            [ 1] 5975 	jreq 2$
      0020FF CC 08 7B         [ 2] 5976 	jp syntax_error
      002102                       5977 2$: 
      002102 5D               [ 2] 5978 	tnzw x 
      002103 26 10            [ 1] 5979 	jrne 9$
      002105 1E 03            [ 2] 5980 	ldw x,(DOLP_ADR,sp)
      002107 CF 00 04         [ 2] 5981 	ldw basicptr,x 
      00210A E6 02            [ 1] 5982 	ld a,(2,x)
      00210C C7 00 03         [ 1] 5983 	ld count,a 
      00210F 1E 05            [ 2] 5984 	ldw x,(DOLP_INW,sp)
      002111 CF 00 00         [ 2] 5985 	ldw in.w,x 
      002114 81               [ 4] 5986 	ret 
      002115                       5987 9$:	; remove loop data from stack  
      002115 85               [ 2] 5988 	popw x
      002116                       5989 	_drop VSIZE
      002116 5B 04            [ 2]    1     addw sp,#VSIZE 
      002118 72 5A 00 20      [ 1] 5990 	dec loop_depth 
      00211C FC               [ 2] 5991 	jp (x)
                                   5992 
                                   5993 ;--------------------------
                                   5994 ; BASIC: PRTA...PRTI  
                                   5995 ;  return constant value 
                                   5996 ;  PORT  offset in GPIO
                                   5997 ;  array
                                   5998 ;---------------------------
      00211D                       5999 const_porta:
      00211D AE 00 00         [ 2] 6000 	ldw x,#0
      002120 A6 84            [ 1] 6001 	ld a,#TK_INTGR 
      002122 81               [ 4] 6002 	ret 
      002123                       6003 const_portb:
      002123 AE 00 01         [ 2] 6004 	ldw x,#1
      002126 A6 84            [ 1] 6005 	ld a,#TK_INTGR 
      002128 81               [ 4] 6006 	ret 
      002129                       6007 const_portc:
      002129 AE 00 02         [ 2] 6008 	ldw x,#2
      00212C A6 84            [ 1] 6009 	ld a,#TK_INTGR 
      00212E 81               [ 4] 6010 	ret 
      00212F                       6011 const_portd:
      00212F AE 00 03         [ 2] 6012 	ldw x,#3
      002132 A6 84            [ 1] 6013 	ld a,#TK_INTGR 
      002134 81               [ 4] 6014 	ret 
      002135                       6015 const_porte:
      002135 AE 00 04         [ 2] 6016 	ldw x,#4
      002138 A6 84            [ 1] 6017 	ld a,#TK_INTGR 
      00213A 81               [ 4] 6018 	ret 
      00213B                       6019 const_portf:
      00213B AE 00 05         [ 2] 6020 	ldw x,#5
      00213E A6 84            [ 1] 6021 	ld a,#TK_INTGR 
      002140 81               [ 4] 6022 	ret 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 115.
Hexadecimal [24-Bits]



      002141                       6023 const_portg:
      002141 AE 00 06         [ 2] 6024 	ldw x,#6
      002144 A6 84            [ 1] 6025 	ld a,#TK_INTGR 
      002146 81               [ 4] 6026 	ret 
      002147                       6027 const_porth:
      002147 AE 00 07         [ 2] 6028 	ldw x,#7
      00214A A6 84            [ 1] 6029 	ld a,#TK_INTGR 
      00214C 81               [ 4] 6030 	ret 
      00214D                       6031 const_porti:
      00214D AE 00 08         [ 2] 6032 	ldw x,#8
      002150 A6 84            [ 1] 6033 	ld a,#TK_INTGR 
      002152 81               [ 4] 6034 	ret 
                                   6035 
                                   6036 ;-------------------------------
                                   6037 ; following return constant 
                                   6038 ; related to GPIO register offset 
                                   6039 ;---------------------------------
      002153                       6040 const_odr:
      002153 A6 84            [ 1] 6041 	ld a,#TK_INTGR 
      002155 AE 00 00         [ 2] 6042 	ldw x,#GPIO_ODR
      002158 81               [ 4] 6043 	ret 
      002159                       6044 const_idr:
      002159 A6 84            [ 1] 6045 	ld a,#TK_INTGR 
      00215B AE 00 01         [ 2] 6046 	ldw x,#GPIO_IDR
      00215E 81               [ 4] 6047 	ret 
      00215F                       6048 const_ddr:
      00215F A6 84            [ 1] 6049 	ld a,#TK_INTGR 
      002161 AE 00 02         [ 2] 6050 	ldw x,#GPIO_DDR
      002164 81               [ 4] 6051 	ret 
      002165                       6052 const_cr1:
      002165 A6 84            [ 1] 6053 	ld a,#TK_INTGR 
      002167 AE 00 03         [ 2] 6054 	ldw x,#GPIO_CR1
      00216A 81               [ 4] 6055 	ret 
      00216B                       6056 const_cr2:
      00216B A6 84            [ 1] 6057 	ld a,#TK_INTGR 
      00216D AE 00 04         [ 2] 6058 	ldw x,#GPIO_CR2
      002170 81               [ 4] 6059 	ret 
                                   6060 ;-------------------------
                                   6061 ;  constant for port mode
                                   6062 ;  used by PMODE 
                                   6063 ;  input or output
                                   6064 ;------------------------
      002171                       6065 const_output:
      002171 A6 84            [ 1] 6066 	ld a,#TK_INTGR 
      002173 AE 00 01         [ 2] 6067 	ldw x,#OUTP
      002176 81               [ 4] 6068 	ret 
      002177                       6069 const_input:
      002177 A6 84            [ 1] 6070 	ld a,#TK_INTGR 
      002179 AE 00 00         [ 2] 6071 	ldw x,#INP 
      00217C 81               [ 4] 6072 	ret 
                                   6073 ;-----------------------
                                   6074 ; memory area constants
                                   6075 ;-----------------------
      00217D                       6076 const_eeprom_base:
      00217D A6 84            [ 1] 6077 	ld a,#TK_INTGR 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 116.
Hexadecimal [24-Bits]



      00217F AE 40 00         [ 2] 6078 	ldw x,#EEPROM_BASE 
      002182 81               [ 4] 6079 	ret 
                                   6080 
                                   6081 ;---------------------------
                                   6082 ; BASIC: DATA 
                                   6083 ; when the interpreter find 
                                   6084 ; a DATA line it skip it.
                                   6085 ;---------------------------
      002183                       6086 data:
      002183 55 00 03 00 01   [ 1] 6087 	mov in,count 
      002188 81               [ 4] 6088 	ret 
                                   6089 
                                   6090 ;---------------------------
                                   6091 ; BASIC: DATLN  *expr*
                                   6092 ; set DATA pointer at line# 
                                   6093 ; specified by *expr* 
                                   6094 ;---------------------------
      002189                       6095 data_line:
      002189 CD 11 0F         [ 4] 6096 	call expression
      00218C A1 84            [ 1] 6097 	cp a,#TK_INTGR
      00218E 27 03            [ 1] 6098 	jreq 1$
      002190 CC 08 7B         [ 2] 6099 	jp syntax_error 
      002193 CD 04 04         [ 4] 6100 1$: call search_lineno
      002196 5D               [ 2] 6101 	tnzw x 
      002197 26 05            [ 1] 6102 	jrne 3$
      002199 A6 05            [ 1] 6103 2$:	ld a,#ERR_NO_LINE 
      00219B CC 08 7D         [ 2] 6104 	jp tb_error
      00219E                       6105 3$: ; check if valid data line 
      00219E 90 93            [ 1] 6106     ldw y,x 
      0021A0 EE 04            [ 2] 6107 	ldw x,(4,x)
      0021A2 A3 21 83         [ 2] 6108 	cpw x,#data 
      0021A5 26 F2            [ 1] 6109 	jrne 2$ 
      0021A7 90 CF 00 06      [ 2] 6110 	ldw data_ptr,y
      0021AB 90 E6 02         [ 1] 6111 	ld a,(2,y)
      0021AE C7 00 09         [ 1] 6112 	ld data_len,a 
      0021B1 35 06 00 08      [ 1] 6113 	mov data_ofs,#FIRST_DATA_ITEM 
      0021B5 81               [ 4] 6114 	ret
                                   6115 
                                   6116 ;---------------------------------
                                   6117 ; BASIC: RESTORE 
                                   6118 ; set data_ptr to first data line
                                   6119 ; if not DATA found pointer set to
                                   6120 ; zero 
                                   6121 ;---------------------------------
      0021B6                       6122 restore:
      0021B6 72 5F 00 06      [ 1] 6123 	clr data_ptr 
      0021BA 72 5F 00 07      [ 1] 6124 	clr data_ptr+1
      0021BE 72 5F 00 08      [ 1] 6125 	clr data_ofs 
      0021C2 72 5F 00 09      [ 1] 6126 	clr data_len
      0021C6 CE 00 1C         [ 2] 6127 	ldw x,txtbgn
      0021C9                       6128 data_search_loop: 	
      0021C9 C3 00 1E         [ 2] 6129 	cpw x,txtend
      0021CC 24 17            [ 1] 6130 	jruge 9$
      0021CE 90 93            [ 1] 6131 	ldw y,x 
      0021D0 EE 04            [ 2] 6132 	ldw x,(4,x)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 117.
Hexadecimal [24-Bits]



      0021D2 A3 21 83         [ 2] 6133 	cpw x,#data 
      0021D5 26 1A            [ 1] 6134 	jrne try_next_line 
      0021D7 90 CF 00 06      [ 2] 6135 	ldw data_ptr,y 
      0021DB 90 E6 02         [ 1] 6136 	ld a,(2,y)
      0021DE C7 00 09         [ 1] 6137 	ld data_len,a 
      0021E1 35 06 00 08      [ 1] 6138 	mov data_ofs,#FIRST_DATA_ITEM
      0021E5 72 5D 00 09      [ 1] 6139 9$:	tnz data_len 
      0021E9 26 05            [ 1] 6140     jrne 10$
      0021EB A6 0C            [ 1] 6141 	ld a,#ERR_NO_DATA 
      0021ED CC 08 7D         [ 2] 6142 	jp tb_error 
      0021F0 81               [ 4] 6143 10$:ret
      0021F1                       6144 try_next_line:
      0021F1 93               [ 1] 6145 	ldw x,y 
      0021F2 E6 02            [ 1] 6146 	ld a,(2,x)
      0021F4 C7 00 0D         [ 1] 6147 	ld acc8,a 
      0021F7 72 5F 00 0C      [ 1] 6148 	clr acc16 
      0021FB 72 BB 00 0C      [ 2] 6149 	addw x,acc16 
      0021FF 20 C8            [ 2] 6150 	jra data_search_loop
                                   6151 
                                   6152 
                                   6153 ;---------------------------------
                                   6154 ; BASIC: READ 
                                   6155 ; return next data item | 0 
                                   6156 ;---------------------------------
                           000001  6157 	CTX_BPTR=1 
                           000003  6158 	CTX_IN=3 
                           000004  6159 	CTX_COUNT=4 
                           000005  6160 	XSAVE=5
                           000006  6161 	VSIZE=6
      002201                       6162 read:
      002201                       6163 	_vars  VSIZE 
      002201 52 06            [ 2]    1     sub sp,#VSIZE 
      002203                       6164 read01:	
      002203 C6 00 08         [ 1] 6165 	ld a,data_ofs
      002206 C1 00 09         [ 1] 6166 	cp a,data_len 
      002209 27 37            [ 1] 6167 	jreq 2$ ; end of line  
      00220B CD 15 6D         [ 4] 6168 	call save_context
      00220E CE 00 06         [ 2] 6169 	ldw x,data_ptr 
      002211 CF 00 04         [ 2] 6170 	ldw basicptr,x 
      002214 55 00 08 00 01   [ 1] 6171 	mov in,data_ofs 
      002219 55 00 09 00 03   [ 1] 6172 	mov count,data_len  
      00221E CD 11 0F         [ 4] 6173 	call expression 
      002221 A1 84            [ 1] 6174 	cp a,#TK_INTGR 
      002223 27 03            [ 1] 6175 	jreq 1$ 
      002225 CC 08 7B         [ 2] 6176 	jp syntax_error 
      002228                       6177 1$:
      002228 1F 05            [ 2] 6178 	ldw (XSAVE,SP),x
      00222A CD 09 6D         [ 4] 6179 	call next_token ; skip comma
      00222D CE 00 04         [ 2] 6180 	ldw x,basicptr 
      002230 CF 00 06         [ 2] 6181 	ldw data_ptr,x 
      002233 55 00 01 00 08   [ 1] 6182 	mov data_ofs,in 
      002238 CD 15 7D         [ 4] 6183 	call rest_context
      00223B 1E 05            [ 2] 6184 	ldw x,(XSAVE,sp)
      00223D A6 84            [ 1] 6185 	ld a,#TK_INTGR
      00223F                       6186 	_drop VSIZE 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 118.
Hexadecimal [24-Bits]



      00223F 5B 06            [ 2]    1     addw sp,#VSIZE 
      002241 81               [ 4] 6187 	ret 
      002242                       6188 2$: ; end of line reached 
      002242 90 CE 00 06      [ 2] 6189 	ldw y, data_ptr 
      002246 72 5F 00 06      [ 1] 6190 	clr data_ptr
      00224A 72 5F 00 07      [ 1] 6191 	clr data_ptr+1   
      00224E 72 5F 00 08      [ 1] 6192 	clr data_ofs 
      002252 72 5F 00 09      [ 1] 6193 	clr data_len 
      002256 CD 21 F1         [ 4] 6194 	call try_next_line 
      002259 20 A8            [ 2] 6195 	jra read01
                                   6196 
                                   6197 
                                   6198 ;---------------------------------
                                   6199 ; BASIC: SPIEN clkdiv, 0|1  
                                   6200 ; clkdiv -> {0..7} Fspi=Fclk/2^(n+1)
                                   6201 ; if clkdiv==-1 disable SPI
                                   6202 ; 0|1 -> disable|enable  
                                   6203 ;--------------------------------- 
                           000005  6204 SPI_CS_BIT=5
      00225B                       6205 spi_enable:
      00225B CD 10 16         [ 4] 6206 	call arg_list 
      00225E A1 02            [ 1] 6207 	cp a,#2
      002260 27 03            [ 1] 6208 	jreq 1$
      002262 CC 08 7B         [ 2] 6209 	jp syntax_error 
      002265                       6210 1$: 
      002265 72 12 50 C7      [ 1] 6211 	bset CLK_PCKENR1,#CLK_PCKENR1_SPI ; enable clock signal 
      002269 85               [ 2] 6212 	popw x  
      00226A 5D               [ 2] 6213 	tnzw x 
      00226B 27 21            [ 1] 6214 	jreq spi_disable 
      00226D 85               [ 2] 6215 	popw x 
      00226E A6 08            [ 1] 6216 	ld a,#(1<<SPI_CR1_BR)
      002270 42               [ 4] 6217 	mul x,a 
      002271 9F               [ 1] 6218 	ld a,xl 
      002272 C7 52 00         [ 1] 6219 	ld SPI_CR1,a 
                                   6220 ; configure ~CS on PE5 (D10 on CN8) as output. 
      002275 72 1A 50 14      [ 1] 6221 	bset PE_ODR,#SPI_CS_BIT	; set ~CS high  
      002279 72 1A 50 16      [ 1] 6222 	bset PE_DDR,#SPI_CS_BIT  ; pin as output 
                                   6223 ; configure SPI as master mode 0.	
      00227D 72 14 52 00      [ 1] 6224 	bset SPI_CR1,#SPI_CR1_MSTR
                                   6225 ; ~CS line controlled by sofware 	
      002281 72 12 52 01      [ 1] 6226 	bset SPI_CR2,#SPI_CR2_SSM 
      002285 72 10 52 01      [ 1] 6227     bset SPI_CR2,#SPI_CR2_SSI 
                                   6228 ; enable SPI
      002289 72 1C 52 00      [ 1] 6229 	bset SPI_CR1,#SPI_CR1_SPE 	
      00228D 81               [ 4] 6230 	ret 
      00228E                       6231 spi_disable:
      00228E                       6232 	_drop #2; throw first argument.
      00228E 5B 02            [ 2]    1     addw sp,##2 
                                   6233 ; wait spi idle 
      002290 A6 82            [ 1] 6234 1$:	ld a,#0x82 
      002292 C4 52 03         [ 1] 6235 	and a,SPI_SR
      002295 A1 02            [ 1] 6236 	cp a,#2 
      002297 26 F7            [ 1] 6237 	jrne 1$
      002299 72 1D 52 00      [ 1] 6238 	bres SPI_CR1,#SPI_CR1_SPE
      00229D 72 13 50 C7      [ 1] 6239 	bres CLK_PCKENR1,#CLK_PCKENR1_SPI 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 119.
Hexadecimal [24-Bits]



      0022A1 72 1B 50 16      [ 1] 6240 	bres PE_DDR,#SPI_CS_BIT 
      0022A5 81               [ 4] 6241 	ret 
                                   6242 
      0022A6                       6243 spi_clear_error:
      0022A6 A6 78            [ 1] 6244 	ld a,#0x78 
      0022A8 C5 52 03         [ 1] 6245 	bcp a,SPI_SR 
      0022AB 27 04            [ 1] 6246 	jreq 1$
      0022AD 72 5F 52 03      [ 1] 6247 	clr SPI_SR 
      0022B1 81               [ 4] 6248 1$: ret 
                                   6249 
      0022B2                       6250 spi_send_byte:
      0022B2 88               [ 1] 6251 	push a 
      0022B3 CD 22 A6         [ 4] 6252 	call spi_clear_error
      0022B6 84               [ 1] 6253 	pop a 
      0022B7 72 03 52 03 FB   [ 2] 6254 	btjf SPI_SR,#SPI_SR_TXE,.
      0022BC C7 52 04         [ 1] 6255 	ld SPI_DR,a
      0022BF 72 01 52 03 FB   [ 2] 6256 	btjf SPI_SR,#SPI_SR_RXNE,.  
      0022C4 C6 52 04         [ 1] 6257 	ld a,SPI_DR 
      0022C7 81               [ 4] 6258 	ret 
                                   6259 
      0022C8                       6260 spi_rcv_byte:
      0022C8 A6 FF            [ 1] 6261 	ld a,#255
      0022CA 72 01 52 03 E3   [ 2] 6262 	btjf SPI_SR,#SPI_SR_RXNE,spi_send_byte 
      0022CF C6 52 04         [ 1] 6263 	ld a,SPI_DR 
      0022D2 81               [ 4] 6264 	ret
                                   6265 
                                   6266 ;------------------------------
                                   6267 ; BASIC: SPIWR byte [,byte]
                                   6268 ; write 1 or more byte
                                   6269 ;------------------------------
      0022D3                       6270 spi_write:
      0022D3 CD 11 0F         [ 4] 6271 	call expression
      0022D6 A1 84            [ 1] 6272 	cp a,#TK_INTGR 
      0022D8 27 03            [ 1] 6273 	jreq 1$
      0022DA CC 08 7B         [ 2] 6274 	jp syntax_error 
      0022DD                       6275 1$:	
      0022DD 9F               [ 1] 6276 	ld a,xl 
      0022DE CD 22 B2         [ 4] 6277 	call spi_send_byte 
      0022E1 CD 09 6D         [ 4] 6278 	call next_token 
      0022E4 A1 09            [ 1] 6279 	cp a,#TK_COMMA 
      0022E6 26 02            [ 1] 6280 	jrne 2$ 
      0022E8 20 E9            [ 2] 6281 	jra spi_write 
      0022EA 4D               [ 1] 6282 2$:	tnz a 
      0022EB 27 05            [ 1] 6283 	jreq 3$
      0022ED                       6284 	_unget_token  
      0022ED 55 00 02 00 01   [ 1]    1     mov in,in.saved
      0022F2 81               [ 4] 6285 3$:	ret 
                                   6286 
                                   6287 
                                   6288 ;-------------------------------
                                   6289 ; BASIC: SPIRD 	
                                   6290 ; read one byte from SPI 
                                   6291 ;-------------------------------
      0022F3                       6292 spi_read:
      0022F3 CD 22 C8         [ 4] 6293 	call spi_rcv_byte 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 120.
Hexadecimal [24-Bits]



      0022F6 5F               [ 1] 6294 	clrw x 
      0022F7 97               [ 1] 6295 	ld xl,a 
      0022F8 A6 84            [ 1] 6296 	ld a,#TK_INTGR 
      0022FA 81               [ 4] 6297 	ret 
                                   6298 
                                   6299 ;------------------------------
                                   6300 ; BASIC: SPISEL 0|1 
                                   6301 ; set state of ~CS line
                                   6302 ; 0|1 deselect|select  
                                   6303 ;------------------------------
      0022FB                       6304 spi_select:
      0022FB CD 09 6D         [ 4] 6305 	call next_token 
      0022FE A1 84            [ 1] 6306 	cp a,#TK_INTGR 
      002300 27 03            [ 1] 6307 	jreq 1$
      002302 CC 08 7B         [ 2] 6308 	jp syntax_error 
      002305 5D               [ 2] 6309 1$: tnzw x  
      002306 27 05            [ 1] 6310 	jreq cs_high 
      002308 72 1B 50 14      [ 1] 6311 	bres PE_ODR,#SPI_CS_BIT
      00230C 81               [ 4] 6312 	ret 
      00230D                       6313 cs_high: 
      00230D 72 1A 50 14      [ 1] 6314 	bset PE_ODR,#SPI_CS_BIT
      002311 81               [ 4] 6315 	ret 
                                   6316 
                                   6317 
                                   6318 ;-------------------------------
                                   6319 ; BASIC: PAD 
                                   6320 ; Return pad buffer address.
                                   6321 ;------------------------------
      002312                       6322 pad_ref:
      002312 AE 16 E0         [ 2] 6323 	ldw x,#pad 
      002315 B6 84            [ 1] 6324 	ld a,TK_INTGR
      002317 81               [ 4] 6325 	ret 
                                   6326 
                                   6327 ;------------------------------
                                   6328 ;      dictionary 
                                   6329 ; format:
                                   6330 ;   link:   2 bytes 
                                   6331 ;   name_length+flags:  1 byte, bits 0:4 lenght,5:8 flags  
                                   6332 ;   cmd_name: 16 byte max 
                                   6333 ;   cmd_index: 2 bytes 
                                   6334 ;------------------------------
                                   6335 	.macro _dict_entry len,name,cmd_idx 
                                   6336 	.word LINK 
                                   6337 	LINK=.
                                   6338 name:
                                   6339 	.byte len 	
                                   6340 	.ascii "name"
                                   6341 	.word cmd_idx 
                                   6342 	.endm 
                                   6343 
                           000000  6344 	LINK=0
                                   6345 ; respect alphabetic order for BASIC names from Z-A
                                   6346 ; this sort order is for a cleaner WORDS cmd output. 	
      002318                       6347 kword_end:
      002318                       6348 	_dict_entry,3+F_IFUNC,XOR,XOR_IDX;bit_xor
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 121.
Hexadecimal [24-Bits]



      002318 00 00                    1 	.word LINK 
                           00231A     2 	LINK=.
      00231A                          3 XOR:
      00231A 43                       4 	.byte 3+F_IFUNC 	
      00231B 58 4F 52                 5 	.ascii "XOR"
      00231E 00 C6                    6 	.word XOR_IDX 
      002320                       6349 	_dict_entry,5,WRITE,WRITE_IDX;write  
      002320 23 1A                    1 	.word LINK 
                           002322     2 	LINK=.
      002322                          3 WRITE:
      002322 05                       4 	.byte 5 	
      002323 57 52 49 54 45           5 	.ascii "WRITE"
      002328 00 C4                    6 	.word WRITE_IDX 
      00232A                       6350 	_dict_entry,5,WORDS,WORDS_IDX;words 
      00232A 23 22                    1 	.word LINK 
                           00232C     2 	LINK=.
      00232C                          3 WORDS:
      00232C 05                       4 	.byte 5 	
      00232D 57 4F 52 44 53           5 	.ascii "WORDS"
      002332 00 C2                    6 	.word WORDS_IDX 
      002334                       6351 	_dict_entry 4,WAIT,WAIT_IDX;wait 
      002334 23 2C                    1 	.word LINK 
                           002336     2 	LINK=.
      002336                          3 WAIT:
      002336 04                       4 	.byte 4 	
      002337 57 41 49 54              5 	.ascii "WAIT"
      00233B 00 C0                    6 	.word WAIT_IDX 
      00233D                       6352 	_dict_entry,3+F_IFUNC,USR,USR_IDX;usr
      00233D 23 36                    1 	.word LINK 
                           00233F     2 	LINK=.
      00233F                          3 USR:
      00233F 43                       4 	.byte 3+F_IFUNC 	
      002340 55 53 52                 5 	.ascii "USR"
      002343 00 BE                    6 	.word USR_IDX 
      002345                       6353 	_dict_entry,5,UNTIL,UNTIL_IDX;until 
      002345 23 3F                    1 	.word LINK 
                           002347     2 	LINK=.
      002347                          3 UNTIL:
      002347 05                       4 	.byte 5 	
      002348 55 4E 54 49 4C           5 	.ascii "UNTIL"
      00234D 00 BC                    6 	.word UNTIL_IDX 
      00234F                       6354 	_dict_entry,6+F_IFUNC,UFLASH,UFLASH_IDX;uflash 
      00234F 23 47                    1 	.word LINK 
                           002351     2 	LINK=.
      002351                          3 UFLASH:
      002351 46                       4 	.byte 6+F_IFUNC 	
      002352 55 46 4C 41 53 48        5 	.ascii "UFLASH"
      002358 00 BA                    6 	.word UFLASH_IDX 
      00235A                       6355 	_dict_entry,6+F_IFUNC,UBOUND,UBOUND_IDX;ubound 
      00235A 23 51                    1 	.word LINK 
                           00235C     2 	LINK=.
      00235C                          3 UBOUND:
      00235C 46                       4 	.byte 6+F_IFUNC 	
      00235D 55 42 4F 55 4E 44        5 	.ascii "UBOUND"
      002363 00 B8                    6 	.word UBOUND_IDX 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 122.
Hexadecimal [24-Bits]



      002365                       6356 	_dict_entry,4,TONE,TONE_IDX;tone  
      002365 23 5C                    1 	.word LINK 
                           002367     2 	LINK=.
      002367                          3 TONE:
      002367 04                       4 	.byte 4 	
      002368 54 4F 4E 45              5 	.ascii "TONE"
      00236C 00 B6                    6 	.word TONE_IDX 
      00236E                       6357 	_dict_entry,2,TO,TO_IDX;to
      00236E 23 67                    1 	.word LINK 
                           002370     2 	LINK=.
      002370                          3 TO:
      002370 02                       4 	.byte 2 	
      002371 54 4F                    5 	.ascii "TO"
      002373 00 B4                    6 	.word TO_IDX 
      002375                       6358 	_dict_entry,7+F_IFUNC,TIMEOUT,TMROUT_IDX;timeout 
      002375 23 70                    1 	.word LINK 
                           002377     2 	LINK=.
      002377                          3 TIMEOUT:
      002377 47                       4 	.byte 7+F_IFUNC 	
      002378 54 49 4D 45 4F 55 54     5 	.ascii "TIMEOUT"
      00237F 00 B2                    6 	.word TMROUT_IDX 
      002381                       6359 	_dict_entry,5,TIMER,TIMER_IDX;set_timer
      002381 23 77                    1 	.word LINK 
                           002383     2 	LINK=.
      002383                          3 TIMER:
      002383 05                       4 	.byte 5 	
      002384 54 49 4D 45 52           5 	.ascii "TIMER"
      002389 00 B0                    6 	.word TIMER_IDX 
      00238B                       6360 	_dict_entry,5+F_IFUNC,TICKS,TICKS_IDX;get_ticks
      00238B 23 83                    1 	.word LINK 
                           00238D     2 	LINK=.
      00238D                          3 TICKS:
      00238D 45                       4 	.byte 5+F_IFUNC 	
      00238E 54 49 43 4B 53           5 	.ascii "TICKS"
      002393 00 AE                    6 	.word TICKS_IDX 
      002395                       6361 	_dict_entry,4,STOP,STOP_IDX;stop 
      002395 23 8D                    1 	.word LINK 
                           002397     2 	LINK=.
      002397                          3 STOP:
      002397 04                       4 	.byte 4 	
      002398 53 54 4F 50              5 	.ascii "STOP"
      00239C 00 AC                    6 	.word STOP_IDX 
      00239E                       6362 	_dict_entry,4,STEP,STEP_IDX;step 
      00239E 23 97                    1 	.word LINK 
                           0023A0     2 	LINK=.
      0023A0                          3 STEP:
      0023A0 04                       4 	.byte 4 	
      0023A1 53 54 45 50              5 	.ascii "STEP"
      0023A5 00 AA                    6 	.word STEP_IDX 
      0023A7                       6363 	_dict_entry,5,SPIWR,SPIWR_IDX;spi_write
      0023A7 23 A0                    1 	.word LINK 
                           0023A9     2 	LINK=.
      0023A9                          3 SPIWR:
      0023A9 05                       4 	.byte 5 	
      0023AA 53 50 49 57 52           5 	.ascii "SPIWR"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 123.
Hexadecimal [24-Bits]



      0023AF 00 A8                    6 	.word SPIWR_IDX 
      0023B1                       6364 	_dict_entry,6,SPISEL,SPISEL_IDX;spi_select
      0023B1 23 A9                    1 	.word LINK 
                           0023B3     2 	LINK=.
      0023B3                          3 SPISEL:
      0023B3 06                       4 	.byte 6 	
      0023B4 53 50 49 53 45 4C        5 	.ascii "SPISEL"
      0023BA 00 A6                    6 	.word SPISEL_IDX 
      0023BC                       6365 	_dict_entry,5,SPIEN,SPIEN_IDX;spi_enable 
      0023BC 23 B3                    1 	.word LINK 
                           0023BE     2 	LINK=.
      0023BE                          3 SPIEN:
      0023BE 05                       4 	.byte 5 	
      0023BF 53 50 49 45 4E           5 	.ascii "SPIEN"
      0023C4 00 A4                    6 	.word SPIEN_IDX 
      0023C6                       6366 	_dict_entry,5+F_IFUNC,SPIRD,SPIRD_IDX; spi_read 
      0023C6 23 BE                    1 	.word LINK 
                           0023C8     2 	LINK=.
      0023C8                          3 SPIRD:
      0023C8 45                       4 	.byte 5+F_IFUNC 	
      0023C9 53 50 49 52 44           5 	.ascii "SPIRD"
      0023CE 00 A2                    6 	.word SPIRD_IDX 
      0023D0                       6367 	_dict_entry,5,SLEEP,SLEEP_IDX;sleep 
      0023D0 23 C8                    1 	.word LINK 
                           0023D2     2 	LINK=.
      0023D2                          3 SLEEP:
      0023D2 05                       4 	.byte 5 	
      0023D3 53 4C 45 45 50           5 	.ascii "SLEEP"
      0023D8 00 A0                    6 	.word SLEEP_IDX 
      0023DA                       6368 	_dict_entry,4+F_IFUNC,SIZE,SIZE_IDX;size
      0023DA 23 D2                    1 	.word LINK 
                           0023DC     2 	LINK=.
      0023DC                          3 SIZE:
      0023DC 44                       4 	.byte 4+F_IFUNC 	
      0023DD 53 49 5A 45              5 	.ascii "SIZE"
      0023E1 00 9E                    6 	.word SIZE_IDX 
      0023E3                       6369     _dict_entry,4,SHOW,SHOW_IDX;show 
      0023E3 23 DC                    1 	.word LINK 
                           0023E5     2 	LINK=.
      0023E5                          3 SHOW:
      0023E5 04                       4 	.byte 4 	
      0023E6 53 48 4F 57              5 	.ascii "SHOW"
      0023EA 00 9C                    6 	.word SHOW_IDX 
      0023EC                       6370 	_dict_entry,4,SAVE,SAVE_IDX;save
      0023EC 23 E5                    1 	.word LINK 
                           0023EE     2 	LINK=.
      0023EE                          3 SAVE:
      0023EE 04                       4 	.byte 4 	
      0023EF 53 41 56 45              5 	.ascii "SAVE"
      0023F3 00 9A                    6 	.word SAVE_IDX 
      0023F5                       6371 	_dict_entry 3,RUN,RUN_IDX;run
      0023F5 23 EE                    1 	.word LINK 
                           0023F7     2 	LINK=.
      0023F7                          3 RUN:
      0023F7 03                       4 	.byte 3 	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 124.
Hexadecimal [24-Bits]



      0023F8 52 55 4E                 5 	.ascii "RUN"
      0023FB 00 98                    6 	.word RUN_IDX 
      0023FD                       6372 	_dict_entry,6+F_IFUNC,RSHIFT,RSHIFT_IDX;rshift
      0023FD 23 F7                    1 	.word LINK 
                           0023FF     2 	LINK=.
      0023FF                          3 RSHIFT:
      0023FF 46                       4 	.byte 6+F_IFUNC 	
      002400 52 53 48 49 46 54        5 	.ascii "RSHIFT"
      002406 00 96                    6 	.word RSHIFT_IDX 
      002408                       6373 	_dict_entry,3+F_IFUNC,RND,RND_IDX;random 
      002408 23 FF                    1 	.word LINK 
                           00240A     2 	LINK=.
      00240A                          3 RND:
      00240A 43                       4 	.byte 3+F_IFUNC 	
      00240B 52 4E 44                 5 	.ascii "RND"
      00240E 00 94                    6 	.word RND_IDX 
      002410                       6374 	_dict_entry,6,RETURN,RET_IDX;return 
      002410 24 0A                    1 	.word LINK 
                           002412     2 	LINK=.
      002412                          3 RETURN:
      002412 06                       4 	.byte 6 	
      002413 52 45 54 55 52 4E        5 	.ascii "RETURN"
      002419 00 92                    6 	.word RET_IDX 
      00241B                       6375 	_dict_entry,7,RESTORE,REST_IDX;restore 
      00241B 24 12                    1 	.word LINK 
                           00241D     2 	LINK=.
      00241D                          3 RESTORE:
      00241D 07                       4 	.byte 7 	
      00241E 52 45 53 54 4F 52 45     5 	.ascii "RESTORE"
      002425 00 90                    6 	.word REST_IDX 
      002427                       6376 	_dict_entry 6,REMARK,REM_IDX;remark 
      002427 24 1D                    1 	.word LINK 
                           002429     2 	LINK=.
      002429                          3 REMARK:
      002429 06                       4 	.byte 6 	
      00242A 52 45 4D 41 52 4B        5 	.ascii "REMARK"
      002430 00 8E                    6 	.word REM_IDX 
      002432                       6377 	_dict_entry,6,REBOOT,RBT_IDX;cold_start
      002432 24 29                    1 	.word LINK 
                           002434     2 	LINK=.
      002434                          3 REBOOT:
      002434 06                       4 	.byte 6 	
      002435 52 45 42 4F 4F 54        5 	.ascii "REBOOT"
      00243B 00 8C                    6 	.word RBT_IDX 
      00243D                       6378 	_dict_entry,4+F_IFUNC,READ,READ_IDX;read  
      00243D 24 34                    1 	.word LINK 
                           00243F     2 	LINK=.
      00243F                          3 READ:
      00243F 44                       4 	.byte 4+F_IFUNC 	
      002440 52 45 41 44              5 	.ascii "READ"
      002444 00 8A                    6 	.word READ_IDX 
      002446                       6379 	_dict_entry,4+F_IFUNC,QKEY,QKEY_IDX;qkey  
      002446 24 3F                    1 	.word LINK 
                           002448     2 	LINK=.
      002448                          3 QKEY:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 125.
Hexadecimal [24-Bits]



      002448 44                       4 	.byte 4+F_IFUNC 	
      002449 51 4B 45 59              5 	.ascii "QKEY"
      00244D 00 88                    6 	.word QKEY_IDX 
      00244F                       6380 	_dict_entry,4+F_IFUNC,PRTI,PRTI_IDX;const_porti 
      00244F 24 48                    1 	.word LINK 
                           002451     2 	LINK=.
      002451                          3 PRTI:
      002451 44                       4 	.byte 4+F_IFUNC 	
      002452 50 52 54 49              5 	.ascii "PRTI"
      002456 00 86                    6 	.word PRTI_IDX 
      002458                       6381 	_dict_entry,4+F_IFUNC,PRTH,PRTH_IDX;const_porth 
      002458 24 51                    1 	.word LINK 
                           00245A     2 	LINK=.
      00245A                          3 PRTH:
      00245A 44                       4 	.byte 4+F_IFUNC 	
      00245B 50 52 54 48              5 	.ascii "PRTH"
      00245F 00 84                    6 	.word PRTH_IDX 
      002461                       6382 	_dict_entry,4+F_IFUNC,PRTG,PRTG_IDX;const_portg 
      002461 24 5A                    1 	.word LINK 
                           002463     2 	LINK=.
      002463                          3 PRTG:
      002463 44                       4 	.byte 4+F_IFUNC 	
      002464 50 52 54 47              5 	.ascii "PRTG"
      002468 00 82                    6 	.word PRTG_IDX 
      00246A                       6383 	_dict_entry,4+F_IFUNC,PRTF,PRTF_IDX;const_portf
      00246A 24 63                    1 	.word LINK 
                           00246C     2 	LINK=.
      00246C                          3 PRTF:
      00246C 44                       4 	.byte 4+F_IFUNC 	
      00246D 50 52 54 46              5 	.ascii "PRTF"
      002471 00 80                    6 	.word PRTF_IDX 
      002473                       6384 	_dict_entry,4+F_IFUNC,PRTE,PRTE_IDX;const_porte
      002473 24 6C                    1 	.word LINK 
                           002475     2 	LINK=.
      002475                          3 PRTE:
      002475 44                       4 	.byte 4+F_IFUNC 	
      002476 50 52 54 45              5 	.ascii "PRTE"
      00247A 00 7E                    6 	.word PRTE_IDX 
      00247C                       6385 	_dict_entry,4+F_IFUNC,PRTD,PRTD_IDX;const_portd
      00247C 24 75                    1 	.word LINK 
                           00247E     2 	LINK=.
      00247E                          3 PRTD:
      00247E 44                       4 	.byte 4+F_IFUNC 	
      00247F 50 52 54 44              5 	.ascii "PRTD"
      002483 00 7C                    6 	.word PRTD_IDX 
      002485                       6386 	_dict_entry,4+F_IFUNC,PRTC,PRTC_IDX;const_portc
      002485 24 7E                    1 	.word LINK 
                           002487     2 	LINK=.
      002487                          3 PRTC:
      002487 44                       4 	.byte 4+F_IFUNC 	
      002488 50 52 54 43              5 	.ascii "PRTC"
      00248C 00 7A                    6 	.word PRTC_IDX 
      00248E                       6387 	_dict_entry,4+F_IFUNC,PRTB,PRTB_IDX;const_portb
      00248E 24 87                    1 	.word LINK 
                           002490     2 	LINK=.
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 126.
Hexadecimal [24-Bits]



      002490                          3 PRTB:
      002490 44                       4 	.byte 4+F_IFUNC 	
      002491 50 52 54 42              5 	.ascii "PRTB"
      002495 00 78                    6 	.word PRTB_IDX 
      002497                       6388 	_dict_entry,4+F_IFUNC,PRTA,PRTA_IDX;const_porta 
      002497 24 90                    1 	.word LINK 
                           002499     2 	LINK=.
      002499                          3 PRTA:
      002499 44                       4 	.byte 4+F_IFUNC 	
      00249A 50 52 54 41              5 	.ascii "PRTA"
      00249E 00 76                    6 	.word PRTA_IDX 
      0024A0                       6389 	_dict_entry 5,PRINT,PRT_IDX;print 
      0024A0 24 99                    1 	.word LINK 
                           0024A2     2 	LINK=.
      0024A2                          3 PRINT:
      0024A2 05                       4 	.byte 5 	
      0024A3 50 52 49 4E 54           5 	.ascii "PRINT"
      0024A8 00 74                    6 	.word PRT_IDX 
      0024AA                       6390 	_dict_entry,4+F_IFUNC,POUT,POUT_IDX;const_output
      0024AA 24 A2                    1 	.word LINK 
                           0024AC     2 	LINK=.
      0024AC                          3 POUT:
      0024AC 44                       4 	.byte 4+F_IFUNC 	
      0024AD 50 4F 55 54              5 	.ascii "POUT"
      0024B1 00 72                    6 	.word POUT_IDX 
      0024B3                       6391 	_dict_entry,4,POKE,POKE_IDX;poke 
      0024B3 24 AC                    1 	.word LINK 
                           0024B5     2 	LINK=.
      0024B5                          3 POKE:
      0024B5 04                       4 	.byte 4 	
      0024B6 50 4F 4B 45              5 	.ascii "POKE"
      0024BA 00 70                    6 	.word POKE_IDX 
      0024BC                       6392 	_dict_entry,4+F_IFUNC,PINP,PINP_IDX;const_input
      0024BC 24 B5                    1 	.word LINK 
                           0024BE     2 	LINK=.
      0024BE                          3 PINP:
      0024BE 44                       4 	.byte 4+F_IFUNC 	
      0024BF 50 49 4E 50              5 	.ascii "PINP"
      0024C3 00 6E                    6 	.word PINP_IDX 
      0024C5                       6393 	_dict_entry,4+F_IFUNC,PEEK,PEEK_IDX;peek 
      0024C5 24 BE                    1 	.word LINK 
                           0024C7     2 	LINK=.
      0024C7                          3 PEEK:
      0024C7 44                       4 	.byte 4+F_IFUNC 	
      0024C8 50 45 45 4B              5 	.ascii "PEEK"
      0024CC 00 6C                    6 	.word PEEK_IDX 
      0024CE                       6394 	_dict_entry,5,PMODE,PMODE_IDX;pin_mode 
      0024CE 24 C7                    1 	.word LINK 
                           0024D0     2 	LINK=.
      0024D0                          3 PMODE:
      0024D0 05                       4 	.byte 5 	
      0024D1 50 4D 4F 44 45           5 	.ascii "PMODE"
      0024D6 00 6A                    6 	.word PMODE_IDX 
      0024D8                       6395 	_dict_entry,5,PAUSE,PAUSE_IDX;pause 
      0024D8 24 D0                    1 	.word LINK 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 127.
Hexadecimal [24-Bits]



                           0024DA     2 	LINK=.
      0024DA                          3 PAUSE:
      0024DA 05                       4 	.byte 5 	
      0024DB 50 41 55 53 45           5 	.ascii "PAUSE"
      0024E0 00 68                    6 	.word PAUSE_IDX 
      0024E2                       6396 	_dict_entry,3+F_IFUNC,PAD,PAD_IDX;pad_ref 
      0024E2 24 DA                    1 	.word LINK 
                           0024E4     2 	LINK=.
      0024E4                          3 PAD:
      0024E4 43                       4 	.byte 3+F_IFUNC 	
      0024E5 50 41 44                 5 	.ascii "PAD"
      0024E8 00 66                    6 	.word PAD_IDX 
      0024EA                       6397 	_dict_entry,2+F_IFUNC,OR,OR_IDX;bit_or
      0024EA 24 E4                    1 	.word LINK 
                           0024EC     2 	LINK=.
      0024EC                          3 OR:
      0024EC 42                       4 	.byte 2+F_IFUNC 	
      0024ED 4F 52                    5 	.ascii "OR"
      0024EF 00 64                    6 	.word OR_IDX 
      0024F1                       6398 	_dict_entry,3+F_IFUNC,ODR,ODR_IDX;const_odr 
      0024F1 24 EC                    1 	.word LINK 
                           0024F3     2 	LINK=.
      0024F3                          3 ODR:
      0024F3 43                       4 	.byte 3+F_IFUNC 	
      0024F4 4F 44 52                 5 	.ascii "ODR"
      0024F7 00 62                    6 	.word ODR_IDX 
      0024F9                       6399 	_dict_entry,3+F_IFUNC,NOT,NOT_IDX;func_not 
      0024F9 24 F3                    1 	.word LINK 
                           0024FB     2 	LINK=.
      0024FB                          3 NOT:
      0024FB 43                       4 	.byte 3+F_IFUNC 	
      0024FC 4E 4F 54                 5 	.ascii "NOT"
      0024FF 00 60                    6 	.word NOT_IDX 
      002501                       6400 	_dict_entry,3,NEW,NEW_IDX;new
      002501 24 FB                    1 	.word LINK 
                           002503     2 	LINK=.
      002503                          3 NEW:
      002503 03                       4 	.byte 3 	
      002504 4E 45 57                 5 	.ascii "NEW"
      002507 00 5E                    6 	.word NEW_IDX 
      002509                       6401 	_dict_entry,4,NEXT,NEXT_IDX;next 
      002509 25 03                    1 	.word LINK 
                           00250B     2 	LINK=.
      00250B                          3 NEXT:
      00250B 04                       4 	.byte 4 	
      00250C 4E 45 58 54              5 	.ascii "NEXT"
      002510 00 5C                    6 	.word NEXT_IDX 
      002512                       6402 	_dict_entry,6+F_IFUNC,MULDIV,MULDIV_IDX;muldiv 
      002512 25 0B                    1 	.word LINK 
                           002514     2 	LINK=.
      002514                          3 MULDIV:
      002514 46                       4 	.byte 6+F_IFUNC 	
      002515 4D 55 4C 44 49 56        5 	.ascii "MULDIV"
      00251B 00 5A                    6 	.word MULDIV_IDX 
      00251D                       6403 	_dict_entry,6+F_IFUNC,LSHIFT,LSHIFT_IDX;lshift
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 128.
Hexadecimal [24-Bits]



      00251D 25 14                    1 	.word LINK 
                           00251F     2 	LINK=.
      00251F                          3 LSHIFT:
      00251F 46                       4 	.byte 6+F_IFUNC 	
      002520 4C 53 48 49 46 54        5 	.ascii "LSHIFT"
      002526 00 58                    6 	.word LSHIFT_IDX 
      002528                       6404 	_dict_entry,3+F_IFUNC,LOG,LOG_IDX;log2 
      002528 25 1F                    1 	.word LINK 
                           00252A     2 	LINK=.
      00252A                          3 LOG:
      00252A 43                       4 	.byte 3+F_IFUNC 	
      00252B 4C 4F 47                 5 	.ascii "LOG"
      00252E 00 56                    6 	.word LOG_IDX 
      002530                       6405 	_dict_entry,4,LOAD,LOAD_IDX;load 
      002530 25 2A                    1 	.word LINK 
                           002532     2 	LINK=.
      002532                          3 LOAD:
      002532 04                       4 	.byte 4 	
      002533 4C 4F 41 44              5 	.ascii "LOAD"
      002537 00 54                    6 	.word LOAD_IDX 
      002539                       6406 	_dict_entry 4,LIST,LIST_IDX;list
      002539 25 32                    1 	.word LINK 
                           00253B     2 	LINK=.
      00253B                          3 LIST:
      00253B 04                       4 	.byte 4 	
      00253C 4C 49 53 54              5 	.ascii "LIST"
      002540 00 52                    6 	.word LIST_IDX 
      002542                       6407 	_dict_entry 3,LET,LET_IDX;let 
      002542 25 3B                    1 	.word LINK 
                           002544     2 	LINK=.
      002544                          3 LET:
      002544 03                       4 	.byte 3 	
      002545 4C 45 54                 5 	.ascii "LET"
      002548 00 50                    6 	.word LET_IDX 
      00254A                       6408 	_dict_entry,3+F_IFUNC,KEY,KEY_IDX;key 
      00254A 25 44                    1 	.word LINK 
                           00254C     2 	LINK=.
      00254C                          3 KEY:
      00254C 43                       4 	.byte 3+F_IFUNC 	
      00254D 4B 45 59                 5 	.ascii "KEY"
      002550 00 4E                    6 	.word KEY_IDX 
      002552                       6409 	_dict_entry,7,IWDGREF,IWDGREF_IDX;refresh_iwdg
      002552 25 4C                    1 	.word LINK 
                           002554     2 	LINK=.
      002554                          3 IWDGREF:
      002554 07                       4 	.byte 7 	
      002555 49 57 44 47 52 45 46     5 	.ascii "IWDGREF"
      00255C 00 4C                    6 	.word IWDGREF_IDX 
      00255E                       6410 	_dict_entry,6,IWDGEN,IWDGEN_IDX;enable_iwdg
      00255E 25 54                    1 	.word LINK 
                           002560     2 	LINK=.
      002560                          3 IWDGEN:
      002560 06                       4 	.byte 6 	
      002561 49 57 44 47 45 4E        5 	.ascii "IWDGEN"
      002567 00 4A                    6 	.word IWDGEN_IDX 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 129.
Hexadecimal [24-Bits]



      002569                       6411 	_dict_entry,6+F_IFUNC,INVERT,INVERT_IDX;invert 
      002569 25 60                    1 	.word LINK 
                           00256B     2 	LINK=.
      00256B                          3 INVERT:
      00256B 46                       4 	.byte 6+F_IFUNC 	
      00256C 49 4E 56 45 52 54        5 	.ascii "INVERT"
      002572 00 48                    6 	.word INVERT_IDX 
      002574                       6412 	_dict_entry,5,INPUT,INPUT_IDX;input_var  
      002574 25 6B                    1 	.word LINK 
                           002576     2 	LINK=.
      002576                          3 INPUT:
      002576 05                       4 	.byte 5 	
      002577 49 4E 50 55 54           5 	.ascii "INPUT"
      00257C 00 46                    6 	.word INPUT_IDX 
      00257E                       6413 	_dict_entry,2,IF,IF_IDX;if 
      00257E 25 76                    1 	.word LINK 
                           002580     2 	LINK=.
      002580                          3 IF:
      002580 02                       4 	.byte 2 	
      002581 49 46                    5 	.ascii "IF"
      002583 00 44                    6 	.word IF_IDX 
      002585                       6414 	_dict_entry,3+F_IFUNC,IDR,IDR_IDX;const_idr 
      002585 25 80                    1 	.word LINK 
                           002587     2 	LINK=.
      002587                          3 IDR:
      002587 43                       4 	.byte 3+F_IFUNC 	
      002588 49 44 52                 5 	.ascii "IDR"
      00258B 00 42                    6 	.word IDR_IDX 
      00258D                       6415 	_dict_entry,3,HEX,HEX_IDX;hex_base
      00258D 25 87                    1 	.word LINK 
                           00258F     2 	LINK=.
      00258F                          3 HEX:
      00258F 03                       4 	.byte 3 	
      002590 48 45 58                 5 	.ascii "HEX"
      002593 00 40                    6 	.word HEX_IDX 
      002595                       6416 	_dict_entry,4+F_IFUNC,GPIO,GPIO_IDX;gpio 
      002595 25 8F                    1 	.word LINK 
                           002597     2 	LINK=.
      002597                          3 GPIO:
      002597 44                       4 	.byte 4+F_IFUNC 	
      002598 47 50 49 4F              5 	.ascii "GPIO"
      00259C 00 3E                    6 	.word GPIO_IDX 
      00259E                       6417 	_dict_entry,4,GOTO,GOTO_IDX;goto 
      00259E 25 97                    1 	.word LINK 
                           0025A0     2 	LINK=.
      0025A0                          3 GOTO:
      0025A0 04                       4 	.byte 4 	
      0025A1 47 4F 54 4F              5 	.ascii "GOTO"
      0025A5 00 3C                    6 	.word GOTO_IDX 
      0025A7                       6418 	_dict_entry,5,GOSUB,GOSUB_IDX;gosub 
      0025A7 25 A0                    1 	.word LINK 
                           0025A9     2 	LINK=.
      0025A9                          3 GOSUB:
      0025A9 05                       4 	.byte 5 	
      0025AA 47 4F 53 55 42           5 	.ascii "GOSUB"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 130.
Hexadecimal [24-Bits]



      0025AF 00 3A                    6 	.word GOSUB_IDX 
      0025B1                       6419 	_dict_entry,6,FORGET,FORGET_IDX;forget 
      0025B1 25 A9                    1 	.word LINK 
                           0025B3     2 	LINK=.
      0025B3                          3 FORGET:
      0025B3 06                       4 	.byte 6 	
      0025B4 46 4F 52 47 45 54        5 	.ascii "FORGET"
      0025BA 00 38                    6 	.word FORGET_IDX 
      0025BC                       6420 	_dict_entry,3,FOR,FOR_IDX;for 
      0025BC 25 B3                    1 	.word LINK 
                           0025BE     2 	LINK=.
      0025BE                          3 FOR:
      0025BE 03                       4 	.byte 3 	
      0025BF 46 4F 52                 5 	.ascii "FOR"
      0025C2 00 36                    6 	.word FOR_IDX 
      0025C4                       6421 	_dict_entry,4,FCPU,FCPU_IDX;fcpu 
      0025C4 25 BE                    1 	.word LINK 
                           0025C6     2 	LINK=.
      0025C6                          3 FCPU:
      0025C6 04                       4 	.byte 4 	
      0025C7 46 43 50 55              5 	.ascii "FCPU"
      0025CB 00 34                    6 	.word FCPU_IDX 
      0025CD                       6422 	_dict_entry,6+F_IFUNC,EEPROM,EEPROM_IDX;const_eeprom_base   
      0025CD 25 C6                    1 	.word LINK 
                           0025CF     2 	LINK=.
      0025CF                          3 EEPROM:
      0025CF 46                       4 	.byte 6+F_IFUNC 	
      0025D0 45 45 50 52 4F 4D        5 	.ascii "EEPROM"
      0025D6 00 32                    6 	.word EEPROM_IDX 
      0025D8                       6423 	_dict_entry,3,END,END_IDX;cmd_end  
      0025D8 25 CF                    1 	.word LINK 
                           0025DA     2 	LINK=.
      0025DA                          3 END:
      0025DA 03                       4 	.byte 3 	
      0025DB 45 4E 44                 5 	.ascii "END"
      0025DE 00 30                    6 	.word END_IDX 
      0025E0                       6424 	_dict_entry,6+F_CMD,DWRITE,DWRITE_IDX;digital_write
      0025E0 25 DA                    1 	.word LINK 
                           0025E2     2 	LINK=.
      0025E2                          3 DWRITE:
      0025E2 06                       4 	.byte 6+F_CMD 	
      0025E3 44 57 52 49 54 45        5 	.ascii "DWRITE"
      0025E9 00 2E                    6 	.word DWRITE_IDX 
      0025EB                       6425 	_dict_entry,5+F_IFUNC,DREAD,DREAD_IDX;digital_read
      0025EB 25 E2                    1 	.word LINK 
                           0025ED     2 	LINK=.
      0025ED                          3 DREAD:
      0025ED 45                       4 	.byte 5+F_IFUNC 	
      0025EE 44 52 45 41 44           5 	.ascii "DREAD"
      0025F3 00 2C                    6 	.word DREAD_IDX 
      0025F5                       6426 	_dict_entry,2,DO,DO_IDX;do_loop
      0025F5 25 ED                    1 	.word LINK 
                           0025F7     2 	LINK=.
      0025F7                          3 DO:
      0025F7 02                       4 	.byte 2 	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 131.
Hexadecimal [24-Bits]



      0025F8 44 4F                    5 	.ascii "DO"
      0025FA 00 2A                    6 	.word DO_IDX 
      0025FC                       6427 	_dict_entry,3,DIR,DIR_IDX;directory 
      0025FC 25 F7                    1 	.word LINK 
                           0025FE     2 	LINK=.
      0025FE                          3 DIR:
      0025FE 03                       4 	.byte 3 	
      0025FF 44 49 52                 5 	.ascii "DIR"
      002602 00 28                    6 	.word DIR_IDX 
      002604                       6428 	_dict_entry,3,DEC,DEC_IDX;dec_base
      002604 25 FE                    1 	.word LINK 
                           002606     2 	LINK=.
      002606                          3 DEC:
      002606 03                       4 	.byte 3 	
      002607 44 45 43                 5 	.ascii "DEC"
      00260A 00 26                    6 	.word DEC_IDX 
      00260C                       6429 	_dict_entry,3+F_IFUNC,DDR,DDR_IDX;const_ddr 
      00260C 26 06                    1 	.word LINK 
                           00260E     2 	LINK=.
      00260E                          3 DDR:
      00260E 43                       4 	.byte 3+F_IFUNC 	
      00260F 44 44 52                 5 	.ascii "DDR"
      002612 00 24                    6 	.word DDR_IDX 
      002614                       6430 	_dict_entry,6,DATALN,DATALN_IDX;data_line  
      002614 26 0E                    1 	.word LINK 
                           002616     2 	LINK=.
      002616                          3 DATALN:
      002616 06                       4 	.byte 6 	
      002617 44 41 54 41 4C 4E        5 	.ascii "DATALN"
      00261D 00 22                    6 	.word DATALN_IDX 
      00261F                       6431 	_dict_entry,4,DATA,DATA_IDX;data  
      00261F 26 16                    1 	.word LINK 
                           002621     2 	LINK=.
      002621                          3 DATA:
      002621 04                       4 	.byte 4 	
      002622 44 41 54 41              5 	.ascii "DATA"
      002626 00 20                    6 	.word DATA_IDX 
      002628                       6432 	_dict_entry,3+F_IFUNC,CRL,CRL_IDX;const_cr1 
      002628 26 21                    1 	.word LINK 
                           00262A     2 	LINK=.
      00262A                          3 CRL:
      00262A 43                       4 	.byte 3+F_IFUNC 	
      00262B 43 52 4C                 5 	.ascii "CRL"
      00262E 00 1E                    6 	.word CRL_IDX 
      002630                       6433 	_dict_entry,3+F_IFUNC,CRH,CRH_IDX;const_cr2 
      002630 26 2A                    1 	.word LINK 
                           002632     2 	LINK=.
      002632                          3 CRH:
      002632 43                       4 	.byte 3+F_IFUNC 	
      002633 43 52 48                 5 	.ascii "CRH"
      002636 00 1C                    6 	.word CRH_IDX 
      002638                       6434 	_dict_entry,4+F_CFUNC,CHAR,CHAR_IDX;char
      002638 26 32                    1 	.word LINK 
                           00263A     2 	LINK=.
      00263A                          3 CHAR:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 132.
Hexadecimal [24-Bits]



      00263A 84                       4 	.byte 4+F_CFUNC 	
      00263B 43 48 41 52              5 	.ascii "CHAR"
      00263F 00 1A                    6 	.word CHAR_IDX 
      002641                       6435 	_dict_entry,3,BYE,BYE_IDX;bye 
      002641 26 3A                    1 	.word LINK 
                           002643     2 	LINK=.
      002643                          3 BYE:
      002643 03                       4 	.byte 3 	
      002644 42 59 45                 5 	.ascii "BYE"
      002647 00 18                    6 	.word BYE_IDX 
      002649                       6436 	_dict_entry,5,BTOGL,BTOGL_IDX;bit_toggle
      002649 26 43                    1 	.word LINK 
                           00264B     2 	LINK=.
      00264B                          3 BTOGL:
      00264B 05                       4 	.byte 5 	
      00264C 42 54 4F 47 4C           5 	.ascii "BTOGL"
      002651 00 16                    6 	.word BTOGL_IDX 
      002653                       6437 	_dict_entry,5+F_IFUNC,BTEST,BTEST_IDX;bit_test 
      002653 26 4B                    1 	.word LINK 
                           002655     2 	LINK=.
      002655                          3 BTEST:
      002655 45                       4 	.byte 5+F_IFUNC 	
      002656 42 54 45 53 54           5 	.ascii "BTEST"
      00265B 00 14                    6 	.word BTEST_IDX 
      00265D                       6438 	_dict_entry,4,BSET,BSET_IDX;bit_set 
      00265D 26 55                    1 	.word LINK 
                           00265F     2 	LINK=.
      00265F                          3 BSET:
      00265F 04                       4 	.byte 4 	
      002660 42 53 45 54              5 	.ascii "BSET"
      002664 00 12                    6 	.word BSET_IDX 
      002666                       6439 	_dict_entry,4,BRES,BRES_IDX;bit_reset
      002666 26 5F                    1 	.word LINK 
                           002668     2 	LINK=.
      002668                          3 BRES:
      002668 04                       4 	.byte 4 	
      002669 42 52 45 53              5 	.ascii "BRES"
      00266D 00 10                    6 	.word BRES_IDX 
      00266F                       6440 	_dict_entry,3+F_IFUNC,BIT,BIT_IDX;bitmask
      00266F 26 68                    1 	.word LINK 
                           002671     2 	LINK=.
      002671                          3 BIT:
      002671 43                       4 	.byte 3+F_IFUNC 	
      002672 42 49 54                 5 	.ascii "BIT"
      002675 00 0E                    6 	.word BIT_IDX 
      002677                       6441 	_dict_entry,3,AWU,AWU_IDX;awu 
      002677 26 71                    1 	.word LINK 
                           002679     2 	LINK=.
      002679                          3 AWU:
      002679 03                       4 	.byte 3 	
      00267A 41 57 55                 5 	.ascii "AWU"
      00267D 00 0C                    6 	.word AWU_IDX 
      00267F                       6442 	_dict_entry,7,AUTORUN,AUTORUN_IDX;autorun
      00267F 26 79                    1 	.word LINK 
                           002681     2 	LINK=.
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 133.
Hexadecimal [24-Bits]



      002681                          3 AUTORUN:
      002681 07                       4 	.byte 7 	
      002682 41 55 54 4F 52 55 4E     5 	.ascii "AUTORUN"
      002689 00 0A                    6 	.word AUTORUN_IDX 
      00268B                       6443 	_dict_entry,3+F_IFUNC,ASC,ASC_IDX;ascii
      00268B 26 81                    1 	.word LINK 
                           00268D     2 	LINK=.
      00268D                          3 ASC:
      00268D 43                       4 	.byte 3+F_IFUNC 	
      00268E 41 53 43                 5 	.ascii "ASC"
      002691 00 08                    6 	.word ASC_IDX 
      002693                       6444 	_dict_entry,3+F_IFUNC,AND,AND_IDX;bit_and
      002693 26 8D                    1 	.word LINK 
                           002695     2 	LINK=.
      002695                          3 AND:
      002695 43                       4 	.byte 3+F_IFUNC 	
      002696 41 4E 44                 5 	.ascii "AND"
      002699 00 06                    6 	.word AND_IDX 
      00269B                       6445 	_dict_entry,7+F_IFUNC,ADCREAD,ADCREAD_IDX;analog_read
      00269B 26 95                    1 	.word LINK 
                           00269D     2 	LINK=.
      00269D                          3 ADCREAD:
      00269D 47                       4 	.byte 7+F_IFUNC 	
      00269E 41 44 43 52 45 41 44     5 	.ascii "ADCREAD"
      0026A5 00 04                    6 	.word ADCREAD_IDX 
      0026A7                       6446 	_dict_entry,5,ADCON,ADCON_IDX;power_adc 
      0026A7 26 9D                    1 	.word LINK 
                           0026A9     2 	LINK=.
      0026A9                          3 ADCON:
      0026A9 05                       4 	.byte 5 	
      0026AA 41 44 43 4F 4E           5 	.ascii "ADCON"
      0026AF 00 02                    6 	.word ADCON_IDX 
      0026B1                       6447 kword_dict:
      0026B1                       6448 	_dict_entry,3+F_IFUNC,ABS,ABS_IDX ;abs
      0026B1 26 A9                    1 	.word LINK 
                           0026B3     2 	LINK=.
      0026B3                          3 ABS:
      0026B3 43                       4 	.byte 3+F_IFUNC 	
      0026B4 41 42 53                 5 	.ascii "ABS"
      0026B7 00 00                    6 	.word ABS_IDX 
                                   6449 
                                   6450 ;comands and fonctions address table 	
      0026B9                       6451 code_addr:
      0026B9 1E 5A 18 96 18 D2 1E  6452 	.word abs,power_adc,analog_read,bit_and,ascii,autorun,awu,bitmask ; 0..7
             6E 1D 0A 1D 95 1E 0B
             20 B1
      0026C9 16 34 16 24 16 55 16  6453 	.word bit_reset,bit_set,bit_test,bit_toggle,bye,char,const_cr2  ; 8..15
             45 1D 8C 1C F8 21 6B
      0026D7 21 65 21 83 21 89 21  6454 	.word const_cr1,data,data_line,const_ddr,dec_base,directory,do_loop,digital_read,digital_write ;16..23 
             5F 11 F9 1C 3F 20 DA
             19 06 19 36
      0026E9 18 42 21 7D 1E E8 16  6455 	.word cmd_end,const_eeprom_base,fcpu,for,forget,gosub,goto,gpio ; 24..31 
             B0 1B D8 17 AB 17 90
             1D 3F
      0026F9 11 F4 21 59 16 9C 15  6456 	.word hex_base,const_idr,if,input_var,invert,enable_iwdg,refresh_iwdg,key ; 32..39 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 134.
Hexadecimal [24-Bits]



             8D 20 CB 20 5B 20 91
             1D 2A
      002709 12 2A 12 55 1B A8 20  6457 	.word let,list,load,log2,lshift,muldiv,next,new ; 40..47
             96 1E B6 0F 69 17 30
             19 BD
      002719 20 4E 21 53 1E 86 23  6458 	.word func_not,const_odr,bit_or,pad_ref,pause,pin_mode,peek,const_input ; 48..55
             12 1D F8 1E F4 16 8B
             21 77
      002729 16 7C 21 71 14 FC 21  6459 	.word poke,const_output,print,const_porta,const_portb,const_portc,const_portd,const_porte ; 56..63
             1D 21 23 21 29 21 2F
             21 35
      002739 21 3B 21 41 21 47 21  6460 	.word const_portf,const_portg,const_porth,const_porti,qkey,read,cold_start,remark ; 64..71 
             4D 1D 32 22 01 05 D8
             15 F9
      002749 21 B6 17 CB 1F 65 1E  6461 	.word restore,return, random,rshift,run,save,show,size ; 72..79
             CF 17 E9 1A AE 11 B3
             11 FE
      002759 1D ED 22 F3 22 5B 22  6462 	.word sleep,spi_read,spi_enable,spi_select,spi_write,step,stop,get_ticks  ; 80..87
             FB 22 D3 17 09 19 71
             1E 54
      002769 20 32 20 41 16 D9 18  6463 	.word set_timer,timeout,to,tone,ubound,uflash,until,usr ; 88..95
             52 12 08 1D 69 20 EF
             1D 6F
      002779 15 FF 1F CC 1C C1 1E  6464 	.word wait,words,write,bit_xor ; 96..103 
             9E
      002781 00 00                 6465 	.word 0 
                                   6466 
      002800                       6467 	.bndry 128 ; align on FLASH block.
                                   6468 ; free space for user application  
      002800                       6469 user_space:
                                   6470 ; USR() function test
      002800 89               [ 2] 6471 	pushw x 
      002801 72 1A 50 0A      [ 1] 6472 	bset PC_ODR,#5 
      002805 85               [ 2] 6473 	popw x 
      002806 CD 1E 02         [ 4] 6474 	call pause02 
      002809 72 1B 50 0A      [ 1] 6475 	bres PC_ODR,#5 
      00280D 81               [ 4] 6476 	ret
                                   6477 
                                   6478 	.area FLASH_DRIVE (ABS)
      010000                       6479 	.org 0x10000
      010000                       6480 fdrive:
                                   6481 ; .byte 0,0,0,0
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 135.
Hexadecimal [24-Bits]

Symbol Table

    .__.$$$.=  002710 L   |     .__.ABS.=  000000 G   |     .__.CPU.=  000000 L
    .__.H$L.=  000001 L   |   5 ABS        0026B3 R   |     ABS_IDX =  000000 
    ACK     =  000006     |   5 ADCON      0026A9 R   |     ADCON_ID=  000002 
  5 ADCREAD    00269D R   |     ADCREAD_=  000004     |     ADC_CR1 =  005401 
    ADC_CR1_=  000000     |     ADC_CR1_=  000001     |     ADC_CR1_=  000004 
    ADC_CR1_=  000005     |     ADC_CR1_=  000006     |     ADC_CR2 =  005402 
    ADC_CR2_=  000003     |     ADC_CR2_=  000004     |     ADC_CR2_=  000005 
    ADC_CR2_=  000006     |     ADC_CR2_=  000001     |     ADC_CR3 =  005403 
    ADC_CR3_=  000007     |     ADC_CR3_=  000006     |     ADC_CSR =  005400 
    ADC_CSR_=  000006     |     ADC_CSR_=  000004     |     ADC_CSR_=  000000 
    ADC_CSR_=  000001     |     ADC_CSR_=  000002     |     ADC_CSR_=  000003 
    ADC_CSR_=  000007     |     ADC_CSR_=  000005     |     ADC_DRH =  005404 
    ADC_DRL =  005405     |     ADC_TDRH=  005406     |     ADC_TDRL=  005407 
    ADDR    =  000001     |     ADR     =  000002     |     AFR     =  004803 
    AFR0_ADC=  000000     |     AFR1_TIM=  000001     |     AFR2_CCO=  000002 
    AFR3_TIM=  000003     |     AFR4_TIM=  000004     |     AFR5_TIM=  000005 
    AFR6_I2C=  000006     |     AFR7_BEE=  000007     |   5 AND        002695 R
    AND_IDX =  000006     |     AREG    =  000002     |     ARG_OFS =  000002 
  5 ASC        00268D R   |     ASC_IDX =  000008     |     ATTRIB  =  000002 
  5 AUTORUN    002681 R   |     AUTORUN_=  00000A     |     AUTORUN_=  004000 
  5 AWU        002679 R   |   5 AWUHandl   000001 R   |     AWU_APR =  0050F1 
    AWU_CSR =  0050F0     |     AWU_CSR_=  000004     |     AWU_IDX =  00000C 
    AWU_TBR =  0050F2     |     B0_MASK =  000001     |     B115200 =  000006 
    B19200  =  000003     |     B1_MASK =  000002     |     B230400 =  000007 
    B2400   =  000000     |     B2_MASK =  000004     |     B38400  =  000004 
    B3_MASK =  000008     |     B460800 =  000008     |     B4800   =  000001 
    B4_MASK =  000010     |     B57600  =  000005     |     B5_MASK =  000020 
    B6_MASK =  000040     |     B7_MASK =  000080     |     B921600 =  000009 
    B9600   =  000002     |     BASE    =  000002     |     BASE_SAV=  000001 
    BCNT    =  000001     |     BEEP_BIT=  000004     |     BEEP_CSR=  0050F3 
    BEEP_MAS=  000010     |     BEEP_POR=  00000F     |     BELL    =  000007 
    BINARY  =  000001     |   5 BIT        002671 R   |     BIT0    =  000000 
    BIT1    =  000001     |     BIT2    =  000002     |     BIT3    =  000003 
    BIT4    =  000004     |     BIT5    =  000005     |     BIT6    =  000006 
    BIT7    =  000007     |     BIT_IDX =  00000E     |     BLOCK_SI=  000080 
    BOOT_ROM=  006000     |     BOOT_ROM=  007FFF     |     BPTR    =  00000B 
  5 BRES       002668 R   |     BRES_IDX=  000010     |     BS      =  000008 
    BSAVE   =  000001     |   5 BSET       00265F R   |     BSET_IDX=  000012 
    BSIZE   =  000001     |   5 BTEST      002655 R   |     BTEST_ID=  000014 
  5 BTOGL      00264B R   |     BTOGL_ID=  000016     |     BTW     =  000001 
  5 BYE        002643 R   |     BYE_IDX =  000018     |     C       =  000001 
    CAN     =  000018     |     CAN_DGR =  005426     |     CAN_FPSR=  005427 
    CAN_IER =  005425     |     CAN_MCR =  005420     |     CAN_MSR =  005421 
    CAN_P0  =  005428     |     CAN_P1  =  005429     |     CAN_P2  =  00542A 
    CAN_P3  =  00542B     |     CAN_P4  =  00542C     |     CAN_P5  =  00542D 
    CAN_P6  =  00542E     |     CAN_P7  =  00542F     |     CAN_P8  =  005430 
    CAN_P9  =  005431     |     CAN_PA  =  005432     |     CAN_PB  =  005433 
    CAN_PC  =  005434     |     CAN_PD  =  005435     |     CAN_PE  =  005436 
    CAN_PF  =  005437     |     CAN_RFR =  005424     |     CAN_TPR =  005423 
    CAN_TSR =  005422     |     CC_C    =  000000     |     CC_H    =  000004 
    CC_I0   =  000003     |     CC_I1   =  000005     |     CC_N    =  000002 
    CC_V    =  000007     |     CC_Z    =  000001     |     CELL_SIZ=  000002 
    CFG_GCR =  007F60     |     CFG_GCR_=  000001     |     CFG_GCR_=  000000 
  5 CHAR       00263A R   |     CHAR_IDX=  00001A     |     CLKOPT  =  004807 
    CLKOPT_C=  000002     |     CLKOPT_E=  000003     |     CLKOPT_P=  000000 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 136.
Hexadecimal [24-Bits]

Symbol Table

    CLKOPT_P=  000001     |     CLK_CCOR=  0050C9     |     CLK_CKDI=  0050C6 
    CLK_CKDI=  000000     |     CLK_CKDI=  000001     |     CLK_CKDI=  000002 
    CLK_CKDI=  000003     |     CLK_CKDI=  000004     |     CLK_CMSR=  0050C3 
    CLK_CSSR=  0050C8     |     CLK_ECKR=  0050C1     |     CLK_ECKR=  000000 
    CLK_ECKR=  000001     |     CLK_HSIT=  0050CC     |     CLK_ICKR=  0050C0 
    CLK_ICKR=  000002     |     CLK_ICKR=  000000     |     CLK_ICKR=  000001 
    CLK_ICKR=  000003     |     CLK_ICKR=  000004     |     CLK_ICKR=  000005 
    CLK_PCKE=  0050C7     |     CLK_PCKE=  000000     |     CLK_PCKE=  000001 
    CLK_PCKE=  000007     |     CLK_PCKE=  000005     |     CLK_PCKE=  000006 
    CLK_PCKE=  000004     |     CLK_PCKE=  000002     |     CLK_PCKE=  000003 
    CLK_PCKE=  0050CA     |     CLK_PCKE=  000003     |     CLK_PCKE=  000002 
    CLK_PCKE=  000007     |     CLK_SWCR=  0050C5     |     CLK_SWCR=  000000 
    CLK_SWCR=  000001     |     CLK_SWCR=  000002     |     CLK_SWCR=  000003 
    CLK_SWIM=  0050CD     |     CLK_SWR =  0050C4     |     CLK_SWR_=  0000B4 
    CLK_SWR_=  0000E1     |     CLK_SWR_=  0000D2     |     CMDX    =  000001 
    CMD_END =  000002     |     CNT     =  000006     |     CNTR    =  000003 
    COMMA   =  000001     |     COUNT   =  000001     |     CPU_A   =  007F00 
    CPU_CCR =  007F0A     |     CPU_PCE =  007F01     |     CPU_PCH =  007F02 
    CPU_PCL =  007F03     |     CPU_SPH =  007F08     |     CPU_SPL =  007F09 
    CPU_XH  =  007F04     |     CPU_XL  =  007F05     |     CPU_YH  =  007F06 
    CPU_YL  =  007F07     |     CR      =  00000D     |   5 CRH        002632 R
    CRH_IDX =  00001C     |   5 CRL        00262A R   |     CRL_IDX =  00001E 
    CTRL_A  =  000001     |     CTRL_B  =  000002     |     CTRL_C  =  000003 
    CTRL_D  =  000004     |     CTRL_E  =  000005     |     CTRL_F  =  000006 
    CTRL_G  =  000007     |     CTRL_H  =  000008     |     CTRL_I  =  000009 
    CTRL_J  =  00000A     |     CTRL_K  =  00000B     |     CTRL_L  =  00000C 
    CTRL_M  =  00000D     |     CTRL_N  =  00000E     |     CTRL_O  =  00000F 
    CTRL_P  =  000010     |     CTRL_Q  =  000011     |     CTRL_R  =  000012 
    CTRL_S  =  000013     |     CTRL_T  =  000014     |     CTRL_U  =  000015 
    CTRL_V  =  000016     |     CTRL_W  =  000017     |     CTRL_X  =  000018 
    CTRL_Y  =  000019     |     CTRL_Z  =  00001A     |     CTXT_SIZ=  000004 
    CTX_BPTR=  000001     |     CTX_COUN=  000004     |     CTX_IN  =  000003 
    CURR    =  000002     |     CVAR    =  000007     |     CX_BPTR =  000001 
    CX_CNT  =  000004     |     CX_IN   =  000003     |   5 DATA       002621 R
  5 DATALN     002616 R   |     DATALN_I=  000022     |     DATA_IDX=  000020 
    DBG_A   =  000005     |     DBG_CC  =  000006     |     DBG_X   =  000003 
    DBG_Y   =  000001     |     DBL     =  000003     |     DBLDIVDN=  000006 
    DBLHI   =  000001     |     DBLLO   =  000003     |     DBL_SIZE=  000004 
    DC1     =  000011     |     DC2     =  000012     |     DC3     =  000013 
    DC4     =  000014     |   5 DDR        00260E R   |     DDR_IDX =  000024 
    DEBUG   =  000000     |     DEBUG_BA=  007F00     |     DEBUG_EN=  007FFF 
    DEBUG_PR=  000001     |   5 DEC        002606 R   |     DEC_IDX =  000026 
    DEST    =  000001     |     DEVID_BA=  0048CD     |     DEVID_EN=  0048D8 
    DEVID_LO=  0048D2     |     DEVID_LO=  0048D3     |     DEVID_LO=  0048D4 
    DEVID_LO=  0048D5     |     DEVID_LO=  0048D6     |     DEVID_LO=  0048D7 
    DEVID_LO=  0048D8     |     DEVID_WA=  0048D1     |     DEVID_XH=  0048CE 
    DEVID_XL=  0048CD     |     DEVID_YH=  0048D0     |     DEVID_YL=  0048CF 
  5 DIR        0025FE R   |     DIR_IDX =  000028     |     DIVDNDHI=  00000B 
    DIVDNDLO=  00000D     |     DIVISOR =  000001     |     DIVISR  =  000007 
    DIVSOR  =  000001     |     DLE     =  000010     |     DM_BK1RE=  007F90 
    DM_BK1RH=  007F91     |     DM_BK1RL=  007F92     |     DM_BK2RE=  007F93 
    DM_BK2RH=  007F94     |     DM_BK2RL=  007F95     |     DM_CR1  =  007F96 
    DM_CR2  =  007F97     |     DM_CSR1 =  007F98     |     DM_CSR2 =  007F99 
    DM_ENFCT=  007F9A     |   5 DO         0025F7 R   |     DOLP_ADR=  000003 
    DOLP_INW=  000005     |     DO_IDX  =  00002A     |   5 DREAD      0025ED R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 137.
Hexadecimal [24-Bits]

Symbol Table

    DREAD_ID=  00002C     |   5 DWRITE     0025E2 R   |     DWRITE_I=  00002E 
  5 EEPROM     0025CF R   |     EEPROM_B=  004000     |     EEPROM_E=  0047FF 
    EEPROM_I=  000032     |     EEPROM_S=  000800     |     EM      =  000019 
  5 END        0025DA R   |     END_IDX =  000030     |     ENQ     =  000005 
    EOF     =  0000FF     |     EOT     =  000004     |     ERR_BAD_=  00000A 
    ERR_BUF_=  00000F     |     ERR_CMD_=  000007     |     ERR_DIV0=  000004 
    ERR_DUPL=  000008     |     ERR_MATH=  000003     |     ERR_MEM_=  000001 
    ERR_NONE=  000000     |     ERR_NOT_=  000009     |     ERR_NO_A=  00000B 
    ERR_NO_D=  00000C     |     ERR_NO_F=  00000E     |     ERR_NO_L=  000005 
    ERR_NO_P=  00000D     |     ERR_RUN_=  000006     |     ERR_SYNT=  000002 
    ESC     =  00001B     |     ETB     =  000017     |     ETX     =  000003 
    EXTI_CR1=  0050A0     |     EXTI_CR2=  0050A1     |     FAUTORUN=  000006 
    FBREAK  =  000004     |     FCOMP   =  000005     |   5 FCPU       0025C6 R
    FCPU_IDX=  000034     |     FF      =  00000C     |     FHSE    =  7A1200 
    FHSI    =  F42400     |     FIRST   =  000001     |     FIRST_DA=  000006 
    FLASH_BA=  008000     |     FLASH_CR=  00505A     |     FLASH_CR=  000002 
    FLASH_CR=  000000     |     FLASH_CR=  000003     |     FLASH_CR=  000001 
    FLASH_CR=  00505B     |     FLASH_CR=  000005     |     FLASH_CR=  000004 
    FLASH_CR=  000007     |     FLASH_CR=  000000     |     FLASH_CR=  000006 
    FLASH_DU=  005064     |     FLASH_DU=  0000AE     |     FLASH_DU=  000056 
    FLASH_EN=  027FFF     |     FLASH_FP=  00505D     |     FLASH_FP=  000000 
    FLASH_FP=  000001     |     FLASH_FP=  000002     |     FLASH_FP=  000003 
    FLASH_FP=  000004     |     FLASH_FP=  000005     |     FLASH_IA=  00505F 
    FLASH_IA=  000003     |     FLASH_IA=  000002     |     FLASH_IA=  000006 
    FLASH_IA=  000001     |     FLASH_IA=  000000     |     FLASH_NC=  00505C 
    FLASH_NF=  00505E     |     FLASH_NF=  000000     |     FLASH_NF=  000001 
    FLASH_NF=  000002     |     FLASH_NF=  000003     |     FLASH_NF=  000004 
    FLASH_NF=  000005     |     FLASH_PU=  005062     |     FLASH_PU=  000056 
    FLASH_PU=  0000AE     |     FLASH_SI=  020000     |     FLASH_WS=  00480D 
    FLOOP   =  000002     |     FLSI    =  01F400     |   5 FOR        0025BE R
  5 FORGET     0025B3 R   |     FORGET_I=  000038     |     FOR_IDX =  000036 
    FRUN    =  000000     |     FS      =  00001C     |     FSIZE   =  000001 
    FSLEEP  =  000003     |     FSTEP   =  000003     |     FTRAP   =  000001 
    F_CFUNC =  000080     |     F_CMD   =  000000     |     F_CONST =  0000C0 
    F_IFUNC =  000040     |   5 GOSUB      0025A9 R   |     GOSUB_ID=  00003A 
  5 GOTO       0025A0 R   |     GOTO_IDX=  00003C     |   5 GPIO       002597 R
    GPIO_BAS=  005000     |     GPIO_CR1=  000003     |     GPIO_CR2=  000004 
    GPIO_DDR=  000002     |     GPIO_IDR=  000001     |     GPIO_IDX=  00003E 
    GPIO_ODR=  000000     |     GPIO_SIZ=  000005     |     GS      =  00001D 
  5 HEX        00258F R   |     HEX_IDX =  000040     |     HSECNT  =  004809 
    I2C_CCRH=  00521C     |     I2C_CCRH=  000080     |     I2C_CCRH=  0000C0 
    I2C_CCRH=  000080     |     I2C_CCRH=  000000     |     I2C_CCRH=  000001 
    I2C_CCRH=  000000     |     I2C_CCRL=  00521B     |     I2C_CCRL=  00001A 
    I2C_CCRL=  000002     |     I2C_CCRL=  00000D     |     I2C_CCRL=  000050 
    I2C_CCRL=  000090     |     I2C_CCRL=  0000A0     |     I2C_CR1 =  005210 
    I2C_CR1_=  000006     |     I2C_CR1_=  000007     |     I2C_CR1_=  000000 
    I2C_CR2 =  005211     |     I2C_CR2_=  000002     |     I2C_CR2_=  000003 
    I2C_CR2_=  000000     |     I2C_CR2_=  000001     |     I2C_CR2_=  000007 
    I2C_DR  =  005216     |     I2C_FREQ=  005212     |     I2C_ITR =  00521A 
    I2C_ITR_=  000002     |     I2C_ITR_=  000000     |     I2C_ITR_=  000001 
    I2C_OARH=  005214     |     I2C_OARH=  000001     |     I2C_OARH=  000002 
    I2C_OARH=  000006     |     I2C_OARH=  000007     |     I2C_OARL=  005213 
    I2C_OARL=  000000     |     I2C_OAR_=  000813     |     I2C_OAR_=  000009 
    I2C_PECR=  00521E     |     I2C_READ=  000001     |     I2C_SR1 =  005217 
    I2C_SR1_=  000003     |     I2C_SR1_=  000001     |     I2C_SR1_=  000002 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 138.
Hexadecimal [24-Bits]

Symbol Table

    I2C_SR1_=  000006     |     I2C_SR1_=  000000     |     I2C_SR1_=  000004 
    I2C_SR1_=  000007     |     I2C_SR2 =  005218     |     I2C_SR2_=  000002 
    I2C_SR2_=  000001     |     I2C_SR2_=  000000     |     I2C_SR2_=  000003 
    I2C_SR2_=  000005     |     I2C_SR3 =  005219     |     I2C_SR3_=  000001 
    I2C_SR3_=  000007     |     I2C_SR3_=  000004     |     I2C_SR3_=  000000 
    I2C_SR3_=  000002     |     I2C_TRIS=  00521D     |     I2C_TRIS=  000005 
    I2C_TRIS=  000005     |     I2C_TRIS=  000005     |     I2C_TRIS=  000011 
    I2C_TRIS=  000011     |     I2C_TRIS=  000011     |     I2C_WRIT=  000000 
  5 IDR        002587 R   |     IDR_IDX =  000042     |   5 IF         002580 R
    IF_IDX  =  000044     |     IN      =  000005     |     INCR    =  000001 
    INP     =  000000     |   5 INPUT      002576 R   |     INPUT_DI=  000000 
    INPUT_EI=  000001     |     INPUT_FL=  000000     |     INPUT_ID=  000046 
    INPUT_PU=  000001     |     INT_ADC2=  000016     |     INT_AUAR=  000012 
    INT_AWU =  000001     |     INT_CAN_=  000008     |     INT_CAN_=  000009 
    INT_CLK =  000002     |     INT_EXTI=  000003     |     INT_EXTI=  000004 
    INT_EXTI=  000005     |     INT_EXTI=  000006     |     INT_EXTI=  000007 
    INT_FLAS=  000018     |     INT_I2C =  000013     |     INT_SPI =  00000A 
    INT_TIM1=  00000C     |     INT_TIM1=  00000B     |     INT_TIM2=  00000E 
    INT_TIM2=  00000D     |     INT_TIM3=  000010     |     INT_TIM3=  00000F 
    INT_TIM4=  000017     |     INT_TLI =  000000     |     INT_UART=  000011 
    INT_UART=  000015     |     INT_UART=  000014     |     INT_VECT=  008060 
    INT_VECT=  00800C     |     INT_VECT=  008028     |     INT_VECT=  00802C 
    INT_VECT=  008010     |     INT_VECT=  008014     |     INT_VECT=  008018 
    INT_VECT=  00801C     |     INT_VECT=  008020     |     INT_VECT=  008024 
    INT_VECT=  008068     |     INT_VECT=  008054     |     INT_VECT=  008000 
    INT_VECT=  008030     |     INT_VECT=  008038     |     INT_VECT=  008034 
    INT_VECT=  008040     |     INT_VECT=  00803C     |     INT_VECT=  008048 
    INT_VECT=  008044     |     INT_VECT=  008064     |     INT_VECT=  008008 
    INT_VECT=  008004     |     INT_VECT=  008050     |     INT_VECT=  00804C 
    INT_VECT=  00805C     |     INT_VECT=  008058     |   5 INVERT     00256B R
    INVERT_I=  000048     |     INW     =  000009     |     ITC_SPR1=  007F70 
    ITC_SPR2=  007F71     |     ITC_SPR3=  007F72     |     ITC_SPR4=  007F73 
    ITC_SPR5=  007F74     |     ITC_SPR6=  007F75     |     ITC_SPR7=  007F76 
    ITC_SPR8=  007F77     |   5 IWDGEN     002560 R   |     IWDGEN_I=  00004A 
  5 IWDGREF    002554 R   |     IWDGREF_=  00004C     |     IWDG_KEY=  000055 
    IWDG_KEY=  0000CC     |     IWDG_KEY=  0000AA     |     IWDG_KR =  0050E0 
    IWDG_PR =  0050E1     |     IWDG_RLR=  0050E2     |   5 KEY        00254C R
    KEY_IDX =  00004E     |     LAST    =  000003     |     LB      =  000002 
    LED2_BIT=  000005     |     LED2_MAS=  000020     |     LED2_POR=  00500A 
    LEN     =  000002     |   5 LET        002544 R   |     LET_IDX =  000050 
    LF      =  00000A     |     LIMIT   =  000005     |     LINENO  =  000005 
  5 LINK    =  0026B3 R   |   5 LIST       00253B R   |     LIST_IDX=  000052 
    LL      =  000001     |     LLEN    =  000002     |     LN_PTR  =  000005 
  5 LOAD       002532 R   |     LOAD_IDX=  000054     |   5 LOG        00252A R
    LOG_IDX =  000056     |   5 LSHIFT     00251F R   |     LSHIFT_I=  000058 
    MAJOR   =  000001     |     MASK    =  000002     |     MATH_OVF=  000000 
    MAX_LINE=  007FFF     |     MINOR   =  000000     |   5 MULDIV     002514 R
    MULDIV_I=  00005A     |     MULOP   =  000003     |     N1      =  000001 
    NAFR    =  004804     |     NAK     =  000015     |     NAMEPTR =  000003 
    NCLKOPT =  004808     |     NEG     =  000001     |   5 NEW        002503 R
    NEW_FREE=  000001     |     NEW_IDX =  00005E     |   5 NEXT       00250B R
    NEXT_IDX=  00005C     |     NFLASH_W=  00480E     |     NHSECNT =  00480A 
    NLEN    =  000001     |     NOPT1   =  004802     |     NOPT2   =  004804 
    NOPT3   =  004806     |     NOPT4   =  004808     |     NOPT5   =  00480A 
    NOPT6   =  00480C     |     NOPT7   =  00480E     |     NOPTBL  =  00487F 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 139.
Hexadecimal [24-Bits]

Symbol Table

  5 NOT        0024FB R   |     NOT_IDX =  000060     |     NUBC    =  004802 
    NWDGOPT =  004806     |     NWDGOPT_=  FFFFFFFD     |     NWDGOPT_=  FFFFFFFC 
    NWDGOPT_=  FFFFFFFF     |     NWDGOPT_=  FFFFFFFE     |   5 NonHandl   000000 R
  5 ODR        0024F3 R   |     ODR_IDX =  000062     |     ONOFF   =  000003 
    OP      =  000003     |     OPT     =  000002     |     OPT0    =  004800 
    OPT1    =  004801     |     OPT2    =  004803     |     OPT3    =  004805 
    OPT4    =  004807     |     OPT5    =  004809     |     OPT6    =  00480B 
    OPT7    =  00480D     |     OPTBL   =  00487E     |     OPTION_B=  004800 
    OPTION_E=  00487F     |     OPTION_S=  000080     |   5 OR         0024EC R
    OR_IDX  =  000064     |     OUTP    =  000001     |     OUTPUT_F=  000001 
    OUTPUT_O=  000000     |     OUTPUT_P=  000001     |     OUTPUT_S=  000000 
    OVFH    =  000001     |     OVFL    =  000002     |     PA      =  000000 
  5 PAD        0024E4 R   |     PAD_IDX =  000066     |     PAD_SIZE=  000080 
  5 PAUSE      0024DA R   |     PAUSE_ID=  000068     |     PA_BASE =  005000 
    PA_CR1  =  005003     |     PA_CR2  =  005004     |     PA_DDR  =  005002 
    PA_IDR  =  005001     |     PA_ODR  =  005000     |     PB      =  000005 
    PB_BASE =  005005     |     PB_CR1  =  005008     |     PB_CR2  =  005009 
    PB_DDR  =  005007     |     PB_IDR  =  005006     |     PB_ODR  =  005005 
    PC      =  00000A     |     PC_BASE =  00500A     |     PC_CR1  =  00500D 
    PC_CR2  =  00500E     |     PC_DDR  =  00500C     |     PC_IDR  =  00500B 
    PC_ODR  =  00500A     |     PD      =  00000F     |     PD_BASE =  00500F 
    PD_CR1  =  005012     |     PD_CR2  =  005013     |     PD_DDR  =  005011 
    PD_IDR  =  005010     |     PD_ODR  =  00500F     |     PE      =  000014 
  5 PEEK       0024C7 R   |     PEEK_IDX=  00006C     |     PE_BASE =  005014 
    PE_CR1  =  005017     |     PE_CR2  =  005018     |     PE_DDR  =  005016 
    PE_IDR  =  005015     |     PE_ODR  =  005014     |     PF      =  000019 
    PF_BASE =  005019     |     PF_CR1  =  00501C     |     PF_CR2  =  00501D 
    PF_DDR  =  00501B     |     PF_IDR  =  00501A     |     PF_ODR  =  005019 
    PG      =  00001E     |     PG_BASE =  00501E     |     PG_CR1  =  005021 
    PG_CR2  =  005022     |     PG_DDR  =  005020     |     PG_IDR  =  00501F 
    PG_ODR  =  00501E     |     PH      =  000023     |     PH_BASE =  005023 
    PH_CR1  =  005026     |     PH_CR2  =  005027     |     PH_DDR  =  005025 
    PH_IDR  =  005024     |     PH_ODR  =  005023     |     PI      =  000028 
    PINNO   =  000001     |   5 PINP       0024BE R   |     PINP_IDX=  00006E 
    PINVAL  =  000002     |     PI_BASE =  005028     |     PI_CR1  =  00502B 
    PI_CR2  =  00502C     |     PI_DDR  =  00502A     |     PI_IDR  =  005029 
    PI_ODR  =  005028     |   5 PMODE      0024D0 R   |     PMODE_ID=  00006A 
  5 POKE       0024B5 R   |     POKE_IDX=  000070     |     PORT    =  000003 
  5 POUT       0024AC R   |     POUT_IDX=  000072     |     PREV    =  000001 
  5 PRINT      0024A2 R   |   5 PRTA       002499 R   |     PRTA_IDX=  000076 
  5 PRTB       002490 R   |     PRTB_IDX=  000078     |   5 PRTC       002487 R
    PRTC_IDX=  00007A     |   5 PRTD       00247E R   |     PRTD_IDX=  00007C 
  5 PRTE       002475 R   |     PRTE_IDX=  00007E     |   5 PRTF       00246C R
    PRTF_IDX=  000080     |   5 PRTG       002463 R   |     PRTG_IDX=  000082 
  5 PRTH       00245A R   |     PRTH_IDX=  000084     |   5 PRTI       002451 R
    PRTI_IDX=  000086     |     PRT_IDX =  000074     |     PSTR    =  000003 
  5 QKEY       002448 R   |     QKEY_IDX=  000088     |     RAM_BASE=  000000 
    RAM_END =  0017FF     |     RAM_SIZE=  001800     |     RBT_IDX =  00008C 
  5 READ       00243F R   |     READ_IDX=  00008A     |   5 REBOOT     002434 R
    REG     =  000001     |     RELOP   =  000003     |   5 REMARK     002429 R
    REM_IDX =  00008E     |   5 RESTORE    00241D R   |     REST_IDX=  000090 
    RETL1   =  000001     |   5 RETURN     002412 R   |     RET_ADDR=  000003 
    RET_IDX =  000092     |     RET_INW =  000005     |   5 RND        00240A R
    RND_IDX =  000094     |     ROP     =  004800     |     RS      =  00001E 
  5 RSHIFT     0023FF R   |     RSHIFT_I=  000096     |     RST_SR  =  0050B3 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 140.
Hexadecimal [24-Bits]

Symbol Table

  5 RUN        0023F7 R   |     RUN_IDX =  000098     |     RX_QUEUE=  000008 
  5 SAVE       0023EE R   |     SAVE_IDX=  00009A     |     SDIVSR  =  000005 
    SFR_BASE=  005000     |     SFR_END =  0057FF     |     SHARP   =  000023 
  5 SHOW       0023E5 R   |     SHOW_IDX=  00009C     |     SI      =  00000F 
    SIGN    =  000001     |   5 SIZE       0023DC R   |     SIZE_IDX=  00009E 
    SKIP    =  000005     |   5 SLEEP      0023D2 R   |     SLEEP_ID=  0000A0 
    SO      =  00000E     |     SOH     =  000001     |     SPACE   =  000020 
  5 SPIEN      0023BE R   |     SPIEN_ID=  0000A4     |   5 SPIRD      0023C8 R
    SPIRD_ID=  0000A2     |   5 SPISEL     0023B3 R   |     SPISEL_I=  0000A6 
  5 SPIWR      0023A9 R   |     SPIWR_ID=  0000A8     |     SPI_CR1 =  005200 
    SPI_CR1_=  000003     |     SPI_CR1_=  000000     |     SPI_CR1_=  000001 
    SPI_CR1_=  000007     |     SPI_CR1_=  000002     |     SPI_CR1_=  000006 
    SPI_CR2 =  005201     |     SPI_CR2_=  000007     |     SPI_CR2_=  000006 
    SPI_CR2_=  000005     |     SPI_CR2_=  000004     |     SPI_CR2_=  000002 
    SPI_CR2_=  000000     |     SPI_CR2_=  000001     |     SPI_CRCP=  005205 
    SPI_CS_B=  000005     |     SPI_DR  =  005204     |     SPI_ICR =  005202 
    SPI_RXCR=  005206     |     SPI_SR  =  005203     |     SPI_SR_B=  000007 
    SPI_SR_C=  000004     |     SPI_SR_M=  000005     |     SPI_SR_O=  000006 
    SPI_SR_R=  000000     |     SPI_SR_T=  000001     |     SPI_SR_W=  000003 
    SPI_TXCR=  005207     |     SQUOT   =  000006     |     SRC     =  000003 
    STACK_EM=  0017FF     |     STACK_SI=  0000A0     |   5 STEP       0023A0 R
    STEP_IDX=  0000AA     |   5 STOP       002397 R   |     STOP_IDX=  0000AC 
    STR     =  000003     |     STX     =  000002     |     SUB     =  00001A 
    SWIM_CSR=  007F80     |     SYN     =  000016     |     TAB     =  000009 
    TABW    =  000004     |     TAB_WIDT=  000004     |     TCHAR   =  000001 
    TEMP    =  000003     |     TIB_SIZE=  000050     |     TICK    =  000027 
  5 TICKS      00238D R   |     TICKS_ID=  0000AE     |     TIM1_ARR=  005262 
    TIM1_ARR=  005263     |     TIM1_BKR=  00526D     |     TIM1_CCE=  00525C 
    TIM1_CCE=  00525D     |     TIM1_CCM=  005258     |     TIM1_CCM=  000000 
    TIM1_CCM=  000001     |     TIM1_CCM=  000004     |     TIM1_CCM=  000005 
    TIM1_CCM=  000006     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000003     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000004     |     TIM1_CCM=  000005     |     TIM1_CCM=  000006 
    TIM1_CCM=  000003     |     TIM1_CCM=  005259     |     TIM1_CCM=  000000 
    TIM1_CCM=  000001     |     TIM1_CCM=  000004     |     TIM1_CCM=  000005 
    TIM1_CCM=  000006     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000003     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000004     |     TIM1_CCM=  000005     |     TIM1_CCM=  000006 
    TIM1_CCM=  000003     |     TIM1_CCM=  00525A     |     TIM1_CCM=  000000 
    TIM1_CCM=  000001     |     TIM1_CCM=  000004     |     TIM1_CCM=  000005 
    TIM1_CCM=  000006     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000003     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000004     |     TIM1_CCM=  000005     |     TIM1_CCM=  000006 
    TIM1_CCM=  000003     |     TIM1_CCM=  00525B     |     TIM1_CCM=  000000 
    TIM1_CCM=  000001     |     TIM1_CCM=  000004     |     TIM1_CCM=  000005 
    TIM1_CCM=  000006     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000003     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000004     |     TIM1_CCM=  000005     |     TIM1_CCM=  000006 
    TIM1_CCM=  000003     |     TIM1_CCR=  005265     |     TIM1_CCR=  005266 
    TIM1_CCR=  005267     |     TIM1_CCR=  005268     |     TIM1_CCR=  005269 
    TIM1_CCR=  00526A     |     TIM1_CCR=  00526B     |     TIM1_CCR=  00526C 
    TIM1_CNT=  00525E     |     TIM1_CNT=  00525F     |     TIM1_CR1=  005250 
    TIM1_CR2=  005251     |     TIM1_CR2=  000000     |     TIM1_CR2=  000002 
    TIM1_CR2=  000004     |     TIM1_CR2=  000005     |     TIM1_CR2=  000006 
    TIM1_DTR=  00526E     |     TIM1_EGR=  005257     |     TIM1_EGR=  000007 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 141.
Hexadecimal [24-Bits]

Symbol Table

    TIM1_EGR=  000001     |     TIM1_EGR=  000002     |     TIM1_EGR=  000003 
    TIM1_EGR=  000004     |     TIM1_EGR=  000005     |     TIM1_EGR=  000006 
    TIM1_EGR=  000000     |     TIM1_ETR=  005253     |     TIM1_ETR=  000006 
    TIM1_ETR=  000000     |     TIM1_ETR=  000001     |     TIM1_ETR=  000002 
    TIM1_ETR=  000003     |     TIM1_ETR=  000007     |     TIM1_ETR=  000004 
    TIM1_ETR=  000005     |     TIM1_IER=  005254     |     TIM1_IER=  000007 
    TIM1_IER=  000001     |     TIM1_IER=  000002     |     TIM1_IER=  000003 
    TIM1_IER=  000004     |     TIM1_IER=  000005     |     TIM1_IER=  000006 
    TIM1_IER=  000000     |     TIM1_OIS=  00526F     |     TIM1_PSC=  005260 
    TIM1_PSC=  005261     |     TIM1_RCR=  005264     |     TIM1_SMC=  005252 
    TIM1_SMC=  000007     |     TIM1_SMC=  000000     |     TIM1_SMC=  000001 
    TIM1_SMC=  000002     |     TIM1_SMC=  000004     |     TIM1_SMC=  000005 
    TIM1_SMC=  000006     |     TIM1_SR1=  005255     |     TIM1_SR1=  000007 
    TIM1_SR1=  000001     |     TIM1_SR1=  000002     |     TIM1_SR1=  000003 
    TIM1_SR1=  000004     |     TIM1_SR1=  000005     |     TIM1_SR1=  000006 
    TIM1_SR1=  000000     |     TIM1_SR2=  005256     |     TIM1_SR2=  000001 
    TIM1_SR2=  000002     |     TIM1_SR2=  000003     |     TIM1_SR2=  000004 
    TIM2_ARR=  00530D     |     TIM2_ARR=  00530E     |     TIM2_CCE=  005308 
    TIM2_CCE=  000000     |     TIM2_CCE=  000001     |     TIM2_CCE=  000004 
    TIM2_CCE=  000005     |     TIM2_CCE=  005309     |     TIM2_CCM=  005305 
    TIM2_CCM=  005306     |     TIM2_CCM=  005307     |     TIM2_CCM=  000000 
    TIM2_CCM=  000004     |     TIM2_CCM=  000003     |     TIM2_CCR=  00530F 
    TIM2_CCR=  005310     |     TIM2_CCR=  005311     |     TIM2_CCR=  005312 
    TIM2_CCR=  005313     |     TIM2_CCR=  005314     |     TIM2_CLK=  00F424 
    TIM2_CNT=  00530A     |     TIM2_CNT=  00530B     |     TIM2_CR1=  005300 
    TIM2_CR1=  000007     |     TIM2_CR1=  000000     |     TIM2_CR1=  000003 
    TIM2_CR1=  000001     |     TIM2_CR1=  000002     |     TIM2_EGR=  005304 
    TIM2_EGR=  000001     |     TIM2_EGR=  000002     |     TIM2_EGR=  000003 
    TIM2_EGR=  000006     |     TIM2_EGR=  000000     |     TIM2_IER=  005301 
    TIM2_PSC=  00530C     |     TIM2_SR1=  005302     |     TIM2_SR2=  005303 
    TIM3_ARR=  00532B     |     TIM3_ARR=  00532C     |     TIM3_CCE=  005327 
    TIM3_CCE=  000000     |     TIM3_CCE=  000001     |     TIM3_CCE=  000004 
    TIM3_CCE=  000005     |     TIM3_CCE=  000000     |     TIM3_CCE=  000001 
    TIM3_CCM=  005325     |     TIM3_CCM=  005326     |     TIM3_CCM=  000000 
    TIM3_CCM=  000004     |     TIM3_CCM=  000003     |     TIM3_CCR=  00532D 
    TIM3_CCR=  00532E     |     TIM3_CCR=  00532F     |     TIM3_CCR=  005330 
    TIM3_CNT=  005328     |     TIM3_CNT=  005329     |     TIM3_CR1=  005320 
    TIM3_CR1=  000007     |     TIM3_CR1=  000000     |     TIM3_CR1=  000003 
    TIM3_CR1=  000001     |     TIM3_CR1=  000002     |     TIM3_EGR=  005324 
    TIM3_IER=  005321     |     TIM3_PSC=  00532A     |     TIM3_SR1=  005322 
    TIM3_SR2=  005323     |     TIM4_ARR=  005346     |     TIM4_CNT=  005344 
    TIM4_CR1=  005340     |     TIM4_CR1=  000007     |     TIM4_CR1=  000000 
    TIM4_CR1=  000003     |     TIM4_CR1=  000001     |     TIM4_CR1=  000002 
    TIM4_EGR=  005343     |     TIM4_EGR=  000000     |     TIM4_IER=  005341 
    TIM4_IER=  000000     |     TIM4_PSC=  005345     |     TIM4_PSC=  000000 
    TIM4_PSC=  000007     |     TIM4_PSC=  000004     |     TIM4_PSC=  000001 
    TIM4_PSC=  000005     |     TIM4_PSC=  000002     |     TIM4_PSC=  000006 
    TIM4_PSC=  000003     |     TIM4_PSC=  000000     |     TIM4_PSC=  000001 
    TIM4_PSC=  000002     |     TIM4_SR =  005342     |     TIM4_SR_=  000000 
  5 TIMEOUT    002377 R   |   5 TIMER      002383 R   |     TIMER_ID=  0000B0 
    TIM_CR1_=  000007     |     TIM_CR1_=  000000     |     TIM_CR1_=  000006 
    TIM_CR1_=  000005     |     TIM_CR1_=  000004     |     TIM_CR1_=  000003 
    TIM_CR1_=  000001     |     TIM_CR1_=  000002     |     TK_ARRAY=  000006 
    TK_CFUNC=  000082     |     TK_CHAR =  000003     |     TK_CMD  =  000080 
    TK_COLON=  000001     |     TK_COMMA=  000009     |     TK_CONST=  000083 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 142.
Hexadecimal [24-Bits]

Symbol Table

    TK_DIV  =  000021     |     TK_EQUAL=  000032     |     TK_GE   =  000033 
    TK_GRP_A=  000010     |     TK_GRP_M=  000030     |     TK_GRP_M=  000000 
    TK_GRP_M=  000020     |     TK_GRP_R=  000030     |     TK_GT   =  000031 
    TK_IFUNC=  000081     |     TK_INTGR=  000084     |     TK_LE   =  000036 
    TK_LPARE=  000007     |     TK_LT   =  000034     |     TK_MINUS=  000011 
    TK_MOD  =  000022     |     TK_MULT =  000020     |     TK_NE   =  000035 
    TK_NONE =  000000     |     TK_PLUS =  000010     |     TK_QSTR =  000002 
    TK_RPARE=  000008     |     TK_SHARP=  00000A     |     TK_VAR  =  000085 
    TMROUT_I=  0000B2     |   5 TO         002370 R   |   5 TONE       002367 R
    TONE_IDX=  0000B6     |     TO_IDX  =  0000B4     |   5 Timer4Up   00004F R
    U1      =  000001     |     U8      =  000003     |     UART1   =  000000 
    UART1_BA=  005230     |     UART1_BR=  005232     |     UART1_BR=  005233 
    UART1_CR=  005234     |     UART1_CR=  005235     |     UART1_CR=  005236 
    UART1_CR=  005237     |     UART1_CR=  005238     |     UART1_DR=  005231 
    UART1_GT=  005239     |     UART1_PO=  000000     |     UART1_PS=  00523A 
    UART1_RX=  000004     |     UART1_SR=  005230     |     UART1_TX=  000005 
    UART3   =  000001     |     UART3_BA=  005240     |     UART3_BR=  005242 
    UART3_BR=  005243     |     UART3_CR=  005244     |     UART3_CR=  005245 
    UART3_CR=  005246     |     UART3_CR=  005247     |     UART3_CR=  004249 
    UART3_DR=  005241     |     UART3_PO=  00000F     |     UART3_RX=  000006 
    UART3_SR=  005240     |     UART3_TX=  000005     |     UART_BRR=  000002 
    UART_BRR=  000003     |     UART_CR1=  000004     |     UART_CR1=  000004 
    UART_CR1=  000002     |     UART_CR1=  000000     |     UART_CR1=  000001 
    UART_CR1=  000007     |     UART_CR1=  000006     |     UART_CR1=  000005 
    UART_CR1=  000003     |     UART_CR2=  000005     |     UART_CR2=  000004 
    UART_CR2=  000002     |     UART_CR2=  000005     |     UART_CR2=  000001 
    UART_CR2=  000000     |     UART_CR2=  000006     |     UART_CR2=  000003 
    UART_CR2=  000007     |     UART_CR3=  000006     |     UART_CR3=  000003 
    UART_CR3=  000001     |     UART_CR3=  000002     |     UART_CR3=  000000 
    UART_CR3=  000006     |     UART_CR3=  000004     |     UART_CR3=  000005 
    UART_CR4=  000007     |     UART_CR4=  000000     |     UART_CR4=  000001 
    UART_CR4=  000002     |     UART_CR4=  000003     |     UART_CR4=  000004 
    UART_CR4=  000006     |     UART_CR4=  000005     |     UART_CR5=  000008 
    UART_CR5=  000003     |     UART_CR5=  000001     |     UART_CR5=  000002 
    UART_CR5=  000004     |     UART_CR5=  000005     |     UART_CR6=  000009 
    UART_CR6=  000004     |     UART_CR6=  000007     |     UART_CR6=  000001 
    UART_CR6=  000002     |     UART_CR6=  000000     |     UART_CR6=  000005 
    UART_DR =  000001     |     UART_GTR=  000009     |     UART_PSC=  00000A 
    UART_SR =  000000     |     UART_SR_=  000001     |     UART_SR_=  000004 
    UART_SR_=  000002     |     UART_SR_=  000003     |     UART_SR_=  000000 
    UART_SR_=  000005     |     UART_SR_=  000006     |     UART_SR_=  000007 
    UBC     =  004801     |   5 UBOUND     00235C R   |     UBOUND_I=  0000B8 
  5 UBTN_Han   000092 R   |   5 UFLASH     002351 R   |     UFLASH_I=  0000BA 
  5 UNTIL      002347 R   |     UNTIL_ID=  0000BC     |     US      =  00001F 
  5 USER_ABO   00009A R   |   5 USR        00233F R   |     USR_BTN_=  000004 
    USR_BTN_=  000010     |     USR_BTN_=  005015     |     USR_IDX =  0000BE 
  5 Uart1RxH   00000F R   |   5 UserButt   000065 R   |     VAR_ADDR=  000006 
    VSIZ    =  000002     |     VSIZE   =  000006     |     VT      =  00000B 
  5 WAIT       002336 R   |     WAIT_IDX=  0000C0     |     WCNT    =  000003 
    WDGOPT  =  004805     |     WDGOPT_I=  000002     |     WDGOPT_L=  000003 
    WDGOPT_W=  000000     |     WDGOPT_W=  000001     |     WIDTH_SA=  000002 
    WLEN    =  000001     |   5 WORDS      00232C R   |     WORDS_ID=  0000C2 
  5 WRITE      002322 R   |     WRITE_ID=  0000C4     |     WWDG_CR =  0050D1 
    WWDG_WR =  0050D2     |     XFIRST  =  000001     |     XMASK   =  000001 
    XOFF    =  000013     |     XON     =  000011     |   5 XOR        00231A R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 143.
Hexadecimal [24-Bits]

Symbol Table

    XOR_IDX =  0000C6     |     XREG    =  000003     |     XSAVE   =  000005 
    YSAVE   =  000007     |   5 abs        001E5A R   |   1 acc16      00000C GR
  1 acc24      00000B GR  |   1 acc8       00000D GR  |   5 add_char   0014BC R
  5 add_spac   0012E6 R   |   5 analog_r   0018D2 R   |   5 arduino_   001F45 R
  5 arg_list   001016 R   |   1 array_si   000021 R   |   5 ascii      001D0A R
  5 at_tst     000CA8 R   |   5 atoi24     000DB9 GR  |   5 atoi_exi   000E1F R
  5 autorun    001D95 R   |   5 autorun_   0006D2 R   |   5 awu        001E0B R
  5 awu02      001E15 R   |   5 bad_port   001D64 R   |   1 base       00000A R
  1 basicptr   000004 GR  |   5 beep       00185F R   |   5 beep_1kh   001849 GR
  5 bin_exit   000B86 R   |   5 bit_and    001E6E R   |   5 bit_or     001E86 R
  5 bit_rese   001634 R   |   5 bit_set    001624 R   |   5 bit_test   001655 R
  5 bit_togg   001645 R   |   5 bit_xor    001E9E R   |   5 bitmask    0020B1 R
  5 bkslsh_t   000C55 R   |   5 block_er   0001BB R   |   5 break_po   00199F R
  5 bye        001D8C R   |   5 cancel_a   00069A R   |   5 char       001CF8 R
  5 clear_ba   0006E7 R   |   5 clear_va   000561 R   |   5 clock_in   0000B5 R
  5 cmd_end    001842 R   |   5 cmd_line   000905 R   |   5 cmd_name   000F85 R
  5 cmp_name   001A40 R   |   5 code_add   0026B9 R   |   5 cold_sta   0005D8 R
  5 colon_ts   000C7C R   |   5 comma_ts   000C87 R   |   5 comp_msg   00085B R
  5 compile    0004EE R   |   5 const_cr   002165 R   |   5 const_cr   00216B R
  5 const_dd   00215F R   |   5 const_ee   00217D R   |   5 const_id   002159 R
  5 const_in   002177 R   |   5 const_od   002153 R   |   5 const_ou   002171 R
  5 const_po   00211D R   |   5 const_po   002123 R   |   5 const_po   002129 R
  5 const_po   00212F R   |   5 const_po   002135 R   |   5 const_po   00213B R
  5 const_po   002141 R   |   5 const_po   002147 R   |   5 const_po   00214D R
  5 convert_   000AFD R   |   5 copy_com   000CDD R   |   1 count      000003 GR
  5 cp_loop    000FC5 R   |   5 cpy_cmd_   0012D1 R   |   5 cpy_quot   00130A R
  5 create_g   000455 R   |   5 cs_high    00230D R   |   5 cstk_pro   0011CD R
  5 dash_tst   000C9D R   |   5 data       002183 R   |   1 data_len   000009 R
  5 data_lin   002189 R   |   1 data_ofs   000008 R   |   1 data_ptr   000006 R
  5 data_sea   0021C9 R   |   5 dbl_sign   000EED R   |   5 dec_base   0011F9 R
  5 decomp_l   0013BB R   |   5 decompil   001374 GR  |   5 del_line   000428 R
  5 digital_   001906 R   |   5 digital_   001936 R   |   5 dir_loop   001C4B R
  5 director   001C3F R   |   5 disk_fre   001A2D R   |   5 div32_16   000EF7 R
  5 divide     000F4E R   |   5 divu24_8   000A40 R   |   5 dneg       000EE2 R
  5 do_loop    0020DA R   |   5 do_progr   0001AE R   |   5 drive_fr   001CB4 R
  5 enable_i   00205B R   |   5 eql_tst    000D32 R   |   5 equal      0014CF R
  5 erase_fl   0001DA R   |   5 err_bad_   0007C7 R   |   5 err_buf_   00083D R
  5 err_cmd_   00078B R   |   5 err_div0   000750 R   |   5 err_dupl   0007A5 R
  5 err_math   000737 R   |   5 err_mem_   00071C R   |   5 err_msg    0006FC R
  5 err_no_a   0007D3 R   |   5 err_no_d   000806 R   |   5 err_no_f   00082A R
  5 err_no_l   00075F R   |   5 err_no_p   000816 R   |   5 err_not_   0007B6 R
  5 err_run_   000775 R   |   5 err_synt   000729 R   |   5 escaped    000B12 R
  5 expect     001004 R   |   5 expr_exi   001155 R   |   5 expressi   00110F R
  5 factor     001066 R   |   1 farptr     000016 R   |   5 fcpu       001EE8 R
  7 fdrive     010000 R   |   1 ffree      000019 R   |   5 file_cou   001CAC R
  5 first_li   00127E R   |   1 flags      000023 R   |   5 for        0016B0 R
  5 forget     001BD8 R   |   1 free_ram   000063 R   |   5 func_arg   001011 R
  5 func_not   00204E R   |   5 ge         0014D1 R   |   5 get_arra   001041 R
  5 get_cmd_   001353 R   |   5 get_targ   00177A R   |   5 get_tick   001E54 R
  5 get_toke   000BEE R   |   5 getc       0002C9 GR  |   5 gosub      0017AB R
  5 goto       001790 R   |   5 gpio       001D3F R   |   5 gt         0014CD R
  5 gt_tst     000D3D R   |   5 hex_base   0011F4 R   |   5 hex_dump   000359 R
  5 if         00169C R   |   1 in         000001 R   |   1 in.saved   000002 R
  1 in.w       000000 R   |   5 incr_far   0019ED R   |   5 input_ex   0015F6 R
  5 input_lo   00158F R   |   5 input_va   00158D R   |   5 insert_l   000481 R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 144.
Hexadecimal [24-Bits]

Symbol Table

  5 insert_l   0004EB R   |   5 interp_l   000946 R   |   5 interpre   000921 R
  5 invert     0020CB R   |   5 is_alnum   000589 R   |   5 is_alpha   00056F R
  5 is_digit   000580 R   |   5 itoa       0009E6 R   |   5 itoa_loo   000A05 R
  5 jp_to_ta   00179E R   |   5 key        001D2A R   |   5 kw_loop    000BA2 R
  5 kword_di   0026B1 R   |   5 kword_en   002318 R   |   5 le         0014D6 R
  5 leading_   0020A1 R   |   5 let        00122A R   |   5 let_arra   001238 R
  5 let_var    00123B R   |   5 lines_sk   001281 R   |   5 list       001255 R
  5 list_exi   0012C3 R   |   5 list_loo   0012A1 R   |   5 load       001BA8 R
  5 load_aut   0006A9 R   |   5 load_fil   001B77 R   |   5 log2       002096 R
  5 logical_   002044 R   |   5 long_div   000ECA R   |   5 loop_bac   00175D R
  1 loop_dep   000020 R   |   5 loop_don   001772 R   |   5 lshift     001EB6 R
  5 lt         0014D4 R   |   5 lt_tst     000D66 R   |   5 modulo     000F64 R
  5 move       0003C2 GR  |   5 move_dow   0003E0 R   |   5 move_era   000140 R
  5 move_exi   000401 R   |   5 move_loo   0003E5 R   |   5 move_prg   000174 R
  5 move_up    0003D2 R   |   5 mul_char   0014BE R   |   5 muldiv     000F69 R
  5 multiply   000E95 R   |   5 mulu24_8   000A68 R   |   5 nbr_tst    000C21 R
  5 ne         0014D9 R   |   5 neg_acc2   000AA2 R   |   5 new        0019BD R
  5 next       001730 R   |   5 next_lin   000929 R   |   5 next_tok   00096D R
  5 no_match   000FD7 R   |   5 other      000D8F R   |   3 pad        0016E0 R
  5 pad_ref    002312 R   |   5 parse_bi   000B64 R   |   5 parse_in   000B1A R
  5 parse_ke   000BA1 R   |   5 parse_qu   000AC5 R   |   5 pause      001DF8 R
  5 pause02    001E02 R   |   5 peek       00168B R   |   5 pin_mode   001EF4 R
  5 plus_tst   000D06 R   |   5 poke       00167C R   |   5 power_ad   001896 R
  5 prcnt_ts   000D27 R   |   5 print      0014FC R   |   5 print_ex   001561 R
  5 print_in   0009CA R   |   5 printxy    000E36 R   |   5 program_   000154 R
  5 program_   000174 R   |   5 prt_basi   0014DC R   |   5 prt_loop   001500 R
  5 prt_tok    0002EB R   |   5 prti24     0009DA R   |   1 ptr16      000017 R
  1 ptr8       000018 R   |   5 putc       0002C0 GR  |     puts       ****** GX
  5 qkey       001D32 GR  |   5 qmark_ts   000CB3 R   |   5 random     001F65 R
  5 read       002201 R   |   5 read01     002203 R   |     readln     ****** GX
  5 refresh_   002091 R   |   5 rel_exit   0011B0 R   |   5 relation   001158 R
  5 relop_st   0014C1 R   |   5 remark     0015F9 R   |   5 reset_co   0014FE R
  5 rest_con   00157D R   |   5 restore    0021B6 R   |   5 return     0017CB R
  5 right_al   0012F8 R   |   5 row_alig   0019D2 R   |   5 row_eras   000119 R
  5 row_eras   000140 R   |   5 row_loop   00033C R   |   5 rparnt_t   000C71 R
  5 rshift     001ECF R   |   5 rt_msg     00084A R   |   5 run        0017E9 R
  5 run_it     00181B R   |   1 rx_head    00002D R   |   1 rx_queue   000025 R
  1 rx_tail    00002E R   |   5 save       001AAE R   |   5 save_con   00156D R
  5 search_d   000FB7 R   |   5 search_e   001001 R   |   5 search_f   001A61 R
  5 search_l   000404 GR  |   5 search_l   00040C R   |   5 search_n   000FBB R
  1 seedx      000012 R   |   1 seedy      000014 R   |   5 seek_fdr   0019FB R
  5 select_p   001F35 R   |   5 set_time   002032 R   |   5 sharp_ts   000C92 R
  5 show       0011B3 R   |   5 show_row   00032A R   |   5 single_c   0014B7 R
  5 size       0011FE R   |   5 skip       000E23 R   |   5 slash_ts   000D1C R
  5 sleep      001DED R   |   5 software   000592 R   |     spaces     ****** GX
  5 spi_clea   0022A6 R   |   5 spi_disa   00228E R   |   5 spi_enab   00225B R
  5 spi_rcv_   0022C8 R   |   5 spi_read   0022F3 R   |   5 spi_sele   0022FB R
  5 spi_send   0022B2 R   |   5 spi_writ   0022D3 R   |   3 stack_fu   001760 R
  3 stack_un   001800 R   |   5 star_tst   000D11 R   |   5 step       001709 R
  5 stop       001971 R   |   5 store_lo   00171D R   |   5 str_matc   000FE4 R
  5 str_tst    000C11 R   |   5 strcmp     0003A3 R   |   5 strcpy     0003B4 R
  5 strlen     000396 GR  |   5 syntax_e   00087B R   |   1 tab_widt   000024 R
  5 tb_error   00087D R   |   5 term       0010C0 R   |   5 term01     0010C9 R
  5 term_exi   00110C R   |   3 tib        001690 GR  |   5 tick_tst   000CCB R
  1 ticks      00000E R   |   5 timeout    002041 R   |   1 timer      000010 R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 145.
Hexadecimal [24-Bits]

Symbol Table

  5 timer2_i   0000CB R   |   5 timer4_i   0000D8 R   |   5 tk_id      00086B R
  5 to         0016D9 R   |   5 to_eepro   000197 R   |   5 to_flash   0001AB R
  5 to_upper   000DAD GR  |   5 token_ch   000DA6 R   |   5 token_ex   000DAA R
  5 token_ms   000322 R   |   5 tone       001852 R   |   5 try_next   0021F1 R
  1 txtbgn     00001C R   |   1 txtend     00001E R   |   5 uart1_in   00027D R
  5 uart1_se   00028D R   |   5 ubound     001208 R   |   5 udiv32_1   000EB8 R
  5 uflash     001D69 R   |   5 umstar     000E5B R   |   5 unlock_e   0000ED R
  5 unlock_f   000103 R   |   5 until      0020EF R   |   5 user_int   000078 R
  5 user_spa   002800 R   |   5 usr        001D6F R   |   5 var_name   00134B R
  1 vars       00002F R   |   5 wait       0015FF R   |   5 warm_ini   00067C R
  5 warm_sta   000902 R   |   5 words      001FCC R   |   5 words_co   00201C R
  5 write      001CC1 R   |   5 write_bl   00025A R   |   5 write_by   0001E5 R
  5 write_ee   000221 R   |   5 write_ex   000255 R   |   5 write_fl   00020B R
  5 write_ro   000188 R   |   5 zero_pad   0019C7 R

ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 146.
Hexadecimal [24-Bits]

Area Table

   0 _CODE      size      0   flags    0
   1 DATA       size     63   flags    0
   2 SSEG       size      0   flags    8
   3 SSEG0      size    170   flags    8
   4 HOME       size     80   flags    0
   5 CODE       size   280E   flags    0
   6 FLASH_DR   size      0   flags    8
   7 FLASH_DR   size      0   flags    8

