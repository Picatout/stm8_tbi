ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 1.
Hexadecimal [24-Bits]



                                      1 ;;
                                      2 ; Copyright Jacques Deschênes 2019,2020 
                                      3 ; This file is part of PABasic 
                                      4 ;
                                      5 ;     PABasic is free software: you can redistribute it and/or modify
                                      6 ;     it under the terms of the GNU General Public License as published by
                                      7 ;     the Free Software Foundation, either version 3 of the License, or
                                      8 ;     (at your option) any later version.
                                      9 ;
                                     10 ;     PABasic is distributed in the hope that it will be useful,
                                     11 ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                     12 ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                     13 ;     GNU General Public License for more details.
                                     14 ;
                                     15 ;     You should have received a copy of the GNU General Public License
                                     16 ;     along with PABasic.  If not, see <http://www.gnu.org/licenses/>.
                                     17 ;;
                                     18 ;--------------------------------------
                                     19 ;   Implementation of Tiny BASIC
                                     20 ;   REF: https://en.wikipedia.org/wiki/Li-Chen_Wang#Palo_Alto_Tiny_BASIC
                                     21 ;   Palo Alto BASIC is 4th version of TinyBasic
                                     22 ;   DATE: 2019-12-17
                                     23 ;
                                     24 ;--------------------------------------------------
                                     25 
                                     26     .module TBI_STM8
                                     27 
                                        	.include "inc/nucleo_8s208.inc"
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of MONA 
                                        ;
                                        ;     MONA is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     MONA is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with MONA.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ; NUCLEO-8S208RB board specific definitions
                                        ; Date: 2019/10/29
                                        ; author: Jacques Deschênes, copyright 2018,2019
                                        ; licence: GPLv3
                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        
                                        ; mcu on board is stm8s208rbt6
                                        
                                        ; crystal on board is 8Mhz
                                 
                                        
                                        ; LED2 is user LED
                                        ; connected to PC5 via Q2 -> 2N7002 MOSFET
                                 
                                 
                                 
                                        
                                        ; B1 on schematic is user button
                                        ; connected to PE4
                                        ; external pullup resistor R6 4k7 and debounce capacitor C5 100nF
                                 
                                 
                                 
                                        
                                        
                                        	.include "inc/stm8s208.inc"
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of MONA 
                                        ;
                                        ;     MONA is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     MONA is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with MONA.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ; 2019/10/18
                                        ; STM8S208RB µC registers map
                                        ; sdas source file
                                        ; author: Jacques Deschênes, copyright 2018,2019
                                        ; licence: GPLv3
                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        	.module stm8s208rb
                                        
                                        ;;;;;;;;;;;;
                                        ; bits
                                        ;;;;;;;;;;;;
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                         	
                                        ;;;;;;;;;;;;
                                        ; bits masks
                                        ;;;;;;;;;;;;
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; HSI oscillator frequency 16Mhz
                                 
                                        ; LSI oscillator frequency 128Khz
                                 
                                        
                                        ; controller memory regions
                                 
                                 
                                        ; STM8S208RB have 128K flash
                                 
                                        ; erase block size 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; options bytes
                                        ; this one can be programmed only from SWIM  (ICP)
                                 
                                        ; these can be programmed at runtime (IAP)
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; option registers usage
                                        ; read out protection, value 0xAA enable ROP
                                 
                                        ; user boot code, {0..0x3e} 512 bytes row
                                 
                                 
                                        ; alternate function register
                                 
                                 
                                        ; miscelinous options
                                 
                                 
                                        ; clock options
                                 
                                 
                                        ; HSE clock startup delay
                                 
                                 
                                        ; flash wait state
                                 
                                 
                                        
                                        ; watchdog options bits
                                 
                                 
                                 
                                 
                                        ; NWDGOPT bits
                                 
                                 
                                 
                                 
                                        
                                        ; CLKOPT bits
                                 
                                 
                                 
                                 
                                        
                                        ; AFR option, remapable functions
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; device ID = (read only)
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        
                                 
                                 
                                        ; PORTS SFR OFFSET
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; GPIO
                                        ; gpio register offset to base
                                 
                                 
                                 
                                 
                                 
                                 
                                         
                                        ; port A
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port B
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port C
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port D
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port E
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port F
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port G
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port H not present on LQFP48/LQFP64 package
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port I ; only bit 0 on LQFP64 package, not present on LQFP48
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; input modes CR1
                                 
                                 
                                        ; output mode CR1
                                 
                                 
                                        ; input modes CR2
                                 
                                 
                                        ; output speed CR2
                                 
                                 
                                        
                                        
                                        ; Flash memory
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; data memory unlock keys
                                 
                                 
                                        ; flash memory unlock keys
                                 
                                 
                                        ; FLASH_CR1 bits
                                 
                                 
                                 
                                 
                                        ; FLASH_CR2 bits
                                 
                                 
                                 
                                 
                                 
                                        ; FLASH_FPR bits
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; FLASH_NFPR bits
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; FLASH_IAPSR bits
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Interrupt control
                                 
                                 
                                        
                                        ; Reset Status
                                 
                                        
                                        ; Clock Registers
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Peripherals clock gating
                                        ; CLK_PCKENR1 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; CLK_PCKENR2
                                 
                                 
                                 
                                        
                                        ; Clock bits
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                        ; clock source
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Watchdog
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                         
                                 
                                 
                                 
                                 
                                        
                                        
                                        
                                        ; Beeper
                                        ; beeper output is alternate function AFR7 on PD4
                                        ; connected to CN9-6
                                 
                                 
                                 
                                 
                                        
                                        ; SPI
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; SPI_CR1 bit fields 
                                 
                                 
                                 
                                 
                                 
                                 
                                          
                                        ; SPI_CR2 bit fields 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; SPI_SR bit fields 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; I2C
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                        
                                        ; Precalculated values, all in KHz
                                 
                                 
                                        ;
                                        ; Fast I2C mode max rise time = 300ns
                                        ; I2C_FREQR = 16 = (MHz) => tMASTER = 1/16 = 62.5 ns
                                        ; TRISER = = (300/62.5) + 1 = floor(4.8) + 1 = 5.
                                        
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                        ;
                                        ; Standard I2C mode max rise time = 1000ns
                                        ; I2C_FREQR = 16 = (MHz) => tMASTER = 1/16 = 62.5 ns
                                        ; TRISER = = (1000/62.5) + 1 = floor(16) + 1 = 17.
                                        
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                        
                                        ; baudrate constant for brr_value table access
                                        ; to be used by uart_init 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; UART registers offset from
                                        ; base address 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; uart identifier
                                        ; to be used by uart_init
                                 
                                 
                                        
                                        ; pins used by uart 
                                 
                                 
                                 
                                 
                                        ; uart port base address 
                                 
                                 
                                        
                                        ; UART1 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; UART3
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; UART Status Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Uart Control Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        ; LIN mode config register
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; TIMERS
                                        ; Timer 1 - 16-bit timer with complementary PWM outputs
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Control Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Slave Mode Control bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer External Trigger Enable bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Interrupt Enable bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Status Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Event Generation Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 1 - channel configured in output
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 1 - channel configured in input
                                 
                                 
                                 
                                 
                                 
                                 
                                        ;  TIM1_CCMR1_CC1S1 = (1)
                                 
                                        
                                        ; Capture/Compare Mode Register 2 - channel configured in output
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 2 - channel configured in input
                                 
                                 
                                 
                                 
                                 
                                 
                                        ;  TIM1_CCMR2_CC2S1 = (1)
                                 
                                        
                                        ; Capture/Compare Mode Register 3 - channel configured in output
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 3 - channel configured in input
                                 
                                 
                                 
                                 
                                 
                                 
                                        ;  TIM1_CCMR3_CC3S1 = (1)
                                 
                                        
                                        ; Capture/Compare Mode Register 4 - channel configured in output
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 4 - channel configured in input
                                 
                                 
                                 
                                 
                                 
                                 
                                        ;  TIM1_CCMR4_CC4S1 = (1)
                                 
                                        
                                        ; Timer 2 - 16-bit timer
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; TIM2_CR1 bitfields
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; TIMER2_CCMR bitfields 
                                 
                                 
                                 
                                        
                                        ; TIMER2_CCER1 bitfields
                                 
                                 
                                 
                                 
                                        
                                        ; TIMER2_EGR bitfields
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer 3
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; TIM3_CR1  fields
                                 
                                 
                                 
                                 
                                 
                                        ; TIM3_CCR2  fields
                                 
                                 
                                 
                                        ; TIM3_CCER1 fields
                                 
                                 
                                 
                                 
                                        ; TIM3_CCER2 fields
                                 
                                 
                                        
                                        ; Timer 4
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer 4 bitmasks
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                        
                                 
                                        
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; ADC2
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                         
                                        ; ADC bitmasks
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                        
                                        ; beCAN
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        
                                        ; CPU
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; global configuration register
                                 
                                 
                                 
                                        
                                        ; interrupt control registers
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; SWIM, control and status register
                                 
                                        ; debug registers
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Interrupt Numbers
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Interrupt Vectors
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Condition code register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        	.include "inc/ascii.inc"
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of MONA 
                                        ;
                                        ;     MONA is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     MONA is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with MONA.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        
                                        ;-------------------------------------------------------
                                        ;     ASCII control  values
                                        ;     CTRL_x   are VT100 keyboard values  
                                        ;-------------------------------------------------------
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        	.include "inc/gen_macros.inc" 
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of STM8_NUCLEO 
                                        ;
                                        ;     STM8_NUCLEO is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     STM8_NUCLEO is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with STM8_NUCLEO.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        ;--------------------------------------
                                        ;   console Input/Output module
                                        ;   DATE: 2019-12-11
                                        ;    
                                        ;   General usage macros.   
                                        ;
                                        ;--------------------------------------
                                        
                                            ; reserve space on stack
                                            ; for local variabls
                                            .macro _vars n 
                                            
                                            ; free space on stack
                                            .macro _drop n 
                                        
                                            ; declare ARG_OFS for arguments 
                                            ; displacement on stack. This 
                                            ; value depend on local variables 
                                            ; size.
                                            .macro _argofs n 
                                        
                                            ; declare a function argument 
                                            ; position relative to stack pointer 
                                            ; _argofs must be called before it.
                                            .macro _arg name ofs 
                                        	.include "pab_macros.inc" 
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of STM8_NUCLEO 
                                        ;
                                        ;     STM8_NUCLEO is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     STM8_NUCLEO is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with STM8_NUCLEO.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        ;--------------------------------------
                                 
                                 
                                                ; keyword types 
                                 
                                 
                                 
                                 
                                        
                                        ;--------------------------------------
                                        ;   constantes related to Arduino 
                                        ;   API mapping 
                                        ;-------------------------------------
                                 
                                 
                                        
                                        ;--------------------------------------
                                        ;       token attribute
                                        ;--------------------------------------
                                                ; bits 4:5 identify token group 
                                                ; 0x0n -> miscelinous 
                                                ; 0x1n -> +|- operators 
                                                ; 0x2n -> *|/|% operators
                                                ; 0x3n -> relational operators 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                                ; don't change these token values 
                                                ; values chosen to be used as a mask.
                                                ; bits 7:6  always 0 
                                                ; bits 5:4 identify group 
                                                ; bits 3:0 token identifier inside group  
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ;--------------------------------------
                                        ;   error codes 
                                        ;--------------------------------------
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                            
                                        ;--------------------------------------
                                        ;   assembler flags 
                                        ;-------------------------------------
                                 
                                        
                                 
                                        
                                            .macro _usec_dly n 
                                            
                                            ; load X register with 
                                            ; entry point of dictionary
                                            ; before calling 'search_dict'
                                            .macro _ldx_dict dict_name
                                        
                                            ; reset BASIC pointer
                                            ; to beginning of last token
                                            ; parsed 
                                            .macro _unget_token 
                                        
                                        ;-------------------------------
                                        ;  macros used to help debugging
                                        ;-------------------------------
                                 
                                            .macro _dbg 
                                        
                                            .macro _nodbg
                                        
                                 
                                 
                                 
                                 
                                            .macro _dbg_save_regs 
                                        
                                            .macro _dbg_restore_regs 
                                        
                                            .macro _dbg_getc 
                                        
                                            .macro _dbg_putc 
                                        
                                            .macro _dbg_puts 
                                        
                                            .macro _dbg_prti24 
                                        
                                            .macro _dbg_prt_regs
                                        
                                            .macro _dbg_peek addr 
                                        
                                            .macro _dbg_parser_init 
                                        
                                            .macro _dbg_readln
                                        
                                            .macro _dbg_number
                                        
                                            .macro _dbg_nextword
                                        
                                            .macro _dbg_dots 
                                        
                                            .macro _dbg_trap
                                        
                                            .macro _dbg_mark n  
                                            
                                            .macro _dbg_prt_var var 
                                        
                                            .macro _dbg_show 
                                        
                                            ; software reset 
                                            .macro _swreset
                                     34     .list 
                                     35 
                                     36 ;_dbg 
                                     37 
                                     38 	
                                     39 ;--------------------------------------
                                     40     .area DATA 
                                     41 ;--------------------------------------	
                                     42 
                           000050    43 	TIB_SIZE=80
                           000028    44     PAD_SIZE=40
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 2.
Hexadecimal [24-Bits]



                           0000A0    45 	STACK_SIZE=160
                           0017FF    46 	STACK_EMPTY=RAM_SIZE-1  
                           000000    47 	FRUN=0 ; flags run code in variable flags
                           000001    48 	FTRAP=1 ; inside trap handler 
                           000002    49 	FLOOP=2 ; FOR loop in preparation 
                           000003    50 	FSLEEP=3 ; halt produit par la commande SLEEP 
                           000004    51 	FBREAK=4 ; break point flag 
                           000005    52 	FCOMP=5  ; compiling flags 
                                     53 
                           004000    54 	AUTORUN_NAME=0x4000 ; address in EEPROM where auto run file name is saved 
                                     55 
                           000006    56     FIRST_DATA_ITEM=6 ; first DATA item offset on line.
                                     57 
                           007FFF    58 	MAX_LINENO=0x7fff; BASIC maximum line number 
                                     59 
      000000                         60 in.w:  .blkb 1 ; parser position in text line
      000001                         61 in:    .blkb 1 ; low byte of in.w
      000002                         62 in.saved: .blkb 1 ; set by get_token before parsing next token, used by unget_token
      000003                         63 count: .blkb 1 ; current BASIC line length and tib text length  
      000004                         64 basicptr:  .blkb 2  ; point to current BASIC line address.
      000006                         65 data_ptr:  .blkw 1  ; point to DATA address
      000008                         66 data_ofs:  .blkb 1  ; index to next data item 
      000009                         67 data_len:  .blkb 1  ; length of data line 
      00000A                         68 base:  .blkb 1 ; nemeric base used to print integer 
      00000B                         69 acc24: .blkb 1 ; 24 bit accumulator
      00000C                         70 acc16: .blkb 1 ; 16 bit accumulator, middle byte of acc24
      00000D                         71 acc8:  .blkb 1 ;  8 bit accumulator, least byte of acc24 
      00000E                         72 ticks: .blkw 1 ; milliseconds ticks counter (see Timer4UpdateHandler)
      000010                         73 timer: .blkw 1 ;  milliseconds count down timer 
      000012                         74 seedx: .blkw 1  ; xorshift 16 seed x  used by RND() function 
      000014                         75 seedy: .blkw 1  ; xorshift 16 seed y  used by RND() funcion
      000016                         76 farptr: .blkb 1 ; 24 bits pointer used by file system
      000017                         77 ptr16:  .blkb 1 ; 16 bits pointer ,  middle byte of farptr
      000018                         78 ptr8:   .blkb 1 ; 8 bits pointer, least byte of farptr 
      000019                         79 ffree: .blkb 3 ; flash free address ; file system free space pointer
      00001C                         80 dstkptr: .blkw 1  ; data stack pointer 
      00001E                         81 txtbgn: .blkw 1 ; tokenized BASIC text beginning address 
      000020                         82 txtend: .blkw 1 ; tokenized BASIC text end address 
      000022                         83 loop_depth: .blkb 1 ; level of nested loop. Conformity check   
      000023                         84 array_size: .blkw 1 ; array size, free RAM left after BASIC code.  
      000025                         85 flags: .blkb 1 ; various boolean flags
      000026                         86 tab_width: .blkb 1 ; print colon width (4)
      000027                         87 rx_char: .blkb 1 ; last received character 
      000028                         88 vars: .blkw 26 ; BASIC variables A-Z, keep it as but last .
                                     89 ; keep as last variable 
      00005C                         90 free_ram: ; from here RAM free for BASIC text 
                                     91 
                                     92 ;-----------------------------------
                                     93     .area SSEG (ABS)
                                     94 ;-----------------------------------
                                     95 ;;;; working buffers and stacks at end of RAM. 	
      0016E8                         96     .org RAM_SIZE-STACK_SIZE-TIB_SIZE-PAD_SIZE 
      0016E8                         97 tib: .ds TIB_SIZE             ; transaction input buffer
      001738                         98 pad: .ds PAD_SIZE             ; working buffer
      001760                         99 stack_full: .ds STACK_SIZE   ; control stack 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 3.
Hexadecimal [24-Bits]



      001800                        100 stack_unf: ; stack underflow ; control_stack bottom 
                                    101 
                                    102 ;--------------------------------------
                                    103     .area HOME 
                                    104 ;--------------------------------------
      000000 82 00 04 D4            105     int cold_start			; RESET vector 
                           000000   106 .if DEBUG
                                    107 	int TrapHandler 		;TRAP  software interrupt
                           000001   108 .else
      000004 82 00 00 00            109 	int NonHandledInterrupt ;TRAP  software interrupt
                                    110 .endif
      000008 82 00 00 00            111 	int NonHandledInterrupt ;int0 TLI   external top level interrupt
      00000C 82 00 00 01            112 	int AWUHandler          ;int1 AWU   auto wake up from halt
      000010 82 00 00 00            113 	int NonHandledInterrupt ;int2 CLK   clock controller
      000014 82 00 00 00            114 	int NonHandledInterrupt ;int3 EXTI0 gpio A external interrupts
      000018 82 00 00 00            115 	int NonHandledInterrupt ;int4 EXTI1 gpio B external interrupts
      00001C 82 00 00 00            116 	int NonHandledInterrupt ;int5 EXTI2 gpio C external interrupts
      000020 82 00 00 00            117 	int NonHandledInterrupt ;int6 EXTI3 gpio D external interrupts
      000024 82 00 00 3C            118 	int UserButtonHandler   ;int7 EXTI4 gpio E external interrupts
      000028 82 00 00 00            119 	int NonHandledInterrupt ;int8 beCAN RX interrupt
      00002C 82 00 00 00            120 	int NonHandledInterrupt ;int9 beCAN TX/ER/SC interrupt
      000030 82 00 00 00            121 	int NonHandledInterrupt ;int10 SPI End of transfer
      000034 82 00 00 00            122 	int NonHandledInterrupt ;int11 TIM1 update/overflow/underflow/trigger/break
      000038 82 00 00 00            123 	int NonHandledInterrupt ;int12 TIM1 capture/compare
      00003C 82 00 00 00            124 	int NonHandledInterrupt ;int13 TIM2 update /overflow
      000040 82 00 00 00            125 	int NonHandledInterrupt ;int14 TIM2 capture/compare
      000044 82 00 00 00            126 	int NonHandledInterrupt ;int15 TIM3 Update/overflow
      000048 82 00 00 00            127 	int NonHandledInterrupt ;int16 TIM3 Capture/compare
      00004C 82 00 00 00            128 	int NonHandledInterrupt ;int17 UART1 TX completed
      000050 82 00 00 0F            129 	int Uart1RxHandler		;int18 UART1 RX full ; user communication channel.
      000054 82 00 00 00            130 	int NonHandledInterrupt ;int19 I2C 
      000058 82 00 00 00            131 	int NonHandledInterrupt ;int20 UART1 TX completed
      00005C 82 00 00 00            132 	int NonHandledInterrupt ;int21 UART1 RX full
      000060 82 00 00 00            133 	int NonHandledInterrupt ;int22 ADC2 end of conversion
      000064 82 00 00 26            134 	int Timer4UpdateHandler	;int23 TIM4 update/overflow ; used as msec ticks counter
      000068 82 00 00 00            135 	int NonHandledInterrupt ;int24 flash writing EOP/WR_PG_DIS
      00006C 82 00 00 00            136 	int NonHandledInterrupt ;int25  not used
      000070 82 00 00 00            137 	int NonHandledInterrupt ;int26  not used
      000074 82 00 00 00            138 	int NonHandledInterrupt ;int27  not used
      000078 82 00 00 00            139 	int NonHandledInterrupt ;int28  not used
      00007C 82 00 00 00            140 	int NonHandledInterrupt ;int29  not used
                                    141 
                                    142 ;---------------------------------------
                                    143     .area CODE
                                    144 ;---------------------------------------
                           000000   145 .if DEBUG
                                    146 .asciz "STM8_TBI" ; I like to put module name here.
                                    147 .endif 
                                    148 
                                    149 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    150 ; non handled interrupt 
                                    151 ; reset MCU
                                    152 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
      000000                        153 NonHandledInterrupt:
      000000 71                     154     .byte 0x71  ; invalid opcode reinitialize MCU
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 4.
Hexadecimal [24-Bits]



                                    155 
                                    156 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    157 ; auto wakeup from halt
                                    158 ; at iret, program continue 
                                    159 ; after hatl instruction
                                    160 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      000001                        161 AWUHandler:
      000001 72 19 50 F0      [ 1]  162 	bres AWU_CSR,#AWU_CSR_AWUEN
      000005 55 00 3F 50 F1   [ 1]  163 	mov AWU_APR,0x3F
      00000A 72 5F 50 F2      [ 1]  164 	clr AWU_TBR 
      00000E 80               [11]  165 	iret
                                    166 
                                    167 ;--------------------------
                                    168 ; UART1 receive character
                                    169 ; CTRL-C (ASCII 3)
                                    170 ; cancel program execution
                                    171 ; and fall back to command line
                                    172 ;--------------------------
      00000F                        173 Uart1RxHandler:
      00000F 72 0B 52 30 FB   [ 2]  174 	btjf UART1_SR,#UART_SR_RXNE,.
      000014 C6 52 31         [ 1]  175 	ld a,UART1_DR 
      000017 A1 03            [ 1]  176 	cp a,#CTRL_C 
      000019 26 07            [ 1]  177 	jrne 1$
      00001B 72 5F 00 27      [ 1]  178 	clr rx_char 
      00001F CC 00 4F         [ 2]  179 	jp user_interrupted
      000022                        180 1$:
      000022 C7 00 27         [ 1]  181 	ld rx_char,a 	
      000025 80               [11]  182 	iret 
                                    183 
                                    184 ;------------------------------------
                                    185 ; software interrupt handler  
                                    186 ;------------------------------------
                           000000   187 .if DEBUG 
                                    188 TrapHandler:
                                    189 	bset flags,#FTRAP 
                                    190 	call print_registers
                                    191 	call cmd_itf
                                    192 	bres flags,#FTRAP 	
                                    193 	iret
                                    194 .endif 
                                    195 
                                    196 ;------------------------------
                                    197 ; TIMER 4 is used to maintain 
                                    198 ; a milliseconds 'ticks' counter
                                    199 ; and decrement 'timer' varaiable
                                    200 ;--------------------------------
      000026                        201 Timer4UpdateHandler:
      000026 72 5F 53 42      [ 1]  202 	clr TIM4_SR 
      00002A CE 00 0E         [ 2]  203 	ldw x,ticks
      00002D 5C               [ 2]  204 	incw x
      00002E CF 00 0E         [ 2]  205 	ldw ticks,x 
      000031 CE 00 10         [ 2]  206 	ldw x,timer
      000034 5D               [ 2]  207 	tnzw x 
      000035 27 04            [ 1]  208 	jreq 1$
      000037 5A               [ 2]  209 	decw x 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 5.
Hexadecimal [24-Bits]



      000038 CF 00 10         [ 2]  210 	ldw timer,x 
      00003B                        211 1$:	
      00003B 80               [11]  212 	iret 
                                    213 
                                    214 
                                    215 ;------------------------------------
                                    216 ; Triggered by pressing USER UserButton 
                                    217 ; on NUCLEO card.
                                    218 ; This is used to abort a progam lock 
                                    219 ; in infinite loop. 
                                    220 ;------------------------------------
      00003C                        221 UserButtonHandler:
                                    222 ; wait button release
      00003C 5F               [ 1]  223 	clrw x
      00003D 5A               [ 2]  224 1$: decw x 
      00003E 26 FD            [ 1]  225 	jrne 1$
      000040 72 09 50 15 F8   [ 2]  226 	btjf USR_BTN_PORT,#USR_BTN_BIT, 1$
                                    227 ; if MCU suspended by SLEEP resume program
      000045 72 07 00 25 05   [ 2]  228     btjf flags,#FSLEEP,2$
      00004A 72 17 00 25      [ 1]  229 	bres flags,#FSLEEP 
      00004E 80               [11]  230 	iret
      00004F                        231 2$:	
      00004F                        232 user_interrupted:
      00004F 72 00 00 25 02   [ 2]  233     btjt flags,#FRUN,4$
      000054 20 13            [ 2]  234 	jra UBTN_Handler_exit 
      000056                        235 4$:	; program interrupted by user 
      000056 72 11 00 25      [ 1]  236 	bres flags,#FRUN 
      00005A AE 00 71         [ 2]  237 	ldw x,#USER_ABORT
      00005D CD 01 C6         [ 4]  238 	call puts 
      000060 CE 00 04         [ 2]  239 	ldw x,basicptr 
      000063 C6 00 01         [ 1]  240 	ld a,in 
      000066 CD 11 F1         [ 4]  241 	call prt_basic_line
      000069                        242 UBTN_Handler_exit:
      000069 AE 17 FF         [ 2]  243     ldw x,#STACK_EMPTY 
      00006C 94               [ 1]  244     ldw sp,x
      00006D 9A               [ 1]  245 	rim 
      00006E CC 07 44         [ 2]  246 	jp warm_start
                                    247 
      000071 0A 50 72 6F 67 72 61   248 USER_ABORT: .asciz "\nProgram aborted by user.\n"
             6D 20 61 62 6F 72 74
             65 64 20 62 79 20 75
             73 65 72 2E 0A 00
                                    249 
                                    250 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    251 ;    peripherals initialization
                                    252 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    253 
                                    254 ;----------------------------------------
                                    255 ; inialize MCU clock 
                                    256 ; input:
                                    257 ;   A 		source  HSI | 1 HSE 
                                    258 ;   XL      CLK_CKDIVR , clock divisor 
                                    259 ; output:
                                    260 ;   none 
                                    261 ;----------------------------------------
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 6.
Hexadecimal [24-Bits]



      00008C                        262 clock_init:	
      00008C C1 50 C3         [ 1]  263 	cp a,CLK_CMSR 
      00008F 27 0C            [ 1]  264 	jreq 2$ ; no switching required 
                                    265 ; select clock source 
      000091 72 12 50 C5      [ 1]  266 	bset CLK_SWCR,#CLK_SWCR_SWEN
      000095 C7 50 C4         [ 1]  267 	ld CLK_SWR,a
      000098 C1 50 C3         [ 1]  268 1$:	cp a,CLK_CMSR
      00009B 26 FB            [ 1]  269 	jrne 1$
      00009D                        270 2$: 	
                                    271 ; HSI and cpu clock divisor 
      00009D 9F               [ 1]  272 	ld a,xl 
      00009E C7 50 C6         [ 1]  273 	ld CLK_CKDIVR,a  
      0000A1 81               [ 4]  274 	ret
                                    275 
                                    276 ;----------------------------------
                                    277 ; TIMER2 used as audio tone output 
                                    278 ; on port D:5.
                                    279 ; channel 1 configured as PWM mode 1 
                                    280 ;-----------------------------------  
                           00F424   281 TIM2_CLK_FREQ=62500
      0000A2                        282 timer2_init:
      0000A2 72 1A 50 C7      [ 1]  283 	bset CLK_PCKENR1,#CLK_PCKENR1_TIM2 ; enable TIMER2 clock 
      0000A6 35 60 53 05      [ 1]  284  	mov TIM2_CCMR1,#(6<<TIM2_CCMR_OCM) ; PWM mode 1 
      0000AA 35 08 53 0C      [ 1]  285 	mov TIM2_PSCR,#8 ; 16Mhz/256=62500
      0000AE 81               [ 4]  286 	ret 
                                    287 
                                    288 ;---------------------------------
                                    289 ; TIM4 is configured to generate an 
                                    290 ; interrupt every millisecond 
                                    291 ;----------------------------------
      0000AF                        292 timer4_init:
      0000AF 72 18 50 C7      [ 1]  293 	bset CLK_PCKENR1,#CLK_PCKENR1_TIM4
      0000B3 35 07 53 45      [ 1]  294 	mov TIM4_PSCR,#7 ; prescale 128  
      0000B7 35 7D 53 46      [ 1]  295 	mov TIM4_ARR,#125 ; set for 1msec.
      0000BB 35 05 53 40      [ 1]  296 	mov TIM4_CR1,#((1<<TIM4_CR1_CEN)|(1<<TIM4_CR1_URS))
      0000BF 72 10 53 41      [ 1]  297 	bset TIM4_IER,#TIM4_IER_UIE
      0000C3 81               [ 4]  298 	ret
                                    299 
                                    300 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    301 ;  routines to write to FLASH, EEPROM 
                                    302 ;  and OPTION 
                                    303 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    304 
                                    305 ;----------------------------------
                                    306 ; unlock EEPROM/OPT for writing/erasing
                                    307 ; wait endlessly for FLASH_IAPSR_DUL bit.
                                    308 ; input:
                                    309 ;  none
                                    310 ; output:
                                    311 ;  none 
                                    312 ;----------------------------------
      0000C4                        313 unlock_eeprom:
      0000C4 35 AE 50 64      [ 1]  314 	mov FLASH_DUKR,#FLASH_DUKR_KEY1
      0000C8 35 56 50 64      [ 1]  315     mov FLASH_DUKR,#FLASH_DUKR_KEY2
      0000CC 72 07 50 5F FB   [ 2]  316 	btjf FLASH_IAPSR,#FLASH_IAPSR_DUL,.
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 7.
Hexadecimal [24-Bits]



      0000D1 81               [ 4]  317 	ret
                                    318 
                                    319 ;----------------------------------
                                    320 ; unlock FLASH for writing/erasing
                                    321 ; wait endlessly for FLASH_IAPSR_PUL bit.
                                    322 ; input:
                                    323 ;  none
                                    324 ; output:
                                    325 ;  none
                                    326 ;----------------------------------
      0000D2                        327 unlock_flash:
      0000D2 35 56 50 62      [ 1]  328 	mov FLASH_PUKR,#FLASH_PUKR_KEY1
      0000D6 35 AE 50 62      [ 1]  329 	mov FLASH_PUKR,#FLASH_PUKR_KEY2
      0000DA 72 03 50 5F FB   [ 2]  330 	btjf FLASH_IAPSR,#FLASH_IAPSR_PUL,.
      0000DF 81               [ 4]  331 	ret
                                    332 
                           000000   333 USE_BLOCK_ERASE=0 
                           000000   334 .if USE_BLOCK_ERASE 
                                    335 ; this code is copied to RAM 
                                    336 
                                    337 ;----------------------------
                                    338 ; erase block code must be 
                                    339 ; executed from RAM
                                    340 ;-----------------------------
                                    341 erase_start:
                                    342 	clr a 
                                    343     bset FLASH_CR2,#FLASH_CR2_ERASE
                                    344     bres FLASH_NCR2,#FLASH_CR2_ERASE
                                    345 	ldf [farptr],a
                                    346     inc farptr+2 
                                    347     ldf [farptr],a
                                    348     inc farptr+2 
                                    349     ldf [farptr],a
                                    350     inc farptr+2 
                                    351     ldf [farptr],a
                                    352 	btjf FLASH_IAPSR,#FLASH_IAPSR_EOP,.
                                    353 	ret
                                    354 erase_end:
                                    355 
                                    356 ; copy erase_start in RAM 
                                    357 move_code_in_ram:
                                    358 	ldw x,#erase_end 
                                    359 	subw x,#erase_start
                                    360 	ldw acc16,x 
                                    361 	ldw x,#pad 
                                    362 	ldw y,#erase_start 
                                    363 	call move 
                                    364 	ret 
                                    365 
                                    366 ;-----------------------------------
                                    367 ; erase flash or EEPROM block 
                                    368 ; a block is 128 bytes 
                                    369 ; input:
                                    370 ;   farptr  address block begin
                                    371 ; output:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 8.
Hexadecimal [24-Bits]



                                    372 ;   none
                                    373 ;--------------------------------------
                                    374 erase_block:
                                    375 	ldw x,farptr+1 
                                    376 	pushw x 
                                    377 	call move_code_in_ram 
                                    378 	popw x 
                                    379 	ldw farptr+1,x 
                                    380 	tnz farptr
                                    381 	jrne erase_flash 
                                    382 	ldw x,#FLASH_BASE 
                                    383 	cpw x,farptr+1 
                                    384 	jrpl erase_flash 
                                    385 ; erase eeprom block
                                    386 	call unlock_eeprom 
                                    387 	sim 
                                    388 	call pad   
                                    389 	bres FLASH_IAPSR,#FLASH_IAPSR_DUL
                                    390 	rim 
                                    391 	ret 
                                    392 ; erase flash block:
                                    393 erase_flash:
                                    394 	call unlock_flash 
                                    395 	bset FLASH_CR2,#FLASH_CR2_ERASE
                                    396 	bres FLASH_NCR2,#FLASH_CR2_ERASE
                                    397 	clr a 
                                    398 	sim 
                                    399 	call pad 
                                    400     bres FLASH_IAPSR,#FLASH_IAPSR_PUL
                                    401 	rim 
                                    402 	ret 
                                    403 .endif ;;;; USE_BLOCK_ERASE ;;;;
                                    404 
                                    405 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                    406 ; write a byte to FLASH or EEPROM/OPTION  
                                    407 ; input:
                                    408 ;    a  		byte to write
                                    409 ;    farptr  	address
                                    410 ;    x          farptr[x]
                                    411 ; output:
                                    412 ;    none
                                    413 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    414 	; variables locales
                           000001   415 	BTW = 1   ; byte to write offset on stack
                           000002   416 	OPT = 2   ; OPTION flag offset on stack
                           000002   417 	VSIZE = 2
      0000E0                        418 write_byte:
      0000E0 90 89            [ 2]  419 	pushw y
      0000E2                        420 	_vars VSIZE
      0000E2 52 02            [ 2]    1     sub sp,#VSIZE 
      0000E4 6B 01            [ 1]  421 	ld (BTW,sp),a ; byte to write 
      0000E6 0F 02            [ 1]  422 	clr (OPT,sp)  ; OPTION flag
                                    423 ; put addr[15:0] in Y, for bounds check.
      0000E8 90 CE 00 17      [ 2]  424 	ldw y,farptr+1   ; Y=addr15:0
                                    425 ; check addr[23:16], if <> 0 then it is extened flash memory
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 9.
Hexadecimal [24-Bits]



      0000EC 72 5D 00 16      [ 1]  426 	tnz farptr 
      0000F0 26 14            [ 1]  427 	jrne write_flash
      0000F2 90 A3 25 00      [ 2]  428     cpw y,#user_space
      0000F6 24 0E            [ 1]  429     jruge write_flash
      0000F8 90 A3 40 00      [ 2]  430 	cpw y,#EEPROM_BASE  
      0000FC 25 52            [ 1]  431     jrult write_exit
      0000FE 90 A3 48 7F      [ 2]  432 	cpw y,#OPTION_END 
      000102 22 4C            [ 1]  433 	jrugt write_exit
      000104 20 16            [ 2]  434 	jra write_eeprom 
                                    435 ; write program memory
      000106                        436 write_flash:
      000106 CD 00 D2         [ 4]  437 	call unlock_flash 
      000109 9B               [ 1]  438 1$:	sim 
      00010A 7B 01            [ 1]  439 	ld a,(BTW,sp)
      00010C 92 A7 00 16      [ 4]  440 	ldf ([farptr],x),a ; farptr[x]=A
      000110 72 05 50 5F FB   [ 2]  441 	btjf FLASH_IAPSR,#FLASH_IAPSR_EOP,.
      000115 9A               [ 1]  442     rim 
      000116 72 13 50 5F      [ 1]  443     bres FLASH_IAPSR,#FLASH_IAPSR_PUL
      00011A 20 34            [ 2]  444     jra write_exit
                                    445 ; write eeprom and option
      00011C                        446 write_eeprom:
      00011C CD 00 C4         [ 4]  447 	call unlock_eeprom
                                    448 	; check for data eeprom or option eeprom
      00011F 90 A3 48 00      [ 2]  449 	cpw y,#OPTION_BASE
      000123 2B 08            [ 1]  450 	jrmi 1$
      000125 90 A3 48 80      [ 2]  451 	cpw y,#OPTION_END+1
      000129 2A 02            [ 1]  452 	jrpl 1$
      00012B 03 02            [ 1]  453 	cpl (OPT,sp)
      00012D                        454 1$: 
      00012D 0D 02            [ 1]  455     tnz (OPT,sp)
      00012F 27 08            [ 1]  456     jreq 2$
                                    457 	; pour modifier une option il faut modifier ces 2 bits
      000131 72 1E 50 5B      [ 1]  458     bset FLASH_CR2,#FLASH_CR2_OPT
      000135 72 1F 50 5C      [ 1]  459     bres FLASH_NCR2,#FLASH_CR2_OPT 
      000139                        460 2$: 
      000139 7B 01            [ 1]  461     ld a,(BTW,sp)
      00013B 92 A7 00 16      [ 4]  462     ldf ([farptr],x),a
      00013F 0D 02            [ 1]  463     tnz (OPT,sp)
      000141 27 08            [ 1]  464     jreq 3$
      000143 5C               [ 2]  465     incw x
      000144 7B 01            [ 1]  466     ld a,(BTW,sp)
      000146 43               [ 1]  467     cpl a
      000147 92 A7 00 16      [ 4]  468     ldf ([farptr],x),a
      00014B 72 05 50 5F FB   [ 2]  469 3$: btjf FLASH_IAPSR,#FLASH_IAPSR_EOP,.
      000150                        470 write_exit:
      000150                        471 	_drop VSIZE 
      000150 5B 02            [ 2]    1     addw sp,#VSIZE 
      000152 90 85            [ 2]  472 	popw y
      000154 81               [ 4]  473     ret
                                    474 
                                    475 ;--------------------------------------------
                                    476 ; write a data block to eeprom or flash 
                                    477 ; input:
                                    478 ;   Y        source address   
                                    479 ;   X        array index  destination  farptr[x]
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 10.
Hexadecimal [24-Bits]



                                    480 ;   BSIZE    block size bytes 
                                    481 ;   farptr   write address , byte* 
                                    482 ; output:
                                    483 ;	X 		after last byte written 
                                    484 ;   Y 		after last byte read 
                                    485 ;  farptr   point after block
                                    486 ;---------------------------------------------
      000155                        487 	_argofs 2 
                           000004     1     ARG_OFS=2+2 
      000155                        488 	_arg BSIZE 1  ; block size
                           000005     1     BSIZE=ARG_OFS+1 
                                    489 	; local var 
                           000001   490 	XSAVE=1 
                           000002   491 	VSIZE=2 
      000155                        492 write_block:
      000155                        493 	_vars VSIZE
      000155 52 02            [ 2]    1     sub sp,#VSIZE 
      000157 1F 01            [ 2]  494 	ldw (XSAVE,sp),x 
      000159 1E 05            [ 2]  495 	ldw x,(BSIZE,sp) 
      00015B 27 13            [ 1]  496 	jreq 9$
      00015D 1E 01            [ 2]  497 1$:	ldw x,(XSAVE,sp)
      00015F 90 F6            [ 1]  498 	ld a,(y)
      000161 CD 00 E0         [ 4]  499 	call write_byte 
      000164 5C               [ 2]  500 	incw x 
      000165 90 5C            [ 2]  501 	incw y 
      000167 1F 01            [ 2]  502 	ldw (XSAVE,sp),x
      000169 1E 05            [ 2]  503 	ldw x,(BSIZE,sp)
      00016B 5A               [ 2]  504 	decw x
      00016C 1F 05            [ 2]  505 	ldw (BSIZE,sp),x 
      00016E 26 ED            [ 1]  506 	jrne 1$
      000170                        507 9$:
      000170 1E 01            [ 2]  508 	ldw x,(XSAVE,sp)
      000172 CD 18 2B         [ 4]  509 	call incr_farptr
      000175                        510 	_drop VSIZE
      000175 5B 02            [ 2]    1     addw sp,#VSIZE 
      000177 81               [ 4]  511 	ret 
                                    512 
                                    513 
                                    514 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    515 ;;   UART1 subroutines
                                    516 ;;   used for user interface 
                                    517 ;;   communication channel.
                                    518 ;;   settings: 
                                    519 ;;		115200 8N1 no flow control
                                    520 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    521 
                                    522 ;---------------------------------------------
                                    523 ; initialize UART1, 115200 8N1
                                    524 ; input:
                                    525 ;	none
                                    526 ; output:
                                    527 ;   none
                                    528 ;---------------------------------------------
      000178                        529 uart1_init:
      000178 72 1A 50 02      [ 1]  530     bset PA_DDR,#UART1_TX_PIN
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 11.
Hexadecimal [24-Bits]



      00017C 72 1A 50 03      [ 1]  531     bset PA_CR1,#UART1_TX_PIN 
      000180 72 1A 50 04      [ 1]  532     bset PA_CR2,#UART1_TX_PIN 
                                    533 ; enable UART1 clock
      000184 72 14 50 C7      [ 1]  534 	bset CLK_PCKENR1,#CLK_PCKENR1_UART1	
      000188                        535 uart1_set_baud: 
                                    536 ; baud rate 115200 Fmaster=8Mhz  8000000/115200=69=0x45
                                    537 ; 1) check clock source, HSI at 16Mhz or HSE at 8Mhz  
      000188 A6 E1            [ 1]  538 	ld a,#CLK_SWR_HSI
      00018A C1 50 C3         [ 1]  539 	cp a,CLK_CMSR 
      00018D 27 0A            [ 1]  540 	jreq 2$ 
      00018F                        541 1$: ; 8 Mhz 	
      00018F 35 05 52 33      [ 1]  542 	mov UART1_BRR2,#0x05 ; must be loaded first
      000193 35 04 52 32      [ 1]  543 	mov UART1_BRR1,#0x4
      000197 20 08            [ 2]  544 	jra 3$
      000199                        545 2$: ; 16 Mhz 	
      000199 35 0B 52 33      [ 1]  546 	mov UART1_BRR2,#0x0b ; must be loaded first
      00019D 35 08 52 32      [ 1]  547 	mov UART1_BRR1,#0x08
      0001A1                        548 3$:
      0001A1 72 5F 52 31      [ 1]  549     clr UART1_DR
      0001A5 35 2C 52 35      [ 1]  550 	mov UART1_CR2,#((1<<UART_CR2_TEN)|(1<<UART_CR2_REN)|(1<<UART_CR2_RIEN));
      0001A9 72 10 52 35      [ 1]  551 	bset UART1_CR2,#UART_CR2_SBK
      0001AD 72 0D 52 30 FB   [ 2]  552     btjf UART1_SR,#UART_SR_TC,.
      0001B2 81               [ 4]  553     ret
                                    554 
                                    555 ;---------------------------------
                                    556 ; send character to UART1 
                                    557 ; input:
                                    558 ;   A 
                                    559 ; output:
                                    560 ;   none 
                                    561 ;--------------------------------	
      0001B3                        562 putc:
      0001B3 72 0F 52 30 FB   [ 2]  563 	btjf UART1_SR,#UART_SR_TXE,.
      0001B8 C7 52 31         [ 1]  564 	ld UART1_DR,a 
      0001BB 81               [ 4]  565 	ret 
                                    566 
                                    567 ;---------------------------------
                                    568 ; wait character from UART1 
                                    569 ; input:
                                    570 ;   none
                                    571 ; output:
                                    572 ;   A 			char  
                                    573 ;--------------------------------	
      0001BC                        574 getc:
      0001BC C6 00 27         [ 1]  575 	ld a,rx_char 
      0001BF 27 FB            [ 1]  576 	jreq getc 
      0001C1 72 5F 00 27      [ 1]  577 	clr rx_char 
      0001C5 81               [ 4]  578 	ret 
                                    579 
                                    580 ;-----------------------------
                                    581 ; send an ASCIZ string to UART1 
                                    582 ; input: 
                                    583 ;   x 		char * 
                                    584 ; output:
                                    585 ;   none 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 12.
Hexadecimal [24-Bits]



                                    586 ;-------------------------------
      0001C6                        587 puts:
      0001C6 F6               [ 1]  588     ld a,(x)
      0001C7 27 06            [ 1]  589 	jreq 1$
      0001C9 CD 01 B3         [ 4]  590 	call putc 
      0001CC 5C               [ 2]  591 	incw x 
      0001CD 20 F7            [ 2]  592 	jra puts 
      0001CF 81               [ 4]  593 1$:	ret 
                                    594 
                                    595 
                                    596 ;---------------------------
                                    597 ; delete character at left 
                                    598 ; of cursor on terminal 
                                    599 ; input:
                                    600 ;   none 
                                    601 ; output:
                                    602 ;	none 
                                    603 ;---------------------------
      0001D0                        604 bksp:
      0001D0 A6 08            [ 1]  605 	ld a,#BSP 
      0001D2 CD 01 B3         [ 4]  606 	call putc 
      0001D5 A6 20            [ 1]  607 	ld a,#SPACE 
      0001D7 CD 01 B3         [ 4]  608 	call putc 
      0001DA A6 08            [ 1]  609 	ld a,#BSP 
      0001DC CD 01 B3         [ 4]  610 	call putc 
      0001DF 81               [ 4]  611 	ret 
                                    612 ;---------------------------
                                    613 ; delete n character left of cursor 
                                    614 ; at terminal.
                                    615 ; input: 
                                    616 ;   A   number of characters to delete.
                                    617 ; output:
                                    618 ;    none 
                                    619 ;--------------------------	
      0001E0                        620 delete:
      0001E0 88               [ 1]  621 	push a 
      0001E1 0D 01            [ 1]  622 0$:	tnz (1,sp)
      0001E3 27 07            [ 1]  623 	jreq 1$
      0001E5 CD 01 D0         [ 4]  624 	call bksp 
      0001E8 0A 01            [ 1]  625 	dec (1,sp)
      0001EA 20 F5            [ 2]  626 	jra 0$
      0001EC 84               [ 1]  627 1$:	pop a 
      0001ED 81               [ 4]  628 	ret
                                    629 
                                    630 ;--------------------------
                                    631 ; print n spaces on terminal
                                    632 ; input:
                                    633 ;  X 		number of spaces 
                                    634 ; output:
                                    635 ;	none 
                                    636 ;---------------------------
      0001EE                        637 spaces:
      0001EE A6 20            [ 1]  638 	ld a,#SPACE 
      0001F0 5D               [ 2]  639 1$:	tnzw x
      0001F1 27 06            [ 1]  640 	jreq 9$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 13.
Hexadecimal [24-Bits]



      0001F3 CD 01 B3         [ 4]  641 	call putc 
      0001F6 5A               [ 2]  642 	decw x
      0001F7 20 F7            [ 2]  643 	jra 1$
      0001F9                        644 9$: 
      0001F9 81               [ 4]  645 	ret 
                                    646 
                           000000   647 .if DEBUG 
                                    648 ;---------------------------------
                                    649 ;; print actual registers states 
                                    650 ;; as pushed on stack 
                                    651 ;; {Y,X,CC,A}
                                    652 ;---------------------------------
                                    653 	_argofs 0  
                                    654 	_arg R_Y 1 
                                    655 	_arg R_X 3
                                    656 	_arg R_A 5
                                    657 	_arg R_CC 6
                                    658 prt_regs:
                                    659 	ldw x,#regs_state 
                                    660 	call puts
                                    661 ; register PC
                                    662 	ldw y,(1,sp)
                                    663 	ldw x,#REG_EPC 
                                    664 	call prt_reg16 
                                    665 ; register CC 
                                    666 	ld a,(R_CC,sp)
                                    667 	ldw x,#REG_CC 
                                    668 	call prt_reg8 
                                    669 ; register A 
                                    670 	ld a,(R_A,sp)
                                    671 	ldw x,#REG_A 
                                    672 	call prt_reg8 
                                    673 ; register X 
                                    674 	ldw y,(R_X,sp)
                                    675 	ldw x,#REG_X 
                                    676 	call prt_reg16 
                                    677 ; register Y 
                                    678 	ldw y,(R_Y,sp)
                                    679 	ldw x,#REG_Y 
                                    680 	call prt_reg16 
                                    681 ; register SP 
                                    682 	ldw y,sp
                                    683 	addw y,#6+ARG_OFS  
                                    684 	ldw x,#REG_SP
                                    685 	call prt_reg16
                                    686 	ld a,#CR 
                                    687 	call putc
                                    688 	call putc   
                                    689 	ret 
                                    690 
                                    691 regs_state: .asciz "\nregisters state\n--------------------\n"
                                    692 
                                    693 
                                    694 ;--------------------
                                    695 ; print content at address in hex.
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 14.
Hexadecimal [24-Bits]



                                    696 ; input:
                                    697 ;   X 	address to peek 
                                    698 ; output:
                                    699 ;	none 
                                    700 ;--------------------	
                                    701 prt_peek:
                                    702 	pushw x 
                                    703 	ldw acc16,x 
                                    704 	clr acc24 
                                    705 	clrw x 
                                    706 	ld a,#16 
                                    707 	call prti24 
                                    708 	ld a,#': 
                                    709 	call putc 
                                    710 	ld a,#SPACE 
                                    711 	call putc 
                                    712 	popw x 
                                    713 	ld a,(x)
                                    714 	ld acc8,a 
                                    715 	clrw x 
                                    716 	ld a,#16 
                                    717 	call prti24
                                    718 	ret 
                                    719 .endif ; DEBUG  
                                    720 
                                    721 ;-------------------------------------
                                    722 ; retrun string length
                                    723 ; input:
                                    724 ;   X         .asciz  pointer 
                                    725 ; output:
                                    726 ;   X         length 
                                    727 ;-------------------------------------
      0001FA                        728 strlen:
      0001FA 90 93            [ 1]  729 	ldw y,x 
      0001FC 5F               [ 1]  730 	clrw x 
      0001FD 90 7D            [ 1]  731 1$:	tnz (y) 
      0001FF 27 05            [ 1]  732 	jreq 9$ 
      000201 5C               [ 2]  733 	incw x
      000202 90 5C            [ 2]  734 	incw y 
      000204 20 F7            [ 2]  735 	jra 1$ 
      000206 81               [ 4]  736 9$: ret 
                                    737 
                                    738 ;------------------------------------
                                    739 ; compare 2 strings
                                    740 ; input:
                                    741 ;   X 		char* first string 
                                    742 ;   Y       char* second string 
                                    743 ; output:
                                    744 ;   A 		0|1 
                                    745 ;-------------------------------------
      000207                        746 strcmp:
      000207 F6               [ 1]  747 	ld a,(x)
      000208 27 0B            [ 1]  748 	jreq 5$ 
      00020A 90 F1            [ 1]  749 	cp a,(y) 
      00020C 26 05            [ 1]  750 	jrne 4$ 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 15.
Hexadecimal [24-Bits]



      00020E 5C               [ 2]  751 	incw x 
      00020F 90 5C            [ 2]  752 	incw y 
      000211 20 F4            [ 2]  753 	jra strcmp 
      000213                        754 4$: ; not same  
      000213 4F               [ 1]  755 	clr a 
      000214 81               [ 4]  756 	ret 
      000215                        757 5$: ; same 
      000215 A6 01            [ 1]  758 	ld a,#1 
      000217 81               [ 4]  759 	ret 
                                    760 
                                    761 
                                    762 ;---------------------------------------
                                    763 ;  copy src to dest 
                                    764 ; input:
                                    765 ;   X 		dest 
                                    766 ;   Y 		src 
                                    767 ; output: 
                                    768 ;   X 		dest 
                                    769 ;----------------------------------
      000218                        770 strcpy:
      000218 89               [ 2]  771 	pushw x 
      000219 90 F6            [ 1]  772 1$: ld a,(y)
      00021B 27 06            [ 1]  773 	jreq 9$ 
      00021D F7               [ 1]  774 	ld (x),a 
      00021E 5C               [ 2]  775 	incw x 
      00021F 90 5C            [ 2]  776 	incw y 
      000221 20 F6            [ 2]  777 	jra 1$ 
      000223 7F               [ 1]  778 9$:	clr (x)
      000224 85               [ 2]  779 	popw x 
      000225 81               [ 4]  780 	ret 
                                    781 
                                    782 ;---------------------------------------
                                    783 ; move memory block 
                                    784 ; input:
                                    785 ;   X 		destination 
                                    786 ;   Y 	    source 
                                    787 ;   acc16	bytes count 
                                    788 ; output:
                                    789 ;   none 
                                    790 ;--------------------------------------
                           000001   791 	INCR=1 ; increament high byte 
                           000002   792 	LB=2 ; increament low byte 
                           000002   793 	VSIZE=2
      000226                        794 move:
      000226                        795 	_vars VSIZE 
      000226 52 02            [ 2]    1     sub sp,#VSIZE 
      000228 0F 01            [ 1]  796 	clr (INCR,sp)
      00022A 0F 02            [ 1]  797 	clr (LB,sp)
      00022C 90 89            [ 2]  798 	pushw y 
      00022E 13 01            [ 2]  799 	cpw x,(1,sp) ; compare DEST to SRC 
      000230 90 85            [ 2]  800 	popw y 
      000232 27 31            [ 1]  801 	jreq move_exit ; x==y 
      000234 2B 0E            [ 1]  802 	jrmi move_down
      000236                        803 move_up: ; start from top address with incr=-1
      000236 72 BB 00 0C      [ 2]  804 	addw x,acc16
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 16.
Hexadecimal [24-Bits]



      00023A 72 B9 00 0C      [ 2]  805 	addw y,acc16
      00023E 03 01            [ 1]  806 	cpl (INCR,sp)
      000240 03 02            [ 1]  807 	cpl (LB,sp)   ; increment = -1 
      000242 20 05            [ 2]  808 	jra move_loop  
      000244                        809 move_down: ; start from bottom address with incr=1 
      000244 5A               [ 2]  810     decw x 
      000245 90 5A            [ 2]  811 	decw y
      000247 0C 02            [ 1]  812 	inc (LB,sp) ; incr=1 
      000249                        813 move_loop:	
      000249 C6 00 0C         [ 1]  814     ld a, acc16 
      00024C CA 00 0D         [ 1]  815 	or a, acc8
      00024F 27 14            [ 1]  816 	jreq move_exit 
      000251 72 FB 01         [ 2]  817 	addw x,(INCR,sp)
      000254 72 F9 01         [ 2]  818 	addw y,(INCR,sp) 
      000257 90 F6            [ 1]  819 	ld a,(y)
      000259 F7               [ 1]  820 	ld (x),a 
      00025A 89               [ 2]  821 	pushw x 
      00025B CE 00 0C         [ 2]  822 	ldw x,acc16 
      00025E 5A               [ 2]  823 	decw x 
      00025F CF 00 0C         [ 2]  824 	ldw acc16,x 
      000262 85               [ 2]  825 	popw x 
      000263 20 E4            [ 2]  826 	jra move_loop
      000265                        827 move_exit:
      000265                        828 	_drop VSIZE
      000265 5B 02            [ 2]    1     addw sp,#VSIZE 
      000267 81               [ 4]  829 	ret 	
                                    830 
                                    831 ;-------------------------------------
                                    832 ; search text area for a line with 
                                    833 ; same number as line#  
                                    834 ; input:
                                    835 ;	X 			line# 
                                    836 ; output:
                                    837 ;   X 			addr of line | 0 
                                    838 ;   Y           line#|insert address if not found  
                                    839 ;-------------------------------------
                           000001   840 	LL=1 ; line length 
                           000002   841 	LB=2 ; line length low byte 
                           000002   842 	VSIZE=2 
      000268                        843 search_lineno:
      000268                        844 	_vars VSIZE
      000268 52 02            [ 2]    1     sub sp,#VSIZE 
      00026A 0F 01            [ 1]  845 	clr (LL,sp)
      00026C 90 CE 00 1E      [ 2]  846 	ldw y,txtbgn
      000270                        847 search_ln_loop:
      000270 90 C3 00 20      [ 2]  848 	cpw y,txtend 
      000274 2A 10            [ 1]  849 	jrpl 8$
      000276 90 F3            [ 1]  850 	cpw x,(y)
      000278 27 0E            [ 1]  851 	jreq 9$
      00027A 2B 0A            [ 1]  852 	jrmi 8$ 
      00027C 90 E6 02         [ 1]  853 	ld a,(2,y)
      00027F 6B 02            [ 1]  854 	ld (LB,sp),a 
      000281 72 F9 01         [ 2]  855 	addw y,(LL,sp)
      000284 20 EA            [ 2]  856 	jra search_ln_loop 
      000286                        857 8$: 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 17.
Hexadecimal [24-Bits]



      000286 5F               [ 1]  858 	clrw x 	
      000287 51               [ 1]  859 	exgw x,y 
      000288                        860 9$: _drop VSIZE
      000288 5B 02            [ 2]    1     addw sp,#VSIZE 
      00028A 51               [ 1]  861 	exgw x,y   
      00028B 81               [ 4]  862 	ret 
                                    863 
                                    864 ;-------------------------------------
                                    865 ; delete line at addr
                                    866 ; move new line to insert with end of text 
                                    867 ; otherwise it would be overwritten.
                                    868 ; input:
                                    869 ;   X 		addr of line i.e DEST for move 
                                    870 ;-------------------------------------
                           000001   871 	LLEN=1
                           000003   872 	SRC=3
                           000004   873 	VSIZE=4
      00028C                        874 del_line: 
      00028C                        875 	_vars VSIZE 
      00028C 52 04            [ 2]    1     sub sp,#VSIZE 
      00028E E6 02            [ 1]  876 	ld a,(2,x) ; line length
      000290 6B 02            [ 1]  877 	ld (LLEN+1,sp),a 
      000292 0F 01            [ 1]  878 	clr (LLEN,sp)
      000294 90 93            [ 1]  879 	ldw y,x  
      000296 72 F9 01         [ 2]  880 	addw y,(LLEN,sp) ;SRC  
      000299 17 03            [ 2]  881 	ldw (SRC,sp),y  ;save source 
      00029B 90 CE 00 20      [ 2]  882 	ldw y,txtend 
      00029F 90 E6 02         [ 1]  883 	ld a,(2,y)
      0002A2 90 5F            [ 1]  884 	clrw y 
      0002A4 90 97            [ 1]  885 	ld yl,a  
      0002A6 72 B9 00 20      [ 2]  886 	addw y,txtend
      0002AA 72 F2 03         [ 2]  887 	subw y,(SRC,sp) ; y=count 
      0002AD 90 CF 00 0C      [ 2]  888 	ldw acc16,y 
      0002B1 16 03            [ 2]  889 	ldw y,(SRC,sp)    ; source
      0002B3 CD 02 26         [ 4]  890 	call move
      0002B6 90 CE 00 20      [ 2]  891 	ldw y,txtend 
      0002BA 72 F2 01         [ 2]  892 	subw y,(LLEN,sp)
      0002BD 90 CF 00 20      [ 2]  893 	ldw txtend,y  
      0002C1                        894 	_drop VSIZE     
      0002C1 5B 04            [ 2]    1     addw sp,#VSIZE 
      0002C3 81               [ 4]  895 	ret 
                                    896 
                                    897 ;---------------------------------------------
                                    898 ; create a gap in text area 
                                    899 ; move new line to insert in gap with end of text
                                    900 ; otherwise it would be overwritten.
                                    901 ; input:
                                    902 ;    X 			addr gap start 
                                    903 ;    Y 			gap length 
                                    904 ; output:
                                    905 ;    X 			addr gap start 
                                    906 ;--------------------------------------------
                           000001   907 	DEST=1
                           000003   908 	SRC=3
                           000005   909 	LEN=5
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 18.
Hexadecimal [24-Bits]



                           000006   910 	VSIZE=6 
      0002C4                        911 create_gap:
      0002C4                        912 	_vars VSIZE
      0002C4 52 06            [ 2]    1     sub sp,#VSIZE 
      0002C6 1F 03            [ 2]  913 	ldw (SRC,sp),x 
      0002C8 17 05            [ 2]  914 	ldw (LEN,sp),y 
      0002CA 90 CF 00 0C      [ 2]  915 	ldw acc16,y 
      0002CE 90 93            [ 1]  916 	ldw y,x ; SRC
      0002D0 72 BB 00 0C      [ 2]  917 	addw x,acc16  
      0002D4 1F 01            [ 2]  918 	ldw (DEST,sp),x 
                                    919 ;compute size to move 	
      0002D6 CE 00 20         [ 2]  920 	ldw x,txtend 
      0002D9 E6 02            [ 1]  921 	ld a,(2,x) ; pending line length 
      0002DB C7 00 0D         [ 1]  922 	ld acc8,a 
      0002DE 72 5F 00 0C      [ 1]  923 	clr acc16 
      0002E2 72 BB 00 0C      [ 2]  924 	addw x,acc16 
      0002E6 72 F0 03         [ 2]  925 	subw x,(SRC,sp)
      0002E9 CF 00 0C         [ 2]  926 	ldw acc16,x ; size to move
      0002EC 1E 01            [ 2]  927 	ldw x,(DEST,sp) 
      0002EE CD 02 26         [ 4]  928 	call move
      0002F1 CE 00 20         [ 2]  929 	ldw x,txtend
      0002F4 72 FB 05         [ 2]  930 	addw x,(LEN,sp)
      0002F7 CF 00 20         [ 2]  931 	ldw txtend,x
      0002FA                        932 9$:	_drop VSIZE 
      0002FA 5B 06            [ 2]    1     addw sp,#VSIZE 
      0002FC 81               [ 4]  933 	ret 
                                    934 
                                    935 
                                    936 ;--------------------------------------------
                                    937 ; insert line in tib into text area 
                                    938 ; first search for already existing 
                                    939 ; replace existing 
                                    940 ; if strlen(tib)==0 delete existing line
                                    941 ; input:
                                    942 ;   ptr16 				pointer to tokenized line  
                                    943 ; output:
                                    944 ;   none
                                    945 ;---------------------------------------------
                           000001   946 	DEST=1  ; text area insertion address 
                           000003   947 	SRC=3   ; str to insert address 
                           000005   948 	LINENO=5 ; line number 
                           000007   949 	LLEN=7 ; line length 
                           000008   950 	VSIZE=8  
      0002FD                        951 insert_line:
      0002FD                        952 	_vars VSIZE 
      0002FD 52 08            [ 2]    1     sub sp,#VSIZE 
      0002FF CE 00 17         [ 2]  953 	ldw x,ptr16  
      000302 C3 00 1E         [ 2]  954 	cpw x,txtbgn 
      000305 26 0D            [ 1]  955 	jrne 0$
                                    956 ;first text line 
      000307 AE 00 02         [ 2]  957 	ldw x,#2 
      00030A 72 D6 00 17      [ 4]  958 	ld a,([ptr16],x)
      00030E 5F               [ 1]  959 	clrw x 
      00030F 97               [ 1]  960 	ld xl,a
      000310 1F 07            [ 2]  961 	ldw (LLEN,sp),x  
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 19.
Hexadecimal [24-Bits]



      000312 20 45            [ 2]  962 	jra 5$
      000314 72 CE 00 17      [ 5]  963 0$:	ldw x,[ptr16]
                                    964 ; new line number
      000318 1F 05            [ 2]  965 	ldw (LINENO,sp),x 
      00031A AE 00 02         [ 2]  966 	ldw x,#2 
      00031D 72 D6 00 17      [ 4]  967 	ld a,([ptr16],x)
      000321 97               [ 1]  968 	ld xl,a
                                    969 ; new line length
      000322 1F 07            [ 2]  970 	ldw (LLEN,sp),x
                                    971 ; check if that line number already exit 	
      000324 1E 05            [ 2]  972 	ldw x,(LINENO,sp)
      000326 CD 02 68         [ 4]  973 	call search_lineno 
      000329 5D               [ 2]  974 	tnzw x 
      00032A 26 04            [ 1]  975 	jrne 2$
                                    976 ; line doesn't exit
                                    977 ; it will be inserted at this point.  	
      00032C 17 01            [ 2]  978 	ldw (DEST,sp),y 
      00032E 20 05            [ 2]  979 	jra 3$
                                    980 ; line exit delete it.
                                    981 ; it will be replaced by new one 	
      000330 1F 01            [ 2]  982 2$: ldw (DEST,sp),x 
      000332 CD 02 8C         [ 4]  983 	call del_line
      000335                        984 3$: 
                                    985 ; insert new line or leave if LLEN==3
                                    986 ; LLEN==3 means empty line 
      000335 A6 03            [ 1]  987 	ld a,#3
      000337 11 08            [ 1]  988 	cp a,(LLEN+1,sp)
      000339 27 27            [ 1]  989 	jreq insert_ln_exit ; empty line exit.
                                    990 ; if insertion point at txtend 
                                    991 ; no move required 
      00033B 1E 01            [ 2]  992 	ldw x,(DEST,sp)
      00033D C3 00 20         [ 2]  993 	cpw x,txtend 
      000340 2A 17            [ 1]  994 	jrpl 5$ 
                                    995 ; must create a gap
                                    996 ; at insertion point  
      000342 1E 01            [ 2]  997 	ldw x,(DEST,sp)
      000344 16 07            [ 2]  998 	ldw y,(LLEN,sp)
      000346 CD 02 C4         [ 4]  999 	call create_gap 
                                   1000 ; move new line in gap 
      000349 1E 07            [ 2] 1001 	ldw x,(LLEN,sp)
      00034B CF 00 0C         [ 2] 1002 	ldw acc16,x 
      00034E 90 CE 00 20      [ 2] 1003 	ldw y,txtend ;SRC 
      000352 1E 01            [ 2] 1004 	ldw x,(DEST,sp) ; dest address 
      000354 CD 02 26         [ 4] 1005 	call move 
      000357 20 09            [ 2] 1006 	jra insert_ln_exit  
      000359                       1007 5$: ; no move required 
      000359 1E 07            [ 2] 1008 	ldw x,(LLEN,sp) 
      00035B 72 BB 00 20      [ 2] 1009 	addw x,txtend 
      00035F CF 00 20         [ 2] 1010 	ldw txtend,x 
      000362                       1011 insert_ln_exit:	
      000362                       1012 	_drop VSIZE
      000362 5B 08            [ 2]    1     addw sp,#VSIZE 
      000364 81               [ 4] 1013 	ret
                                   1014 
                                   1015 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 20.
Hexadecimal [24-Bits]



                                   1016 ;-----------------------------
                                   1017 ; check if text buffer full
                                   1018 ; input:
                                   1019 ;   ptr16     addr start tokenize line 
                                   1020 ;   X         buffer index 
                                   1021 ; output:
                                   1022 ;   none 
                                   1023 ;-----------------------------------
      000365                       1024 check_full:
      000365 72 BB 00 17      [ 2] 1025 	addw x,ptr16 
      000369 A3 16 E8         [ 2] 1026 	cpw x,#tib 
      00036C 25 05            [ 1] 1027 	jrult 1$
      00036E A6 01            [ 1] 1028 	ld a,#ERR_MEM_FULL
      000370 CC 07 03         [ 2] 1029 	jp tb_error 
      000373 81               [ 4] 1030 1$: ret 
                                   1031 
                                   1032 
                                   1033 ;-----------------------------------
                                   1034 ; create token list form text line 
                                   1035 ; save this list in text area
                                   1036 ;  compiled line format: 
                                   1037 ;    line_no  2 bytes {0...32767}
                                   1038 ;    count    1 byte 
                                   1039 ;    tokens   variable 
                                   1040 ;   
                                   1041 ; input:
                                   1042 ;   none
                                   1043 ; output:
                                   1044 ;   basicptr     token list buffer address 
                                   1045 ;   in.w  		 cleared, index in buffer 
                                   1046 ;-----------------------------------
                           000001  1047 	XSAVE=1
                           000003  1048 	BUFIDX=3
                           000004  1049 	VSIZE=4
      000374                       1050 compile:
      000374                       1051 	_vars VSIZE 
      000374 52 04            [ 2]    1     sub sp,#VSIZE 
      000376 72 1A 00 25      [ 1] 1052 	bset flags,#FCOMP 
      00037A CE 00 20         [ 2] 1053 	ldw x,txtend
      00037D CF 00 17         [ 2] 1054 	ldw ptr16,x ; code buffer start address 
      000380 5F               [ 1] 1055 	clrw x 
      000381 AE 00 03         [ 2] 1056 	ldw x,#3
      000384 1F 03            [ 2] 1057 	ldw (BUFIDX,sp),X  
      000386 CD 03 65         [ 4] 1058 	call check_full
      000389 5F               [ 1] 1059 	clrw x 
      00038A 72 CF 00 17      [ 5] 1060 	ldw [ptr16],x ; initialize line# to zero 
      00038E CD 0A B9         [ 4] 1061 	call get_token
      000391 1F 01            [ 2] 1062 	ldw (XSAVE,sp),x 
      000393 A1 04            [ 1] 1063 	cp a,#TK_INTGR 
      000395 26 13            [ 1] 1064 	jrne 3$
      000397 A3 00 00         [ 2] 1065 	cpw x,#0 
      00039A 2C 05            [ 1] 1066 	jrsgt 1$
      00039C A6 0A            [ 1] 1067 	ld a,#ERR_BAD_VALUE 
      00039E CC 07 03         [ 2] 1068 	jp tb_error ; line number must be in range {1..32767}
      0003A1 72 CF 00 17      [ 5] 1069 1$:	ldw [ptr16],x; line number
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 21.
Hexadecimal [24-Bits]



      0003A5 CD 0A B9         [ 4] 1070 2$:	call get_token
      0003A8 1F 01            [ 2] 1071 	ldw (XSAVE,sp),x 
      0003AA A1 00            [ 1] 1072 3$:	cp a,#TK_NONE 
      0003AC 26 03            [ 1] 1073 	jrne 30$
      0003AE CC 04 3F         [ 2] 1074 	jp 9$ ; end of line. 
      0003B1                       1075 30$: 	 
      0003B1 1E 03            [ 2] 1076 	ldw x,(BUFIDX,sp)
      0003B3 CD 03 65         [ 4] 1077 	call check_full 
      0003B6 16 03            [ 2] 1078 	ldw y,(BUFIDX,sp) 
      0003B8 91 D7 17         [ 4] 1079 	ld ([ptr16],y),a ; token attribute 
      0003BB 90 5C            [ 2] 1080 	incw y
      0003BD 17 03            [ 2] 1081 	ldw (BUFIDX,sp),y
      0003BF A1 01            [ 1] 1082 	cp a,#TK_COLON 
      0003C1 26 02            [ 1] 1083 	jrne 31$
      0003C3 20 E0            [ 2] 1084 	jra 2$ ; loop for next token 
      0003C5                       1085 31$: ; check for token type 
                                   1086 ; character token have 1 byte attribute, i.e. ASCII character 
      0003C5 A1 03            [ 1] 1087 	cp a,#TK_CHAR
      0003C7 26 0C            [ 1] 1088 	jrne 32$ 
      0003C9 1E 01            [ 2] 1089 	ldw x,(XSAVE,sp)
      0003CB 9F               [ 1] 1090 	ld a,xl 
      0003CC 91 D7 17         [ 4] 1091 	ld ([ptr16],y),a
      0003CF 90 5C            [ 2] 1092 	incw y 
      0003D1 17 03            [ 2] 1093 	ldw (BUFIDX,sp),y 
      0003D3 20 D0            [ 2] 1094 	jra 2$ 
      0003D5                       1095 32$:
      0003D5 A1 02            [ 1] 1096 	cp a,#TK_ARRAY 
                                   1097 ; this token have not attribute. 
      0003D7 27 CC            [ 1] 1098 	jreq 2$ 
      0003D9 A1 0A            [ 1] 1099 	cp a,#TK_QSTR 
      0003DB 26 25            [ 1] 1100 	jrne 4$
                                   1101 ; copy string as C string.	
      0003DD AE 17 38         [ 2] 1102 	ldw x,#pad 
      0003E0 CD 01 FA         [ 4] 1103 	call strlen
      0003E3 5C               [ 2] 1104 	incw x  
      0003E4 CD 03 65         [ 4] 1105 	call check_full 
      0003E7 90 AE 17 38      [ 2] 1106 	ldw y,#pad 
      0003EB CE 00 17         [ 2] 1107 	ldw x,ptr16
      0003EE 72 FB 03         [ 2] 1108 	addw x,(BUFIDX,sp)	
      0003F1 CD 02 18         [ 4] 1109 	call strcpy 
      0003F4 AE 17 38         [ 2] 1110 	ldw x,#pad 
      0003F7 CD 01 FA         [ 4] 1111 	call strlen 
      0003FA 5C               [ 2] 1112 	incw x
      0003FB 72 FB 03         [ 2] 1113 	addw x,(BUFIDX,sp) 
      0003FE 1F 03            [ 2] 1114 	ldw (BUFIDX,sp),x
      000400 20 A3            [ 2] 1115 	jra 2$  
      000402 A1 04            [ 1] 1116 4$: cp a,#TK_INTGR
      000404 25 9F            [ 1] 1117 	jrult 2$ ; 
      000406 A1 08            [ 1] 1118 	cp a,#TK_CFUNC 
      000408 22 9B            [ 1] 1119 	Jrugt 2$ ; those tokens have no attributes 
      00040A 1E 01            [ 2] 1120 	ldw x,(XSAVE,sp) 
      00040C 16 03            [ 2] 1121 	ldw y,(BUFIDX,sp)
      00040E 91 DF 17         [ 5] 1122 	ldw ([ptr16],y),x ; the attribute is an address or integer. 
      000411 A3 14 46         [ 2] 1123 	cpw x,#rem ; is this a comment? 
      000414 27 09            [ 1] 1124 	jreq 5$	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 22.
Hexadecimal [24-Bits]



      000416 72 A9 00 02      [ 2] 1125 	addw y,#2 
      00041A 17 03            [ 2] 1126 	ldw (BUFIDX,sp),y 
      00041C CC 03 A5         [ 2] 1127 	jp 2$
      00041F                       1128 5$:
                                   1129 ; copy commment in code buffer and
                                   1130 ; skip to end of line.  
      00041F 72 A9 00 02      [ 2] 1131 	addw y,#2 ; skip exec address 
      000423 17 03            [ 2] 1132 	ldw (BUFIDX,sp),y 
      000425 CE 00 17         [ 2] 1133 	ldw x,ptr16 
      000428 72 FB 03         [ 2] 1134 	addw x,(BUFIDX,sp)
      00042B 90 CE 00 00      [ 2] 1135 	ldw y,in.w 
      00042F 72 A9 16 E8      [ 2] 1136 	addw y,#tib 
      000433 CD 02 18         [ 4] 1137 	call strcpy 	
      000436 CD 01 FA         [ 4] 1138 	call strlen 
      000439 5C               [ 2] 1139 	incw x ; skip string 0. 
      00043A 72 FB 03         [ 2] 1140 	addw x,(BUFIDX,sp)
      00043D 1F 03            [ 2] 1141 	ldw (BUFIDX,sp),x 
      00043F                       1142 9$: 
      00043F AE 00 02         [ 2] 1143 	ldw x,#2
      000442 16 03            [ 2] 1144 	ldw y,(BUFIDX,sp)
      000444 90 9F            [ 1] 1145 	ld a,yl 
      000446 72 D7 00 17      [ 4] 1146 	ld ([ptr16],x),a ; code byte count   	
      00044A 72 CE 00 17      [ 5] 1147 	ldw x,[ptr16]
      00044E 27 09            [ 1] 1148 	jreq 10$
      000450 CD 02 FD         [ 4] 1149 	call insert_line
      000453 72 5F 00 03      [ 1] 1150 	clr  count 
      000457 20 0F            [ 2] 1151 	jra  11$ 
      000459                       1152 10$: ; line# is zero 
      000459 CE 00 17         [ 2] 1153 	ldw x,ptr16 
      00045C CF 00 04         [ 2] 1154 	ldw basicptr,x 
      00045F E6 02            [ 1] 1155 	ld a,(2,x)
      000461 C7 00 03         [ 1] 1156 	ld count,a 
      000464 35 03 00 01      [ 1] 1157 	mov in,#3 
      000468                       1158 11$:
      000468                       1159 	_drop VSIZE 
      000468 5B 04            [ 2]    1     addw sp,#VSIZE 
      00046A 72 1B 00 25      [ 1] 1160 	bres flags,#FCOMP 
      00046E 81               [ 4] 1161 	ret 
                                   1162 
                                   1163 
                                   1164 ;------------------------------------
                                   1165 ;  set all variables to zero 
                                   1166 ; input:
                                   1167 ;   none 
                                   1168 ; output:
                                   1169 ;	none
                                   1170 ;------------------------------------
      00046F                       1171 clear_vars:
      00046F AE 00 28         [ 2] 1172 	ldw x,#vars 
      000472 90 AE 00 34      [ 2] 1173 	ldw y,#2*26 
      000476 7F               [ 1] 1174 1$:	clr (x)
      000477 5C               [ 2] 1175 	incw x 
      000478 90 5A            [ 2] 1176 	decw y 
      00047A 26 FA            [ 1] 1177 	jrne 1$
      00047C 81               [ 4] 1178 	ret 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 23.
Hexadecimal [24-Bits]



                                   1179 
                                   1180 ;-------------------------------------
                                   1181 ; check if A is a letter 
                                   1182 ; input:
                                   1183 ;   A 			character to test 
                                   1184 ; output:
                                   1185 ;   C flag      1 true, 0 false 
                                   1186 ;-------------------------------------
      00047D                       1187 is_alpha:
      00047D A1 41            [ 1] 1188 	cp a,#'A 
      00047F 8C               [ 1] 1189 	ccf
      000480 24 0B            [ 1] 1190 	jrnc 9$ 
      000482 A1 5B            [ 1] 1191 	cp a,#'Z+1 
      000484 25 07            [ 1] 1192 	jrc 9$ 
      000486 A1 61            [ 1] 1193 	cp a,#'a 
      000488 8C               [ 1] 1194 	ccf 
      000489 24 02            [ 1] 1195 	jrnc 9$
      00048B A1 7B            [ 1] 1196 	cp a,#'z+1   
      00048D 81               [ 4] 1197 9$: ret 	
                                   1198 
                                   1199 ;-------------------------------------
                                   1200 ;  program initialization entry point 
                                   1201 ;-------------------------------------
                           000001  1202 	MAJOR=1
                           000000  1203 	MINOR=0
      00048E 0A 0A 54 69 6E 79 20  1204 software: .asciz "\n\nTiny BASIC for STM8\nCopyright, Jacques Deschenes 2019,2020\nversion "
             42 41 53 49 43 20 66
             6F 72 20 53 54 4D 38
             0A 43 6F 70 79 72 69
             67 68 74 2C 20 4A 61
             63 71 75 65 73 20 44
             65 73 63 68 65 6E 65
             73 20 32 30 31 39 2C
             32 30 32 30 0A 76 65
             72 73 69 6F 6E 20 00
      0004D4                       1205 cold_start:
                                   1206 ;set stack 
      0004D4 AE 17 FF         [ 2] 1207 	ldw x,#STACK_EMPTY
      0004D7 94               [ 1] 1208 	ldw sp,x   
                                   1209 ; clear all ram 
      0004D8 7F               [ 1] 1210 0$: clr (x)
      0004D9 5A               [ 2] 1211 	decw x 
      0004DA 26 FC            [ 1] 1212 	jrne 0$
                                   1213 ; activate pull up on all inputs 
      0004DC A6 FF            [ 1] 1214 	ld a,#255 
      0004DE C7 50 03         [ 1] 1215 	ld PA_CR1,a 
      0004E1 C7 50 08         [ 1] 1216 	ld PB_CR1,a 
      0004E4 C7 50 0D         [ 1] 1217 	ld PC_CR1,a 
      0004E7 C7 50 12         [ 1] 1218 	ld PD_CR1,a 
      0004EA C7 50 17         [ 1] 1219 	ld PE_CR1,a 
      0004ED C7 50 1C         [ 1] 1220 	ld PF_CR1,a 
      0004F0 C7 50 21         [ 1] 1221 	ld PG_CR1,a 
      0004F3 C7 50 2B         [ 1] 1222 	ld PI_CR1,a
                                   1223 ; set LD2 pin as output and turn it on
      0004F6 72 1A 50 0D      [ 1] 1224     bset PC_CR1,#LED2_BIT
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 24.
Hexadecimal [24-Bits]



      0004FA 72 1A 50 0E      [ 1] 1225     bset PC_CR2,#LED2_BIT
      0004FE 72 1A 50 0C      [ 1] 1226     bset PC_DDR,#LED2_BIT
      000502 72 1A 50 0A      [ 1] 1227 	bset PC_ODR,#LED2_BIT 
                                   1228 ; disable schmitt triggers on Arduino CN4 analog inputs
      000506 55 00 3F 54 07   [ 1] 1229 	mov ADC_TDRL,0x3f
                                   1230 ; disable peripherals clocks
                                   1231 ;	clr CLK_PCKENR1 
                                   1232 ;	clr CLK_PCKENR2
      00050B 72 5F 50 F2      [ 1] 1233 	clr AWU_TBR 
      00050F 72 14 50 CA      [ 1] 1234 	bset CLK_PCKENR2,#CLK_PCKENR2_AWU ; enable LSI for AWU 
                                   1235 ; select internal clock no divisor: 16 Mhz 	
      000513 A6 E1            [ 1] 1236 	ld a,#CLK_SWR_HSI 
      000515 5F               [ 1] 1237 	clrw x  
      000516 CD 00 8C         [ 4] 1238     call clock_init 
      000519 CD 00 AF         [ 4] 1239 	call timer4_init
      00051C CD 00 A2         [ 4] 1240 	call timer2_init
                                   1241 ; UART1 at 115200 BAUD
      00051F CD 01 78         [ 4] 1242 	call uart1_init
                                   1243 ; activate PE_4 (user button interrupt)
      000522 72 18 50 18      [ 1] 1244     bset PE_CR2,#USR_BTN_BIT 
                                   1245 ; display system information
      000526 AE 04 8E         [ 2] 1246 	ldw x,#software 
      000529 CD 01 C6         [ 4] 1247 	call puts 
      00052C A6 01            [ 1] 1248 	ld a,#MAJOR 
      00052E C7 00 0D         [ 1] 1249 	ld acc8,a 
      000531 5F               [ 1] 1250 	clrw x 
      000532 CF 00 0B         [ 2] 1251 	ldw acc24,x 
      000535 A6 0A            [ 1] 1252 	ld a,#10 
      000537 CD 08 02         [ 4] 1253 	call prti24 
      00053A A6 2E            [ 1] 1254 	ld a,#'.
      00053C CD 01 B3         [ 4] 1255 	call putc 
      00053F A6 00            [ 1] 1256 	ld a,#MINOR 
      000541 C7 00 0D         [ 1] 1257 	ld acc8,a 
      000544 5F               [ 1] 1258 	clrw x 
      000545 CF 00 0B         [ 2] 1259 	ldw acc24,x 
      000548 A6 0A            [ 1] 1260 	ld a,#10 
      00054A CD 08 02         [ 4] 1261 	call prti24 
      00054D A6 0D            [ 1] 1262 	ld a,#CR 
      00054F CD 01 B3         [ 4] 1263 	call putc 
      000552 CD 18 39         [ 4] 1264 	call seek_fdrive 
      000555 9A               [ 1] 1265 	rim 
      000556 72 5C 00 15      [ 1] 1266 	inc seedy+1 
      00055A 72 5C 00 13      [ 1] 1267 	inc seedx+1 
      00055E CD 05 CB         [ 4] 1268 	call clear_basic
      000561 CD 10 E1         [ 4] 1269 	call ubound 
                                   1270 ;	jra 2$	
                                   1271 ; 150 msec beep 
      000564 AE 00 96         [ 2] 1272 	ldw x,#150 
      000567 90 AE 03 E6      [ 2] 1273 	ldw y,#998 
      00056B CD 16 BD         [ 4] 1274 	call beep  
      00056E 72 1B 50 0A      [ 1] 1275 2$:	bres PC_ODR,#LED2_BIT	
      000572 CD 05 7B         [ 4] 1276 	call warm_init
      000575 CD 05 92         [ 4] 1277 	call load_autorun
      000578 CC 07 47         [ 2] 1278     jp interp 
                                   1279 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 25.
Hexadecimal [24-Bits]



      00057B                       1280 warm_init:
      00057B 72 5F 00 25      [ 1] 1281 	clr flags 
      00057F 72 5F 00 22      [ 1] 1282 	clr loop_depth 
      000583 35 04 00 26      [ 1] 1283 	mov tab_width,#TAB_WIDTH 
      000587 35 0A 00 0A      [ 1] 1284 	mov base,#10 
      00058B AE 16 E8         [ 2] 1285 	ldw x,#tib 
      00058E CF 00 04         [ 2] 1286 	ldw basicptr,x 
      000591 81               [ 4] 1287 	ret 
                                   1288 
                                   1289 ;--------------------------
                                   1290 ; if autorun file defined 
                                   1291 ; in eeprom address AUTORUN_NAME 
                                   1292 ; load and run it.
                                   1293 ;-------------------------
      000592                       1294 load_autorun:
      000592 AE 40 00         [ 2] 1295 	ldw x,#AUTORUN_NAME
      000595 F6               [ 1] 1296 	ld a,(x)
      000596 27 1D            [ 1] 1297 	jreq 9$
      000598 90 AE 40 00      [ 2] 1298 	ldw y,#AUTORUN_NAME
      00059C CD 18 97         [ 4] 1299 	call search_file
      00059F 25 02            [ 1] 1300 	jrc 2$ 
      0005A1 20 12            [ 2] 1301 	jra 9$ 
      0005A3 CD 19 A6         [ 4] 1302 2$:	call load_file
      0005A6 AE 40 00         [ 2] 1303 	ldw x,#AUTORUN_NAME 
      0005A9 CD 01 C6         [ 4] 1304 	call puts
      0005AC AE 05 B6         [ 2] 1305 	ldw x,#autorun_msg 
      0005AF CD 01 C6         [ 4] 1306 	call puts 
      0005B2 CC 16 7A         [ 2] 1307 	jp run_it    
      0005B5 81               [ 4] 1308 9$: ret 	
                                   1309 
      0005B6 20 6C 6F 61 64 65 64  1310 autorun_msg: .asciz " loaded and running\n"
             20 61 6E 64 20 72 75
             6E 6E 69 6E 67 0A 00
                                   1311 ;---------------------------
                                   1312 ; reset BASIC text variables 
                                   1313 ; and clear variables 
                                   1314 ;---------------------------
      0005CB                       1315 clear_basic:
      0005CB 72 5F 00 03      [ 1] 1316 	clr count 
      0005CF AE 00 5C         [ 2] 1317 	ldw x,#free_ram 
      0005D2 CF 00 1E         [ 2] 1318 	ldw txtbgn,x 
      0005D5 CF 00 20         [ 2] 1319 	ldw txtend,x 
      0005D8 CD 04 6F         [ 4] 1320 	call clear_vars 
      0005DB 81               [ 4] 1321 	ret 
                                   1322 
                                   1323 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   1324 ;;   Tiny BASIC error messages     ;;
                                   1325 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      0005DC                       1326 err_msg:
      0005DC 00 00 05 F6 06 04 06  1327 	.word 0,err_mem_full, err_syntax, err_math_ovf, err_div0,err_no_line    
             13 06 2D 06 3D
      0005E8 06 54 06 6B 06 86 06  1328 	.word err_run_only,err_cmd_only,err_duplicate,err_not_file,err_bad_value
             98 06 AA
      0005F2 06 B7 06 EB           1329 	.word err_no_access,err_no_data  
                                   1330 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 26.
Hexadecimal [24-Bits]



      0005F6 0A 4D 65 6D 6F 72 79  1331 err_mem_full: .asciz "\nMemory full\n" 
             20 66 75 6C 6C 0A 00
      000604 0A 73 79 6E 74 61 78  1332 err_syntax: .asciz "\nsyntax error\n" 
             20 65 72 72 6F 72 0A
             00
      000613 0A 6D 61 74 68 20 6F  1333 err_math_ovf: .asciz "\nmath operation overflow\n"
             70 65 72 61 74 69 6F
             6E 20 6F 76 65 72 66
             6C 6F 77 0A 00
      00062D 0A 64 69 76 69 73 69  1334 err_div0: .asciz "\ndivision by 0\n" 
             6F 6E 20 62 79 20 30
             0A 00
      00063D 0A 69 6E 76 61 6C 69  1335 err_no_line: .asciz "\ninvalid line number.\n"
             64 20 6C 69 6E 65 20
             6E 75 6D 62 65 72 2E
             0A 00
      000654 0A 72 75 6E 20 74 69  1336 err_run_only: .asciz "\nrun time only usage.\n" 
             6D 65 20 6F 6E 6C 79
             20 75 73 61 67 65 2E
             0A 00
      00066B 0A 63 6F 6D 6D 61 6E  1337 err_cmd_only: .asciz "\ncommand line only usage.\n"
             64 20 6C 69 6E 65 20
             6F 6E 6C 79 20 75 73
             61 67 65 2E 0A 00
      000686 0A 64 75 70 6C 69 63  1338 err_duplicate: .asciz "\nduplicate name.\n"
             61 74 65 20 6E 61 6D
             65 2E 0A 00
      000698 0A 46 69 6C 65 20 6E  1339 err_not_file: .asciz "\nFile not found.\n"
             6F 74 20 66 6F 75 6E
             64 2E 0A 00
      0006AA 0A 62 61 64 20 76 61  1340 err_bad_value: .asciz "\nbad value.\n"
             6C 75 65 2E 0A 00
      0006B7 0A 46 69 6C 65 20 69  1341 err_no_access: .asciz "\nFile in extended memory, can't be run from there.\n" 
             6E 20 65 78 74 65 6E
             64 65 64 20 6D 65 6D
             6F 72 79 2C 20 63 61
             6E 27 74 20 62 65 20
             72 75 6E 20 66 72 6F
             6D 20 74 68 65 72 65
             2E 0A 00
      0006EB 0A 4E 6F 20 64 61 74  1342 err_no_data: .asciz "\nNo data line found.\n"
             61 20 6C 69 6E 65 20
             66 6F 75 6E 64 2E 0A
             00
                                   1343 
                                   1344 ;rt_msg: .asciz "last token id: "
                                   1345 
      000701                       1346 syntax_error:
      000701 A6 02            [ 1] 1347 	ld a,#ERR_SYNTAX 
                                   1348 
      000703                       1349 tb_error:
      000703 AE 05 DC         [ 2] 1350 	ldw x, #err_msg 
      000706 72 5F 00 0C      [ 1] 1351 	clr acc16 
      00070A 48               [ 1] 1352 	sll a
      00070B 72 59 00 0C      [ 1] 1353 	rlc acc16  
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 27.
Hexadecimal [24-Bits]



      00070F C7 00 0D         [ 1] 1354 	ld acc8, a 
      000712 72 BB 00 0C      [ 2] 1355 	addw x,acc16 
      000716 FE               [ 2] 1356 	ldw x,(x)
      000717 CD 01 C6         [ 4] 1357 	call puts
      00071A 72 0B 00 25 18   [ 2] 1358 	btjf flags,#FCOMP, 1$
      00071F AE 16 E8         [ 2] 1359 	ldw x,#tib
      000722 CD 01 C6         [ 4] 1360 	call puts 
      000725 A6 0D            [ 1] 1361 	ld a,#CR 
      000727 CD 01 B3         [ 4] 1362 	call putc
      00072A CE 00 00         [ 2] 1363 	ldw x,in.w
      00072D CD 01 EE         [ 4] 1364 	call spaces
      000730 A6 5E            [ 1] 1365 	ld a,#'^
      000732 CD 01 B3         [ 4] 1366 	call putc 
      000735 20 09            [ 2] 1367 	jra 6$
      000737 CE 00 04         [ 2] 1368 1$:	ldw x,basicptr
      00073A C6 00 01         [ 1] 1369 	ld a,in 
      00073D CD 11 F1         [ 4] 1370 	call prt_basic_line
                                   1371 ;	ldw x,#rt_msg 
                                   1372 ;	call puts 
                                   1373 ;	clrw x 
                                   1374 ;	ld a,in.saved 
                                   1375 ;	ld xl,a 
                                   1376 ;	ld a,([basicptr],x)
                                   1377 ;	clrw x 
                                   1378 ;	ld xl,a 
                                   1379 ;	call print_int 
      000740 AE 17 FF         [ 2] 1380 6$: ldw x,#STACK_EMPTY 
      000743 94               [ 1] 1381     ldw sp,x
      000744                       1382 warm_start:
      000744 CD 05 7B         [ 4] 1383 	call warm_init
                                   1384 ;----------------------------
                                   1385 ;   BASIC interpreter
                                   1386 ;----------------------------
      000747                       1387 interp:
      000747 72 5F 00 00      [ 1] 1388 	clr in.w
      00074B 72 01 00 25 23   [ 2] 1389 	btjf flags,#FRUN,cmd_line
                                   1390 ; flag FRUN is set 
                                   1391 ; running program
                                   1392 ; goto next basic line 
      000750 CE 00 04         [ 2] 1393 	ldw x,basicptr
      000753 E6 02            [ 1] 1394 	ld a,(2,x) ; line length 
      000755 C7 00 0D         [ 1] 1395 	ld acc8,a 
      000758 72 5F 00 0C      [ 1] 1396 	clr acc16 
      00075C 72 BB 00 0C      [ 2] 1397 	addw x,acc16
      000760 C3 00 20         [ 2] 1398 	cpw x,txtend 
      000763 2A DF            [ 1] 1399 	jrpl warm_start
      000765 CF 00 04         [ 2] 1400 	ldw basicptr,x ; start of next line  
      000768 E6 02            [ 1] 1401 	ld a,(2,x)
      00076A C7 00 03         [ 1] 1402 	ld count,a 
      00076D 35 03 00 01      [ 1] 1403 	mov in,#3 ; skip first 3 bytes of line 
      000771 20 14            [ 2] 1404 	jra interp_loop 
      000773                       1405 cmd_line: ; commande line interface  	
      000773 72 5F 00 01      [ 1] 1406 	clr in
      000777 A6 0D            [ 1] 1407 	ld a,#CR 
      000779 CD 01 B3         [ 4] 1408 	call putc 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 28.
Hexadecimal [24-Bits]



      00077C A6 3E            [ 1] 1409 	ld a,#'> 
      00077E CD 01 B3         [ 4] 1410 	call putc 
      000781 CD 09 3A         [ 4] 1411 	call readln
      000784 CD 03 74         [ 4] 1412 	call compile
                                   1413 ; if text begin with a line number
                                   1414 ; the compile set count=0   
                                   1415 ; so code is not interpreted
                                   1416 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   1417 ;; This is the interpreter loop
                                   1418 ;; for each BASIC code line. 
                                   1419 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
      000787                       1420 interp_loop:  
      000787 C6 00 01         [ 1] 1421 	ld a,in 
      00078A C1 00 03         [ 1] 1422 	cp a,count  
      00078D 2A B8            [ 1] 1423 	jrpl interp
      00078F CD 07 B5         [ 4] 1424 	call next_token
      000792 A1 01            [ 1] 1425 	cp a,#TK_COLON 
      000794 27 F1            [ 1] 1426 	jreq interp_loop 
      000796                       1427 1$:
      000796 A1 05            [ 1] 1428 	cp a,#TK_VAR
      000798 26 05            [ 1] 1429 	jrne 2$
      00079A CD 11 0D         [ 4] 1430 	call let02  
      00079D 20 E8            [ 2] 1431 	jra interp_loop 
      00079F                       1432 2$:	
      00079F A1 02            [ 1] 1433 	cp a,#TK_ARRAY 
      0007A1 26 08            [ 1] 1434 	jrne 3$
      0007A3 CD 0E C2         [ 4] 1435 	call get_array_element
      0007A6 CD 11 0D         [ 4] 1436 	call let02 
      0007A9 20 DC            [ 2] 1437 	jra interp_loop 
      0007AB                       1438 3$:
      0007AB A1 06            [ 1] 1439 	cp a,#TK_CMD
      0007AD 26 03            [ 1] 1440 	jrne 4$
      0007AF FD               [ 4] 1441 	call (x) 
      0007B0 20 D5            [ 2] 1442 	jra interp_loop 
      0007B2                       1443 4$:	
      0007B2 CC 07 01         [ 2] 1444 	jp syntax_error 
                                   1445 
                                   1446 ;--------------------------
                                   1447 ; extract next token from
                                   1448 ; token list 
                                   1449 ; basicptr -> base address 
                                   1450 ; in  -> offset in list array 
                                   1451 ; output:
                                   1452 ;   A 		token attribute
                                   1453 ;   X 		token value if there is one
                                   1454 ;----------------------------------------
      0007B5                       1455 next_token:
      0007B5 C6 00 01         [ 1] 1456 	ld a,in 
      0007B8 C0 00 03         [ 1] 1457 	sub a,count ; don't replace sub by cp.  
      0007BB 27 44            [ 1] 1458 	jreq 10$
      0007BD 55 00 01 00 02   [ 1] 1459 	mov in.saved,in 
      0007C2 90 CE 00 04      [ 2] 1460 	ldw y,basicptr 
      0007C6 72 B9 00 00      [ 2] 1461 	addw y,in.w 
      0007CA 90 F6            [ 1] 1462 	ld a,(y)
      0007CC 90 5C            [ 2] 1463 	incw y  
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 29.
Hexadecimal [24-Bits]



      0007CE A1 02            [ 1] 1464 	cp a,#TK_ARRAY  
      0007D0 23 27            [ 2] 1465 	jrule 9$
      0007D2 A1 03            [ 1] 1466 	cp a,#TK_CHAR
      0007D4 26 0A            [ 1] 1467 	jrne 1$
      0007D6 90 F6            [ 1] 1468 	ld a,(y)
      0007D8 90 5C            [ 2] 1469 	incw y
      0007DA 5F               [ 1] 1470 	clrw x 
      0007DB 97               [ 1] 1471 	ld xl,a 
      0007DC A6 03            [ 1] 1472 	ld a,#TK_CHAR
      0007DE 20 19            [ 2] 1473 	jra 9$ 
      0007E0 A1 0A            [ 1] 1474 1$:	cp a,#TK_QSTR 
      0007E2 25 0F            [ 1] 1475 	jrult 4$
      0007E4 26 13            [ 1] 1476 	jrne 9$
      0007E6 93               [ 1] 1477 	ldw x,y 
      0007E7 90 7D            [ 1] 1478 2$:	tnz (y)
      0007E9 27 04            [ 1] 1479 	jreq 3$
      0007EB 90 5C            [ 2] 1480 	incw y
      0007ED 20 F8            [ 2] 1481 	jra 2$ 
      0007EF 90 5C            [ 2] 1482 3$:	incw y 
      0007F1 20 06            [ 2] 1483 	jra 9$ 
      0007F3 93               [ 1] 1484 4$: ldw x,y 
      0007F4 FE               [ 2] 1485 	ldw x,(x)
      0007F5 72 A9 00 02      [ 2] 1486 	addw y,#2  
      0007F9 72 B2 00 04      [ 2] 1487 9$: subw y,basicptr 
      0007FD 90 CF 00 00      [ 2] 1488     ldw in.w,y 
      000801                       1489 10$:
      000801 81               [ 4] 1490 	ret	
                                   1491 
                                   1492 
                                   1493 ;----------------------------------------
                                   1494 ;   DEBUG support functions
                                   1495 ;----------------------------------------
                           000000  1496 .if DEBUG 
                                   1497 
                                   1498 ; turn LED on 
                                   1499 ledon:
                                   1500     bset PC_ODR,#LED2_BIT
                                   1501     ret 
                                   1502 
                                   1503 ; turn LED off 
                                   1504 ledoff:
                                   1505     bres PC_ODR,#LED2_BIT 
                                   1506     ret 
                                   1507 
                                   1508 ; invert LED status 
                                   1509 ledtoggle:
                                   1510     ld a,#LED2_MASK
                                   1511     xor a,PC_ODR
                                   1512     ld PC_ODR,a
                                   1513     ret 
                                   1514 
                                   1515 left_paren:
                                   1516 	ld a,#SPACE 
                                   1517 	call putc
                                   1518 	ld a,#'( 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 30.
Hexadecimal [24-Bits]



                                   1519 	call putc 	
                                   1520 	ret 
                                   1521 
                                   1522 ;------------------------------
                                   1523 ; print 8 bit register 
                                   1524 ; input:
                                   1525 ;   X  point to register name 
                                   1526 ;   A  register value to print 
                                   1527 ; output:
                                   1528 ;   none
                                   1529 ;------------------------------- 
                                   1530 prt_reg8:
                                   1531 	push a 
                                   1532 	call puts 
                                   1533 	ld a,(1,sp) 
                                   1534 	ld acc8,a 
                                   1535 	clrw x 
                                   1536 	ld xl,a 
                                   1537 	mov base,#16
                                   1538 	call print_int 
                                   1539 	call left_paren 
                                   1540 	pop a 
                                   1541 	clrw x 
                                   1542 	ld xl,a 
                                   1543 	mov base,#10 
                                   1544 	call print_int  
                                   1545 	ld a,#') 
                                   1546 	call putc
                                   1547 	ret
                                   1548 
                                   1549 ;--------------------------------
                                   1550 ; print 16 bits register 
                                   1551 ; input:
                                   1552 ;   X   point register name 
                                   1553 ;   Y   register value to print 
                                   1554 ; output:
                                   1555 ;  none
                                   1556 ;--------------------------------
                                   1557 prt_reg16: 
                                   1558 	pushw y 
                                   1559 	call puts 
                                   1560 	ldw x,(1,sp) 
                                   1561 	mov base,#16 
                                   1562 	call print_int  
                                   1563 	call left_paren 
                                   1564 	popw x 
                                   1565 	mov base,#10 
                                   1566 	call print_int  
                                   1567 	ld a,#') 
                                   1568 	call putc
                                   1569 	ret 
                                   1570 
                                   1571 ;------------------------------------
                                   1572 ; print registers contents saved on
                                   1573 ; stack by trap interrupt.
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 31.
Hexadecimal [24-Bits]



                                   1574 ;------------------------------------
                                   1575 print_registers:
                                   1576 	ldw x,#STATES
                                   1577 	call puts
                                   1578 ; print EPC 
                                   1579 	ldw x, #REG_EPC
                                   1580 	call puts 
                                   1581 	ld a, (11,sp)
                                   1582 	ld acc8,a 
                                   1583 	ld a, (10,sp) 
                                   1584 	ld acc16,a 
                                   1585 	ld a,(9,sp) 
                                   1586 	ld acc24,a
                                   1587 	clrw x  
                                   1588 	ld a,#16
                                   1589 	call prti24  
                                   1590 ; print X
                                   1591 	ldw x,#REG_X
                                   1592 	ldw y,(5,sp)
                                   1593 	call prt_reg16  
                                   1594 ; print Y 
                                   1595 	ldw x,#REG_Y
                                   1596 	ldw y, (7,sp)
                                   1597 	call prt_reg16  
                                   1598 ; print A 
                                   1599 	ldw x,#REG_A
                                   1600 	ld a, (4,sp) 
                                   1601 	call prt_reg8
                                   1602 ; print CC 
                                   1603 	ldw x,#REG_CC 
                                   1604 	ld a, (3,sp) 
                                   1605 	call prt_reg8 
                                   1606 ; print SP 
                                   1607 	ldw x,#REG_SP
                                   1608 	ldw y,sp 
                                   1609 	addw y,#12
                                   1610 	call prt_reg16  
                                   1611 	ld a,#'\n' 
                                   1612 	call putc
                                   1613 	ret
                                   1614 
                                   1615 STATES:  .asciz "\nRegisters state at abort point.\n--------------------------\n"
                                   1616 REG_EPC: .asciz "EPC:"
                                   1617 REG_Y:   .asciz "\nY:" 
                                   1618 REG_X:   .asciz "\nX:"
                                   1619 REG_A:   .asciz "\nA:" 
                                   1620 REG_CC:  .asciz "\nCC:"
                                   1621 REG_SP:  .asciz "\nSP:"
                                   1622 
                                   1623 .endif ; DEBUG 
                                   1624 ;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   1625 
                                   1626 
                                   1627 ;------------------------------------
                                   1628 ; print integer in acc24 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 32.
Hexadecimal [24-Bits]



                                   1629 ; input:
                                   1630 ;	acc24 		integer to print 
                                   1631 ;	A 			numerical base for conversion 
                                   1632 ;               if bit 7 is set add a space at print end.
                                   1633 ;   XL 			field width, 0 -> no fill.
                                   1634 ;  output:
                                   1635 ;    none 
                                   1636 ;------------------------------------
                           000001  1637 	WIDTH = 1
                           000002  1638 	BASE = 2
                           000003  1639 	ADD_SPACE=3 ; add a space after number 
                           000003  1640 	VSIZE = 3
      000802                       1641 prti24:
      000802                       1642 	_vars VSIZE 
      000802 52 03            [ 2]    1     sub sp,#VSIZE 
      000804 0F 03            [ 1] 1643 	clr (ADD_SPACE,sp)
      000806 A5 80            [ 1] 1644 	bcp a,#0x80 
      000808 27 02            [ 1] 1645 	jreq 0$ 
      00080A 03 03            [ 1] 1646 	cpl (ADD_SPACE,sp)
      00080C A4 1F            [ 1] 1647 0$:	and a,#31 
      00080E 6B 02            [ 1] 1648 	ld (BASE,sp),a
      000810 9F               [ 1] 1649 	ld a,xl
      000811 6B 01            [ 1] 1650 	ld (WIDTH,sp),a 
      000813 7B 02            [ 1] 1651 	ld a, (BASE,sp)  
      000815 CD 08 A8         [ 4] 1652     call itoa  ; conversion entier en  .asciz
      000818 7B 01            [ 1] 1653 1$: ld a,(WIDTH,sp)
      00081A 27 1F            [ 1] 1654 	jreq 4$
      00081C C7 00 0D         [ 1] 1655 	ld acc8,a 
      00081F 89               [ 2] 1656 	pushw x 
      000820 CD 01 FA         [ 4] 1657 	call strlen 
      000823 9F               [ 1] 1658 	ld a,xl 
      000824 85               [ 2] 1659 	popw x 
      000825 31 00 0D         [ 3] 1660 	exg a,acc8 
      000828 C0 00 0D         [ 1] 1661 	sub a,acc8 
      00082B 2B 0E            [ 1] 1662 	jrmi 4$
      00082D 6B 01            [ 1] 1663 	ld (WIDTH,sp),a 
      00082F A6 20            [ 1] 1664 	ld  a,#SPACE
      000831 0D 01            [ 1] 1665 3$: tnz (WIDTH,sp)
      000833 27 06            [ 1] 1666 	jreq 4$
      000835 5A               [ 2] 1667 	decw x 
      000836 F7               [ 1] 1668 	ld (x),a 
      000837 0A 01            [ 1] 1669 	dec (WIDTH,sp) 
      000839 20 F6            [ 2] 1670 	jra 3$
      00083B                       1671 4$: 
      00083B CD 01 C6         [ 4] 1672 	call puts 
      00083E 0D 03            [ 1] 1673 	tnz (ADD_SPACE,sp)
      000840 27 05            [ 1] 1674 	jreq 5$
      000842 A6 20            [ 1] 1675     ld a,#SPACE 
      000844 CD 01 B3         [ 4] 1676 	call putc 
      000847                       1677 5$: _drop VSIZE 
      000847 5B 03            [ 2]    1     addw sp,#VSIZE 
      000849 81               [ 4] 1678     ret	
                                   1679 
                                   1680 ;-----------------------------------
                                   1681 ; print a 16 bit integer 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 33.
Hexadecimal [24-Bits]



                                   1682 ; using variable 'base' as conversion
                                   1683 ; format.
                                   1684 ; input:
                                   1685 ;   X       integer to print 
                                   1686 ;   base    conversion base 
                                   1687 ; output:
                                   1688 ;   none 
                                   1689 ;-----------------------------------
                           000001  1690 	SIGN=1
                           000001  1691 	VSIZE=1
      00084A                       1692 print_int: 
      00084A                       1693 	_vars VSIZE 
      00084A 52 01            [ 2]    1     sub sp,#VSIZE 
      00084C 0F 01            [ 1] 1694 	clr (SIGN,sp)
      00084E 90 AE 17 5F      [ 2] 1695 	ldw y,#pad+PAD_SIZE-1 
      000852 90 7F            [ 1] 1696 	clr (y)
      000854 C6 00 0A         [ 1] 1697 	ld a,base  
      000857 A1 0A            [ 1] 1698 	cp a,#10 
      000859 26 06            [ 1] 1699 	jrne 1$ 
      00085B 5D               [ 2] 1700 	tnzw x 
      00085C 2A 03            [ 1] 1701 	jrpl 1$ 
      00085E 03 01            [ 1] 1702 	cpl (SIGN,sp)
      000860 50               [ 2] 1703 	negw x 	 
      000861                       1704 1$:	
      000861 C6 00 0A         [ 1] 1705 	ld a,base 
      000864 62               [ 2] 1706 	div x,a 
      000865 AB 30            [ 1] 1707 	add a,#'0 
      000867 A1 3A            [ 1] 1708 	cp a,#'9+1 
      000869 2B 02            [ 1] 1709 	jrmi 2$ 
      00086B AB 07            [ 1] 1710 	add a,#7 
      00086D 90 5A            [ 2] 1711 2$: decw y 
      00086F 90 F7            [ 1] 1712 	ld (y),a 
      000871 5D               [ 2] 1713 	tnzw x 
      000872 26 ED            [ 1] 1714 	jrne 1$ 
      000874 A6 10            [ 1] 1715 	ld a,#16 
      000876 C1 00 0A         [ 1] 1716 	cp a,base 
      000879 26 08            [ 1] 1717 	jrne 3$
      00087B A6 24            [ 1] 1718 	ld a,#'$
      00087D 90 5A            [ 2] 1719 	decw y  
      00087F 90 F7            [ 1] 1720 	ld (y),a
      000881 20 0A            [ 2] 1721 	jra 9$ 
      000883 0D 01            [ 1] 1722 3$: tnz (SIGN,sp)
      000885 27 06            [ 1] 1723 	jreq 9$ 
      000887 A6 2D            [ 1] 1724 	ld a,#'-
      000889 90 5A            [ 2] 1725 	decw y  
      00088B 90 F7            [ 1] 1726 	ld (y),a
      00088D                       1727 9$:	
      00088D 93               [ 1] 1728 	ldw x,y 
      00088E 1D 17 5F         [ 2] 1729 	subw x,#pad+PAD_SIZE-1 
      000891 50               [ 2] 1730 	negw x  
      000892                       1731 10$:
      000892 9F               [ 1] 1732 	ld a,xl 
      000893 C1 00 26         [ 1] 1733 	cp a,tab_width
      000896 24 09            [ 1] 1734 	jruge 12$
      000898 90 5A            [ 2] 1735 	decw y 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 34.
Hexadecimal [24-Bits]



      00089A A6 20            [ 1] 1736 	ld a,#SPACE 
      00089C 90 F7            [ 1] 1737 	ld (y),a
      00089E 5C               [ 2] 1738 	incw x 
      00089F 20 F1            [ 2] 1739 	jra 10$ 
      0008A1                       1740 12$:
      0008A1 93               [ 1] 1741     ldw x,y 
      0008A2 CD 01 C6         [ 4] 1742 	call puts  
      0008A5                       1743 	_drop VSIZE 
      0008A5 5B 01            [ 2]    1     addw sp,#VSIZE 
      0008A7 81               [ 4] 1744 	ret 
                                   1745 
                                   1746 ;------------------------------------
                                   1747 ; convert integer in acc24 to string
                                   1748 ; input:
                                   1749 ;   A	  	base
                                   1750 ;	acc24	integer to convert
                                   1751 ; output:
                                   1752 ;   X  		pointer to string
                                   1753 ;------------------------------------
                           000001  1754 	SIGN=1  ; integer sign 
                           000002  1755 	BASE=2  ; numeric base 
                           000002  1756 	VSIZE=2  ;locals size
      0008A8                       1757 itoa:
      0008A8 52 02            [ 2] 1758 	sub sp,#VSIZE
      0008AA 6B 02            [ 1] 1759 	ld (BASE,sp), a  ; base
      0008AC 0F 01            [ 1] 1760 	clr (SIGN,sp)    ; sign
      0008AE A1 0A            [ 1] 1761 	cp a,#10
      0008B0 26 0A            [ 1] 1762 	jrne 1$
                                   1763 	; base 10 string display with negative sign if bit 23==1
      0008B2 72 0F 00 0B 05   [ 2] 1764 	btjf acc24,#7,1$
      0008B7 03 01            [ 1] 1765 	cpl (SIGN,sp)
      0008B9 CD 09 17         [ 4] 1766 	call neg_acc24
      0008BC                       1767 1$:
                                   1768 ; initialize string pointer 
      0008BC AE 17 5F         [ 2] 1769 	ldw x,#pad+PAD_SIZE-1
      0008BF 7F               [ 1] 1770 	clr (x)
      0008C0                       1771 itoa_loop:
      0008C0 7B 02            [ 1] 1772     ld a,(BASE,sp)
      0008C2 CD 08 EF         [ 4] 1773     call divu24_8 ; acc24/A 
      0008C5 AB 30            [ 1] 1774     add a,#'0  ; remainder of division
      0008C7 A1 3A            [ 1] 1775     cp a,#'9+1
      0008C9 2B 02            [ 1] 1776     jrmi 2$
      0008CB AB 07            [ 1] 1777     add a,#7 
      0008CD 5A               [ 2] 1778 2$: decw x
      0008CE F7               [ 1] 1779     ld (x),a
                                   1780 	; if acc24==0 conversion done
      0008CF C6 00 0B         [ 1] 1781 	ld a,acc24
      0008D2 CA 00 0C         [ 1] 1782 	or a,acc16
      0008D5 CA 00 0D         [ 1] 1783 	or a,acc8
      0008D8 26 E6            [ 1] 1784     jrne itoa_loop
                                   1785 	;conversion done, next add '$' or '-' as required
      0008DA 7B 02            [ 1] 1786 	ld a,(BASE,sp)
      0008DC A1 10            [ 1] 1787 	cp a,#16
      0008DE 27 08            [ 1] 1788 	jreq 8$
      0008E0 7B 01            [ 1] 1789 	ld a,(SIGN,sp)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 35.
Hexadecimal [24-Bits]



      0008E2 27 08            [ 1] 1790     jreq 10$
      0008E4 A6 2D            [ 1] 1791     ld a,#'-
      0008E6 20 02            [ 2] 1792 	jra 9$ 
      0008E8 A6 24            [ 1] 1793 8$: ld a,#'$ 
      0008EA 5A               [ 2] 1794 9$: decw x
      0008EB F7               [ 1] 1795     ld (x),a
      0008EC                       1796 10$:
      0008EC 5B 02            [ 2] 1797 	addw sp,#VSIZE
      0008EE 81               [ 4] 1798 	ret
                                   1799 
                                   1800 ;-------------------------------------
                                   1801 ; divide uint24_t by uint8_t
                                   1802 ; used to convert uint24_t to string
                                   1803 ; input:
                                   1804 ;	acc24	dividend
                                   1805 ;   A 		divisor
                                   1806 ; output:
                                   1807 ;   acc24	quotient
                                   1808 ;   A		remainder
                                   1809 ;------------------------------------- 
                                   1810 ; offset  on sp of arguments and locals
                           000001  1811 	U8   = 1   ; divisor on stack
                           000001  1812 	VSIZE =1
      0008EF                       1813 divu24_8:
      0008EF 89               [ 2] 1814 	pushw x ; save x
      0008F0 88               [ 1] 1815 	push a 
                                   1816 	; ld dividend UU:MM bytes in X
      0008F1 C6 00 0B         [ 1] 1817 	ld a, acc24
      0008F4 95               [ 1] 1818 	ld xh,a
      0008F5 C6 00 0C         [ 1] 1819 	ld a,acc24+1
      0008F8 97               [ 1] 1820 	ld xl,a
      0008F9 7B 01            [ 1] 1821 	ld a,(U8,SP) ; divisor
      0008FB 62               [ 2] 1822 	div x,a ; UU:MM/U8
      0008FC 88               [ 1] 1823 	push a  ;save remainder
      0008FD 9E               [ 1] 1824 	ld a,xh
      0008FE C7 00 0B         [ 1] 1825 	ld acc24,a
      000901 9F               [ 1] 1826 	ld a,xl
      000902 C7 00 0C         [ 1] 1827 	ld acc24+1,a
      000905 84               [ 1] 1828 	pop a
      000906 95               [ 1] 1829 	ld xh,a
      000907 C6 00 0D         [ 1] 1830 	ld a,acc24+2
      00090A 97               [ 1] 1831 	ld xl,a
      00090B 7B 01            [ 1] 1832 	ld a,(U8,sp) ; divisor
      00090D 62               [ 2] 1833 	div x,a  ; R:LL/U8
      00090E 6B 01            [ 1] 1834 	ld (U8,sp),a ; save remainder
      000910 9F               [ 1] 1835 	ld a,xl
      000911 C7 00 0D         [ 1] 1836 	ld acc24+2,a
      000914 84               [ 1] 1837 	pop a
      000915 85               [ 2] 1838 	popw x
      000916 81               [ 4] 1839 	ret
                                   1840 
                                   1841 ;------------------------------------
                                   1842 ;  two's complement acc24
                                   1843 ;  input:
                                   1844 ;		acc24 variable
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 36.
Hexadecimal [24-Bits]



                                   1845 ;  output:
                                   1846 ;		acc24 variable
                                   1847 ;-------------------------------------
      000917                       1848 neg_acc24:
      000917 72 53 00 0D      [ 1] 1849 	cpl acc24+2
      00091B 72 53 00 0C      [ 1] 1850 	cpl acc24+1
      00091F 72 53 00 0B      [ 1] 1851 	cpl acc24
      000923 A6 01            [ 1] 1852 	ld a,#1
      000925 CB 00 0D         [ 1] 1853 	add a,acc24+2
      000928 C7 00 0D         [ 1] 1854 	ld acc24+2,a
      00092B 4F               [ 1] 1855 	clr a
      00092C C9 00 0C         [ 1] 1856 	adc a,acc24+1
      00092F C7 00 0C         [ 1] 1857 	ld acc24+1,a 
      000932 4F               [ 1] 1858 	clr a 
      000933 C9 00 0B         [ 1] 1859 	adc a,acc24 
      000936 C7 00 0B         [ 1] 1860 	ld acc24,a 
      000939 81               [ 4] 1861 	ret
                                   1862 
                                   1863 
                                   1864 ;------------------------------------
                                   1865 ; read a line of text from terminal
                                   1866 ; input:
                                   1867 ;	none
                                   1868 ; local variable on stack:
                                   1869 ;	LL  line length
                                   1870 ;   RXCHAR last received chaaracte 
                                   1871 ; output:
                                   1872 ;   text in tib  buffer
                                   1873 ;------------------------------------
                                   1874 	; local variables
                           000001  1875 	LL_HB=1
                           000001  1876 	RXCHAR = 1 ; last char received
                           000002  1877 	LL = 2  ; accepted line length
                           000002  1878 	VSIZE=2 
      00093A                       1879 readln:
      00093A 5F               [ 1] 1880 	clrw x 
      00093B 89               [ 2] 1881 	pushw x 
      00093C 90 AE 16 E8      [ 2] 1882  	ldw y,#tib ; input buffer
      000940                       1883 readln_loop:
      000940 CD 01 BC         [ 4] 1884 	call getc
      000943 6B 01            [ 1] 1885 	ld (RXCHAR,sp),a
      000945 A1 0D            [ 1] 1886 	cp a,#CR
      000947 26 03            [ 1] 1887 	jrne 1$
      000949 CC 09 B5         [ 2] 1888 	jp readln_quit
      00094C A1 0A            [ 1] 1889 1$:	cp a,#NL
      00094E 27 65            [ 1] 1890 	jreq readln_quit
      000950 A1 08            [ 1] 1891 	cp a,#BSP
      000952 27 3D            [ 1] 1892 	jreq del_back
      000954 A1 04            [ 1] 1893 	cp a,#CTRL_D
      000956 27 2A            [ 1] 1894 	jreq del_ln
      000958 A1 12            [ 1] 1895 	cp a,#CTRL_R 
      00095A 27 06            [ 1] 1896 	jreq reprint 
                                   1897 ;	cp a,#'[
                                   1898 ;	jreq ansi_seq
      00095C                       1899 final_test:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 37.
Hexadecimal [24-Bits]



      00095C A1 20            [ 1] 1900 	cp a,#SPACE
      00095E 2A 40            [ 1] 1901 	jrpl accept_char
      000960 20 DE            [ 2] 1902 	jra readln_loop
      000962                       1903 ansi_seq:
                                   1904 ;	call getc
                                   1905 ;	cp a,#'C 
                                   1906 ;	jreq rigth_arrow
                                   1907 ;	cp a,#'D 
                                   1908 ;	jreq left_arrow 
                                   1909 ;	jra final_test
      000962                       1910 right_arrow:
                                   1911 ;	ld a,#BSP 
                                   1912 ;	call putc 
                                   1913 ;	jra realn_loop 
      000962                       1914 left_arrow:
                                   1915 
                                   1916 ;	jra readln_loop
      000962                       1917 reprint: 
      000962 0D 02            [ 1] 1918 	tnz (LL,sp)
      000964 26 DA            [ 1] 1919 	jrne readln_loop
      000966 AE 16 E8         [ 2] 1920 	ldw x,#tib 
      000969 CD 01 FA         [ 4] 1921 	call strlen 
      00096C 90 AE 16 E8      [ 2] 1922 	ldw y,#tib 
      000970 9F               [ 1] 1923 	ld a,xl
      000971 27 CD            [ 1] 1924 	jreq readln_loop
      000973 6B 02            [ 1] 1925 	ld (LL,sp),a 
      000975 AE 16 E8         [ 2] 1926 	ldw x,#tib 
      000978 CD 01 C6         [ 4] 1927 	call puts
      00097B 0F 01            [ 1] 1928 	clr (LL_HB,sp)
      00097D 72 F9 01         [ 2] 1929 	addw y,(LL_HB,sp)
      000980 20 BE            [ 2] 1930 	jra readln_loop 
      000982                       1931 del_ln:
      000982 7B 02            [ 1] 1932 	ld a,(LL,sp)
      000984 CD 01 E0         [ 4] 1933 	call delete
      000987 90 AE 16 E8      [ 2] 1934 	ldw y,#tib
      00098B 90 7F            [ 1] 1935 	clr (y)
      00098D 0F 02            [ 1] 1936 	clr (LL,sp)
      00098F 20 AF            [ 2] 1937 	jra readln_loop
      000991                       1938 del_back:
      000991 0D 02            [ 1] 1939     tnz (LL,sp)
      000993 27 AB            [ 1] 1940     jreq readln_loop
      000995 0A 02            [ 1] 1941     dec (LL,sp)
      000997 90 5A            [ 2] 1942     decw y
      000999 90 7F            [ 1] 1943     clr  (y)
      00099B CD 01 D0         [ 4] 1944     call bksp 
      00099E 20 A0            [ 2] 1945     jra readln_loop	
      0009A0                       1946 accept_char:
      0009A0 A6 4F            [ 1] 1947 	ld a,#TIB_SIZE-1
      0009A2 11 02            [ 1] 1948 	cp a, (LL,sp)
      0009A4 27 9A            [ 1] 1949 	jreq readln_loop
      0009A6 7B 01            [ 1] 1950 	ld a,(RXCHAR,sp)
      0009A8 90 F7            [ 1] 1951 	ld (y),a
      0009AA 0C 02            [ 1] 1952 	inc (LL,sp)
      0009AC 90 5C            [ 2] 1953 	incw y
      0009AE 90 7F            [ 1] 1954 	clr (y)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 38.
Hexadecimal [24-Bits]



      0009B0 CD 01 B3         [ 4] 1955 	call putc 
      0009B3 20 8B            [ 2] 1956 	jra readln_loop
      0009B5                       1957 readln_quit:
      0009B5 90 7F            [ 1] 1958 	clr (y)
      0009B7 7B 02            [ 1] 1959 	ld a,(LL,sp)
      0009B9 C7 00 03         [ 1] 1960 	ld count,a 
      0009BC                       1961 	_drop VSIZE 
      0009BC 5B 02            [ 2]    1     addw sp,#VSIZE 
      0009BE A6 0D            [ 1] 1962 	ld a,#CR
      0009C0 CD 01 B3         [ 4] 1963 	call putc
      0009C3 81               [ 4] 1964 	ret
                                   1965 
                           000000  1966 .if DEBUG 	
                                   1967 ;----------------------------
                                   1968 ; command interface
                                   1969 ; only 3 commands:
                                   1970 ;  'q' to resume application
                                   1971 ;  'p [addr]' to print memory values 
                                   1972 ;  's addr' to print string 
                                   1973 ;----------------------------
                                   1974 ;local variable 
                                   1975 	PSIZE=1
                                   1976 	VSIZE=1 
                                   1977 cmd_itf:
                                   1978 	sub sp,#VSIZE 
                                   1979 	clr farptr 
                                   1980 	clr farptr+1 
                                   1981 	clr farptr+2  
                                   1982 repl:
                                   1983 	ld a,#CR 
                                   1984 	call putc 
                                   1985 	ld a,#'? 
                                   1986 	call putc
                                   1987 	clr in.w 
                                   1988 	clr in 
                                   1989 	call readln
                                   1990 	ldw y,#tib  
                                   1991 	ld a,(y)
                                   1992 	jreq repl  
                                   1993 	inc in 
                                   1994 	call to_upper 
                                   1995 	cp a,#'Q 
                                   1996 	jrne test_p
                                   1997 repl_exit:
                                   1998 	clr tib 
                                   1999 	clr count 
                                   2000 	clr in 
                                   2001 	_drop #VSIZE 	
                                   2002 	ret  
                                   2003 invalid:
                                   2004 	ldw x,#invalid_cmd 
                                   2005 	call puts 
                                   2006 	jra repl 
                                   2007 test_p:	
                                   2008     cp a,#'P 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 39.
Hexadecimal [24-Bits]



                                   2009 	jreq mem_peek
                                   2010     cp a,#'S 
                                   2011 	jrne invalid 
                                   2012 print_string:	
                                   2013 	call get_token
                                   2014 	cp a,#TK_INTGR 
                                   2015 	jrne invalid 
                                   2016 	call puts
                                   2017 	jp repl 	
                                   2018 mem_peek:
                                   2019 	ld a,#SPACE 
                                   2020 	call skip  	 
                                   2021 	addw y,in.w 
                                   2022 	ldw x,#pad 
                                   2023 	call strcpy
                                   2024 	call atoi24 	
                                   2025 	ld a, acc24 
                                   2026 	or a,acc16 
                                   2027 	or a,acc8 
                                   2028 	jrne 1$ 
                                   2029 	jra peek_byte  
                                   2030 1$:	ldw x,acc24 
                                   2031 	ldw farptr,x 
                                   2032 	ld a,acc8 
                                   2033 	ld farptr+2,a 
                                   2034 peek_byte:
                                   2035 	call print_farptr 
                                   2036 	ld a,#8 
                                   2037 	ld (PSIZE,sp),a 
                                   2038 	clrw x 
                                   2039 1$:	call fetchc  
                                   2040 	pushw x 
                                   2041 	ld acc8,a 
                                   2042 	clrw x 
                                   2043 	ldw acc24,x 
                                   2044 	ld a,#16+128
                                   2045 	call prti24
                                   2046 	popw x 
                                   2047 	dec (PSIZE,sp)
                                   2048 	jrne 1$ 
                                   2049 	ld a,#8 
                                   2050 	add a,farptr+2 
                                   2051 	ld farptr+2,a
                                   2052 	clr a 
                                   2053 	adc a,farptr+1 
                                   2054 	ld farptr+1,a 
                                   2055 	clr a 
                                   2056 	adc a,farptr 
                                   2057 	ld farptr,a 
                                   2058 	jp repl  
                                   2059 
                                   2060 invalid_cmd: .asciz "not a command\n" 
                                   2061 
                                   2062 ;----------------------------
                                   2063 ; display farptr address
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 40.
Hexadecimal [24-Bits]



                                   2064 ;----------------------------
                                   2065 print_farptr:
                                   2066 	ld a ,farptr+2 
                                   2067 	ld acc8,a 
                                   2068 	ldw x,farptr 
                                   2069 	ldw acc24,x 
                                   2070 	clrw x 
                                   2071 	ld a,#16 
                                   2072 	call prti24
                                   2073 	ld a,#SPACE 
                                   2074 	call putc 
                                   2075 	call putc 
                                   2076 	ret
                                   2077 
                                   2078 ;------------------------------------
                                   2079 ; get byte at address farptr[X]
                                   2080 ; input:
                                   2081 ;	 farptr   address to peek
                                   2082 ;    X		  farptr index 	
                                   2083 ; output:
                                   2084 ;	 A 		  byte from memory  
                                   2085 ;    x		  incremented by 1
                                   2086 ;------------------------------------
                                   2087 fetchc: ; @C
                                   2088 	ldf a,([farptr],x)
                                   2089 	incw x
                                   2090 	ret
                                   2091 
                                   2092 
                                   2093 ;------------------------------------
                                   2094 ; expect a number from command line 
                                   2095 ; next argument
                                   2096 ;  input:
                                   2097 ;	  none
                                   2098 ;  output:
                                   2099 ;    acc24   int24_t 
                                   2100 ;------------------------------------
                                   2101 number::
                                   2102 	call get_token
                                   2103 	call atoi24
                                   2104 	ret
                                   2105 .endif ; DEBUG 
                                   2106 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2107 
                                   2108 
                                   2109 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2110 ;; compiler routines        ;;
                                   2111 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2112 ;------------------------------------
                                   2113 ; parse quoted string 
                                   2114 ; input:
                                   2115 ;   Y 	pointer to tib 
                                   2116 ;   X   pointer to pad
                                   2117 ; output:
                                   2118 ;	pad   parsed string
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 41.
Hexadecimal [24-Bits]



                                   2119 ;   TOS  char* to pad  
                                   2120 ;------------------------------------
                           000001  2121 	PREV = 1
                           000002  2122 	CURR =2 
                           000002  2123 	VSIZE=2 
      0009C4                       2124 parse_quote: ; { -- addr }
      0009C4                       2125 	_vars VSIZE 
      0009C4 52 02            [ 2]    1     sub sp,#VSIZE 
      0009C6 4F               [ 1] 2126 	clr a
      0009C7 6B 01            [ 1] 2127 1$:	ld (PREV,sp),a 
      0009C9 72 5C 00 01      [ 1] 2128 2$:	inc in
      0009CD 91 D6 00         [ 4] 2129 	ld a,([in.w],y)
      0009D0 27 24            [ 1] 2130 	jreq 6$
      0009D2 6B 02            [ 1] 2131 	ld (CURR,sp),a 
      0009D4 A6 5C            [ 1] 2132 	ld a,#'\
      0009D6 11 01            [ 1] 2133 	cp a, (PREV,sp)
      0009D8 26 0A            [ 1] 2134 	jrne 3$
      0009DA 0F 01            [ 1] 2135 	clr (PREV,sp)
      0009DC 7B 02            [ 1] 2136 	ld a,(CURR,sp)
      0009DE AD 1F            [ 4] 2137 	callr convert_escape
      0009E0 F7               [ 1] 2138 	ld (x),a 
      0009E1 5C               [ 2] 2139 	incw x 
      0009E2 20 E5            [ 2] 2140 	jra 2$
      0009E4                       2141 3$:
      0009E4 7B 02            [ 1] 2142 	ld a,(CURR,sp)
      0009E6 A1 5C            [ 1] 2143 	cp a,#'\'
      0009E8 27 DD            [ 1] 2144 	jreq 1$
      0009EA A1 22            [ 1] 2145 	cp a,#'"
      0009EC 27 04            [ 1] 2146 	jreq 5$ 
      0009EE F7               [ 1] 2147 	ld (x),a 
      0009EF 5C               [ 2] 2148 	incw x 
      0009F0 20 D7            [ 2] 2149 	jra 2$
      0009F2 72 5C 00 01      [ 1] 2150 5$:	inc in 
      0009F6 7F               [ 1] 2151 6$: clr (x)
      0009F7 AE 17 38         [ 2] 2152 	ldw x,#pad 
      0009FA                       2153 	_drop VSIZE
      0009FA 5B 02            [ 2]    1     addw sp,#VSIZE 
      0009FC A6 0A            [ 1] 2154 	ld a,#TK_QSTR  
      0009FE 81               [ 4] 2155 	ret 
                                   2156 
                                   2157 ;---------------------------------------
                                   2158 ; called by parse_quote
                                   2159 ; subtitute escaped character 
                                   2160 ; by their ASCII value .
                                   2161 ; input:
                                   2162 ;   A  character following '\'
                                   2163 ; output:
                                   2164 ;   A  substitued char or same if not valid.
                                   2165 ;---------------------------------------
      0009FF                       2166 convert_escape:
      0009FF 89               [ 2] 2167 	pushw x 
      000A00 AE 0A 14         [ 2] 2168 	ldw x,#escaped 
      000A03 F1               [ 1] 2169 1$:	cp a,(x)
      000A04 27 06            [ 1] 2170 	jreq 2$
      000A06 7D               [ 1] 2171 	tnz (x)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 42.
Hexadecimal [24-Bits]



      000A07 27 09            [ 1] 2172 	jreq 3$
      000A09 5C               [ 2] 2173 	incw x 
      000A0A 20 F7            [ 2] 2174 	jra 1$
      000A0C 1D 0A 14         [ 2] 2175 2$: subw x,#escaped 
      000A0F 9F               [ 1] 2176 	ld a,xl 
      000A10 AB 07            [ 1] 2177 	add a,#7
      000A12 85               [ 2] 2178 3$:	popw x 
      000A13 81               [ 4] 2179 	ret 
                                   2180 
      000A14 61 62 74 6E 76 66 72  2181 escaped: .asciz "abtnvfr"
             00
                                   2182 
                                   2183 ;-------------------------
                                   2184 ; integer parser 
                                   2185 ; input:
                                   2186 ;   X 		point to pad 
                                   2187 ;   Y 		point to tib 
                                   2188 ;   A 	    first digit|'$' 
                                   2189 ; output:  
                                   2190 ;   pad     number string 
                                   2191 ;   X 		integer 
                                   2192 ;   A 		TK_INTGR
                                   2193 ;-------------------------
                           000001  2194 	BASE=1
                           000002  2195 	TCHAR=2 
                           000002  2196 	VSIZE=2 
      000A1C                       2197 parse_integer: ; { -- n }
      000A1C 4B 00            [ 1] 2198 	push #0 ; TCHAR 
      000A1E A1 24            [ 1] 2199 	cp a,#'$
      000A20 27 04            [ 1] 2200 	jreq 1$ 
      000A22 4B 0A            [ 1] 2201 	push #10 ; BASE=10 
      000A24 20 02            [ 2] 2202 	jra 2$ 
      000A26 4B 10            [ 1] 2203 1$: push #16  ; BASE=16
      000A28 F7               [ 1] 2204 2$:	ld (x),a 
      000A29 5C               [ 2] 2205 	incw x 
      000A2A 72 5C 00 01      [ 1] 2206 	inc in 
      000A2E 91 D6 00         [ 4] 2207 	ld a,([in.w],y)
      000A31 CD 0C 7A         [ 4] 2208 	call to_upper 
      000A34 6B 02            [ 1] 2209 	ld (TCHAR,sp),a 
      000A36 CD 0C 71         [ 4] 2210 	call is_digit 
      000A39 25 ED            [ 1] 2211 	jrc 2$
      000A3B A6 10            [ 1] 2212 	ld a,#16 
      000A3D 11 01            [ 1] 2213 	cp a,(BASE,sp)
      000A3F 26 0A            [ 1] 2214 	jrne 3$ 
      000A41 7B 02            [ 1] 2215 	ld a,(TCHAR,sp)
      000A43 A1 41            [ 1] 2216 	cp a,#'A 
      000A45 2B 04            [ 1] 2217 	jrmi 3$ 
      000A47 A1 47            [ 1] 2218 	cp a,#'G 
      000A49 2B DD            [ 1] 2219 	jrmi 2$ 
      000A4B 7F               [ 1] 2220 3$:	clr (x)
      000A4C CD 0C 86         [ 4] 2221 	call atoi24
      000A4F CE 00 0C         [ 2] 2222 	ldw x,acc16 
      000A52 A6 04            [ 1] 2223 	ld a,#TK_INTGR
      000A54                       2224 	_drop VSIZE  
      000A54 5B 02            [ 2]    1     addw sp,#VSIZE 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 43.
Hexadecimal [24-Bits]



      000A56 81               [ 4] 2225 	ret 	
                                   2226 
                                   2227 ;-------------------------
                                   2228 ; binary integer parser 
                                   2229 ; input:
                                   2230 ;   X 		point to pad 
                                   2231 ;   Y 		point to tib 
                                   2232 ;   A 	    '%' 
                                   2233 ; output:  
                                   2234 ;   pad     number string 
                                   2235 ;   X 		integer 
                                   2236 ;   A 		TK_INTGR
                                   2237 ;   TOS     integer 
                                   2238 ;-------------------------
                           000001  2239 	BINARY=1
                           000002  2240 	VSIZE=2
      000A57                       2241 parse_binary: ; { -- n }
      000A57 4B 00            [ 1] 2242 	push #0
      000A59 4B 00            [ 1] 2243 	push #0
      000A5B F7               [ 1] 2244 1$: ld (x),a 
      000A5C 5C               [ 2] 2245 	incw x 
      000A5D 72 5C 00 01      [ 1] 2246 	inc in 
      000A61 91 D6 00         [ 4] 2247 	ld a,([in.w],y)
      000A64 A1 30            [ 1] 2248 	cp a,#'0 
      000A66 27 06            [ 1] 2249 	jreq 2$
      000A68 A1 31            [ 1] 2250 	cp a,#'1 
      000A6A 27 02            [ 1] 2251 	jreq 2$ 
      000A6C 20 09            [ 2] 2252 	jra bin_exit 
      000A6E A0 30            [ 1] 2253 2$: sub a,#'0	
      000A70 46               [ 1] 2254 	rrc a 
      000A71 09 02            [ 1] 2255 	rlc (BINARY+1,sp)
      000A73 09 01            [ 1] 2256 	rlc (BINARY,sp)
      000A75 20 E4            [ 2] 2257 	jra 1$  
      000A77                       2258 bin_exit:
      000A77 7F               [ 1] 2259 	clr (x)
      000A78 1E 01            [ 2] 2260 	ldw x,(BINARY,sp)
      000A7A A6 04            [ 1] 2261 	ld a,#TK_INTGR 	
      000A7C                       2262 	_drop VSIZE 
      000A7C 5B 02            [ 2]    1     addw sp,#VSIZE 
      000A7E 81               [ 4] 2263 	ret
                                   2264 
                                   2265 ;---------------------------
                                   2266 ;  token begin with a letter,
                                   2267 ;  is keyword or variable. 	
                                   2268 ; input:
                                   2269 ;   X 		point to pad 
                                   2270 ;   Y 		point to text
                                   2271 ;   A 	    first letter  
                                   2272 ; output:
                                   2273 ;   X		exec_addr|var_addr 
                                   2274 ;   A 		TK_CMD 
                                   2275 ;   pad 	keyword|var_name  
                                   2276 ;   TOS     exec_addr|var_addr 
                                   2277 ;--------------------------  
      000A7F                       2278 parse_keyword: ; { -- exec_addr|var_addr}
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 44.
Hexadecimal [24-Bits]



      000A7F CD 0C 7A         [ 4] 2279 	call to_upper 
      000A82 F7               [ 1] 2280 	ld (x),a 
      000A83 5C               [ 2] 2281 	incw x 
      000A84 72 5C 00 01      [ 1] 2282 	inc in 
      000A88 91 D6 00         [ 4] 2283 	ld a,([in.w],y)
      000A8B CD 04 7D         [ 4] 2284 	call is_alpha 
      000A8E 25 EF            [ 1] 2285 	jrc parse_keyword 
      000A90 7F               [ 1] 2286 1$: clr (x)
      000A91 72 5D 17 39      [ 1] 2287 	tnz pad+1 
      000A95 26 15            [ 1] 2288 	jrne 2$
                                   2289 ; one letter variable name 
      000A97 C6 17 38         [ 1] 2290 	ld a,pad 
      000A9A A0 41            [ 1] 2291 	sub a,#'A 
      000A9C 48               [ 1] 2292 	sll a 
      000A9D 88               [ 1] 2293 	push a 
      000A9E 4B 00            [ 1] 2294 	push #0
      000AA0 AE 00 28         [ 2] 2295 	ldw x,#vars 
      000AA3 72 FB 01         [ 2] 2296 	addw x,(1,sp) ; X=var address 
      000AA6                       2297 	_drop 2 
      000AA6 5B 02            [ 2]    1     addw sp,#2 
      000AA8 A6 05            [ 1] 2298 	ld a,#TK_VAR 
      000AAA 20 0C            [ 2] 2299 	jra 4$ 
      000AAC                       2300 2$: ; check for keyword, otherwise syntax error.
      000AAC                       2301 	_ldx_dict kword_dict
      000AAC AE 24 90         [ 2]    1     ldw x,#kword_dict+2
      000AAF CD 0E 22         [ 4] 2302 	call search_dict
      000AB2 4D               [ 1] 2303 	tnz a
      000AB3 26 03            [ 1] 2304 	jrne 4$ 
      000AB5 CC 07 01         [ 2] 2305 	jp syntax_error
      000AB8 81               [ 4] 2306 4$:	ret  	
                                   2307 
                                   2308 
                                   2309 ;------------------------------------
                                   2310 ; scan text for next token
                                   2311 ; move token in 'pad'
                                   2312 ; input: 
      000AB9                       2313 	none: 
                                   2314 ; use:
                                   2315 ;	Y   pointer to text
                                   2316 ;   X	pointer to pad 
                                   2317 ;   in.w   index in text buffer
                                   2318 ; output:
                                   2319 ;   A       token attribute 
                                   2320 ;   pad 	token as .asciz
                                   2321 ;   X 		token value   
                                   2322 ;------------------------------------
                                   2323 	; use to check special character 
                                   2324 	.macro _case c t  
                                   2325 	ld a,#c 
                                   2326 	cp a,(TCHAR,sp) 
                                   2327 	jrne t
                                   2328 	.endm 
                                   2329 
                           000001  2330 	TCHAR=1
                           000002  2331 	ATTRIB=2 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 45.
Hexadecimal [24-Bits]



                           000002  2332 	VSIZE=2
      000AB9                       2333 get_token: 
      000AB9 90 AE 16 E8      [ 2] 2334 	ldw y,#tib    	
      000ABD C6 00 01         [ 1] 2335 	ld a,in 
      000AC0 C1 00 03         [ 1] 2336 	cp a,count 
      000AC3 2B 03            [ 1] 2337 	jrmi 1$
      000AC5 A6 00            [ 1] 2338 	ld a,#TK_NONE 
      000AC7 81               [ 4] 2339 	ret 
      000AC8                       2340 1$:	
      000AC8                       2341 	_vars VSIZE
      000AC8 52 02            [ 2]    1     sub sp,#VSIZE 
      000ACA AE 17 38         [ 2] 2342 	ldw x, #pad
      000ACD A6 20            [ 1] 2343 	ld a,#SPACE
      000ACF CD 0D 32         [ 4] 2344 	call skip
      000AD2 55 00 01 00 02   [ 1] 2345 	mov in.saved,in 
      000AD7 91 D6 00         [ 4] 2346 	ld a,([in.w],y)
      000ADA 26 07            [ 1] 2347 	jrne str_tst
      000ADC 72 5F 17 38      [ 1] 2348 	clr pad 
      000AE0 CC 0C 6E         [ 2] 2349 	jp token_exit ; end of line 
                                   2350 
      000AE3                       2351 str_tst: ; check for quoted string  	
      000AE3 CD 0C 7A         [ 4] 2352 	call to_upper 
      000AE6 6B 01            [ 1] 2353 	ld (TCHAR,sp),a 
      000AE8                       2354 	_case '"' nbr_tst
      000AE8 A6 22            [ 1]    1 	ld a,#'"' 
      000AEA 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000AEC 26 06            [ 1]    3 	jrne nbr_tst
      000AEE CD 09 C4         [ 4] 2355 	call parse_quote
      000AF1 CC 0C 6E         [ 2] 2356 	jp token_exit
      000AF4                       2357 nbr_tst: ; check for number 
      000AF4 A6 24            [ 1] 2358 	ld a,#'$'
      000AF6 11 01            [ 1] 2359 	cp a,(TCHAR,sp) 
      000AF8 27 13            [ 1] 2360 	jreq 1$
      000AFA A6 26            [ 1] 2361 	ld a,#'&
      000AFC 11 01            [ 1] 2362 	cp a,(TCHAR,sp)
      000AFE 26 06            [ 1] 2363 	jrne 0$
      000B00 CD 0A 57         [ 4] 2364 	call parse_binary ; expect binary integer 
      000B03 CC 0C 6E         [ 2] 2365 	jp token_exit 
      000B06 7B 01            [ 1] 2366 0$:	ld a,(TCHAR,sp)
      000B08 CD 0C 71         [ 4] 2367 	call is_digit
      000B0B 24 06            [ 1] 2368 	jrnc 3$
      000B0D CD 0A 1C         [ 4] 2369 1$:	call parse_integer 
      000B10 CC 0C 6E         [ 2] 2370 	jp token_exit 
      000B13                       2371 3$: 
      000B13                       2372 	_case '(' bkslsh_tst 
      000B13 A6 28            [ 1]    1 	ld a,#'(' 
      000B15 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B17 26 05            [ 1]    3 	jrne bkslsh_tst
      000B19 A6 0B            [ 1] 2373 	ld a,#TK_LPAREN
      000B1B CC 0C 5E         [ 2] 2374 	jp token_char   	
      000B1E                       2375 bkslsh_tst: ; character token 
      000B1E                       2376 	_case '\',rparnt_tst
      000B1E A6 5C            [ 1]    1 	ld a,#'\' 
      000B20 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B22 26 18            [ 1]    3 	jrne rparnt_tst
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 46.
Hexadecimal [24-Bits]



      000B24 7B 01            [ 1] 2377 	ld a,(TCHAR,sp)
      000B26 F7               [ 1] 2378 	ld (x),a 
      000B27 5C               [ 2] 2379 	incw x 
      000B28 72 5C 00 01      [ 1] 2380 	inc in 
      000B2C 91 D6 00         [ 4] 2381 	ld a,([in.w],y)
      000B2F F7               [ 1] 2382 	ld (x),a 
      000B30 5C               [ 2] 2383 	incw x 
      000B31 72 5C 00 01      [ 1] 2384 	inc in  
      000B35 7F               [ 1] 2385 	clr (x) 
      000B36 97               [ 1] 2386 	ld xl,a 
      000B37 A6 03            [ 1] 2387 	ld a,#TK_CHAR 
      000B39 CC 0C 6E         [ 2] 2388 	jp token_exit 
      000B3C                       2389 rparnt_tst:		
      000B3C                       2390 	_case ')' colon_tst 
      000B3C A6 29            [ 1]    1 	ld a,#')' 
      000B3E 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B40 26 05            [ 1]    3 	jrne colon_tst
      000B42 A6 0C            [ 1] 2391 	ld a,#TK_RPAREN 
      000B44 CC 0C 5E         [ 2] 2392 	jp token_char 
      000B47                       2393 colon_tst:
      000B47                       2394 	_case ':' comma_tst 
      000B47 A6 3A            [ 1]    1 	ld a,#':' 
      000B49 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B4B 26 05            [ 1]    3 	jrne comma_tst
      000B4D A6 01            [ 1] 2395 	ld a,#TK_COLON 
      000B4F CC 0C 5E         [ 2] 2396 	jp token_char 
      000B52                       2397 comma_tst:
      000B52                       2398 	_case COMMA sharp_tst 
      000B52 A6 2C            [ 1]    1 	ld a,#COMMA 
      000B54 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B56 26 05            [ 1]    3 	jrne sharp_tst
      000B58 A6 0D            [ 1] 2399 	ld a,#TK_COMMA
      000B5A CC 0C 5E         [ 2] 2400 	jp token_char
      000B5D                       2401 sharp_tst:
      000B5D                       2402 	_case SHARP dash_tst 
      000B5D A6 23            [ 1]    1 	ld a,#SHARP 
      000B5F 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B61 26 05            [ 1]    3 	jrne dash_tst
      000B63 A6 0E            [ 1] 2403 	ld a,#TK_SHARP
      000B65 CC 0C 5E         [ 2] 2404 	jp token_char  	 	 
      000B68                       2405 dash_tst: 	
      000B68                       2406 	_case '-' at_tst 
      000B68 A6 2D            [ 1]    1 	ld a,#'-' 
      000B6A 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B6C 26 05            [ 1]    3 	jrne at_tst
      000B6E A6 11            [ 1] 2407 	ld a,#TK_MINUS  
      000B70 CC 0C 5E         [ 2] 2408 	jp token_char 
      000B73                       2409 at_tst:
      000B73                       2410 	_case '@' qmark_tst 
      000B73 A6 40            [ 1]    1 	ld a,#'@' 
      000B75 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B77 26 05            [ 1]    3 	jrne qmark_tst
      000B79 A6 02            [ 1] 2411 	ld a,#TK_ARRAY 
      000B7B CC 0C 5E         [ 2] 2412 	jp token_char
      000B7E                       2413 qmark_tst:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 47.
Hexadecimal [24-Bits]



      000B7E                       2414 	_case '?' tick_tst 
      000B7E A6 3F            [ 1]    1 	ld a,#'?' 
      000B80 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B82 26 11            [ 1]    3 	jrne tick_tst
      000B84 7B 01            [ 1] 2415 	ld a,(TCHAR,sp)
      000B86 F7               [ 1] 2416 	ld (x),a 
      000B87 5C               [ 2] 2417 	incw x 
      000B88 7F               [ 1] 2418 	clr (x)
      000B89 72 5C 00 01      [ 1] 2419 	inc in 
      000B8D A6 06            [ 1] 2420 	ld a,#TK_CMD 
      000B8F AE 13 58         [ 2] 2421 	ldw x,#print 
      000B92 CC 0C 6E         [ 2] 2422 	jp token_exit
      000B95                       2423 tick_tst: ; ignore comment 
      000B95                       2424 	_case TICK plus_tst 
      000B95 A6 27            [ 1]    1 	ld a,#TICK 
      000B97 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B99 26 0C            [ 1]    3 	jrne plus_tst
      000B9B 72 5C 00 01      [ 1] 2425 	inc in 
      000B9F A6 06            [ 1] 2426 	ld a,#TK_CMD 
      000BA1 AE 14 46         [ 2] 2427 	ldw x,#rem 
      000BA4 CC 0C 6E         [ 2] 2428 	jp token_exit 
      000BA7                       2429 plus_tst:
      000BA7                       2430 	_case '+' star_tst 
      000BA7 A6 2B            [ 1]    1 	ld a,#'+' 
      000BA9 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000BAB 26 05            [ 1]    3 	jrne star_tst
      000BAD A6 10            [ 1] 2431 	ld a,#TK_PLUS  
      000BAF CC 0C 5E         [ 2] 2432 	jp token_char 
      000BB2                       2433 star_tst:
      000BB2                       2434 	_case '*' slash_tst 
      000BB2 A6 2A            [ 1]    1 	ld a,#'*' 
      000BB4 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000BB6 26 05            [ 1]    3 	jrne slash_tst
      000BB8 A6 20            [ 1] 2435 	ld a,#TK_MULT 
      000BBA CC 0C 5E         [ 2] 2436 	jp token_char 
      000BBD                       2437 slash_tst: 
      000BBD                       2438 	_case '/' prcnt_tst 
      000BBD A6 2F            [ 1]    1 	ld a,#'/' 
      000BBF 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000BC1 26 05            [ 1]    3 	jrne prcnt_tst
      000BC3 A6 21            [ 1] 2439 	ld a,#TK_DIV 
      000BC5 CC 0C 5E         [ 2] 2440 	jp token_char 
      000BC8                       2441 prcnt_tst:
      000BC8                       2442 	_case '%' eql_tst 
      000BC8 A6 25            [ 1]    1 	ld a,#'%' 
      000BCA 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000BCC 26 05            [ 1]    3 	jrne eql_tst
      000BCE A6 22            [ 1] 2443 	ld a,#TK_MOD
      000BD0 CC 0C 5E         [ 2] 2444 	jp token_char  
                                   2445 ; 1 or 2 character tokens 	
      000BD3                       2446 eql_tst:
      000BD3                       2447 	_case '=' gt_tst 		
      000BD3 A6 3D            [ 1]    1 	ld a,#'=' 
      000BD5 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000BD7 26 05            [ 1]    3 	jrne gt_tst
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 48.
Hexadecimal [24-Bits]



      000BD9 A6 32            [ 1] 2448 	ld a,#TK_EQUAL
      000BDB CC 0C 5E         [ 2] 2449 	jp token_char 
      000BDE                       2450 gt_tst:
      000BDE                       2451 	_case '>' lt_tst 
      000BDE A6 3E            [ 1]    1 	ld a,#'>' 
      000BE0 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000BE2 26 33            [ 1]    3 	jrne lt_tst
      000BE4 A6 31            [ 1] 2452 	ld a,#TK_GT 
      000BE6 6B 02            [ 1] 2453 	ld (ATTRIB,sp),a 
      000BE8 72 5C 00 01      [ 1] 2454 	inc in 
      000BEC 91 D6 00         [ 4] 2455 	ld a,([in.w],y)
      000BEF A1 3D            [ 1] 2456 	cp a,#'=
      000BF1 26 0C            [ 1] 2457 	jrne 1$
      000BF3 7B 01            [ 1] 2458 	ld a,(TCHAR,sp)
      000BF5 F7               [ 1] 2459 	ld (x),a
      000BF6 5C               [ 2] 2460 	incw x 
      000BF7 A6 3D            [ 1] 2461 	ld a,#'=
      000BF9 6B 01            [ 1] 2462 	ld (TCHAR,sp),a 
      000BFB A6 33            [ 1] 2463 	ld a,#TK_GE 
      000BFD 20 5F            [ 2] 2464 	jra token_char  
      000BFF A1 3C            [ 1] 2465 1$: cp a,#'<
      000C01 26 0C            [ 1] 2466 	jrne 2$
      000C03 7B 01            [ 1] 2467 	ld a,(TCHAR,sp)
      000C05 F7               [ 1] 2468 	ld (x),a
      000C06 5C               [ 2] 2469 	incw x 
      000C07 A6 3C            [ 1] 2470 	ld a,#'<	
      000C09 6B 01            [ 1] 2471 	ld (TCHAR,sp),a 
      000C0B A6 35            [ 1] 2472 	ld a,#TK_NE 
      000C0D 20 4F            [ 2] 2473 	jra token_char 
      000C0F 72 5A 00 01      [ 1] 2474 2$: dec in
      000C13 7B 02            [ 1] 2475 	ld a,(ATTRIB,sp)
      000C15 20 47            [ 2] 2476 	jra token_char 
      000C17                       2477 lt_tst:
      000C17                       2478 	_case '<' other
      000C17 A6 3C            [ 1]    1 	ld a,#'<' 
      000C19 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000C1B 26 32            [ 1]    3 	jrne other
      000C1D A6 34            [ 1] 2479 	ld a,#TK_LT 
      000C1F 6B 02            [ 1] 2480 	ld (ATTRIB,sp),a 
      000C21 72 5C 00 01      [ 1] 2481 	inc in 
      000C25 91 D6 00         [ 4] 2482 	ld a,([in.w],y)
      000C28 A1 3D            [ 1] 2483 	cp a,#'=
      000C2A 26 0B            [ 1] 2484 	jrne 1$
      000C2C 7B 01            [ 1] 2485 	ld a,(TCHAR,sp)
      000C2E F7               [ 1] 2486 	ld (x),a 
      000C2F A6 3D            [ 1] 2487 	ld a,#'=
      000C31 6B 01            [ 1] 2488 	ld (TCHAR,sp),a 
      000C33 A6 36            [ 1] 2489 	ld a,#TK_LE 
      000C35 20 27            [ 2] 2490 	jra token_char 
      000C37 A1 3E            [ 1] 2491 1$: cp a,#'>
      000C39 26 0C            [ 1] 2492 	jrne 2$
      000C3B 7B 01            [ 1] 2493 	ld a,(TCHAR,sp)
      000C3D F7               [ 1] 2494 	ld (x),a 
      000C3E 5C               [ 2] 2495 	incw x 
      000C3F A6 3E            [ 1] 2496 	ld a,#'>
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 49.
Hexadecimal [24-Bits]



      000C41 6B 01            [ 1] 2497 	ld (TCHAR,sp),a 
      000C43 A6 35            [ 1] 2498 	ld a,#TK_NE 
      000C45 20 17            [ 2] 2499 	jra token_char 
      000C47 72 5A 00 01      [ 1] 2500 2$: dec in 
      000C4B 7B 02            [ 1] 2501 	ld a,(ATTRIB,sp)
      000C4D 20 0F            [ 2] 2502 	jra token_char 	
      000C4F                       2503 other: ; not a special character 	 
      000C4F 7B 01            [ 1] 2504 	ld a,(TCHAR,sp)
      000C51 CD 04 7D         [ 4] 2505 	call is_alpha 
      000C54 25 03            [ 1] 2506 	jrc 30$ 
      000C56 CC 07 01         [ 2] 2507 	jp syntax_error 
      000C59                       2508 30$: 
      000C59 CD 0A 7F         [ 4] 2509 	call parse_keyword
      000C5C 20 10            [ 2] 2510 	jra token_exit 
      000C5E                       2511 token_char:
      000C5E 6B 02            [ 1] 2512 	ld (ATTRIB,sp),a 
      000C60 7B 01            [ 1] 2513 	ld a,(TCHAR,sp)
      000C62 F7               [ 1] 2514 	ld (x),a 
      000C63 5C               [ 2] 2515 	incw x 
      000C64 7F               [ 1] 2516 	clr(x)
      000C65 72 5C 00 01      [ 1] 2517 	inc in 
      000C69 7B 02            [ 1] 2518 	ld a,(ATTRIB,sp)
      000C6B AE 17 38         [ 2] 2519 	ldw x,#pad 
      000C6E                       2520 token_exit:
      000C6E                       2521 	_drop VSIZE 
      000C6E 5B 02            [ 2]    1     addw sp,#VSIZE 
      000C70 81               [ 4] 2522 	ret
                                   2523 
                                   2524 ;------------------------------------
                                   2525 ; check if character in {'0'..'9'}
                                   2526 ; input:
                                   2527 ;    A  character to test
                                   2528 ; output:
                                   2529 ;    Carry  0 not digit | 1 digit
                                   2530 ;------------------------------------
      000C71                       2531 is_digit:
      000C71 A1 30            [ 1] 2532 	cp a,#'0
      000C73 25 03            [ 1] 2533 	jrc 1$
      000C75 A1 3A            [ 1] 2534     cp a,#'9+1
      000C77 8C               [ 1] 2535 	ccf 
      000C78 8C               [ 1] 2536 1$:	ccf 
      000C79 81               [ 4] 2537     ret
                                   2538 
                                   2539 ;------------------------------------
                                   2540 ; convert alpha to uppercase
                                   2541 ; input:
                                   2542 ;    a  character to convert
                                   2543 ; output:
                                   2544 ;    a  uppercase character
                                   2545 ;------------------------------------
      000C7A                       2546 to_upper::
      000C7A A1 61            [ 1] 2547 	cp a,#'a
      000C7C 2A 01            [ 1] 2548 	jrpl 1$
      000C7E 81               [ 4] 2549 0$:	ret
      000C7F A1 7A            [ 1] 2550 1$: cp a,#'z	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 50.
Hexadecimal [24-Bits]



      000C81 22 FB            [ 1] 2551 	jrugt 0$
      000C83 A0 20            [ 1] 2552 	sub a,#32
      000C85 81               [ 4] 2553 	ret
                                   2554 	
                                   2555 ;------------------------------------
                                   2556 ; convert pad content in integer
                                   2557 ; input:
                                   2558 ;    pad		.asciz to convert
                                   2559 ; output:
                                   2560 ;    acc24      int24_t
                                   2561 ;------------------------------------
                                   2562 	; local variables
                           000001  2563 	SIGN=1 ; 1 byte, 
                           000002  2564 	BASE=2 ; 1 byte, numeric base used in conversion
                           000003  2565 	TEMP=3 ; 1 byte, temporary storage
                           000003  2566 	VSIZE=3 ; 3 bytes reserved for local storage
      000C86                       2567 atoi24:
      000C86 89               [ 2] 2568 	pushw x ;save x
      000C87 52 03            [ 2] 2569 	sub sp,#VSIZE
                                   2570 	; acc24=0 
      000C89 72 5F 00 0B      [ 1] 2571 	clr acc24    
      000C8D 72 5F 00 0C      [ 1] 2572 	clr acc16
      000C91 72 5F 00 0D      [ 1] 2573 	clr acc8 
      000C95 C6 17 38         [ 1] 2574 	ld a, pad 
      000C98 27 5A            [ 1] 2575 	jreq atoi_exit
      000C9A 0F 01            [ 1] 2576 	clr (SIGN,sp)
      000C9C A6 0A            [ 1] 2577 	ld a,#10
      000C9E 6B 02            [ 1] 2578 	ld (BASE,sp),a ; default base decimal
      000CA0 AE 17 38         [ 2] 2579 	ldw x,#pad ; pointer to string to convert
      000CA3 F6               [ 1] 2580 	ld a,(x)
      000CA4 27 47            [ 1] 2581 	jreq 9$  ; completed if 0
      000CA6 A1 2D            [ 1] 2582 	cp a,#'-
      000CA8 26 04            [ 1] 2583 	jrne 1$
      000CAA 03 01            [ 1] 2584 	cpl (SIGN,sp)
      000CAC 20 08            [ 2] 2585 	jra 2$
      000CAE A1 24            [ 1] 2586 1$: cp a,#'$
      000CB0 26 06            [ 1] 2587 	jrne 3$
      000CB2 A6 10            [ 1] 2588 	ld a,#16
      000CB4 6B 02            [ 1] 2589 	ld (BASE,sp),a
      000CB6 5C               [ 2] 2590 2$:	incw x
      000CB7 F6               [ 1] 2591 	ld a,(x)
      000CB8                       2592 3$:	
      000CB8 A1 61            [ 1] 2593 	cp a,#'a
      000CBA 2B 02            [ 1] 2594 	jrmi 4$
      000CBC A0 20            [ 1] 2595 	sub a,#32
      000CBE A1 30            [ 1] 2596 4$:	cp a,#'0
      000CC0 2B 2B            [ 1] 2597 	jrmi 9$
      000CC2 A0 30            [ 1] 2598 	sub a,#'0
      000CC4 A1 0A            [ 1] 2599 	cp a,#10
      000CC6 2B 06            [ 1] 2600 	jrmi 5$
      000CC8 A0 07            [ 1] 2601 	sub a,#7
      000CCA 11 02            [ 1] 2602 	cp a,(BASE,sp)
      000CCC 2A 1F            [ 1] 2603 	jrpl 9$
      000CCE 6B 03            [ 1] 2604 5$:	ld (TEMP,sp),a
      000CD0 7B 02            [ 1] 2605 	ld a,(BASE,sp)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 51.
Hexadecimal [24-Bits]



      000CD2 CD 0C F8         [ 4] 2606 	call mulu24_8
      000CD5 7B 03            [ 1] 2607 	ld a,(TEMP,sp)
      000CD7 CB 00 0D         [ 1] 2608 	add a,acc24+2
      000CDA C7 00 0D         [ 1] 2609 	ld acc24+2,a
      000CDD 4F               [ 1] 2610 	clr a
      000CDE C9 00 0C         [ 1] 2611 	adc a,acc24+1
      000CE1 C7 00 0C         [ 1] 2612 	ld acc24+1,a
      000CE4 4F               [ 1] 2613 	clr a
      000CE5 C9 00 0B         [ 1] 2614 	adc a,acc24
      000CE8 C7 00 0B         [ 1] 2615 	ld acc24,a
      000CEB 20 C9            [ 2] 2616 	jra 2$
      000CED 0D 01            [ 1] 2617 9$:	tnz (SIGN,sp)
      000CEF 27 03            [ 1] 2618     jreq atoi_exit
      000CF1 CD 09 17         [ 4] 2619     call neg_acc24
      000CF4                       2620 atoi_exit: 
      000CF4 5B 03            [ 2] 2621 	addw sp,#VSIZE
      000CF6 85               [ 2] 2622 	popw x ; restore x
      000CF7 81               [ 4] 2623 	ret
                                   2624 
                                   2625 ;--------------------------------------
                                   2626 ; unsigned multiply uint24_t by uint8_t
                                   2627 ; use to convert numerical string to uint24_t
                                   2628 ; input:
                                   2629 ;	acc24	uint24_t 
                                   2630 ;   A		uint8_t
                                   2631 ; output:
                                   2632 ;   acc24   A*acc24
                                   2633 ;-------------------------------------
                                   2634 ; local variables offset  on sp
                           000003  2635 	U8   = 3   ; A pushed on stack
                           000002  2636 	OVFL = 2  ; multiplicaton overflow low byte
                           000001  2637 	OVFH = 1  ; multiplication overflow high byte
                           000003  2638 	VSIZE = 3
      000CF8                       2639 mulu24_8:
      000CF8 89               [ 2] 2640 	pushw x    ; save X
                                   2641 	; local variables
      000CF9 88               [ 1] 2642 	push a     ; U8
      000CFA 5F               [ 1] 2643 	clrw x     ; initialize overflow to 0
      000CFB 89               [ 2] 2644 	pushw x    ; multiplication overflow
                                   2645 ; multiply low byte.
      000CFC C6 00 0D         [ 1] 2646 	ld a,acc24+2
      000CFF 97               [ 1] 2647 	ld xl,a
      000D00 7B 03            [ 1] 2648 	ld a,(U8,sp)
      000D02 42               [ 4] 2649 	mul x,a
      000D03 9F               [ 1] 2650 	ld a,xl
      000D04 C7 00 0D         [ 1] 2651 	ld acc24+2,a
      000D07 9E               [ 1] 2652 	ld a, xh
      000D08 6B 02            [ 1] 2653 	ld (OVFL,sp),a
                                   2654 ; multipy middle byte
      000D0A C6 00 0C         [ 1] 2655 	ld a,acc24+1
      000D0D 97               [ 1] 2656 	ld xl,a
      000D0E 7B 03            [ 1] 2657 	ld a, (U8,sp)
      000D10 42               [ 4] 2658 	mul x,a
                                   2659 ; add overflow to this partial product
      000D11 72 FB 01         [ 2] 2660 	addw x,(OVFH,sp)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 52.
Hexadecimal [24-Bits]



      000D14 9F               [ 1] 2661 	ld a,xl
      000D15 C7 00 0C         [ 1] 2662 	ld acc24+1,a
      000D18 4F               [ 1] 2663 	clr a
      000D19 A9 00            [ 1] 2664 	adc a,#0
      000D1B 6B 01            [ 1] 2665 	ld (OVFH,sp),a
      000D1D 9E               [ 1] 2666 	ld a,xh
      000D1E 6B 02            [ 1] 2667 	ld (OVFL,sp),a
                                   2668 ; multiply most signficant byte	
      000D20 C6 00 0B         [ 1] 2669 	ld a, acc24
      000D23 97               [ 1] 2670 	ld xl, a
      000D24 7B 03            [ 1] 2671 	ld a, (U8,sp)
      000D26 42               [ 4] 2672 	mul x,a
      000D27 72 FB 01         [ 2] 2673 	addw x, (OVFH,sp)
      000D2A 9F               [ 1] 2674 	ld a, xl
      000D2B C7 00 0B         [ 1] 2675 	ld acc24,a
      000D2E 5B 03            [ 2] 2676     addw sp,#VSIZE
      000D30 85               [ 2] 2677 	popw x
      000D31 81               [ 4] 2678 	ret
                                   2679 
                                   2680 ;------------------------------------
                                   2681 ; skip character c in text starting from 'in'
                                   2682 ; input:
                                   2683 ;	 y 		point to text buffer
                                   2684 ;    a 		character to skip
                                   2685 ; output:  
                                   2686 ;	'in' ajusted to new position
                                   2687 ;------------------------------------
                           000001  2688 	C = 1 ; local var
      000D32                       2689 skip:
      000D32 88               [ 1] 2690 	push a
      000D33 91 D6 00         [ 4] 2691 1$:	ld a,([in.w],y)
      000D36 27 0A            [ 1] 2692 	jreq 2$
      000D38 11 01            [ 1] 2693 	cp a,(C,sp)
      000D3A 26 06            [ 1] 2694 	jrne 2$
      000D3C 72 5C 00 01      [ 1] 2695 	inc in
      000D40 20 F1            [ 2] 2696 	jra 1$
      000D42                       2697 2$: _drop 1 
      000D42 5B 01            [ 2]    1     addw sp,#1 
      000D44 81               [ 4] 2698 	ret
                                   2699 	
                                   2700 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2701 ;;   TINY BASIC  operators,
                                   2702 ;;   commands and functions 
                                   2703 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2704 
                                   2705 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2706 ;;  Arithmetic operators
                                   2707 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2708 
                                   2709 ;--------------------------------
                                   2710 ;  add 2 integers
                                   2711 ;  input:
                                   2712 ;    N1     on cstack 
                                   2713 ;    N2     on cstack 
                                   2714 ;  output:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 53.
Hexadecimal [24-Bits]



                                   2715 ;    X 		n2+n1 
                                   2716 ;--------------------------------
                                   2717 	;arugments on cstack 
      000D45                       2718 	_argofs 0 
                           000002     1     ARG_OFS=2+0 
      000D45                       2719 	_arg N1 1 
                           000003     1     N1=ARG_OFS+1 
      000D45                       2720 	_arg N2 3 
                           000005     1     N2=ARG_OFS+3 
      000D45                       2721 add:
      000D45 1E 05            [ 2] 2722 	ldw x ,(N2,sp)
      000D47 72 FB 03         [ 2] 2723 	addw x,(N1,sp)
      000D4A 1F 03            [ 2] 2724 	ldw (N1,sp),x 
      000D4C 81               [ 4] 2725 	ret 
                                   2726 
                                   2727 ;--------------------------------
                                   2728 ;  substract 2 ntegers
                                   2729 ;  input:
                                   2730 ;    N1     on cstack 
                                   2731 ;    N2     on cstack 
                                   2732 ;  output:
                                   2733 ;    X 		n2+n1 
                                   2734 ;--------------------------------
      000D4D                       2735 	_argofs 0 
                           000002     1     ARG_OFS=2+0 
      000D4D                       2736 	_arg N1 1 
                           000003     1     N1=ARG_OFS+1 
      000D4D                       2737 	_arg N2 3 
                           000005     1     N2=ARG_OFS+3 
      000D4D                       2738 substract:
      000D4D 1E 05            [ 2] 2739 	ldw x,(N2,sp)
      000D4F 72 F0 03         [ 2] 2740 	subw x,(N1,sp)
      000D52 81               [ 4] 2741 	ret 
                                   2742 
                                   2743 ;-------------------------------------
                                   2744 ; multiply 2 integers
                                   2745 ; product overflow is ignored unless
                                   2746 ; MATH_OVF assembler flag is set to 1
                                   2747 ; input:
                                   2748 ;  	N1      on cstack
                                   2749 ;   N2 		on cstack 
                                   2750 ; output:
                                   2751 ;	X        N1*N2 
                                   2752 ;-------------------------------------
                                   2753 	;arguments 
      000D53                       2754 	_argofs 3
                           000005     1     ARG_OFS=2+3 
      000D53                       2755 	_arg N1_HB 1
                           000006     1     N1_HB=ARG_OFS+1 
      000D53                       2756 	_arg N1_LB 2
                           000007     1     N1_LB=ARG_OFS+2 
      000D53                       2757 	_arg N2_HB 3
                           000008     1     N2_HB=ARG_OFS+3 
      000D53                       2758 	_arg N2_LB 4 
                           000009     1     N2_LB=ARG_OFS+4 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 54.
Hexadecimal [24-Bits]



                                   2759    ; local variables 
                           000001  2760 	SIGN=1
                           000002  2761 	PROD=2
                           000003  2762 	VSIZE=3
      000D53                       2763 multiply:
      000D53                       2764 	_vars VSIZE 
      000D53 52 03            [ 2]    1     sub sp,#VSIZE 
      000D55 0F 01            [ 1] 2765 	clr (SIGN,sp)
      000D57 1E 06            [ 2] 2766 	ldw x,(N1_HB,sp)
      000D59 9E               [ 1] 2767 	ld a,xh  
      000D5A A5 80            [ 1] 2768 	bcp a,#0x80 
      000D5C 27 05            [ 1] 2769 	jreq 2$
      000D5E 03 01            [ 1] 2770 	cpl (SIGN,sp)
      000D60 50               [ 2] 2771 	negw x 
      000D61 1F 06            [ 2] 2772 	ldw (N1_HB,sp),x 
      000D63 1E 08            [ 2] 2773 2$: ldw x,(N2_HB,sp)
      000D65 9E               [ 1] 2774 	ld a,xh  
      000D66 A5 80            [ 1] 2775 	bcp a,#0x80 
      000D68 27 05            [ 1] 2776 	jreq 3$
      000D6A 03 01            [ 1] 2777 	cpl (SIGN,sp)
      000D6C 50               [ 2] 2778 	negw x 
      000D6D 1F 08            [ 2] 2779 	ldw (N2_HB,sp),x 
                                   2780 ; N1_LB * N2_LB 	
      000D6F 7B 07            [ 1] 2781 3$:	ld a,(N1_LB,sp)
      000D71 97               [ 1] 2782 	ld xl,a 
      000D72 7B 09            [ 1] 2783 	ld a,(N2_LB,sp) 
      000D74 42               [ 4] 2784 	mul x,a 
                           000000  2785 .if MATH_OVF 	
                                   2786 	ld a,xh 
                                   2787 	bcp a,#0x80 
                                   2788 	jreq 4$ 
                                   2789 	ld a,#ERR_MATH_OVF 
                                   2790 	jp tb_error
                                   2791 .endif 	 
      000D75 1F 02            [ 2] 2792 4$:	ldw (PROD,sp),x
                                   2793 ; N1_LB * N2_HB	 
      000D77 7B 07            [ 1] 2794 	ld a,(N1_LB,sp) 
      000D79 97               [ 1] 2795 	ld xl,a 
      000D7A 7B 08            [ 1] 2796 	ld a,(N2_HB,sp)
      000D7C 42               [ 4] 2797 	mul x,a
      000D7D 9F               [ 1] 2798 	ld a,xl 
      000D7E 1B 02            [ 1] 2799 	add a,(PROD,sp)
                           000000  2800 .if MATH_OVF 	
                                   2801 	bcp a,#0x80 
                                   2802 	jreq 5$ 
                                   2803 	ld a,#ERR_MATH_OVF 
                                   2804 	jp tb_error
                                   2805 .endif 	 
      000D80 6B 02            [ 1] 2806 5$:	ld (PROD,sp),a 
                                   2807 ; N1_HB * N2_LB 
      000D82 7B 06            [ 1] 2808 	ld a,(N1_HB,sp)
      000D84 97               [ 1] 2809 	ld xl,a 
      000D85 7B 09            [ 1] 2810 	ld a,(N2_LB,sp)
      000D87 42               [ 4] 2811 	mul x,a 
      000D88 9F               [ 1] 2812 	ld a,xl 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 55.
Hexadecimal [24-Bits]



      000D89 1B 02            [ 1] 2813 	add a,(PROD,sp)
                           000000  2814 .if MATH_OVF 	
                                   2815 	bcp a,#0x80 
                                   2816 	jreq 6$ 
                                   2817 	ld a,#ERR_MATH_OVF 
                                   2818 	jp tb_error
                                   2819 .endif 	 
      000D8B 6B 02            [ 1] 2820 6$:	ld (PROD,sp),a 
                                   2821 ; N1_HB * N2_HB 	
                                   2822 ; it is pointless to multiply N1_HB*N2_HB 
                                   2823 ; as this product is over 65535 or 0 
                                   2824 ;
                                   2825 ; sign adjust product
      000D8D 0D 01            [ 1] 2826 	tnz (SIGN,sp)
      000D8F 27 05            [ 1] 2827 	jreq 7$
      000D91 1E 02            [ 2] 2828 	ldw x, (PROD,sp)
      000D93 50               [ 2] 2829 	negw x
      000D94 1F 02            [ 2] 2830 	ldw (PROD,sp),x  
      000D96                       2831 7$: 
      000D96 1E 02            [ 2] 2832 	ldw x,(PROD,sp) 
      000D98                       2833 	_drop VSIZE 
      000D98 5B 03            [ 2]    1     addw sp,#VSIZE 
      000D9A 81               [ 4] 2834 	ret
                                   2835 
                                   2836 ;----------------------------------
                                   2837 ;  euclidian divide n2/n1 
                                   2838 ; input:
                                   2839 ;    N2 	on cstack
                                   2840 ;    N1 	on cstack
                                   2841 ; output:
                                   2842 ;    X      n2/n1 
                                   2843 ;    Y      remainder 
                                   2844 ;----------------------------------
      000D9B                       2845 	_argofs 2
                           000004     1     ARG_OFS=2+2 
      000D9B                       2846 	_arg DIVISR 1
                           000005     1     DIVISR=ARG_OFS+1 
      000D9B                       2847 	_arg DIVIDND 3
                           000007     1     DIVIDND=ARG_OFS+3 
                                   2848 	; local variables
                           000001  2849 	SQUOT=1 ; sign quotient
                           000002  2850 	SDIVD=2 ; sign dividend  
                           000002  2851 	VSIZE=2
      000D9B                       2852 divide:
      000D9B                       2853 	_vars VSIZE 
      000D9B 52 02            [ 2]    1     sub sp,#VSIZE 
      000D9D 0F 01            [ 1] 2854 	clr (SQUOT,sp)
      000D9F 0F 02            [ 1] 2855 	clr (SDIVD,sp)
                                   2856 ; check for 0 divisor
      000DA1 1E 05            [ 2] 2857 	ldw x,(DIVISR,sp)
      000DA3 5D               [ 2] 2858 	tnzw x 
      000DA4 26 05            [ 1] 2859     jrne 0$
      000DA6 A6 04            [ 1] 2860 	ld a,#ERR_DIV0 
      000DA8 CC 07 03         [ 2] 2861 	jp tb_error 
                                   2862 ; check divisor sign 	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 56.
Hexadecimal [24-Bits]



      000DAB 9E               [ 1] 2863 0$:	ld a,xh 
      000DAC A5 80            [ 1] 2864 	bcp a,#0x80 
      000DAE 27 03            [ 1] 2865 	jreq 1$
      000DB0 03 01            [ 1] 2866 	cpl (SQUOT,sp)
      000DB2 50               [ 2] 2867 	negw x 
      000DB3 1F 05            [ 2] 2868 1$:	ldw (DIVISR,sp),x
                                   2869 ; check dividend sign 	 
      000DB5 1E 07            [ 2] 2870     ldw x,(DIVIDND,sp)
      000DB7 9E               [ 1] 2871 	ld a,xh 
      000DB8 A5 80            [ 1] 2872 	bcp a,#0x80 
      000DBA 27 05            [ 1] 2873 	jreq 2$ 
      000DBC 03 01            [ 1] 2874 	cpl (SQUOT,sp)
      000DBE 03 02            [ 1] 2875 	cpl (SDIVD,sp)
      000DC0 50               [ 2] 2876 	negw x 
      000DC1 16 05            [ 2] 2877 2$:	ldw y,(DIVISR,sp)
      000DC3 65               [ 2] 2878 	divw x,y
      000DC4 90 CF 00 0C      [ 2] 2879 	ldw acc16,y 
                                   2880 ; if sign dividend is negative and remainder!=0 inc divisor 	 
      000DC8 0D 02            [ 1] 2881 	tnz (SDIVD,sp)
      000DCA 27 0B            [ 1] 2882 	jreq 7$
      000DCC 90 5D            [ 2] 2883 	tnzw y 
      000DCE 27 07            [ 1] 2884 	jreq 7$
      000DD0 5C               [ 2] 2885 	incw x
      000DD1 16 05            [ 2] 2886 	ldw y,(DIVISR,sp)
      000DD3 72 B2 00 0C      [ 2] 2887 	subw y,acc16
      000DD7 0D 01            [ 1] 2888 7$: tnz (SQUOT,sp)
      000DD9 27 01            [ 1] 2889 	jreq 9$ 	 
      000DDB 50               [ 2] 2890 8$:	negw x 
      000DDC                       2891 9$: 
      000DDC                       2892 	_drop VSIZE 
      000DDC 5B 02            [ 2]    1     addw sp,#VSIZE 
      000DDE 81               [ 4] 2893 	ret 
                                   2894 
                                   2895 
                                   2896 ;----------------------------------
                                   2897 ;  remainder resulting from euclidian 
                                   2898 ;  division of n2/n1 
                                   2899 ; input:
                                   2900 ;   N1 		cstack 
                                   2901 ;   N2      cstack
                                   2902 ; output:
                                   2903 ;   X       N2%N1 
                                   2904 ;----------------------------------
                           000003  2905 	N1=3
                           000005  2906 	N2=5
                           000004  2907 	VSIZE=4
      000DDF                       2908 modulo:
      000DDF 1E 03            [ 2] 2909 	Ldw x,(N1,sp)
      000DE1 16 05            [ 2] 2910 	ldw y,(N2,sp)
      000DE3                       2911 	_vars VSIZE 
      000DE3 52 04            [ 2]    1     sub sp,#VSIZE 
      000DE5 1F 01            [ 2] 2912 	ldw (1,sp),x 
      000DE7 17 03            [ 2] 2913 	ldw (3,sp),y 
      000DE9 CD 0D 9B         [ 4] 2914 	call divide 
      000DEC 93               [ 1] 2915 	ldw x,y
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 57.
Hexadecimal [24-Bits]



      000DED                       2916 	_drop VSIZE 
      000DED 5B 04            [ 2]    1     addw sp,#VSIZE 
      000DEF 81               [ 4] 2917 	ret 
                                   2918 
                                   2919 
                                   2920 ;----------------------------------
                                   2921 ; search in kword_dict name
                                   2922 ; from its execution address 
                                   2923 ; input:
                                   2924 ;   X       	execution address 
                                   2925 ; output:
                                   2926 ;   X 			cstr*  | 0 
                                   2927 ;--------------------------------
                           000001  2928 	XADR=1 
                           000003  2929 	LINK=3 
                           000004  2930 	VSIZE=4
      000DF0                       2931 cmd_name:
      000DF0                       2932 	_vars VSIZE 
      000DF0 52 04            [ 2]    1     sub sp,#VSIZE 
      000DF2 72 5F 00 0C      [ 1] 2933 	clr acc16 
      000DF6 1F 01            [ 2] 2934 	ldw (XADR,sp),x  
      000DF8 AE 24 8E         [ 2] 2935 	ldw x,#kword_dict	
      000DFB 1F 03            [ 2] 2936 1$:	ldw (LINK,sp),x
      000DFD E6 02            [ 1] 2937 	ld a,(2,x)
      000DFF A4 0F            [ 1] 2938 	and a,#15 
      000E01 C7 00 0D         [ 1] 2939 	ld acc8,a 
      000E04 1C 00 03         [ 2] 2940 	addw x,#3
      000E07 72 BB 00 0C      [ 2] 2941 	addw x,acc16
      000E0B FE               [ 2] 2942 	ldw x,(x) ; execution address 
      000E0C 13 01            [ 2] 2943 	cpw x,(XADR,sp)
      000E0E 27 0A            [ 1] 2944 	jreq 2$
      000E10 1E 03            [ 2] 2945 	ldw x,(LINK,sp)
      000E12 FE               [ 2] 2946 	ldw x,(x) 
      000E13 1D 00 02         [ 2] 2947 	subw x,#2  
      000E16 26 E3            [ 1] 2948 	jrne 1$
      000E18 20 05            [ 2] 2949 	jra 9$
      000E1A 1E 03            [ 2] 2950 2$: ldw x,(LINK,sp)
      000E1C 1C 00 02         [ 2] 2951 	addw x,#2 	
      000E1F                       2952 9$:	_drop VSIZE
      000E1F 5B 04            [ 2]    1     addw sp,#VSIZE 
      000E21 81               [ 4] 2953 	ret
                                   2954 
                                   2955 
                                   2956 ;---------------------------------
                                   2957 ; dictionary search 
                                   2958 ; input:
                                   2959 ;	X 		dictionary entry point 
                                   2960 ;  pad		.asciz name to search 
                                   2961 ; output:
                                   2962 ;  A 		TK_CMD|TK_IFUNC|TK_NONE 
                                   2963 ;  X		execution address | 0 
                                   2964 ;---------------------------------
                           000001  2965 	NLEN=1 ; cmd length 
                           000002  2966 	YSAVE=2
                           000003  2967 	VSIZE=3 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 58.
Hexadecimal [24-Bits]



      000E22                       2968 search_dict:
      000E22                       2969 	_vars VSIZE 
      000E22 52 03            [ 2]    1     sub sp,#VSIZE 
      000E24 90 93            [ 1] 2970 	ldw y,x 
      000E26                       2971 search_next:	
      000E26 90 F6            [ 1] 2972 	ld a,(y)
      000E28 A4 0F            [ 1] 2973 	and a,#0xf 
      000E2A 6B 01            [ 1] 2974 	ld (NLEN,sp),a  
      000E2C AE 17 38         [ 2] 2975 	ldw x,#pad 
      000E2F 17 02            [ 2] 2976 	ldw (YSAVE,sp),y
      000E31 90 5C            [ 2] 2977 	incw y  
      000E33                       2978 cp_loop:
      000E33 F6               [ 1] 2979 	ld a,(x)
      000E34 27 1E            [ 1] 2980 	jreq str_match 
      000E36 0D 01            [ 1] 2981 	tnz (NLEN,sp)
      000E38 27 0B            [ 1] 2982 	jreq no_match  
      000E3A 90 F1            [ 1] 2983 	cp a,(y)
      000E3C 26 07            [ 1] 2984 	jrne no_match 
      000E3E 90 5C            [ 2] 2985 	incw y 
      000E40 5C               [ 2] 2986 	incw x
      000E41 0A 01            [ 1] 2987 	dec (NLEN,sp)
      000E43 20 EE            [ 2] 2988 	jra cp_loop 
      000E45                       2989 no_match:
      000E45 16 02            [ 2] 2990 	ldw y,(YSAVE,sp) 
      000E47 72 A2 00 02      [ 2] 2991 	subw y,#2 ; move Y to link field
      000E4B 4B 00            [ 1] 2992 	push #TK_NONE 
      000E4D 90 FE            [ 2] 2993 	ldw y,(y) ; next word link 
      000E4F 84               [ 1] 2994 	pop a ; TK_NONE 
      000E50 27 21            [ 1] 2995 	jreq search_exit  ; not found  
                                   2996 ;try next 
      000E52 20 D2            [ 2] 2997 	jra search_next
      000E54                       2998 str_match:
      000E54 16 02            [ 2] 2999 	ldw y,(YSAVE,sp)
      000E56 90 F6            [ 1] 3000 	ld a,(y)
      000E58 6B 01            [ 1] 3001 	ld (NLEN,sp),a ; needed to test keyword type  
      000E5A A4 0F            [ 1] 3002 	and a,#0xf 
                                   3003 ; move y to procedure address field 	
      000E5C 4C               [ 1] 3004 	inc a 
      000E5D C7 00 0D         [ 1] 3005 	ld acc8,a 
      000E60 72 5F 00 0C      [ 1] 3006 	clr acc16 
      000E64 72 B9 00 0C      [ 2] 3007 	addw y,acc16 
      000E68 90 FE            [ 2] 3008 	ldw y,(y) ; routine entry point 
                                   3009 ;determine keyword type bits 7:6 
      000E6A 7B 01            [ 1] 3010 	ld a,(NLEN,sp)
      000E6C 4E               [ 1] 3011 	swap a 
      000E6D A4 0C            [ 1] 3012 	and a,#0xc
      000E6F 44               [ 1] 3013 	srl a
      000E70 44               [ 1] 3014 	srl a 
      000E71 AB 06            [ 1] 3015 	add a,#6
      000E73                       3016 search_exit: 
      000E73 93               [ 1] 3017 	ldw x,y ; x=routine address 
      000E74                       3018 	_drop VSIZE 	 
      000E74 5B 03            [ 2]    1     addw sp,#VSIZE 
      000E76 81               [ 4] 3019 	ret 
                                   3020 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 59.
Hexadecimal [24-Bits]



                                   3021 ;---------------------
                                   3022 ; check if next token
                                   3023 ;  is of expected type 
                                   3024 ; input:
                                   3025 ;   A 		 expected token attribute
                                   3026 ;  ouput:
                                   3027 ;   none     if fail call syntax_error 
                                   3028 ;--------------------
      000E77                       3029 expect:
      000E77 88               [ 1] 3030 	push a 
      000E78 CD 07 B5         [ 4] 3031 	call next_token 
      000E7B 11 01            [ 1] 3032 	cp a,(1,sp)
      000E7D 27 03            [ 1] 3033 	jreq 1$
      000E7F CC 07 01         [ 2] 3034 	jp syntax_error
      000E82 84               [ 1] 3035 1$: pop a 
      000E83 81               [ 4] 3036 	ret 
                                   3037 
                                   3038 
                                   3039 ;-------------------------------
                                   3040 ; parse embedded BASIC routines 
                                   3041 ; arguments list.
                                   3042 ; arg_list::=  rel[','rel]*
                                   3043 ; all arguments are of integer type
                                   3044 ; and pushed on stack 
                                   3045 ; input:
                                   3046 ;   none
                                   3047 ; output:
                                   3048 ;   stack{n}   arguments pushed on stack
                                   3049 ;   A 	number of arguments pushed on stack  
                                   3050 ;--------------------------------
      000E84                       3051 arg_list:
      000E84 4B 00            [ 1] 3052 	push #0  
      000E86 CD 0F D4         [ 4] 3053 1$: call relation
      000E89 A1 00            [ 1] 3054 	cp a,#TK_NONE 
      000E8B 27 1C            [ 1] 3055 	jreq 5$
      000E8D A1 04            [ 1] 3056 	cp a,#TK_INTGR
      000E8F 26 13            [ 1] 3057 	jrne 4$
      000E91                       3058 3$: 
                                   3059 ; swap return address with argument
      000E91 84               [ 1] 3060 	pop a 
      000E92 90 85            [ 2] 3061 	popw y 
      000E94 89               [ 2] 3062 	pushw x 
      000E95 90 89            [ 2] 3063 	pushw y 
      000E97 4C               [ 1] 3064     inc a
      000E98 88               [ 1] 3065 	push a 
      000E99 CD 07 B5         [ 4] 3066 	call next_token 
      000E9C A1 0D            [ 1] 3067 	cp a,#TK_COMMA 
      000E9E 27 E6            [ 1] 3068 	jreq 1$ 
      000EA0 A1 00            [ 1] 3069 	cp a,#TK_NONE 
      000EA2 27 05            [ 1] 3070 	jreq 5$ 
      000EA4                       3071 4$:	_unget_token 
      000EA4 55 00 02 00 01   [ 1]    1     mov in,in.saved
      000EA9 84               [ 1] 3072 5$:	pop a  
      000EAA 81               [ 4] 3073 	ret 
                                   3074 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 60.
Hexadecimal [24-Bits]



                                   3075 ;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   3076 ; parse arguments list 
                                   3077 ; between ()
                                   3078 ;;;;;;;;;;;;;;;;;;;;;;;;;;
      000EAB                       3079 func_args:
      000EAB 85               [ 2] 3080 	popw x
      000EAC CF 00 17         [ 2] 3081 	ldw farptr+1,x  
      000EAF A6 0B            [ 1] 3082 	ld a,#TK_LPAREN 
      000EB1 CD 0E 77         [ 4] 3083 	call expect 
      000EB4 CD 0E 84         [ 4] 3084 	call arg_list 
      000EB7 88               [ 1] 3085 	push a 
      000EB8 A6 0C            [ 1] 3086 	ld a,#TK_RPAREN 
      000EBA CD 0E 77         [ 4] 3087 	call expect 
      000EBD 84               [ 1] 3088 	pop a 
      000EBE 72 CC 00 17      [ 5] 3089 	jp [farptr+1]
                                   3090 
                                   3091 ;--------------------------------
                                   3092 ;   BASIC commnands 
                                   3093 ;--------------------------------
                                   3094 
                                   3095 ;--------------------------------
                                   3096 ;  arithmetic and relational 
                                   3097 ;  routines
                                   3098 ;  operators precedence
                                   3099 ;  highest to lowest
                                   3100 ;  operators on same row have 
                                   3101 ;  same precedence and are executed
                                   3102 ;  from left to right.
                                   3103 ;	'*','/','%'
                                   3104 ;   '-','+'
                                   3105 ;   '=','>','<','>=','<=','<>','><'
                                   3106 ;   '<>' and '><' are equivalent for not equal.
                                   3107 ;--------------------------------
                                   3108 
                                   3109 ;---------------------
                                   3110 ; return array element
                                   3111 ; address from @(expr)
                                   3112 ; input:
                                   3113 ;   A 		TK_ARRAY
                                   3114 ; output:
                                   3115 ;   A 		TK_INTGR
                                   3116 ;	X 		element address 
                                   3117 ;----------------------
      000EC2                       3118 get_array_element:
      000EC2 CD 0E AB         [ 4] 3119 	call func_args 
      000EC5 A1 01            [ 1] 3120 	cp a,#1
      000EC7 27 03            [ 1] 3121 	jreq 1$
      000EC9 CC 07 01         [ 2] 3122 	jp syntax_error
      000ECC 85               [ 2] 3123 1$: popw x 
                                   3124 	; check for bounds 
      000ECD C3 00 23         [ 2] 3125 	cpw x,array_size 
      000ED0 23 05            [ 2] 3126 	jrule 3$
                                   3127 ; bounds {1..array_size}	
      000ED2 A6 0A            [ 1] 3128 2$: ld a,#ERR_BAD_VALUE 
      000ED4 CC 07 03         [ 2] 3129 	jp tb_error 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 61.
Hexadecimal [24-Bits]



      000ED7 5D               [ 2] 3130 3$: tnzw  x
      000ED8 27 F8            [ 1] 3131 	jreq 2$ 
      000EDA 58               [ 2] 3132 	sllw x 
      000EDB 89               [ 2] 3133 	pushw x 
      000EDC AE 16 E8         [ 2] 3134 	ldw x,#tib
      000EDF 72 F0 01         [ 2] 3135 	subw x,(1,sp)
      000EE2                       3136 	_drop 2   
      000EE2 5B 02            [ 2]    1     addw sp,#2 
      000EE4 A6 04            [ 1] 3137 	ld a,#TK_INTGR
      000EE6 81               [ 4] 3138 	ret 
                                   3139 
                                   3140 ;***********************************
                                   3141 ;   expression parse,execute 
                                   3142 ;***********************************
                                   3143 ;-----------------------------------
                                   3144 ; factor ::= ['+'|'-'|e]  var | @ |
                                   3145 ;			 integer | function |
                                   3146 ;			 '('relation')' 
                                   3147 ; output:
                                   3148 ;   A    token attribute 
                                   3149 ;   X 	 integer
                                   3150 ; ---------------------------------
                           000001  3151 	NEG=1
                           000001  3152 	VSIZE=1
      000EE7                       3153 factor:
      000EE7                       3154 	_vars VSIZE 
      000EE7 52 01            [ 2]    1     sub sp,#VSIZE 
      000EE9 CD 07 B5         [ 4] 3155 	call next_token
      000EEC A1 02            [ 1] 3156 	cp a,#CMD_END 
      000EEE 2B 4E            [ 1] 3157 	jrmi 20$
      000EF0 6B 01            [ 1] 3158 1$:	ld (NEG,sp),a 
      000EF2 A4 30            [ 1] 3159 	and a,#TK_GRP_MASK
      000EF4 A1 10            [ 1] 3160 	cp a,#TK_GRP_ADD 
      000EF6 27 04            [ 1] 3161 	jreq 2$
      000EF8 7B 01            [ 1] 3162 	ld a,(NEG,sp)
      000EFA 20 03            [ 2] 3163 	jra 4$  
      000EFC                       3164 2$:	
      000EFC CD 07 B5         [ 4] 3165 	call next_token 
      000EFF                       3166 4$:	
      000EFF A1 07            [ 1] 3167 	cp a,#TK_IFUNC 
      000F01 26 03            [ 1] 3168 	jrne 5$ 
      000F03 FD               [ 4] 3169 	call (x) 
      000F04 20 2F            [ 2] 3170 	jra 18$ 
      000F06                       3171 5$:
      000F06 A1 04            [ 1] 3172 	cp a,#TK_INTGR
      000F08 26 02            [ 1] 3173 	jrne 6$
      000F0A 20 29            [ 2] 3174 	jra 18$
      000F0C                       3175 6$:
      000F0C A1 02            [ 1] 3176 	cp a,#TK_ARRAY
      000F0E 26 06            [ 1] 3177 	jrne 10$
      000F10 CD 0E C2         [ 4] 3178 	call get_array_element
      000F13 FE               [ 2] 3179 	ldw x,(x)
      000F14 20 1F            [ 2] 3180 	jra 18$ 
      000F16                       3181 10$:
      000F16 A1 05            [ 1] 3182 	cp a,#TK_VAR 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 62.
Hexadecimal [24-Bits]



      000F18 26 03            [ 1] 3183 	jrne 12$
      000F1A FE               [ 2] 3184 	ldw x,(x)
      000F1B 20 18            [ 2] 3185 	jra 18$
      000F1D                       3186 12$:			
      000F1D A1 0B            [ 1] 3187 	cp a,#TK_LPAREN
      000F1F 26 0C            [ 1] 3188 	jrne 16$
      000F21 CD 0F D4         [ 4] 3189 	call relation
      000F24 89               [ 2] 3190 	pushw x 
      000F25 A6 0C            [ 1] 3191 	ld a,#TK_RPAREN 
      000F27 CD 0E 77         [ 4] 3192 	call expect
      000F2A 85               [ 2] 3193 	popw x 
      000F2B 20 08            [ 2] 3194 	jra 18$	
      000F2D                       3195 16$:
      000F2D                       3196 	_unget_token
      000F2D 55 00 02 00 01   [ 1]    1     mov in,in.saved
      000F32 4F               [ 1] 3197 	clr a 
      000F33 20 09            [ 2] 3198 	jra 20$ 
      000F35                       3199 18$: 
      000F35 A6 11            [ 1] 3200 	ld a,#TK_MINUS 
      000F37 11 01            [ 1] 3201 	cp a,(NEG,sp)
      000F39 26 01            [ 1] 3202 	jrne 19$
      000F3B 50               [ 2] 3203 	negw x
      000F3C                       3204 19$:
      000F3C A6 04            [ 1] 3205 	ld a,#TK_INTGR
      000F3E                       3206 20$:
      000F3E                       3207 	_drop VSIZE
      000F3E 5B 01            [ 2]    1     addw sp,#VSIZE 
      000F40 81               [ 4] 3208 	ret
                                   3209 
                                   3210 ;-----------------------------------
                                   3211 ; term ::= factor [['*'|'/'|'%'] factor]* 
                                   3212 ; output:
                                   3213 ;   A    	token attribute 
                                   3214 ;	X		integer
                                   3215 ;-----------------------------------
                           000001  3216 	N1=1
                           000003  3217 	N2=3
                           000005  3218 	MULOP=5
                           000005  3219 	VSIZE=5
      000F41                       3220 term:
      000F41                       3221 	_vars VSIZE
      000F41 52 05            [ 2]    1     sub sp,#VSIZE 
      000F43 CD 0E E7         [ 4] 3222 	call factor
      000F46 A1 02            [ 1] 3223 	cp a,#CMD_END
      000F48 2B 43            [ 1] 3224 	jrmi term_exit
      000F4A                       3225 term01:	 ; check for  operator 
      000F4A 1F 03            [ 2] 3226 	ldw (N2,sp),x  ; save first factor 
      000F4C CD 07 B5         [ 4] 3227 	call next_token
      000F4F A1 02            [ 1] 3228 	cp a,#CMD_END
      000F51 2B 36            [ 1] 3229 	jrmi 9$
      000F53 6B 05            [ 1] 3230 0$:	ld (MULOP,sp),a
      000F55 A4 30            [ 1] 3231 	and a,#TK_GRP_MASK
      000F57 A1 20            [ 1] 3232 	cp a,#TK_GRP_MULT
      000F59 27 09            [ 1] 3233 	jreq 1$
      000F5B 7B 05            [ 1] 3234 	ld a,(MULOP,sp) 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 63.
Hexadecimal [24-Bits]



      000F5D                       3235 	_unget_token 
      000F5D 55 00 02 00 01   [ 1]    1     mov in,in.saved
      000F62 20 25            [ 2] 3236 	jra 9$
      000F64                       3237 1$:	; got *|/|%
      000F64 CD 0E E7         [ 4] 3238 	call factor
      000F67 A1 04            [ 1] 3239 	cp a,#TK_INTGR
      000F69 27 03            [ 1] 3240 	jreq 2$ 
      000F6B CC 07 01         [ 2] 3241 	jp syntax_error
      000F6E 1F 01            [ 2] 3242 2$:	ldw (N1,sp),x  
      000F70 7B 05            [ 1] 3243 	ld a,(MULOP,sp) 
      000F72 A1 20            [ 1] 3244 	cp a,#TK_MULT 
      000F74 26 05            [ 1] 3245 	jrne 3$
      000F76 CD 0D 53         [ 4] 3246 	call multiply 
      000F79 20 CF            [ 2] 3247 	jra term01
      000F7B A1 21            [ 1] 3248 3$: cp a,#TK_DIV 
      000F7D 26 05            [ 1] 3249 	jrne 4$ 
      000F7F CD 0D 9B         [ 4] 3250 	call divide 
      000F82 20 C6            [ 2] 3251 	jra term01 
      000F84 CD 0D DF         [ 4] 3252 4$: call modulo
      000F87 20 C1            [ 2] 3253 	jra term01 
      000F89 1E 03            [ 2] 3254 9$: ldw x,(N2,sp)  
      000F8B A6 04            [ 1] 3255 	ld a,#TK_INTGR 	
      000F8D                       3256 term_exit:
      000F8D                       3257 	_drop VSIZE 
      000F8D 5B 05            [ 2]    1     addw sp,#VSIZE 
      000F8F 81               [ 4] 3258 	ret 
                                   3259 
                                   3260 ;-------------------------------
                                   3261 ;  expr ::= term [['+'|'-'] term]*
                                   3262 ;  result range {-32768..32767}
                                   3263 ;  output:
                                   3264 ;   A    token attribute 
                                   3265 ;   X	 integer   
                                   3266 ;-------------------------------
                           000001  3267 	N1=1 
                           000003  3268 	N2=3
                           000005  3269 	OP=5 
                           000005  3270 	VSIZE=5 
      000F90                       3271 expression:
      000F90                       3272 	_vars VSIZE 
      000F90 52 05            [ 2]    1     sub sp,#VSIZE 
      000F92 CD 0F 41         [ 4] 3273 	call term
      000F95 A1 02            [ 1] 3274 	cp a,#CMD_END 
      000F97 2B 38            [ 1] 3275 	jrmi expr_exit 
      000F99 1F 03            [ 2] 3276 0$:	ldw (N2,sp),x 
      000F9B CD 07 B5         [ 4] 3277 	call next_token
      000F9E A1 02            [ 1] 3278 	cp a,#CMD_END 
      000FA0 2B 2B            [ 1] 3279 	jrmi 9$ 
      000FA2 6B 05            [ 1] 3280 1$:	ld (OP,sp),a  
      000FA4 A4 30            [ 1] 3281 	and a,#TK_GRP_MASK
      000FA6 A1 10            [ 1] 3282 	cp a,#TK_GRP_ADD 
      000FA8 27 07            [ 1] 3283 	jreq 2$ 
      000FAA                       3284 	_unget_token
      000FAA 55 00 02 00 01   [ 1]    1     mov in,in.saved
      000FAF 20 1C            [ 2] 3285 	jra 9$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 64.
Hexadecimal [24-Bits]



      000FB1                       3286 2$: 
      000FB1 CD 0F 41         [ 4] 3287 	call term
      000FB4 A1 04            [ 1] 3288 	cp a,#TK_INTGR 
      000FB6 27 03            [ 1] 3289 	jreq 3$
      000FB8 CC 07 01         [ 2] 3290 	jp syntax_error
      000FBB 1F 01            [ 2] 3291 3$:	ldw (N1,sp),x 
      000FBD 7B 05            [ 1] 3292 	ld a,(OP,sp)
      000FBF A1 10            [ 1] 3293 	cp a,#TK_PLUS 
      000FC1 26 05            [ 1] 3294 	jrne 4$
      000FC3 CD 0D 45         [ 4] 3295 	call add 
      000FC6 20 D1            [ 2] 3296 	jra 0$ 
      000FC8 CD 0D 4D         [ 4] 3297 4$:	call substract
      000FCB 20 CC            [ 2] 3298 	jra 0$
      000FCD 1E 03            [ 2] 3299 9$: ldw x,(N2,sp)
      000FCF A6 04            [ 1] 3300 	ld a,#TK_INTGR	
      000FD1                       3301 expr_exit:
      000FD1                       3302 	_drop VSIZE 
      000FD1 5B 05            [ 2]    1     addw sp,#VSIZE 
      000FD3 81               [ 4] 3303 	ret 
                                   3304 
                                   3305 ;---------------------------------------------
                                   3306 ; rel ::= expr rel_op expr
                                   3307 ; rel_op ::=  '=','<','>','>=','<=','<>','><'
                                   3308 ;  relation return 1 | 0  for true | false 
                                   3309 ;  output:
                                   3310 ;    A 		token attribute  
                                   3311 ;	 X		1|0
                                   3312 ;---------------------------------------------
                           000001  3313 	N1=1
                           000003  3314 	N2=3
                           000005  3315 	RELOP=5
                           000005  3316 	VSIZE=5 
      000FD4                       3317 relation: 
      000FD4                       3318 	_vars VSIZE
      000FD4 52 05            [ 2]    1     sub sp,#VSIZE 
      000FD6 CD 0F 90         [ 4] 3319 	call expression
      000FD9 A1 02            [ 1] 3320 	cp a,#CMD_END  
      000FDB 2B 4B            [ 1] 3321 	jrmi rel_exit 
                                   3322 	; expect rel_op or leave 
      000FDD 1F 03            [ 2] 3323 	ldw (N2,sp),x 
      000FDF CD 07 B5         [ 4] 3324 	call next_token 
      000FE2 A1 02            [ 1] 3325 	cp a,#CMD_END 
      000FE4 2B 3E            [ 1] 3326 	jrmi 9$
      000FE6                       3327 1$:	
      000FE6 6B 05            [ 1] 3328 	ld (RELOP,sp),a 
      000FE8 A4 30            [ 1] 3329 	and a,#TK_GRP_MASK
      000FEA A1 30            [ 1] 3330 	cp a,#TK_GRP_RELOP 
      000FEC 27 07            [ 1] 3331 	jreq 2$
      000FEE                       3332 	_unget_token  
      000FEE 55 00 02 00 01   [ 1]    1     mov in,in.saved
      000FF3 20 2F            [ 2] 3333 	jra 9$
      000FF5                       3334 2$:	; expect another expression or error 
      000FF5 CD 0F 90         [ 4] 3335 	call expression
      000FF8 A1 04            [ 1] 3336 	cp a,#TK_INTGR 
      000FFA 27 03            [ 1] 3337 	jreq 3$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 65.
Hexadecimal [24-Bits]



      000FFC CC 07 01         [ 2] 3338 	jp syntax_error 
      000FFF 1F 01            [ 2] 3339 3$:	ldw (N1,sp),x 
      001001 CD 0D 4D         [ 4] 3340 	call substract
      001004 26 06            [ 1] 3341 	jrne 4$
      001006 35 02 00 0D      [ 1] 3342 	mov acc8,#2 ; n1==n2
      00100A 20 0C            [ 2] 3343 	jra 6$ 
      00100C                       3344 4$: 
      00100C 2C 06            [ 1] 3345 	jrsgt 5$  
      00100E 35 04 00 0D      [ 1] 3346 	mov acc8,#4 ; n1<2 
      001012 20 04            [ 2] 3347 	jra 6$
      001014                       3348 5$:
      001014 35 01 00 0D      [ 1] 3349 	mov acc8,#1 ; n1>n2 
      001018                       3350 6$:
      001018 5F               [ 1] 3351 	clrw x 
      001019 C6 00 0D         [ 1] 3352 	ld a, acc8  
      00101C 14 05            [ 1] 3353 	and a,(RELOP,sp)
      00101E 4D               [ 1] 3354 	tnz a 
      00101F 27 05            [ 1] 3355 	jreq 10$
      001021 5C               [ 2] 3356 	incw x 
      001022                       3357 7$:	 
      001022 20 02            [ 2] 3358 	jra 10$  	
      001024 1E 03            [ 2] 3359 9$: ldw x,(N2,sp)
      001026                       3360 10$:
      001026 A6 04            [ 1] 3361 	ld a,#TK_INTGR
      001028                       3362 rel_exit: 	 
      001028                       3363 	_drop VSIZE
      001028 5B 05            [ 2]    1     addw sp,#VSIZE 
      00102A 81               [ 4] 3364 	ret 
                                   3365 
                                   3366 ;--------------------------------
                                   3367 ; BASIC: SHOW 
                                   3368 ; print stack content in hexadecimal bytes 
                                   3369 ; 16 bytes per row 
                                   3370 ;--------------------------------
                           000001  3371 	TWSAVE=1
                           000002  3372 	BSAVE=2
                           000003  3373 	ADDR=3
                           000004  3374 	VSIZE=4 
      00102B                       3375 show:
      00102B                       3376 	_vars VSIZE
      00102B 52 04            [ 2]    1     sub sp,#VSIZE 
      00102D C6 00 0A         [ 1] 3377 	ld a,base 
      001030 6B 02            [ 1] 3378 	ld (BSAVE,sp),a
      001032 C6 00 26         [ 1] 3379 	ld a,tab_width
      001035 6B 01            [ 1] 3380 	ld (TWSAVE,sp),a
      001037 35 10 00 0A      [ 1] 3381 	mov base,#16   
      00103B AE 10 77         [ 2] 3382 	ldw x,#cstk_prompt
      00103E CD 01 C6         [ 4] 3383 	call puts 
      001041 96               [ 1] 3384 	ldw x,sp 
      001042 1C 00 05         [ 2] 3385 	addw x,#VSIZE+1 ; ignore local vars and return address
      001045 1F 03            [ 2] 3386 	ldw (ADDR,sp),x 
      001047                       3387 dotr_loop:
      001047 A3 18 00         [ 2] 3388 	cpw x,#RAM_SIZE 
      00104A 24 18            [ 1] 3389 	jruge 9$
      00104C A6 10            [ 1] 3390 	ld a,#16 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 66.
Hexadecimal [24-Bits]



      00104E 90 AE 18 00      [ 2] 3391 	ldw y,#RAM_SIZE  
      001052 72 F2 03         [ 2] 3392 	subw y,(ADDR,sp)
      001055 90 A3 00 10      [ 2] 3393 	cpw y,#16 
      001059 24 02            [ 1] 3394 	jruge 2$
      00105B 90 9F            [ 1] 3395 	ld a,yl  
      00105D                       3396 2$:  
      00105D CD 10 9E         [ 4] 3397 	call show_row 
      001060 1F 03            [ 2] 3398 	ldw (ADDR,sp),x 
      001062 20 E3            [ 2] 3399 	jra dotr_loop 
      001064 A6 0D            [ 1] 3400 9$:	ld a,#CR 
      001066 CD 01 B3         [ 4] 3401 	call putc 
      001069 7B 02            [ 1] 3402 	ld a,(BSAVE,sp)
      00106B C7 00 0A         [ 1] 3403 	ld base,a 
      00106E 7B 01            [ 1] 3404 	ld a,(TWSAVE,sp)
      001070 C7 00 26         [ 1] 3405 	ld tab_width,a 
      001073                       3406 	_drop VSIZE 
      001073 5B 04            [ 2]    1     addw sp,#VSIZE 
      001075 4F               [ 1] 3407 	clr a 
      001076 81               [ 4] 3408 	ret
                                   3409 
      001077 0A 63 6F 6E 74 65 6E  3410 cstk_prompt: .asciz "\ncontent of stack from top to bottom:\n"
             74 20 6F 66 20 73 74
             61 63 6B 20 66 72 6F
             6D 20 74 6F 70 20 74
             6F 20 62 6F 74 74 6F
             6D 3A 0A 00
                                   3411 
                                   3412 ;---------------------
                                   3413 ; display n bytes row 
                                   3414 ; from memory.
                                   3415 ; input:
                                   3416 ;   A   bytes to print 
                                   3417 ;	X   start address 
                                   3418 ; output:
                                   3419 ;   X   address after last shown  
                                   3420 ;---------------------
                           000001  3421 	CNT=1 
                           000002  3422 	ADR=2 
                           000003  3423 	VSIZE=3 
      00109E                       3424 show_row:
      00109E 4D               [ 1] 3425 	tnz a 
      00109F 26 01            [ 1] 3426 	jrne 1$
      0010A1 81               [ 4] 3427 	ret 
      0010A2                       3428 1$:	
      0010A2 89               [ 2] 3429 	pushw x  
      0010A3 88               [ 1] 3430 	push a 
      0010A4 35 04 00 26      [ 1] 3431 	mov tab_width,#4 
      0010A8 CD 08 4A         [ 4] 3432 	call print_int 
      0010AB A6 20            [ 1] 3433 	ld a,#SPACE  
      0010AD CD 01 B3         [ 4] 3434 	call putc
      0010B0                       3435 row_loop:
      0010B0 1E 02            [ 2] 3436 	ldw x,(ADR,sp)
      0010B2 F6               [ 1] 3437 	ld a,(x)
      0010B3 5F               [ 1] 3438 	clrw x 
      0010B4 97               [ 1] 3439 	ld xl,a 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 67.
Hexadecimal [24-Bits]



      0010B5 CD 08 4A         [ 4] 3440 	call print_int 
      0010B8 1E 02            [ 2] 3441 	ldw x,(ADR,sp)
      0010BA 5C               [ 2] 3442 	incw x 
      0010BB 1F 02            [ 2] 3443 	ldw (ADR,sp),x 
      0010BD 0A 01            [ 1] 3444 	dec (CNT,sp)
      0010BF 26 EF            [ 1] 3445 	jrne row_loop
      0010C1                       3446 	_drop VSIZE  		
      0010C1 5B 03            [ 2]    1     addw sp,#VSIZE 
      0010C3 35 04 00 26      [ 1] 3447 	mov tab_width,#4
      0010C7 A6 0D            [ 1] 3448 	ld a,#CR 
      0010C9 CD 01 B3         [ 4] 3449 	call putc 
      0010CC 81               [ 4] 3450 	ret 
                                   3451 
                                   3452 ;--------------------------------------------
                                   3453 ; BASIC: HEX 
                                   3454 ; select hexadecimal base for integer print
                                   3455 ;---------------------------------------------
      0010CD                       3456 hex_base:
      0010CD 35 10 00 0A      [ 1] 3457 	mov base,#16 
      0010D1 81               [ 4] 3458 	ret 
                                   3459 
                                   3460 ;--------------------------------------------
                                   3461 ; BASIC: DEC 
                                   3462 ; select decimal base for integer print
                                   3463 ;---------------------------------------------
      0010D2                       3464 dec_base:
      0010D2 35 0A 00 0A      [ 1] 3465 	mov base,#10
      0010D6 81               [ 4] 3466 	ret 
                                   3467 
                                   3468 ;------------------------
                                   3469 ; BASIC: SIZE 
                                   3470 ; return free size in text area
                                   3471 ; output:
                                   3472 ;   A 		TK_INTGR
                                   3473 ;   X 	    size integer
                                   3474 ;--------------------------
      0010D7                       3475 size:
      0010D7 AE 16 E8         [ 2] 3476 	ldw x,#tib 
      0010DA 72 B0 00 20      [ 2] 3477 	subw x,txtend 
      0010DE A6 04            [ 1] 3478 	ld a,#TK_INTGR
      0010E0 81               [ 4] 3479 	ret 
                                   3480 
                                   3481 
                                   3482 ;------------------------
                                   3483 ; BASIC: UBOUND  
                                   3484 ; return array variable size 
                                   3485 ; output:
                                   3486 ;   A 		TK_INTGR
                                   3487 ;   X 	    array size 
                                   3488 ;--------------------------
      0010E1                       3489 ubound:
      0010E1 AE 16 E8         [ 2] 3490 	ldw x,#tib
      0010E4 72 B0 00 20      [ 2] 3491 	subw x,txtend 
      0010E8 90 CE 00 04      [ 2] 3492 	ldw y,basicptr 
      0010EC 90 C3 00 20      [ 2] 3493 	cpw y,txtend 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 68.
Hexadecimal [24-Bits]



      0010F0 25 0A            [ 1] 3494 	jrult 1$
      0010F2 3B 00 03         [ 1] 3495 	push count 
      0010F5 4B 00            [ 1] 3496 	push #0 
      0010F7 72 F0 01         [ 2] 3497 	subw x,(1,sp)
      0010FA                       3498 	_drop 2 
      0010FA 5B 02            [ 2]    1     addw sp,#2 
      0010FC 54               [ 2] 3499 1$:	srlw x 
      0010FD CF 00 23         [ 2] 3500 	ldw array_size,x
      001100 A6 04            [ 1] 3501 	ld a,#TK_INTGR
      001102 81               [ 4] 3502 	ret 
                                   3503 
                                   3504 ;-----------------------------
                                   3505 ; BASIC: LET var=expr 
                                   3506 ; variable assignement 
                                   3507 ; output:
                                   3508 ;   A 		TK_NONE 
                                   3509 ;-----------------------------
      001103                       3510 let:
      001103 CD 07 B5         [ 4] 3511 	call next_token 
      001106 A1 05            [ 1] 3512 	cp a,#TK_VAR 
      001108 27 03            [ 1] 3513 	jreq let02
      00110A CC 07 01         [ 2] 3514 	jp syntax_error
      00110D                       3515 let02:
      00110D 89               [ 2] 3516 	pushw x  
      00110E CD 07 B5         [ 4] 3517 	call next_token 
      001111 A1 32            [ 1] 3518 	cp a,#TK_EQUAL
      001113 27 03            [ 1] 3519 	jreq 1$
      001115 CC 07 01         [ 2] 3520 	jp syntax_error
      001118                       3521 1$:	
      001118 CD 0F D4         [ 4] 3522 	call relation   
      00111B A1 04            [ 1] 3523 	cp a,#TK_INTGR 
      00111D 27 03            [ 1] 3524 	jreq 2$
      00111F CC 07 01         [ 2] 3525 	jp syntax_error
      001122                       3526 2$:	
      001122 90 93            [ 1] 3527 	ldw y,x 
      001124 85               [ 2] 3528 	popw x   
      001125 FF               [ 2] 3529 	ldw (x),y   
      001126 81               [ 4] 3530 	ret 
                                   3531 
                                   3532 ;----------------------------
                                   3533 ; BASIC: LIST [[start][,end]]
                                   3534 ; list program lines 
                                   3535 ; form start to end 
                                   3536 ; if empty argument list then 
                                   3537 ; list all.
                                   3538 ;----------------------------
                           000001  3539 	FIRST=1
                           000003  3540 	LAST=3 
                           000005  3541 	LN_PTR=5
                           000006  3542 	VSIZE=6 
      001127                       3543 list:
      001127                       3544 	_vars VSIZE
      001127 52 06            [ 2]    1     sub sp,#VSIZE 
      001129 CE 00 1E         [ 2] 3545 	ldw x,txtbgn 
      00112C C3 00 20         [ 2] 3546 	cpw x,txtend 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 69.
Hexadecimal [24-Bits]



      00112F 2B 03            [ 1] 3547 	jrmi 1$
      001131 CC 11 9E         [ 2] 3548 	jp list_exit ; nothing to list 
      001134 1F 05            [ 2] 3549 1$:	ldw (LN_PTR,sp),x 
      001136 FE               [ 2] 3550 	ldw x,(x) 
      001137 1F 01            [ 2] 3551 	ldw (FIRST,sp),x ; list from first line 
      001139 AE 7F FF         [ 2] 3552 	ldw x,#MAX_LINENO ; biggest line number 
      00113C 1F 03            [ 2] 3553 	ldw (LAST,sp),x 
      00113E CD 0E 84         [ 4] 3554 	call arg_list
      001141 4D               [ 1] 3555 	tnz a
      001142 27 34            [ 1] 3556 	jreq list_start 
      001144 A1 02            [ 1] 3557 	cp a,#2 
      001146 27 07            [ 1] 3558 	jreq 4$
      001148 A1 01            [ 1] 3559 	cp a,#1 
      00114A 27 06            [ 1] 3560 	jreq first_line 
      00114C CC 07 01         [ 2] 3561 	jp syntax_error 
      00114F 85               [ 2] 3562 4$:	popw x 
      001150 1F 03            [ 2] 3563 	ldw (LAST,sp),x 
      001152                       3564 first_line:
      001152 85               [ 2] 3565 	popw x 
      001153 1F 01            [ 2] 3566 	ldw (FIRST,sp),x 
      001155                       3567 lines_skip:
      001155 CE 00 1E         [ 2] 3568 	ldw x,txtbgn
      001158 1F 05            [ 2] 3569 2$:	ldw (LN_PTR,sp),x 
      00115A C3 00 20         [ 2] 3570 	cpw x,txtend 
      00115D 2A 3F            [ 1] 3571 	jrpl list_exit 
      00115F FE               [ 2] 3572 	ldw x,(x) ;line# 
      001160 13 01            [ 2] 3573 	cpw x,(FIRST,sp)
      001162 2A 14            [ 1] 3574 	jrpl list_start 
      001164 1E 05            [ 2] 3575 	ldw x,(LN_PTR,sp) 
      001166 1C 00 02         [ 2] 3576 	addw x,#2 
      001169 F6               [ 1] 3577 	ld a,(x)
      00116A 5C               [ 2] 3578 	incw x 
      00116B C7 00 0D         [ 1] 3579 	ld acc8,a 
      00116E 72 5F 00 0C      [ 1] 3580 	clr acc16 
      001172 72 BB 00 0C      [ 2] 3581 	addw x,acc16
      001176 20 E0            [ 2] 3582 	jra 2$ 
                                   3583 ; print loop
      001178                       3584 list_start:
      001178 1E 05            [ 2] 3585 	ldw x,(LN_PTR,sp)
      00117A E6 02            [ 1] 3586 3$:	ld a,(2,x) 
      00117C CD 11 F1         [ 4] 3587 	call prt_basic_line
      00117F 1E 05            [ 2] 3588 	ldw x,(LN_PTR,sp)
      001181 E6 02            [ 1] 3589 	ld a,(2,x)
      001183 C7 00 0D         [ 1] 3590 	ld acc8,a 
      001186 72 5F 00 0C      [ 1] 3591 	clr acc16 
      00118A 72 BB 00 0C      [ 2] 3592 	addw x,acc16
      00118E C3 00 20         [ 2] 3593 	cpw x,txtend 
      001191 2A 0B            [ 1] 3594 	jrpl list_exit
      001193 1F 05            [ 2] 3595 	ldw (LN_PTR,sp),x
      001195 FE               [ 2] 3596 	ldw x,(x)
      001196 13 03            [ 2] 3597 	cpw x,(LAST,sp)  
      001198 2C 04            [ 1] 3598 	jrsgt list_exit 
      00119A 1E 05            [ 2] 3599 	ldw x,(LN_PTR,sp)
      00119C 20 DC            [ 2] 3600 	jra 3$
      00119E                       3601 list_exit:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 70.
Hexadecimal [24-Bits]



      00119E                       3602 	_drop VSIZE 
      00119E 5B 06            [ 2]    1     addw sp,#VSIZE 
      0011A0 81               [ 4] 3603 	ret
                                   3604 
                                   3605 ;-------------------------
                                   3606 ; print counted string 
                                   3607 ; input:
                                   3608 ;   X 	address of string
                                   3609 ;--------------------------
      0011A1                       3610 prt_cmd_name:
      0011A1 F6               [ 1] 3611 	ld a,(x)
      0011A2 5C               [ 2] 3612 	incw x
      0011A3 A4 0F            [ 1] 3613 	and a,#15  
      0011A5 88               [ 1] 3614 	push a 
      0011A6 0D 01            [ 1] 3615 1$: tnz (1,sp) 
      0011A8 27 09            [ 1] 3616 	jreq 9$
      0011AA F6               [ 1] 3617 	ld a,(x)
      0011AB CD 01 B3         [ 4] 3618 	call putc 
      0011AE 5C               [ 2] 3619 	incw x
      0011AF 0A 01            [ 1] 3620 	dec (1,sp)	 
      0011B1 20 F3            [ 2] 3621 	jra 1$
      0011B3 84               [ 1] 3622 9$: pop a 
      0011B4 81               [ 4] 3623 	ret	
                                   3624 
                                   3625 ;--------------------------
                                   3626 ; print TK_QSTR
                                   3627 ; converting control character
                                   3628 ; to backslash sequence
                                   3629 ; input:
                                   3630 ;   X        char *
                                   3631 ;-----------------------------
      0011B5                       3632 prt_quote:
      0011B5 A6 22            [ 1] 3633 	ld a,#'"
      0011B7 CD 01 B3         [ 4] 3634 	call putc 
      0011BA F6               [ 1] 3635 1$:	ld a,(x)
      0011BB 27 2D            [ 1] 3636 	jreq 9$
      0011BD 5C               [ 2] 3637 	incw x 
      0011BE A1 20            [ 1] 3638 	cp a,#SPACE 
      0011C0 25 0C            [ 1] 3639 	jrult 3$
      0011C2 CD 01 B3         [ 4] 3640 	call putc
      0011C5 A1 5C            [ 1] 3641 	cp a,#'\ 
      0011C7 26 F1            [ 1] 3642 	jrne 1$ 
      0011C9                       3643 2$:
      0011C9 CD 01 B3         [ 4] 3644 	call putc 
      0011CC 20 EC            [ 2] 3645 	jra 1$
      0011CE 88               [ 1] 3646 3$: push a 
      0011CF A6 5C            [ 1] 3647 	ld a,#'\
      0011D1 CD 01 B3         [ 4] 3648 	call putc 
      0011D4 84               [ 1] 3649 	pop a 
      0011D5 A0 07            [ 1] 3650 	sub a,#7
      0011D7 C7 00 0D         [ 1] 3651 	ld acc8,a 
      0011DA 72 5F 00 0C      [ 1] 3652 	clr acc16
      0011DE 90 AE 0A 14      [ 2] 3653 	ldw y,#escaped 
      0011E2 72 B9 00 0C      [ 2] 3654 	addw y,acc16 
      0011E6 90 F6            [ 1] 3655 	ld a,(y)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 71.
Hexadecimal [24-Bits]



      0011E8 20 DF            [ 2] 3656 	jra 2$
      0011EA A6 22            [ 1] 3657 9$: ld a,#'"
      0011EC CD 01 B3         [ 4] 3658 	call putc 
      0011EF 5C               [ 2] 3659 	incw x 
      0011F0 81               [ 4] 3660 	ret
                                   3661 
                                   3662 
                                   3663 ;--------------------------
                                   3664 ; decompile line from token list 
                                   3665 ; input:
                                   3666 ;   A       stop at this position 
                                   3667 ;   X 		pointer at line
                                   3668 ; output:
                                   3669 ;   none 
                                   3670 ;--------------------------	
                           000001  3671 	BASE_SAV=1
                           000002  3672 	WIDTH_SAV=2
                           000003  3673 	XSAVE=3
                           000005  3674 	LLEN=5
                           000005  3675 	VSIZE=5 
      0011F1                       3676 prt_basic_line:
      0011F1                       3677 	_vars VSIZE
      0011F1 52 05            [ 2]    1     sub sp,#VSIZE 
      0011F3 6B 05            [ 1] 3678 	ld (LLEN,sp),a  
      0011F5 C6 00 0A         [ 1] 3679 	ld a,base
      0011F8 6B 01            [ 1] 3680 	ld (BASE_SAV,sp),a  
      0011FA C6 00 26         [ 1] 3681 	ld a,tab_width 
      0011FD 6B 02            [ 1] 3682 	ld (WIDTH_SAV,sp),a 
      0011FF CF 00 17         [ 2] 3683 	ldw ptr16,x
      001202 FE               [ 2] 3684 	ldw x,(x)
      001203 35 0A 00 0A      [ 1] 3685 	mov base,#10
      001207 35 05 00 26      [ 1] 3686 	mov tab_width,#5
      00120B CD 08 4A         [ 4] 3687 	call print_int ; print line number 
      00120E A6 20            [ 1] 3688 	ld a,#SPACE 
      001210 CD 01 B3         [ 4] 3689 	call putc 
      001213 72 5F 00 26      [ 1] 3690 	clr tab_width
      001217 AE 00 03         [ 2] 3691 	ldw x,#3
      00121A 9F               [ 1] 3692 1$:	ld a,xl 
      00121B 11 05            [ 1] 3693 	cp a,(LLEN,sp)
      00121D 2B 03            [ 1] 3694 	jrmi 20$
      00121F CC 13 24         [ 2] 3695 	jp 90$
      001222                       3696 20$:	 
      001222 72 D6 00 17      [ 4] 3697 	ld a,([ptr16],x)
      001226 5C               [ 2] 3698 	incw x 
      001227 1F 03            [ 2] 3699 	ldw (XSAVE,sp),x 
      001229 A1 06            [ 1] 3700 	cp a,#TK_CMD 
      00122B 25 44            [ 1] 3701 	jrult 5$
      00122D A1 08            [ 1] 3702 	cp a,#TK_CFUNC 
      00122F 22 2F            [ 1] 3703 	jrugt 4$
      001231                       3704 2$:	
      001231 72 DE 00 17      [ 5] 3705 	ldw x,([ptr16],x)
      001235 A3 14 46         [ 2] 3706 	cpw x,#rem 
      001238 26 14            [ 1] 3707 	jrne 3$
      00123A A6 27            [ 1] 3708 	ld a,#''
      00123C CD 01 B3         [ 4] 3709 	call putc 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 72.
Hexadecimal [24-Bits]



      00123F 1E 03            [ 2] 3710 	ldw x,(XSAVE,sp)
      001241 1C 00 02         [ 2] 3711 	addw x,#2
      001244 72 BB 00 17      [ 2] 3712 	addw x,ptr16  
      001248 CD 01 C6         [ 4] 3713 	call puts 
      00124B CC 13 24         [ 2] 3714 	jp 90$ 
      00124E CD 0D F0         [ 4] 3715 3$:	call cmd_name
      001251 CD 11 A1         [ 4] 3716 	call prt_cmd_name
      001254 A6 20            [ 1] 3717 	ld a,#SPACE 
      001256 CD 01 B3         [ 4] 3718 	call putc 
      001259 1E 03            [ 2] 3719 	ldw x,(XSAVE,sp)
      00125B 1C 00 02         [ 2] 3720 	addw x,#2
      00125E 20 BA            [ 2] 3721 	jra 1$
      001260 A1 0A            [ 1] 3722 4$: cp a,#TK_QSTR 
      001262 26 0D            [ 1] 3723 	jrne 5$
      001264 72 BB 00 17      [ 2] 3724 	addw x,ptr16
      001268 CD 11 B5         [ 4] 3725 	call prt_quote 
      00126B 72 B0 00 17      [ 2] 3726 	subw x,ptr16  
      00126F 20 A9            [ 2] 3727 	jra 1$
      001271 A1 05            [ 1] 3728 5$:	cp a,#TK_VAR
      001273 26 1A            [ 1] 3729 	jrne 6$ 
      001275 72 DE 00 17      [ 5] 3730 	ldw x,([ptr16],x)
      001279 1D 00 28         [ 2] 3731 	subw x,#vars 
      00127C 9F               [ 1] 3732 	ld a,xl
      00127D 44               [ 1] 3733 	srl a 
      00127E AB 41            [ 1] 3734 	add a,#'A 
      001280 CD 01 B3         [ 4] 3735 	call putc 
      001283 A6 20            [ 1] 3736 	ld a,#SPACE 
      001285 CD 01 B3         [ 4] 3737 	call putc 
      001288 1E 03            [ 2] 3738 	ldw x,(XSAVE,sp)
      00128A 1C 00 02         [ 2] 3739 	addw x,#2 
      00128D 20 8B            [ 2] 3740 	jra 1$ 
      00128F A1 02            [ 1] 3741 6$: cp a,#TK_ARRAY 
      001291 26 0A            [ 1] 3742 	jrne 7$
      001293 A6 40            [ 1] 3743 	ld a,#'@ 
      001295 CD 01 B3         [ 4] 3744 	call putc 
      001298 1E 03            [ 2] 3745 	ldw x,(XSAVE,sp)
      00129A CC 12 1A         [ 2] 3746 	jp 1$ 
      00129D A1 04            [ 1] 3747 7$: cp a,#TK_INTGR 
      00129F 26 0F            [ 1] 3748 	jrne 8$
      0012A1 72 DE 00 17      [ 5] 3749 	ldw x,([ptr16],x)
      0012A5 CD 08 4A         [ 4] 3750 	call print_int
                                   3751 ;	ld a,#SPACE 
                                   3752 ;	call putc 
      0012A8 1E 03            [ 2] 3753 	ldw x,(XSAVE,sp)
      0012AA 1C 00 02         [ 2] 3754 	addw x,#2 
      0012AD CC 12 1A         [ 2] 3755 	jp 1$
      0012B0 A1 31            [ 1] 3756 8$: cp a,#TK_GT 
      0012B2 2B 1A            [ 1] 3757 	jrmi 9$
      0012B4 A1 35            [ 1] 3758 	cp a,#TK_NE 
      0012B6 22 16            [ 1] 3759 	jrugt 9$
      0012B8 A0 31            [ 1] 3760 	sub a,#TK_GT  
      0012BA 48               [ 1] 3761 	sll a 
      0012BB 90 5F            [ 1] 3762 	clrw y 
      0012BD 90 97            [ 1] 3763 	ld yl,a 
      0012BF 72 A9 13 3D      [ 2] 3764 	addw y,#relop_str 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 73.
Hexadecimal [24-Bits]



      0012C3 90 FE            [ 2] 3765 	ldw y,(y)
      0012C5 93               [ 1] 3766 	ldw x,y 
      0012C6 CD 01 C6         [ 4] 3767 	call puts 
      0012C9 1E 03            [ 2] 3768 	ldw x,(XSAVE,sp)
      0012CB CC 12 1A         [ 2] 3769 	jp 1$
      0012CE A1 10            [ 1] 3770 9$: cp a,#TK_PLUS 
      0012D0 26 04            [ 1] 3771 	jrne 10$
      0012D2 A6 2B            [ 1] 3772 	ld a,#'+
      0012D4 20 46            [ 2] 3773 	jra 80$ 
      0012D6 A1 11            [ 1] 3774 10$: cp a,#TK_MINUS
      0012D8 26 04            [ 1] 3775 	jrne 11$
      0012DA A6 2D            [ 1] 3776 	ld a,#'-
      0012DC 20 3E            [ 2] 3777 	jra 80$
      0012DE A1 20            [ 1] 3778 11$: cp a,#TK_MULT 
      0012E0 2B 0E            [ 1] 3779 	jrmi 12$
      0012E2 A1 22            [ 1] 3780 	cp a,#TK_MOD 
      0012E4 22 0A            [ 1] 3781 	jrugt 12$
      0012E6 A0 20            [ 1] 3782 	sub a,#0x20
      0012E8 5F               [ 1] 3783 	clrw x 
      0012E9 97               [ 1] 3784 	ld xl,a 
      0012EA 1C 13 3A         [ 2] 3785 	addw x,#mul_char 
      0012ED F6               [ 1] 3786 	ld a,(x)
      0012EE 20 2C            [ 2] 3787 	jra 80$ 
      0012F0 A1 0B            [ 1] 3788 12$: cp a,#TK_LPAREN 
      0012F2 2B 0E            [ 1] 3789 	jrmi 13$
      0012F4 A1 0E            [ 1] 3790 	cp a,#TK_SHARP 
      0012F6 22 0A            [ 1] 3791 	jrugt 13$
      0012F8 A0 0B            [ 1] 3792 	sub a,#TK_LPAREN
      0012FA 5F               [ 1] 3793 	clrw x 
      0012FB 97               [ 1] 3794 	ld xl,a 
      0012FC 1C 13 36         [ 2] 3795 	addw x,#single_char 
      0012FF F6               [ 1] 3796 	ld a,(x)
      001300 20 1A            [ 2] 3797 	jra 80$
      001302 A1 03            [ 1] 3798 13$: cp a,#TK_CHAR 
      001304 26 14            [ 1] 3799 	jrne 14$
      001306 A6 5C            [ 1] 3800 	ld a,#'\
      001308 CD 01 B3         [ 4] 3801 	call putc 
      00130B 1E 03            [ 2] 3802 	ldw x,(XSAVE,sp)
      00130D 72 D6 00 17      [ 4] 3803 	ld a,([ptr16],x)
      001311 5C               [ 2] 3804 	incw x 
      001312 1F 03            [ 2] 3805 	ldw (XSAVE,sp),x 
      001314 CD 01 B3         [ 4] 3806 	call putc 
      001317 CC 12 1A         [ 2] 3807 	jp 1$ 
      00131A A6 3A            [ 1] 3808 14$: ld a,#':
      00131C CD 01 B3         [ 4] 3809 80$: call putc 
      00131F 1E 03            [ 2] 3810 	ldw x,(XSAVE,sp)
      001321 CC 12 1A         [ 2] 3811 	jp 1$ 
      001324                       3812 90$: 
      001324 A6 0D            [ 1] 3813 	ld a,#CR 
      001326 CD 01 B3         [ 4] 3814 	call putc
      001329 7B 02            [ 1] 3815 	ld a,(WIDTH_SAV,sp) 
      00132B C7 00 26         [ 1] 3816 	ld tab_width,a 
      00132E 7B 01            [ 1] 3817 	ld a,(BASE_SAV,sp) 
      001330 C7 00 0A         [ 1] 3818 	ld base,a
      001333                       3819 	_drop VSIZE 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 74.
Hexadecimal [24-Bits]



      001333 5B 05            [ 2]    1     addw sp,#VSIZE 
      001335 81               [ 4] 3820 	ret 	
      001336 28 29 2C 23           3821 single_char: .byte '(',')',',','#'
      00133A 2A 2F 25              3822 mul_char: .byte '*','/','%'
      00133D 13 49 13 4B 13 4D 13  3823 relop_str: .word gt,equal,ge,lt,le,ne 
             50 13 52 13 55
      001349 3E 00                 3824 gt: .asciz ">"
      00134B 3D 00                 3825 equal: .asciz "="
      00134D 3E 3D 00              3826 ge: .asciz ">="
      001350 3C 00                 3827 lt: .asciz "<"
      001352 3C 3D 00              3828 le: .asciz "<="
      001355 3C 3E 00              3829 ne:  .asciz "<>"
                                   3830 
                                   3831 
                                   3832 ;---------------------------------
                                   3833 ; BASIC: PRINT|? arg_list 
                                   3834 ; print values from argument list
                                   3835 ;----------------------------------
                           000001  3836 	COMMA=1
                           000001  3837 	VSIZE=1
      001358                       3838 print:
      001358 4B 00            [ 1] 3839 push #0 ; local variable COMMA 
      00135A                       3840 reset_comma:
      00135A 0F 01            [ 1] 3841 	clr (COMMA,sp)
      00135C                       3842 prt_loop:
      00135C CD 0F D4         [ 4] 3843 	call relation 
      00135F A1 01            [ 1] 3844 	cp a,#TK_COLON 
      001361 27 53            [ 1] 3845 	jreq print_exit   
      001363 A1 04            [ 1] 3846 	cp a,#TK_INTGR 
      001365 26 05            [ 1] 3847 	jrne 0$ 
      001367 CD 08 4A         [ 4] 3848 	call print_int 
      00136A 20 EE            [ 2] 3849 	jra reset_comma
      00136C                       3850 0$: 	
      00136C CD 07 B5         [ 4] 3851 	call next_token
      00136F A1 00            [ 1] 3852 	cp a,#TK_NONE 
      001371 27 43            [ 1] 3853 	jreq print_exit 
      001373 A1 0A            [ 1] 3854 1$:	cp a,#TK_QSTR
      001375 26 05            [ 1] 3855 	jrne 2$   
      001377 CD 01 C6         [ 4] 3856 	call puts
      00137A 20 DE            [ 2] 3857 	jra reset_comma
      00137C A1 03            [ 1] 3858 2$: cp a,#TK_CHAR 
      00137E 26 06            [ 1] 3859 	jrne 3$
      001380 9F               [ 1] 3860 	ld a,xl 
      001381 CD 01 B3         [ 4] 3861 	call putc 
      001384 20 D4            [ 2] 3862 	jra reset_comma 
      001386                       3863 3$: 	
      001386 A1 08            [ 1] 3864 	cp a,#TK_CFUNC 
      001388 26 07            [ 1] 3865 	jrne 4$ 
      00138A FD               [ 4] 3866 	call (x)
      00138B 9F               [ 1] 3867 	ld a,xl 
      00138C CD 01 B3         [ 4] 3868 	call putc
      00138F 20 C9            [ 2] 3869 	jra reset_comma 
      001391                       3870 4$: 
      001391 A1 0D            [ 1] 3871 	cp a,#TK_COMMA 
      001393 26 05            [ 1] 3872 	jrne 5$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 75.
Hexadecimal [24-Bits]



      001395 03 01            [ 1] 3873 	cpl (COMMA,sp) 
      001397 CC 13 5C         [ 2] 3874 	jp prt_loop   
      00139A                       3875 5$: 
      00139A A1 0E            [ 1] 3876 	cp a,#TK_SHARP
      00139C 26 13            [ 1] 3877 	jrne 7$
      00139E CD 07 B5         [ 4] 3878 	call next_token
      0013A1 A1 04            [ 1] 3879 	cp a,#TK_INTGR 
      0013A3 27 03            [ 1] 3880 	jreq 6$
      0013A5 CC 07 01         [ 2] 3881 	jp syntax_error 
      0013A8                       3882 6$:
      0013A8 9F               [ 1] 3883 	ld a,xl 
      0013A9 A4 0F            [ 1] 3884 	and a,#15 
      0013AB C7 00 26         [ 1] 3885 	ld tab_width,a 
      0013AE CC 13 5A         [ 2] 3886 	jp reset_comma 
      0013B1                       3887 7$:	
      0013B1                       3888 	_unget_token
      0013B1 55 00 02 00 01   [ 1]    1     mov in,in.saved
      0013B6                       3889 print_exit:
      0013B6 0D 01            [ 1] 3890 	tnz (COMMA,sp)
      0013B8 26 05            [ 1] 3891 	jrne 9$
      0013BA A6 0D            [ 1] 3892 	ld a,#CR 
      0013BC CD 01 B3         [ 4] 3893     call putc 
      0013BF                       3894 9$:	_drop VSIZE 
      0013BF 5B 01            [ 2]    1     addw sp,#VSIZE 
      0013C1 81               [ 4] 3895 	ret 
                                   3896 
                                   3897 ;----------------------
                                   3898 ; 'save_context' and
                                   3899 ; 'rest_context' must be 
                                   3900 ; called at the same 
                                   3901 ; call stack depth 
                                   3902 ; i.e. SP must have the 
                                   3903 ; save value at  
                                   3904 ; entry point of both 
                                   3905 ; routine. 
                                   3906 ;---------------------
                           000004  3907 	CTXT_SIZE=4 ; size of saved data 
                                   3908 ;--------------------
                                   3909 ; save current BASIC
                                   3910 ; interpreter context 
                                   3911 ; on stack 
                                   3912 ;--------------------
      0013C2                       3913 	_argofs 0 
                           000002     1     ARG_OFS=2+0 
      0013C2                       3914 	_arg BPTR 1
                           000003     1     BPTR=ARG_OFS+1 
      0013C2                       3915 	_arg IN 3
                           000005     1     IN=ARG_OFS+3 
      0013C2                       3916 	_arg CNT 4
                           000006     1     CNT=ARG_OFS+4 
      0013C2                       3917 save_context:
      0013C2 CE 00 04         [ 2] 3918 	ldw x,basicptr 
      0013C5 1F 03            [ 2] 3919 	ldw (BPTR,sp),x
      0013C7 C6 00 01         [ 1] 3920 	ld a,in 
      0013CA 6B 05            [ 1] 3921 	ld (IN,sp),a
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 76.
Hexadecimal [24-Bits]



      0013CC C6 00 03         [ 1] 3922 	ld a,count 
      0013CF 6B 06            [ 1] 3923 	ld (CNT,sp),a  
      0013D1 81               [ 4] 3924 	ret
                                   3925 
                                   3926 ;-----------------------
                                   3927 ; restore previously saved 
                                   3928 ; BASIC interpreter context 
                                   3929 ; from stack 
                                   3930 ;-------------------------
      0013D2                       3931 rest_context:
      0013D2 1E 03            [ 2] 3932 	ldw x,(BPTR,sp)
      0013D4 CF 00 04         [ 2] 3933 	ldw basicptr,x 
      0013D7 7B 05            [ 1] 3934 	ld a,(IN,sp)
      0013D9 C7 00 01         [ 1] 3935 	ld in,a
      0013DC 7B 06            [ 1] 3936 	ld a,(CNT,sp)
      0013DE C7 00 03         [ 1] 3937 	ld count,a  
      0013E1 81               [ 4] 3938 	ret
                                   3939 
                                   3940 ;------------------------------------------
                                   3941 ; BASIC: INPUT [string],var[,[string],var]
                                   3942 ; input value in variables 
                                   3943 ; [string] optionally can be used as prompt 
                                   3944 ;-----------------------------------------
                           000001  3945 	CX_BPTR=1
                           000003  3946 	CX_IN=3
                           000004  3947 	CX_CNT=4
                           000005  3948 	SKIP=5
                           000006  3949 	VAR_ADDR=6 
                           000007  3950 	VSIZE=7
      0013E2                       3951 input_var:
      0013E2                       3952 	_vars VSIZE 
      0013E2 52 07            [ 2]    1     sub sp,#VSIZE 
      0013E4                       3953 input_loop:
      0013E4 0F 05            [ 1] 3954 	clr (SKIP,sp)
      0013E6 CD 07 B5         [ 4] 3955 	call next_token 
      0013E9 A1 0A            [ 1] 3956 	cp a,#TK_QSTR 
      0013EB 26 08            [ 1] 3957 	jrne 1$ 
      0013ED CD 01 C6         [ 4] 3958 	call puts 
      0013F0 03 05            [ 1] 3959 	cpl (SKIP,sp)
      0013F2 CD 07 B5         [ 4] 3960 	call next_token 
      0013F5 A1 05            [ 1] 3961 1$: cp a,#TK_VAR  
      0013F7 27 03            [ 1] 3962 	jreq 2$ 
      0013F9 CC 07 01         [ 2] 3963 	jp syntax_error
      0013FC 1F 06            [ 2] 3964 2$:	ldw (VAR_ADDR,sp),x 
      0013FE 0D 05            [ 1] 3965 	tnz (SKIP,sp)
      001400 26 06            [ 1] 3966 	jrne 21$ 
                                   3967 ;	clr pad+2
      001402 AE 17 38         [ 2] 3968 	ldw x,#pad 
      001405 CD 01 C6         [ 4] 3969 	call puts   
      001408                       3970 21$:
      001408 A6 3A            [ 1] 3971 	ld a,#':
      00140A CD 01 B3         [ 4] 3972 	call putc 
      00140D CD 13 C2         [ 4] 3973 	call save_context 
      001410 72 5F 00 03      [ 1] 3974 	clr count  
      001414 CD 09 3A         [ 4] 3975 	call readln 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 77.
Hexadecimal [24-Bits]



      001417 AE 16 E8         [ 2] 3976 	ldw x,#tib 
      00141A CF 00 04         [ 2] 3977 	ldw basicptr,x  
      00141D 72 5F 00 01      [ 1] 3978 	clr in 
      001421 CD 0A B9         [ 4] 3979 	call get_token
      001424 A1 04            [ 1] 3980 	cp a,#TK_INTGR
      001426 27 06            [ 1] 3981 	jreq 3$ 
      001428 CD 13 D2         [ 4] 3982 	call rest_context 
      00142B CC 07 01         [ 2] 3983 	jp syntax_error
      00142E 90 85            [ 2] 3984 3$: popw y 
      001430 90 FF            [ 2] 3985 	ldw (y),x 
      001432 CD 13 D2         [ 4] 3986 	call rest_context
      001435 CD 07 B5         [ 4] 3987 	call next_token 
      001438 A1 0D            [ 1] 3988 	cp a,#TK_COMMA 
      00143A 27 A8            [ 1] 3989 	jreq input_loop 
      00143C A1 01            [ 1] 3990 	cp a,#TK_COLON 
      00143E 23 03            [ 2] 3991     jrule input_exit 
      001440 CC 07 01         [ 2] 3992 	jp syntax_error 
      001443                       3993 input_exit:
      001443                       3994 	_drop VSIZE 
      001443 5B 07            [ 2]    1     addw sp,#VSIZE 
      001445 81               [ 4] 3995 	ret 
                                   3996 
                                   3997 
                                   3998 ;---------------------
                                   3999 ; BASIC: REMARK | ' 
                                   4000 ; skip comment to end of line 
                                   4001 ;---------------------- 
      001446                       4002 rem:
      001446 55 00 01 00 03   [ 1] 4003  	mov count,in 
      00144B 81               [ 4] 4004 	ret 
                                   4005 
                                   4006 ;---------------------
                                   4007 ; BASIC: WAIT addr,mask[,xor_mask] 
                                   4008 ; read in loop 'addr'  
                                   4009 ; apply & 'mask' to value 
                                   4010 ; loop while result==0.  
                                   4011 ; if 'xor_mask' given 
                                   4012 ; apply ^ in second  
                                   4013 ; loop while result==0 
                                   4014 ;---------------------
                           000001  4015 	XMASK=1 
                           000002  4016 	MASK=2
                           000003  4017 	ADDR=3
                           000004  4018 	VSIZE=4
      00144C                       4019 wait: 
      00144C                       4020 	_vars VSIZE
      00144C 52 04            [ 2]    1     sub sp,#VSIZE 
      00144E 0F 01            [ 1] 4021 	clr (XMASK,sp) 
      001450 CD 0E 84         [ 4] 4022 	call arg_list 
      001453 A1 02            [ 1] 4023 	cp a,#2
      001455 24 03            [ 1] 4024 	jruge 0$
      001457 CC 07 01         [ 2] 4025 	jp syntax_error 
      00145A A1 03            [ 1] 4026 0$:	cp a,#3
      00145C 25 04            [ 1] 4027 	jrult 1$
      00145E 85               [ 2] 4028 	popw x 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 78.
Hexadecimal [24-Bits]



      00145F 9F               [ 1] 4029 	ld a,xl
      001460 6B 01            [ 1] 4030 	ld (XMASK,sp),a 
      001462 85               [ 2] 4031 1$: popw x ; mask 
      001463 9F               [ 1] 4032 	ld a,xl 
      001464 6B 02            [ 1] 4033 	ld (MASK,sp),a 
      001466 85               [ 2] 4034 	popw x ; address 
      001467 F6               [ 1] 4035 2$:	ld a,(x)
      001468 14 02            [ 1] 4036 	and a,(MASK,sp)
      00146A 18 01            [ 1] 4037 	xor a,(XMASK,sp)
      00146C 27 F9            [ 1] 4038 	jreq 2$ 
      00146E                       4039 	_drop VSIZE 
      00146E 5B 04            [ 2]    1     addw sp,#VSIZE 
      001470 81               [ 4] 4040 	ret 
                                   4041 
                                   4042 ;---------------------
                                   4043 ; BASIC: BSET addr,mask
                                   4044 ; set bits at 'addr' corresponding 
                                   4045 ; to those of 'mask' that are at 1.
                                   4046 ; arguments:
                                   4047 ; 	addr 		memory address RAM|PERIPHERAL 
                                   4048 ;   mask        mask|addr
                                   4049 ; output:
                                   4050 ;	none 
                                   4051 ;--------------------------
      001471                       4052 bit_set:
      001471 CD 0E 84         [ 4] 4053 	call arg_list 
      001474 A1 02            [ 1] 4054 	cp a,#2	 
      001476 27 03            [ 1] 4055 	jreq 1$ 
      001478 CC 07 01         [ 2] 4056 	jp syntax_error
      00147B                       4057 1$: 
      00147B 85               [ 2] 4058 	popw x ; mask 
      00147C 9F               [ 1] 4059 	ld a,xl 
      00147D 85               [ 2] 4060 	popw x ; addr  
      00147E FA               [ 1] 4061 	or a,(x)
      00147F F7               [ 1] 4062 	ld (x),a
      001480 81               [ 4] 4063 	ret 
                                   4064 
                                   4065 ;---------------------
                                   4066 ; BASIC: BRES addr,mask
                                   4067 ; reset bits at 'addr' corresponding 
                                   4068 ; to those of 'mask' that are at 1.
                                   4069 ; arguments:
                                   4070 ; 	addr 		memory address RAM|PERIPHERAL 
                                   4071 ;   mask	    ~mask&*addr  
                                   4072 ; output:
                                   4073 ;	none 
                                   4074 ;--------------------------
      001481                       4075 bit_reset:
      001481 CD 0E 84         [ 4] 4076 	call arg_list 
      001484 A1 02            [ 1] 4077 	cp a,#2  
      001486 27 03            [ 1] 4078 	jreq 1$ 
      001488 CC 07 01         [ 2] 4079 	jp syntax_error
      00148B                       4080 1$: 
      00148B 85               [ 2] 4081 	popw x ; mask 
      00148C 9F               [ 1] 4082 	ld a,xl 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 79.
Hexadecimal [24-Bits]



      00148D 43               [ 1] 4083 	cpl a 
      00148E 85               [ 2] 4084 	popw x ; addr  
      00148F F4               [ 1] 4085 	and a,(x)
      001490 F7               [ 1] 4086 	ld (x),a 
      001491 81               [ 4] 4087 	ret 
                                   4088 
                                   4089 ;---------------------
                                   4090 ; BASIC: BTOGL addr,mask
                                   4091 ; toggle bits at 'addr' corresponding 
                                   4092 ; to those of 'mask' that are at 1.
                                   4093 ; arguments:
                                   4094 ; 	addr 		memory address RAM|PERIPHERAL 
                                   4095 ;   mask	    mask^*addr  
                                   4096 ; output:
                                   4097 ;	none 
                                   4098 ;--------------------------
      001492                       4099 bit_toggle:
      001492 CD 0E 84         [ 4] 4100 	call arg_list 
      001495 A1 02            [ 1] 4101 	cp a,#2 
      001497 27 03            [ 1] 4102 	jreq 1$ 
      001499 CC 07 01         [ 2] 4103 	jp syntax_error
      00149C 85               [ 2] 4104 1$: popw x ; mask 
      00149D 9F               [ 1] 4105 	ld a,xl 
      00149E 85               [ 2] 4106 	popw x ; addr  
      00149F F8               [ 1] 4107 	xor a,(x)
      0014A0 F7               [ 1] 4108 	ld (x),a 
      0014A1 81               [ 4] 4109 	ret 
                                   4110 
                                   4111 
                                   4112 ;---------------------
                                   4113 ; BASIC: BTEST(addr,bit)
                                   4114 ; return bit value at 'addr' 
                                   4115 ; bit is in range {0..7}.
                                   4116 ; arguments:
                                   4117 ; 	addr 		memory address RAM|PERIPHERAL 
                                   4118 ;   bit 	    bit position {0..7}  
                                   4119 ; output:
                                   4120 ;	none 
                                   4121 ;--------------------------
      0014A2                       4122 bit_test:
      0014A2 CD 0E AB         [ 4] 4123 	call func_args 
      0014A5 A1 02            [ 1] 4124 	cp a,#2
      0014A7 27 03            [ 1] 4125 	jreq 0$
      0014A9 CC 07 01         [ 2] 4126 	jp syntax_error
      0014AC                       4127 0$:	
      0014AC 85               [ 2] 4128 	popw x 
      0014AD 9F               [ 1] 4129 	ld a,xl 
      0014AE A4 07            [ 1] 4130 	and a,#7
      0014B0 88               [ 1] 4131 	push a   
      0014B1 A6 01            [ 1] 4132 	ld a,#1 
      0014B3 0D 01            [ 1] 4133 1$: tnz (1,sp)
      0014B5 27 05            [ 1] 4134 	jreq 2$
      0014B7 48               [ 1] 4135 	sll a 
      0014B8 0A 01            [ 1] 4136 	dec (1,sp)
      0014BA 20 F7            [ 2] 4137 	jra 1$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 80.
Hexadecimal [24-Bits]



      0014BC                       4138 2$: _drop 1 
      0014BC 5B 01            [ 2]    1     addw sp,#1 
      0014BE 85               [ 2] 4139 	popw x 
      0014BF F4               [ 1] 4140 	and a,(x)
      0014C0 27 02            [ 1] 4141 	jreq 3$
      0014C2 A6 01            [ 1] 4142 	ld a,#1 
      0014C4 5F               [ 1] 4143 3$:	clrw x 
      0014C5 97               [ 1] 4144 	ld xl,a 
      0014C6 A6 04            [ 1] 4145 	ld a,#TK_INTGR
      0014C8 81               [ 4] 4146 	ret
                                   4147 
                                   4148 
                                   4149 ;--------------------
                                   4150 ; BASIC: POKE addr,byte
                                   4151 ; put a byte at addr 
                                   4152 ;--------------------
      0014C9                       4153 poke:
      0014C9 CD 0E 84         [ 4] 4154 	call arg_list 
      0014CC A1 02            [ 1] 4155 	cp a,#2
      0014CE 27 03            [ 1] 4156 	jreq 1$
      0014D0 CC 07 01         [ 2] 4157 	jp syntax_error
      0014D3                       4158 1$:	
      0014D3 85               [ 2] 4159 	popw x  
      0014D4 9F               [ 1] 4160     ld a,xl 
      0014D5 85               [ 2] 4161 	popw x 
      0014D6 F7               [ 1] 4162 	ld (x),a 
      0014D7 81               [ 4] 4163 	ret 
                                   4164 
                                   4165 ;-----------------------
                                   4166 ; BASIC: PEEK(addr)
                                   4167 ; get the byte at addr 
                                   4168 ; input:
                                   4169 ;	none 
                                   4170 ; output:
                                   4171 ;	X 		value 
                                   4172 ;-----------------------
      0014D8                       4173 peek:
      0014D8 CD 0E AB         [ 4] 4174 	call func_args
      0014DB A1 01            [ 1] 4175 	cp a,#1
      0014DD 27 03            [ 1] 4176 	jreq 1$
      0014DF CC 07 01         [ 2] 4177 	jp syntax_error
      0014E2 85               [ 2] 4178 1$:	popw x 
      0014E3 F6               [ 1] 4179 	ld a,(x)
      0014E4 5F               [ 1] 4180 	clrw x 
      0014E5 97               [ 1] 4181 	ld xl,a 
      0014E6 A6 04            [ 1] 4182 	ld a,#TK_INTGR
      0014E8 81               [ 4] 4183 	ret 
                                   4184 
                                   4185 ;----------------------------
                                   4186 ; BASIC: XPEEK(page,addr)
                                   4187 ; read extended memory byte
                                   4188 ; page in range {0,1,2}
                                   4189 ;----------------------------
      0014E9                       4190 xpeek:
      0014E9 CD 0E AB         [ 4] 4191 	call func_args 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 81.
Hexadecimal [24-Bits]



      0014EC A1 02            [ 1] 4192 	cp a,#2 
      0014EE 27 03            [ 1] 4193 	jreq 1$
      0014F0 CC 07 01         [ 2] 4194 	jp syntax_error
      0014F3                       4195 1$: 
      0014F3 85               [ 2] 4196 	popw x  
      0014F4 CF 00 17         [ 2] 4197 	ldw farptr+1,x 
      0014F7 85               [ 2] 4198 	popw x 
      0014F8 9F               [ 1] 4199 	ld a,xl 
      0014F9 C7 00 16         [ 1] 4200 	ld farptr,a 
      0014FC 5F               [ 1] 4201 	clrw x
      0014FD 92 BC 00 16      [ 5] 4202 	ldf a,[farptr]
      001501 97               [ 1] 4203 	ld xl,a 
      001502 A6 04            [ 1] 4204 	ld a,#TK_INTGR 
      001504 81               [ 4] 4205 	ret 
                                   4206 
                                   4207 ;---------------------------
                                   4208 ; BASIC IF expr : instructions
                                   4209 ; evaluate expr and if true 
                                   4210 ; execute instructions on same line. 
                                   4211 ;----------------------------
      001505                       4212 if: 
      001505 CD 0F D4         [ 4] 4213 	call relation 
      001508 A1 04            [ 1] 4214 	cp a,#TK_INTGR
      00150A 27 03            [ 1] 4215 	jreq 1$ 
      00150C CC 07 01         [ 2] 4216 	jp syntax_error
      00150F 4F               [ 1] 4217 1$:	clr a 
      001510 5D               [ 2] 4218 	tnzw x 
      001511 26 05            [ 1] 4219 	jrne 9$  
                                   4220 ;skip to next line
      001513 55 00 03 00 01   [ 1] 4221 	mov in,count
      001518 81               [ 4] 4222 9$:	ret 
                                   4223 
                                   4224 ;------------------------
                                   4225 ; BASIC: FOR var=expr 
                                   4226 ; set variable to expression 
                                   4227 ; leave variable address 
                                   4228 ; on stack and set
                                   4229 ; FLOOP bit in 'flags'
                                   4230 ;-----------------
                           000001  4231 	RETL1=1 ; return address  
                           000003  4232 	FSTEP=3  ; variable increment
                           000005  4233 	LIMIT=5 ; loop limit 
                           000007  4234 	CVAR=7   ; control variable 
                           000009  4235 	INW=9   ;  in.w saved
                           00000B  4236 	BPTR=11 ; baseptr saved
                           00000A  4237 	VSIZE=10  
      001519                       4238 for: ; { -- var_addr }
      001519 85               [ 2] 4239 	popw x ; call return address 
      00151A                       4240 	_vars VSIZE 
      00151A 52 0A            [ 2]    1     sub sp,#VSIZE 
      00151C 89               [ 2] 4241 	pushw x  ; RETL1 
      00151D A6 05            [ 1] 4242 	ld a,#TK_VAR 
      00151F CD 0E 77         [ 4] 4243 	call expect
      001522 1F 07            [ 2] 4244 	ldw (CVAR,sp),x  ; control variable 
      001524 CD 11 0D         [ 4] 4245 	call let02 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 82.
Hexadecimal [24-Bits]



      001527 72 14 00 25      [ 1] 4246 	bset flags,#FLOOP 
                                   4247 ; open space on stack for loop data 
      00152B 5F               [ 1] 4248 	clrw x 
      00152C 1F 0B            [ 2] 4249 	ldw (BPTR,sp),x 
      00152E 1F 09            [ 2] 4250 	ldw (INW,sp),x 
      001530 CD 07 B5         [ 4] 4251 	call next_token 
      001533 A1 06            [ 1] 4252 	cp a,#TK_CMD 
      001535 27 03            [ 1] 4253 	jreq 1$
      001537 CC 07 01         [ 2] 4254 	jp syntax_error
      00153A                       4255 1$:  
      00153A A3 15 42         [ 2] 4256 	cpw x,#to 
      00153D 27 03            [ 1] 4257 	jreq to
      00153F CC 07 01         [ 2] 4258 	jp syntax_error 
                                   4259 
                                   4260 ;-----------------------------------
                                   4261 ; BASIC: TO expr 
                                   4262 ; second part of FOR loop initilization
                                   4263 ; leave limit on stack and set 
                                   4264 ; FTO bit in 'flags'
                                   4265 ;-----------------------------------
      001542                       4266 to: ; { var_addr -- var_addr limit step }
      001542 72 04 00 25 03   [ 2] 4267 	btjt flags,#FLOOP,1$
      001547 CC 07 01         [ 2] 4268 	jp syntax_error
      00154A CD 0F D4         [ 4] 4269 1$: call relation  
      00154D A1 04            [ 1] 4270 	cp a,#TK_INTGR 
      00154F 27 03            [ 1] 4271 	jreq 2$ 
      001551 CC 07 01         [ 2] 4272 	jp syntax_error
      001554 1F 05            [ 2] 4273 2$: ldw (LIMIT,sp),x
                                   4274 ;	ldw x,in.w 
      001556 CD 07 B5         [ 4] 4275 	call next_token
      001559 A1 00            [ 1] 4276 	cp a,#TK_NONE  
      00155B 27 0E            [ 1] 4277 	jreq 4$ 
      00155D A1 06            [ 1] 4278 	cp a,#TK_CMD
      00155F 26 05            [ 1] 4279 	jrne 3$
      001561 A3 15 72         [ 2] 4280 	cpw x,#step 
      001564 27 0C            [ 1] 4281 	jreq step
      001566                       4282 3$:	
      001566                       4283 	_unget_token   	 
      001566 55 00 02 00 01   [ 1]    1     mov in,in.saved
      00156B                       4284 4$:	
      00156B AE 00 01         [ 2] 4285 	ldw x,#1   ; default step  
      00156E 1F 03            [ 2] 4286 	ldw (FSTEP,sp),x 
      001570 20 14            [ 2] 4287 	jra store_loop_addr 
                                   4288 
                                   4289 
                                   4290 ;----------------------------------
                                   4291 ; BASIC: STEP expr 
                                   4292 ; optional third par of FOR loop
                                   4293 ; initialization. 	
                                   4294 ;------------------------------------
      001572                       4295 step: ; {var limit -- var limit step}
      001572 72 04 00 25 03   [ 2] 4296 	btjt flags,#FLOOP,1$
      001577 CC 07 01         [ 2] 4297 	jp syntax_error
      00157A CD 0F D4         [ 4] 4298 1$: call relation
      00157D A1 04            [ 1] 4299 	cp a,#TK_INTGR
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 83.
Hexadecimal [24-Bits]



      00157F 27 03            [ 1] 4300 	jreq 2$
      001581 CC 07 01         [ 2] 4301 	jp syntax_error
      001584 1F 03            [ 2] 4302 2$:	ldw (FSTEP,sp),x ; step
                                   4303 ; leave loop back entry point on cstack 
                                   4304 ; cstack is 1 call deep from interp_loop
      001586                       4305 store_loop_addr:
      001586 CE 00 04         [ 2] 4306 	ldw x,basicptr  
      001589 1F 0B            [ 2] 4307 	ldw (BPTR,sp),x 
      00158B CE 00 00         [ 2] 4308 	ldw x,in.w 
      00158E 1F 09            [ 2] 4309 	ldw (INW,sp),x   
      001590 72 15 00 25      [ 1] 4310 	bres flags,#FLOOP 
      001594 72 5C 00 22      [ 1] 4311 	inc loop_depth  
      001598 81               [ 4] 4312 	ret 
                                   4313 
                                   4314 ;--------------------------------
                                   4315 ; BASIC: NEXT var 
                                   4316 ; FOR loop control 
                                   4317 ; increment variable with step 
                                   4318 ; and compare with limit 
                                   4319 ; loop if threshold not crossed.
                                   4320 ; else stack. 
                                   4321 ; and decrement 'loop_depth' 
                                   4322 ;--------------------------------
      001599                       4323 next: ; {var limit step retl1 -- [var limit step ] }
      001599 72 5D 00 22      [ 1] 4324 	tnz loop_depth 
      00159D 26 03            [ 1] 4325 	jrne 1$ 
      00159F CC 07 01         [ 2] 4326 	jp syntax_error 
      0015A2                       4327 1$: 
      0015A2 A6 05            [ 1] 4328 	ld a,#TK_VAR 
      0015A4 CD 0E 77         [ 4] 4329 	call expect
                                   4330 ; check for good variable after NEXT 	 
      0015A7 13 07            [ 2] 4331 	cpw x,(CVAR,sp)
      0015A9 27 03            [ 1] 4332 	jreq 2$  
      0015AB CC 07 01         [ 2] 4333 	jp syntax_error ; not the good one 
      0015AE                       4334 2$: ; increment variable 
      0015AE FE               [ 2] 4335 	ldw x,(x)  ; get var value 
      0015AF 72 FB 03         [ 2] 4336 	addw x,(FSTEP,sp) ; var+step 
      0015B2 16 07            [ 2] 4337 	ldw y,(CVAR,sp)
      0015B4 90 FF            [ 2] 4338 	ldw (y),x ; save var new value 
                                   4339 ; check sign of STEP  
      0015B6 A6 80            [ 1] 4340 	ld a,#0x80
      0015B8 15 03            [ 1] 4341 	bcp a,(FSTEP,sp)
      0015BA 2A 06            [ 1] 4342 	jrpl 4$
                                   4343 ;negative step 
      0015BC 13 05            [ 2] 4344 	cpw x,(LIMIT,sp)
      0015BE 2F 1B            [ 1] 4345 	jrslt loop_done
      0015C0 20 04            [ 2] 4346 	jra loop_back 
      0015C2                       4347 4$: ; positive step
      0015C2 13 05            [ 2] 4348 	cpw x,(LIMIT,sp)
      0015C4 2C 15            [ 1] 4349 	jrsgt loop_done
      0015C6                       4350 loop_back:
      0015C6 1E 0B            [ 2] 4351 	ldw x,(BPTR,sp)
      0015C8 CF 00 04         [ 2] 4352 	ldw basicptr,x 
      0015CB 72 01 00 25 05   [ 2] 4353 	btjf flags,#FRUN,1$ 
      0015D0 E6 02            [ 1] 4354 	ld a,(2,x)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 84.
Hexadecimal [24-Bits]



      0015D2 C7 00 03         [ 1] 4355 	ld count,a
      0015D5 1E 09            [ 2] 4356 1$:	ldw x,(INW,sp)
      0015D7 CF 00 00         [ 2] 4357 	ldw in.w,x 
      0015DA 81               [ 4] 4358 	ret 
      0015DB                       4359 loop_done:
                                   4360 	; remove loop data from stack  
      0015DB 85               [ 2] 4361 	popw x
      0015DC                       4362 	_drop VSIZE 
      0015DC 5B 0A            [ 2]    1     addw sp,#VSIZE 
      0015DE 72 5A 00 22      [ 1] 4363 	dec loop_depth 
                                   4364 ;	pushw x 
                                   4365 ;	ret 
      0015E2 FC               [ 2] 4366 	jp (x)
                                   4367 
                                   4368 ;----------------------------
                                   4369 ; called by goto/gosub
                                   4370 ; to get target line number 
                                   4371 ;---------------------------
      0015E3                       4372 get_target_line:
      0015E3 CD 0F D4         [ 4] 4373 	call relation 
      0015E6 A1 04            [ 1] 4374 	cp a,#TK_INTGR
      0015E8 27 03            [ 1] 4375 	jreq 1$
      0015EA CC 07 01         [ 2] 4376 	jp syntax_error
      0015ED CD 02 68         [ 4] 4377 1$:	call search_lineno  
      0015F0 5D               [ 2] 4378 	tnzw x 
      0015F1 26 05            [ 1] 4379 	jrne 2$ 
      0015F3 A6 05            [ 1] 4380 	ld a,#ERR_NO_LINE 
      0015F5 CC 07 03         [ 2] 4381 	jp tb_error 
      0015F8 81               [ 4] 4382 2$:	ret 
                                   4383 
                                   4384 ;------------------------
                                   4385 ; BASIC: GOTO line# 
                                   4386 ; jump to line# 
                                   4387 ; here cstack is 2 call deep from interp_loop 
                                   4388 ;------------------------
      0015F9                       4389 goto:
      0015F9 72 00 00 25 06   [ 2] 4390 	btjt flags,#FRUN,0$ 
      0015FE A6 06            [ 1] 4391 	ld a,#ERR_RUN_ONLY
      001600 CC 07 03         [ 2] 4392 	jp tb_error 
      001603 81               [ 4] 4393 	ret 
      001604 CD 15 E3         [ 4] 4394 0$:	call get_target_line
      001607                       4395 jp_to_target:
      001607 CF 00 04         [ 2] 4396 	ldw basicptr,x 
      00160A E6 02            [ 1] 4397 	ld a,(2,x)
      00160C C7 00 03         [ 1] 4398 	ld count,a 
      00160F 35 03 00 01      [ 1] 4399 	mov in,#3 
      001613 81               [ 4] 4400 	ret 
                                   4401 
                                   4402 
                                   4403 ;--------------------
                                   4404 ; BASIC: GOSUB line#
                                   4405 ; basic subroutine call
                                   4406 ; actual line# and basicptr 
                                   4407 ; are saved on cstack
                                   4408 ; here cstack is 2 call deep from interp_loop 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 85.
Hexadecimal [24-Bits]



                                   4409 ;--------------------
                           000003  4410 	RET_ADDR=3
                           000005  4411 	RET_INW=5
                           000004  4412 	VSIZE=4  
      001614                       4413 gosub:
      001614 72 00 00 25 06   [ 2] 4414 	btjt flags,#FRUN,0$ 
      001619 A6 06            [ 1] 4415 	ld a,#ERR_RUN_ONLY
      00161B CC 07 03         [ 2] 4416 	jp tb_error 
      00161E 81               [ 4] 4417 	ret 
      00161F 85               [ 2] 4418 0$:	popw x 
      001620                       4419 	_vars VSIZE  
      001620 52 04            [ 2]    1     sub sp,#VSIZE 
      001622 89               [ 2] 4420 	pushw x 
      001623 CE 00 04         [ 2] 4421 	ldw x,basicptr
      001626 1F 03            [ 2] 4422 	ldw (RET_ADDR,sp),x 
      001628 CD 15 E3         [ 4] 4423 	call get_target_line  
      00162B 89               [ 2] 4424 	pushw x 
      00162C CE 00 00         [ 2] 4425 	ldw x,in.w 
      00162F 1F 07            [ 2] 4426 	ldw (RET_INW+2,sp),x
      001631 85               [ 2] 4427 	popw x 
      001632 20 D3            [ 2] 4428 	jra jp_to_target
                                   4429 
                                   4430 ;------------------------
                                   4431 ; BASIC: RETURN 
                                   4432 ; exit from a subroutine 
                                   4433 ; 
                                   4434 ;------------------------
      001634                       4435 return:
      001634 72 00 00 25 05   [ 2] 4436 	btjt flags,#FRUN,0$ 
      001639 A6 06            [ 1] 4437 	ld a,#ERR_RUN_ONLY
      00163B CC 07 03         [ 2] 4438 	jp tb_error 
      00163E                       4439 0$:	
      00163E 1E 03            [ 2] 4440 	ldw x,(RET_ADDR,sp) 
      001640 CF 00 04         [ 2] 4441 	ldw basicptr,x
      001643 E6 02            [ 1] 4442 	ld a,(2,x)
      001645 C7 00 03         [ 1] 4443 	ld count,a  
      001648 1E 05            [ 2] 4444 	ldw x,(RET_INW,sp)
      00164A CF 00 00         [ 2] 4445 	ldw in.w,x 
      00164D 85               [ 2] 4446 	popw x 
      00164E                       4447 	_drop VSIZE 
      00164E 5B 04            [ 2]    1     addw sp,#VSIZE 
      001650 89               [ 2] 4448 	pushw x
      001651 81               [ 4] 4449 	ret  
                                   4450 
                                   4451 
                                   4452 ;----------------------------------
                                   4453 ; BASIC: RUN
                                   4454 ; run BASIC program in RAM
                                   4455 ;----------------------------------- 
      001652                       4456 run: 
      001652 72 01 00 25 02   [ 2] 4457 	btjf flags,#FRUN,0$  
      001657 4F               [ 1] 4458 	clr a 
      001658 81               [ 4] 4459 	ret
      001659                       4460 0$: 
      001659 72 09 00 25 12   [ 2] 4461 	btjf flags,#FBREAK,1$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 86.
Hexadecimal [24-Bits]



      00165E                       4462 	_drop 2 
      00165E 5B 02            [ 2]    1     addw sp,#2 
      001660 CD 13 D2         [ 4] 4463 	call rest_context
      001663                       4464 	_drop CTXT_SIZE 
      001663 5B 04            [ 2]    1     addw sp,#CTXT_SIZE 
      001665 72 19 00 25      [ 1] 4465 	bres flags,#FBREAK 
      001669 72 10 00 25      [ 1] 4466 	bset flags,#FRUN 
      00166D CC 07 87         [ 2] 4467 	jp interp_loop 
      001670 CE 00 1E         [ 2] 4468 1$:	ldw x,txtbgn
      001673 C3 00 20         [ 2] 4469 	cpw x,txtend 
      001676 2B 02            [ 1] 4470 	jrmi run_it 
      001678 4F               [ 1] 4471 	clr a 
      001679 81               [ 4] 4472 	ret
                                   4473 
      00167A                       4474 run_it:	 
      00167A CD 10 E1         [ 4] 4475     call ubound 
      00167D                       4476 	_drop 2 ; drop return address 
      00167D 5B 02            [ 2]    1     addw sp,#2 
                                   4477 ; clear data pointer 
      00167F 5F               [ 1] 4478 	clrw x 
      001680 CF 00 06         [ 2] 4479 	ldw data_ptr,x 
      001683 72 5F 00 08      [ 1] 4480 	clr data_ofs 
      001687 72 5F 00 09      [ 1] 4481 	clr data_len 
                                   4482 ; initialize BASIC pointer 
      00168B CE 00 1E         [ 2] 4483 	ldw x,txtbgn 
      00168E CF 00 04         [ 2] 4484 	ldw basicptr,x 
      001691 E6 02            [ 1] 4485 	ld a,(2,x)
      001693 C7 00 03         [ 1] 4486 	ld count,a
      001696 35 03 00 01      [ 1] 4487 	mov in,#3	
      00169A 72 10 00 25      [ 1] 4488 	bset flags,#FRUN 
      00169E CC 07 87         [ 2] 4489 	jp interp_loop 
                                   4490 
                                   4491 
                                   4492 ;----------------------
                                   4493 ; BASIC: END
                                   4494 ; end running program
                                   4495 ;---------------------- 
      0016A1                       4496 cmd_end: 
                                   4497 ; clean stack 
      0016A1 AE 17 FF         [ 2] 4498 	ldw x,#STACK_EMPTY 
      0016A4 94               [ 1] 4499 	ldw sp,x 
      0016A5 72 11 00 25      [ 1] 4500 	bres flags,#FRUN 
      0016A9 72 19 00 25      [ 1] 4501 	bres flags,#FBREAK
      0016AD CC 07 44         [ 2] 4502 	jp warm_start
                                   4503 
                                   4504 
                                   4505 ;-----------------------
                                   4506 ; BASIC: TONE expr1,expr2
                                   4507 ; used TIMER2 channel 1
                                   4508 ; to produce a tone 
                                   4509 ; arguments:
                                   4510 ;    expr1   frequency 
                                   4511 ;    expr2   duration msec.
                                   4512 ;---------------------------
      0016B0                       4513 tone:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 87.
Hexadecimal [24-Bits]



      0016B0 CD 0E 84         [ 4] 4514 	call arg_list 
      0016B3 A1 02            [ 1] 4515 	cp a,#2 
      0016B5 27 03            [ 1] 4516 	jreq 1$
      0016B7 CC 07 01         [ 2] 4517 	jp syntax_error 
      0016BA                       4518 1$: 
      0016BA 85               [ 2] 4519 	popw x ; duration
      0016BB 90 85            [ 2] 4520 	popw y ; frequency 
      0016BD                       4521 beep:  
      0016BD 89               [ 2] 4522 	pushw x 
      0016BE AE F4 24         [ 2] 4523 	ldw x,#TIM2_CLK_FREQ
      0016C1 65               [ 2] 4524 	divw x,y 
                                   4525 ; round to nearest integer 
      0016C2 90 A3 7A 12      [ 2] 4526 	cpw y,#TIM2_CLK_FREQ/2
      0016C6 2B 01            [ 1] 4527 	jrmi 2$
      0016C8 5C               [ 2] 4528 	incw x 
      0016C9                       4529 2$:	 
      0016C9 9E               [ 1] 4530 	ld a,xh 
      0016CA C7 53 0D         [ 1] 4531 	ld TIM2_ARRH,a 
      0016CD 9F               [ 1] 4532 	ld a,xl 
      0016CE C7 53 0E         [ 1] 4533 	ld TIM2_ARRL,a 
                                   4534 ; 50% duty cycle 
      0016D1 8C               [ 1] 4535 	ccf 
      0016D2 56               [ 2] 4536 	rrcw x 
      0016D3 9E               [ 1] 4537 	ld a,xh 
      0016D4 C7 53 0F         [ 1] 4538 	ld TIM2_CCR1H,a 
      0016D7 9F               [ 1] 4539 	ld a,xl
      0016D8 C7 53 10         [ 1] 4540 	ld TIM2_CCR1L,a
      0016DB 72 10 53 08      [ 1] 4541 	bset TIM2_CCER1,#TIM2_CCER1_CC1E
      0016DF 72 10 53 00      [ 1] 4542 	bset TIM2_CR1,#TIM2_CR1_CEN
      0016E3 72 10 53 04      [ 1] 4543 	bset TIM2_EGR,#TIM2_EGR_UG
      0016E7 85               [ 2] 4544 	popw x 
      0016E8 CF 00 10         [ 2] 4545 	ldw timer,x 
      0016EB CE 00 10         [ 2] 4546 3$: ldw x,timer 	
      0016EE 26 FB            [ 1] 4547 	jrne 3$ 
      0016F0 72 11 53 08      [ 1] 4548 	bres TIM2_CCER1,#TIM2_CCER1_CC1E
      0016F4 72 11 53 00      [ 1] 4549 	bres TIM2_CR1,#TIM2_CR1_CEN 
      0016F8 81               [ 4] 4550 	ret 
                                   4551 
                                   4552 ;-------------------------------
                                   4553 ; BASIC: ADCON 0|1 [,divisor]  
                                   4554 ; disable/enanble ADC 
                                   4555 ;-------------------------------
                           000003  4556 	ONOFF=3 
                           000001  4557 	DIVSOR=1
                           000004  4558 	VSIZE=4 
      0016F9                       4559 power_adc:
      0016F9 CD 0E 84         [ 4] 4560 	call arg_list 
      0016FC A1 02            [ 1] 4561 	cp a,#2	
      0016FE 27 0B            [ 1] 4562 	jreq 1$
      001700 A1 01            [ 1] 4563 	cp a,#1 
      001702 27 03            [ 1] 4564 	jreq 0$ 
      001704 CC 07 01         [ 2] 4565 	jp syntax_error 
      001707 AE 00 00         [ 2] 4566 0$: ldw x,#0
      00170A 89               [ 2] 4567 	pushw x  ; divisor 
      00170B 1E 03            [ 2] 4568 1$: ldw x,(ONOFF,sp)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 88.
Hexadecimal [24-Bits]



      00170D 5D               [ 2] 4569 	tnzw x 
      00170E 27 1A            [ 1] 4570 	jreq 2$ 
      001710 1E 01            [ 2] 4571 	ldw x,(DIVSOR,sp) ; divisor 
      001712 9F               [ 1] 4572 	ld a,xl
      001713 A4 07            [ 1] 4573 	and a,#7
      001715 4E               [ 1] 4574 	swap a 
      001716 C7 54 01         [ 1] 4575 	ld ADC_CR1,a
      001719 72 16 50 CA      [ 1] 4576 	bset CLK_PCKENR2,#CLK_PCKENR2_ADC
      00171D 72 10 54 01      [ 1] 4577 	bset ADC_CR1,#ADC_CR1_ADON 
      001721                       4578 	_usec_dly 7 
      001721 AE 00 1B         [ 2]    1     ldw x,#(16*7-2)/4
      001724 5A               [ 2]    2     decw x
      001725 9D               [ 1]    3     nop 
      001726 26 FA            [ 1]    4     jrne .-4
      001728 20 08            [ 2] 4579 	jra 3$
      00172A 72 11 54 01      [ 1] 4580 2$: bres ADC_CR1,#ADC_CR1_ADON
      00172E 72 17 50 CA      [ 1] 4581 	bres CLK_PCKENR2,#CLK_PCKENR2_ADC
      001732                       4582 3$:	_drop VSIZE 
      001732 5B 04            [ 2]    1     addw sp,#VSIZE 
      001734 81               [ 4] 4583 	ret
                                   4584 
                                   4585 ;-----------------------------
                                   4586 ; BASIC: ADCREAD (channel)
                                   4587 ; read adc channel {0..5}
                                   4588 ; output:
                                   4589 ;   A 		TK_INTGR 
                                   4590 ;   X 		value 
                                   4591 ;-----------------------------
      001735                       4592 analog_read:
      001735 CD 0E AB         [ 4] 4593 	call func_args 
      001738 A1 01            [ 1] 4594 	cp a,#1 
      00173A 27 03            [ 1] 4595 	jreq 1$
      00173C CC 07 01         [ 2] 4596 	jp syntax_error
      00173F 85               [ 2] 4597 1$: popw x 
      001740 A3 00 05         [ 2] 4598 	cpw x,#5 
      001743 23 05            [ 2] 4599 	jrule 2$
      001745 A6 0A            [ 1] 4600 	ld a,#ERR_BAD_VALUE
      001747 CC 07 03         [ 2] 4601 	jp tb_error 
      00174A 9F               [ 1] 4602 2$: ld a,xl
      00174B C7 00 0D         [ 1] 4603 	ld acc8,a 
      00174E A6 05            [ 1] 4604 	ld a,#5
      001750 C0 00 0D         [ 1] 4605 	sub a,acc8 
      001753 C7 54 00         [ 1] 4606 	ld ADC_CSR,a
      001756 72 16 54 02      [ 1] 4607 	bset ADC_CR2,#ADC_CR2_ALIGN
      00175A 72 10 54 01      [ 1] 4608 	bset ADC_CR1,#ADC_CR1_ADON
      00175E 72 0F 54 00 FB   [ 2] 4609 	btjf ADC_CSR,#ADC_CSR_EOC,.
      001763 CE 54 04         [ 2] 4610 	ldw x,ADC_DRH
      001766 A6 04            [ 1] 4611 	ld a,#TK_INTGR
      001768 81               [ 4] 4612 	ret 
                                   4613 
                                   4614 ;-----------------------
                                   4615 ; BASIC: DREAD(pin)
                                   4616 ; Arduino pins 
                                   4617 ; read state of a digital pin 
                                   4618 ; pin# {0..15}
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 89.
Hexadecimal [24-Bits]



                                   4619 ; output:
                                   4620 ;    A 		TK_INTGR
                                   4621 ;    X      0|1 
                                   4622 ;-------------------------
                           000001  4623 	PINNO=1
                           000001  4624 	VSIZE=1
      001769                       4625 digital_read:
      001769                       4626 	_vars VSIZE 
      001769 52 01            [ 2]    1     sub sp,#VSIZE 
      00176B CD 0E AB         [ 4] 4627 	call func_args
      00176E A1 01            [ 1] 4628 	cp a,#1
      001770 27 03            [ 1] 4629 	jreq 1$
      001772 CC 07 01         [ 2] 4630 	jp syntax_error
      001775 85               [ 2] 4631 1$: popw x 
      001776 A3 00 0F         [ 2] 4632 	cpw x,#15 
      001779 23 05            [ 2] 4633 	jrule 2$
      00177B A6 0A            [ 1] 4634 	ld a,#ERR_BAD_VALUE
      00177D CC 07 03         [ 2] 4635 	jp tb_error 
      001780 CD 1D 4E         [ 4] 4636 2$:	call select_pin 
      001783 6B 01            [ 1] 4637 	ld (PINNO,sp),a
      001785 E6 01            [ 1] 4638 	ld a,(GPIO_IDR,x)
      001787 0D 01            [ 1] 4639 	tnz (PINNO,sp)
      001789 27 05            [ 1] 4640 	jreq 8$
      00178B 44               [ 1] 4641 3$: srl a 
      00178C 0A 01            [ 1] 4642 	dec (PINNO,sp)
      00178E 26 FB            [ 1] 4643 	jrne 3$ 
      001790 A4 01            [ 1] 4644 8$: and a,#1 
      001792 5F               [ 1] 4645 	clrw x 
      001793 97               [ 1] 4646 	ld xl,a 
      001794 A6 04            [ 1] 4647 	ld a,#TK_INTGR
      001796                       4648 	_drop VSIZE
      001796 5B 01            [ 2]    1     addw sp,#VSIZE 
      001798 81               [ 4] 4649 	ret
                                   4650 
                                   4651 ;-----------------------
                                   4652 ; BASIC: DWRITE pin,0|1
                                   4653 ; Arduino pins 
                                   4654 ; write to a digital pin 
                                   4655 ; pin# {0..15}
                                   4656 ; output:
                                   4657 ;    A 		TK_INTGR
                                   4658 ;    X      0|1 
                                   4659 ;-------------------------
                           000001  4660 	PINNO=1
                           000002  4661 	PINVAL=2
                           000002  4662 	VSIZE=2
      001799                       4663 digital_write:
      001799                       4664 	_vars VSIZE 
      001799 52 02            [ 2]    1     sub sp,#VSIZE 
      00179B CD 0E 84         [ 4] 4665 	call arg_list  
      00179E A1 02            [ 1] 4666 	cp a,#2 
      0017A0 27 03            [ 1] 4667 	jreq 1$
      0017A2 CC 07 01         [ 2] 4668 	jp syntax_error
      0017A5 85               [ 2] 4669 1$: popw x 
      0017A6 9F               [ 1] 4670 	ld a,xl 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 90.
Hexadecimal [24-Bits]



      0017A7 6B 02            [ 1] 4671 	ld (PINVAL,sp),a
      0017A9 85               [ 2] 4672 	popw x 
      0017AA A3 00 0F         [ 2] 4673 	cpw x,#15 
      0017AD 23 05            [ 2] 4674 	jrule 2$
      0017AF A6 0A            [ 1] 4675 	ld a,#ERR_BAD_VALUE
      0017B1 CC 07 03         [ 2] 4676 	jp tb_error 
      0017B4 CD 1D 4E         [ 4] 4677 2$:	call select_pin 
      0017B7 6B 01            [ 1] 4678 	ld (PINNO,sp),a 
      0017B9 A6 01            [ 1] 4679 	ld a,#1
      0017BB 0D 01            [ 1] 4680 	tnz (PINNO,sp)
      0017BD 27 05            [ 1] 4681 	jreq 4$
      0017BF 48               [ 1] 4682 3$: sll a
      0017C0 0A 01            [ 1] 4683 	dec (PINNO,sp)
      0017C2 26 FB            [ 1] 4684 	jrne 3$
      0017C4 0D 02            [ 1] 4685 4$: tnz (PINVAL,sp)
      0017C6 26 05            [ 1] 4686 	jrne 5$
      0017C8 43               [ 1] 4687 	cpl a 
      0017C9 E4 00            [ 1] 4688 	and a,(GPIO_ODR,x)
      0017CB 20 02            [ 2] 4689 	jra 8$
      0017CD EA 00            [ 1] 4690 5$: or a,(GPIO_ODR,x)
      0017CF E7 00            [ 1] 4691 8$: ld (GPIO_ODR,x),a 
      0017D1                       4692 	_drop VSIZE 
      0017D1 5B 02            [ 2]    1     addw sp,#VSIZE 
      0017D3 81               [ 4] 4693 	ret
                                   4694 
                                   4695 
                                   4696 ;-----------------------
                                   4697 ; BASIC: STOP
                                   4698 ; stop progam execution  
                                   4699 ; without resetting pointers 
                                   4700 ; the program is resumed
                                   4701 ; with RUN 
                                   4702 ;-------------------------
      0017D4                       4703 stop:
      0017D4 72 00 00 25 02   [ 2] 4704 	btjt flags,#FRUN,2$
      0017D9 4F               [ 1] 4705 	clr a
      0017DA 81               [ 4] 4706 	ret 
      0017DB                       4707 2$:	 
                                   4708 ; create space on cstack to save context 
      0017DB AE 18 02         [ 2] 4709 	ldw x,#break_point 
      0017DE CD 01 C6         [ 4] 4710 	call puts 
      0017E1                       4711 	_drop 2 ;drop return address 
      0017E1 5B 02            [ 2]    1     addw sp,#2 
      0017E3                       4712 	_vars CTXT_SIZE ; context size 
      0017E3 52 04            [ 2]    1     sub sp,#CTXT_SIZE 
      0017E5 CD 13 C2         [ 4] 4713 	call save_context 
      0017E8 AE 16 E8         [ 2] 4714 	ldw x,#tib 
      0017EB CF 00 04         [ 2] 4715 	ldw basicptr,x
      0017EE 7F               [ 1] 4716 	clr (x)
      0017EF 72 5F 00 03      [ 1] 4717 	clr count  
      0017F3 5F               [ 1] 4718 	clrw x 
      0017F4 CF 00 00         [ 2] 4719 	ldw in.w,x
      0017F7 72 11 00 25      [ 1] 4720 	bres flags,#FRUN 
      0017FB 72 18 00 25      [ 1] 4721 	bset flags,#FBREAK
      0017FF CC 07 87         [ 2] 4722 	jp interp_loop 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 91.
Hexadecimal [24-Bits]



      001802 0A 62 72 65 61 6B 20  4723 break_point: .asciz "\nbreak point, RUN to resume.\n"
             70 6F 69 6E 74 2C 20
             52 55 4E 20 74 6F 20
             72 65 73 75 6D 65 2E
             0A 00
                                   4724 
                                   4725 ;-----------------------
                                   4726 ; BASIC: NEW
                                   4727 ; from command line only 
                                   4728 ; free program memory
                                   4729 ; and clear variables 
                                   4730 ;------------------------
      001820                       4731 new: 
      001820 72 01 00 25 02   [ 2] 4732 	btjf flags,#FRUN,0$ 
      001825 4F               [ 1] 4733 	clr a 
      001826 81               [ 4] 4734 	ret 
      001827                       4735 0$:	
      001827 CD 05 CB         [ 4] 4736 	call clear_basic 
      00182A 81               [ 4] 4737 	ret 
                                   4738 	 
                                   4739 ;;;;;;;;;;;;;;;;;;;;;;;;;
                                   4740 ;  file system routines
                                   4741 ;  MCU flash memory from
                                   4742 ;  0x10000-0x27fff is 
                                   4743 ;  used to store BASIC 
                                   4744 ;  program files. 
                                   4745 ;;;;;;;;;;;;;;;;;;;;;;;;;
                                   4746 
                                   4747 ;--------------------
                                   4748 ; input:
                                   4749 ;   X     increment 
                                   4750 ; output:
                                   4751 ;   farptr  incremented 
                                   4752 ;---------------------
      00182B                       4753 incr_farptr:
      00182B 72 BB 00 17      [ 2] 4754 	addw x,farptr+1 
      00182F 24 04            [ 1] 4755 	jrnc 1$
      001831 72 5C 00 16      [ 1] 4756 	inc farptr 
      001835 CF 00 17         [ 2] 4757 1$:	ldw farptr+1,x  
      001838 81               [ 4] 4758 	ret 
                                   4759 
                                   4760 ;------------------------------
                                   4761 ; extended flash memory used as FLASH_DRIVE 
                                   4762 ; seek end of used flash drive   
                                   4763 ; starting at 0x10000 address.
                                   4764 ; 4 consecutives 0 bytes signal free space. 
                                   4765 ; input:
                                   4766 ;	none
                                   4767 ; output:
                                   4768 ;   ffree     free_addr| 0 if memory full.
                                   4769 ;------------------------------
      001839                       4770 seek_fdrive:
                                   4771 ; start scan at 0x10000 address 
      001839 A6 01            [ 1] 4772 	ld a,#1
      00183B C7 00 16         [ 1] 4773 	ld farptr,a 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 92.
Hexadecimal [24-Bits]



      00183E 5F               [ 1] 4774 	clrw x 
      00183F CF 00 17         [ 2] 4775 	ldw farptr+1,x 
      001842                       4776 1$:
      001842 AE 00 03         [ 2] 4777 	ldw x,#3  
      001845 92 AF 00 16      [ 5] 4778 2$:	ldf a,([farptr],x) 
      001849 26 05            [ 1] 4779 	jrne 3$
      00184B 5A               [ 2] 4780 	decw x
      00184C 2A F7            [ 1] 4781 	jrpl 2$
      00184E 20 19            [ 2] 4782 	jra 4$ 
      001850 5C               [ 2] 4783 3$:	incw x 
      001851 CD 18 2B         [ 4] 4784 	call incr_farptr
      001854 AE 02 7F         [ 2] 4785 	ldw x,#0x27f 
      001857 C3 00 16         [ 2] 4786 	cpw x,farptr
      00185A 2A E6            [ 1] 4787 	jrpl 1$
                                   4788 ; drive full 
      00185C 72 5F 00 19      [ 1] 4789 	clr ffree 
      001860 72 5F 00 1A      [ 1] 4790 	clr ffree+1 
      001864 72 5F 00 1B      [ 1] 4791 	clr ffree+2 
      001868 81               [ 4] 4792 	ret
      001869                       4793 4$: ; copy farptr to ffree	 
      001869 CE 00 16         [ 2] 4794 	ldw x,farptr 
      00186C C6 00 18         [ 1] 4795 	ld a,farptr+2 
      00186F CF 00 19         [ 2] 4796 	ldw ffree,x 
      001872 C7 00 1B         [ 1] 4797 	ld ffree+2,a  
      001875 81               [ 4] 4798 	ret 
                                   4799 
                                   4800 ;-----------------------
                                   4801 ; compare file name 
                                   4802 ; with name pointed by Y  
                                   4803 ; input:
                                   4804 ;   farptr   file name 
                                   4805 ;   Y        target name 
                                   4806 ; output:
                                   4807 ;   farptr 	 at file_name
                                   4808 ;   X 		 farptr[x] point at size field  
                                   4809 ;   Carry    0|1 no match|match  
                                   4810 ;----------------------
      001876                       4811 cmp_name:
      001876 5F               [ 1] 4812 	clrw x
      001877 92 AF 00 16      [ 5] 4813 1$:	ldf a,([farptr],x)
      00187B 90 F1            [ 1] 4814 	cp a,(y)
      00187D 26 08            [ 1] 4815 	jrne 4$
      00187F 4D               [ 1] 4816 	tnz a 
      001880 27 12            [ 1] 4817 	jreq 9$ 
      001882 5C               [ 2] 4818     incw x 
      001883 90 5C            [ 2] 4819 	incw y 
      001885 20 F0            [ 2] 4820 	jra 1$
      001887                       4821 4$: ;no match 
      001887 4D               [ 1] 4822 	tnz a 
      001888 27 07            [ 1] 4823 	jreq 5$
      00188A 5C               [ 2] 4824 	incw x 
      00188B 92 AF 00 16      [ 5] 4825 	ldf a,([farptr],x)
      00188F 20 F6            [ 2] 4826 	jra 4$  
      001891 5C               [ 2] 4827 5$:	incw x ; farptr[x] point at 'size' field 
      001892 98               [ 1] 4828 	rcf 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 93.
Hexadecimal [24-Bits]



      001893 81               [ 4] 4829 	ret
      001894                       4830 9$: ; match  
      001894 5C               [ 2] 4831 	incw x  ; farptr[x] at 'size' field 
      001895 99               [ 1] 4832 	scf 
      001896 81               [ 4] 4833 	ret 
                                   4834 
                                   4835 ;-----------------------
                                   4836 ; search file in 
                                   4837 ; flash memory 
                                   4838 ; input:
                                   4839 ;   Y       file name  
                                   4840 ; output:
                                   4841 ;   farptr  addr at name|0
                                   4842 ;-----------------------
                           000001  4843 	FSIZE=1
                           000003  4844 	YSAVE=3
                           000004  4845 	VSIZE=4 
      001897                       4846 search_file: 
      001897                       4847 	_vars VSIZE
      001897 52 04            [ 2]    1     sub sp,#VSIZE 
      001899 17 03            [ 2] 4848 	ldw (YSAVE,sp),y  
      00189B 5F               [ 1] 4849 	clrw x 
      00189C CF 00 17         [ 2] 4850 	ldw farptr+1,x 
      00189F 35 01 00 16      [ 1] 4851 	mov farptr,#1
      0018A3                       4852 1$:	
                                   4853 ; check if farptr is after any file 
                                   4854 ; if  0 then so.
      0018A3 92 BC 00 16      [ 5] 4855 	ldf a,[farptr]
      0018A7 27 25            [ 1] 4856 	jreq 6$
      0018A9 5F               [ 1] 4857 2$: clrw x 	
      0018AA 16 03            [ 2] 4858 	ldw y,(YSAVE,sp) 
      0018AC CD 18 76         [ 4] 4859 	call cmp_name
      0018AF 25 2D            [ 1] 4860 	jrc 9$
      0018B1 92 AF 00 16      [ 5] 4861 	ldf a,([farptr],x)
      0018B5 6B 01            [ 1] 4862 	ld (FSIZE,sp),a 
      0018B7 5C               [ 2] 4863 	incw x 
      0018B8 92 AF 00 16      [ 5] 4864 	ldf a,([farptr],x)
      0018BC 6B 02            [ 1] 4865 	ld (FSIZE+1,sp),a 
      0018BE 5C               [ 2] 4866 	incw x 
      0018BF 72 FB 01         [ 2] 4867 	addw x,(FSIZE,sp) ; count to skip 
      0018C2 5C               [ 2] 4868 	incw x ; skip over EOF marker 
      0018C3 CD 18 2B         [ 4] 4869 	call incr_farptr ; now at next file 'name_field'
      0018C6 AE 02 80         [ 2] 4870 	ldw x,#0x280
      0018C9 C3 00 16         [ 2] 4871 	cpw x,farptr 
      0018CC 2A D5            [ 1] 4872 	jrpl 1$
      0018CE                       4873 6$: ; file not found 
      0018CE 72 5F 00 16      [ 1] 4874 	clr farptr
      0018D2 72 5F 00 17      [ 1] 4875 	clr farptr+1 
      0018D6 72 5F 00 18      [ 1] 4876 	clr farptr+2 
      0018DA                       4877 	_drop VSIZE 
      0018DA 5B 04            [ 2]    1     addw sp,#VSIZE 
      0018DC 98               [ 1] 4878 	rcf
      0018DD 81               [ 4] 4879 	ret
      0018DE                       4880 9$: ; file found  farptr[0] at 'name_field',farptr[x] at 'file_size' 
      0018DE                       4881 	_drop VSIZE 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 94.
Hexadecimal [24-Bits]



      0018DE 5B 04            [ 2]    1     addw sp,#VSIZE 
      0018E0 99               [ 1] 4882 	scf 	
      0018E1 81               [ 4] 4883 	ret
                                   4884 
                                   4885 ;--------------------------------
                                   4886 ; BASIC: SAVE "name" 
                                   4887 ; save text program in 
                                   4888 ; flash memory used as 
                                   4889 ;--------------------------------
                           000001  4890 	BSIZE=1
                           000003  4891 	NAMEPTR=3
                           000004  4892 	VSIZE=4
      0018E2                       4893 save:
      0018E2 72 01 00 25 05   [ 2] 4894 	btjf flags,#FRUN,0$ 
      0018E7 A6 07            [ 1] 4895 	ld a,#ERR_CMD_ONLY 
      0018E9 CC 07 03         [ 2] 4896 	jp tb_error
      0018EC                       4897 0$:	 
      0018EC CE 00 20         [ 2] 4898 	ldw x,txtend 
      0018EF 72 B0 00 1E      [ 2] 4899 	subw x,txtbgn
      0018F3 26 01            [ 1] 4900 	jrne 1$
                                   4901 ; nothing to save 
      0018F5 81               [ 4] 4902 	ret 
      0018F6                       4903 1$:	
      0018F6                       4904 	_vars VSIZE 
      0018F6 52 04            [ 2]    1     sub sp,#VSIZE 
      0018F8 1F 01            [ 2] 4905 	ldw (BSIZE,sp),x 
      0018FA CD 07 B5         [ 4] 4906 	call next_token	
      0018FD A1 0A            [ 1] 4907 	cp a,#TK_QSTR
      0018FF 27 03            [ 1] 4908 	jreq 2$
      001901 CC 07 01         [ 2] 4909 	jp syntax_error
      001904                       4910 2$: 
      001904 90 CE 00 04      [ 2] 4911 	ldw y,basicptr 
      001908 72 B9 00 00      [ 2] 4912 	addw y,in.w
      00190C 17 03            [ 2] 4913 	ldw (NAMEPTR,sp),y  
      00190E 55 00 03 00 01   [ 1] 4914 	mov in,count 
                                   4915 ; check if enough free space 
      001913 93               [ 1] 4916 	ldw x,y 
      001914 CD 01 FA         [ 4] 4917 	call strlen 
      001917 1C 00 03         [ 2] 4918 	addw x,#3 
      00191A 72 FB 01         [ 2] 4919 	addw x,(BSIZE,sp)
      00191D 72 5D 00 19      [ 1] 4920 	tnz ffree 
      001921 26 0B            [ 1] 4921 	jrne 21$
      001923 72 B0 00 1A      [ 2] 4922 	subw x,ffree+1 
      001927 23 05            [ 2] 4923 	jrule 21$
      001929 A6 01            [ 1] 4924 	ld a,#ERR_MEM_FULL 
      00192B CC 07 03         [ 2] 4925 	jp tb_error
      00192E                       4926 21$: 
                                   4927 ; check for existing file of that name 
      00192E 16 03            [ 2] 4928 	ldw y,(NAMEPTR,sp)	
      001930 CD 18 97         [ 4] 4929 	call search_file 
      001933 24 05            [ 1] 4930 	jrnc 3$ 
      001935 A6 08            [ 1] 4931 	ld a,#ERR_DUPLICATE 
      001937 CC 07 03         [ 2] 4932 	jp tb_error 
      00193A                       4933 3$:	;** write file name to flash **
      00193A CE 00 19         [ 2] 4934 	ldw x,ffree 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 95.
Hexadecimal [24-Bits]



      00193D C6 00 1B         [ 1] 4935 	ld a,ffree+2 
      001940 CF 00 16         [ 2] 4936 	ldw farptr,x 
      001943 C7 00 18         [ 1] 4937 	ld farptr+2,a 
      001946 1E 03            [ 2] 4938 	ldw x,(NAMEPTR,sp)  
      001948 CD 01 FA         [ 4] 4939 	call strlen 
      00194B 5C               [ 2] 4940 	incw  x
      00194C 1F 01            [ 2] 4941 	ldw (BSIZE,sp),x  
      00194E 5F               [ 1] 4942 	clrw x   
      00194F 16 03            [ 2] 4943 	ldw y,(NAMEPTR,sp)
      001951 CD 01 55         [ 4] 4944 	call write_block  
                                   4945 ;** write file length after name **
      001954 CE 00 20         [ 2] 4946 	ldw x,txtend 
      001957 72 B0 00 1E      [ 2] 4947 	subw x,txtbgn
      00195B 1F 01            [ 2] 4948 	ldw (BSIZE,sp),x 
      00195D 5F               [ 1] 4949 	clrw x 
      00195E 7B 01            [ 1] 4950 	ld a,(1,sp)
      001960 CD 00 E0         [ 4] 4951 	call write_byte 
      001963 5C               [ 2] 4952 	incw x 
      001964 7B 02            [ 1] 4953 	ld a,(2,sp)
      001966 CD 00 E0         [ 4] 4954 	call write_byte
      001969 5C               [ 2] 4955 	incw x  
      00196A CD 18 2B         [ 4] 4956 	call incr_farptr ; move farptr after SIZE field 
                                   4957 ;** write BASIC text **
                                   4958 ; copy BSIZE, cstack:{... bsize -- ... bsize bsize }	
      00196D 1E 01            [ 2] 4959 	ldw x,(BSIZE,sp)
      00196F 89               [ 2] 4960 	pushw x ; write_block argument 
      001970 5F               [ 1] 4961 	clrw x 
      001971 90 CE 00 1E      [ 2] 4962 	ldw y,txtbgn  ; BASIC text to save 
      001975 CD 01 55         [ 4] 4963 	call write_block 
      001978                       4964 	_drop 2 ;  drop write_block argument  
      001978 5B 02            [ 2]    1     addw sp,#2 
                                   4965 ; write en end of file marker 
      00197A AE 00 01         [ 2] 4966 	ldw x,#1
      00197D A6 FF            [ 1] 4967 	ld a,#EOF  
      00197F CD 00 E0         [ 4] 4968 	call write_byte 
      001982 CD 18 2B         [ 4] 4969 	call incr_farptr
                                   4970 ; save farptr in ffree
      001985 CE 00 16         [ 2] 4971 	ldw x,farptr 
      001988 C6 00 18         [ 1] 4972 	ld a,farptr+2 
      00198B CF 00 19         [ 2] 4973 	ldw ffree,x 
      00198E C7 00 1B         [ 1] 4974 	ld ffree+2,a
                                   4975 ;write 4 zero bytes as an end of all files marker 
      001991 5F               [ 1] 4976     clrw x 
      001992 4B 04            [ 1] 4977 	push #4 
      001994                       4978 4$:
      001994 4F               [ 1] 4979 	clr a 
      001995 CD 00 E0         [ 4] 4980 	call write_byte 
      001998 5C               [ 2] 4981 	incw x 
      001999 0A 01            [ 1] 4982 	dec (1,sp)
      00199B 26 F7            [ 1] 4983 	jrne 4$
      00199D 84               [ 1] 4984 5$: pop a 
                                   4985 ; display saved size  
      00199E 1E 01            [ 2] 4986 	ldw x,(BSIZE,sp) 
      0019A0 CD 08 4A         [ 4] 4987 	call print_int 
      0019A3                       4988 	_drop VSIZE 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 96.
Hexadecimal [24-Bits]



      0019A3 5B 04            [ 2]    1     addw sp,#VSIZE 
      0019A5 81               [ 4] 4989 	ret 
                                   4990 
                                   4991 ;----------------------
                                   4992 ; load file in RAM memory
                                   4993 ; input:
                                   4994 ;    farptr point at file size 
                                   4995 ; output:
                                   4996 ;   y point after BASIC program in RAM.
                                   4997 ;------------------------
      0019A6                       4998 load_file:
      0019A6 CD 18 2B         [ 4] 4999 	call incr_farptr  
      0019A9 CD 05 CB         [ 4] 5000 	call clear_basic  
      0019AC 5F               [ 1] 5001 	clrw x
      0019AD 92 AF 00 16      [ 5] 5002 	ldf a,([farptr],x)
      0019B1 90 95            [ 1] 5003 	ld yh,a 
      0019B3 5C               [ 2] 5004 	incw x  
      0019B4 92 AF 00 16      [ 5] 5005 	ldf a,([farptr],x)
      0019B8 5C               [ 2] 5006 	incw x 
      0019B9 90 97            [ 1] 5007 	ld yl,a 
      0019BB 72 B9 00 1E      [ 2] 5008 	addw y,txtbgn
      0019BF 90 CF 00 20      [ 2] 5009 	ldw txtend,y
      0019C3 90 CE 00 1E      [ 2] 5010 	ldw y,txtbgn
      0019C7                       5011 3$:	; load BASIC text 	
      0019C7 92 AF 00 16      [ 5] 5012 	ldf a,([farptr],x)
      0019CB 90 F7            [ 1] 5013 	ld (y),a 
      0019CD 5C               [ 2] 5014 	incw x 
      0019CE 90 5C            [ 2] 5015 	incw y 
      0019D0 90 C3 00 20      [ 2] 5016 	cpw y,txtend 
      0019D4 2B F1            [ 1] 5017 	jrmi 3$
      0019D6 81               [ 4] 5018 	ret 
                                   5019 
                                   5020 ;------------------------
                                   5021 ; BASIC: LOAD "file" 
                                   5022 ; load file to RAM 
                                   5023 ; for execution 
                                   5024 ;------------------------
      0019D7                       5025 load:
      0019D7 72 01 00 25 07   [ 2] 5026 	btjf flags,#FRUN,0$ 
      0019DC 27 05            [ 1] 5027 	jreq 0$ 
      0019DE A6 07            [ 1] 5028 	ld a,#ERR_CMD_ONLY 
      0019E0 CC 07 03         [ 2] 5029 	jp tb_error 
      0019E3                       5030 0$:	
      0019E3 CD 07 B5         [ 4] 5031 	call next_token 
      0019E6 A1 0A            [ 1] 5032 	cp a,#TK_QSTR
      0019E8 27 03            [ 1] 5033 	jreq 1$
      0019EA CC 07 01         [ 2] 5034 	jp syntax_error 
      0019ED                       5035 1$:	
      0019ED 90 CE 00 04      [ 2] 5036 	ldw y,basicptr
      0019F1 72 B9 00 00      [ 2] 5037 	addw y,in.w 
      0019F5 55 00 03 00 01   [ 1] 5038 	mov in,count 
      0019FA CD 18 97         [ 4] 5039 	call search_file 
      0019FD 25 05            [ 1] 5040 	jrc 2$ 
      0019FF A6 09            [ 1] 5041 	ld a,#ERR_NOT_FILE
      001A01 CC 07 03         [ 2] 5042 	jp tb_error  
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 97.
Hexadecimal [24-Bits]



      001A04                       5043 2$:
      001A04 CD 19 A6         [ 4] 5044 	call load_file
                                   5045 ; print loaded size 	 
      001A07 CE 00 20         [ 2] 5046 	ldw x,txtend 
      001A0A 72 B0 00 1E      [ 2] 5047 	subw x,txtbgn
      001A0E CD 08 4A         [ 4] 5048 	call print_int 
      001A11 81               [ 4] 5049 	ret 
                                   5050 
                                   5051 ;-----------------------------------
                                   5052 ; BASIC: FORGET ["file_name"] 
                                   5053 ; erase file_name and all others 
                                   5054 ; after it. 
                                   5055 ; without argument erase all files 
                                   5056 ;-----------------------------------
      001A12                       5057 forget:
      001A12 CD 07 B5         [ 4] 5058 	call next_token 
      001A15 A1 00            [ 1] 5059 	cp a,#TK_NONE 
      001A17 27 26            [ 1] 5060 	jreq 3$ 
      001A19 A1 0A            [ 1] 5061 	cp a,#TK_QSTR
      001A1B 27 03            [ 1] 5062 	jreq 1$
      001A1D CC 07 01         [ 2] 5063 	jp syntax_error
      001A20 90 CE 00 04      [ 2] 5064 1$: ldw y,basicptr
      001A24 72 B9 00 00      [ 2] 5065 	addw y,in.w
      001A28 55 00 03 00 01   [ 1] 5066 	mov in,count 
      001A2D CD 18 97         [ 4] 5067 	call search_file
      001A30 25 05            [ 1] 5068 	jrc 2$
      001A32 A6 09            [ 1] 5069 	ld a,#ERR_NOT_FILE 
      001A34 CC 07 03         [ 2] 5070 	jp tb_error 
      001A37                       5071 2$: 
      001A37 CE 00 16         [ 2] 5072 	ldw x,farptr
      001A3A C6 00 18         [ 1] 5073 	ld a,farptr+2
      001A3D 20 0A            [ 2] 5074 	jra 4$ 
      001A3F                       5075 3$: ; forget all files 
      001A3F AE 01 00         [ 2] 5076 	ldw x,#0x100
      001A42 4F               [ 1] 5077 	clr a 
      001A43 CF 00 16         [ 2] 5078 	ldw farptr,x 
      001A46 C7 00 18         [ 1] 5079 	ld farptr+2,a 
      001A49                       5080 4$:
      001A49 CF 00 19         [ 2] 5081 	ldw ffree,x 
      001A4C C7 00 1B         [ 1] 5082 	ld ffree+2,a 
      001A4F 4B 04            [ 1] 5083 	push #4
      001A51 5F               [ 1] 5084 	clrw x 
      001A52                       5085 5$: 
      001A52 4F               [ 1] 5086 	clr a  
      001A53 CD 00 E0         [ 4] 5087 	call write_byte 
      001A56 5C               [ 2] 5088 	incw x 
      001A57 0A 01            [ 1] 5089 	dec (1,sp)
      001A59 26 F7            [ 1] 5090 	jrne 5$	
      001A5B 84               [ 1] 5091 6$: pop a 
      001A5C 81               [ 4] 5092 	ret 
                                   5093 
                                   5094 ;----------------------
                                   5095 ; BASIC: DIR 
                                   5096 ; list saved files 
                                   5097 ;----------------------
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 98.
Hexadecimal [24-Bits]



                           000001  5098 	COUNT=1 ; files counter 
                           000002  5099 	VSIZE=2 
      001A5D                       5100 directory:
      001A5D                       5101 	_vars VSIZE 
      001A5D 52 02            [ 2]    1     sub sp,#VSIZE 
      001A5F 5F               [ 1] 5102 	clrw x 
      001A60 1F 01            [ 2] 5103 	ldw (COUNT,sp),x 
      001A62 CF 00 17         [ 2] 5104 	ldw farptr+1,x 
      001A65 35 01 00 16      [ 1] 5105 	mov farptr,#1 
      001A69                       5106 dir_loop:
      001A69 5F               [ 1] 5107 	clrw x 
      001A6A 92 AF 00 16      [ 5] 5108 	ldf a,([farptr],x)
      001A6E 27 39            [ 1] 5109 	jreq 8$ 
      001A70                       5110 1$: ;name loop 	
      001A70 92 AF 00 16      [ 5] 5111 	ldf a,([farptr],x)
      001A74 27 06            [ 1] 5112 	jreq 2$ 
      001A76 CD 01 B3         [ 4] 5113 	call putc 
      001A79 5C               [ 2] 5114 	incw x 
      001A7A 20 F4            [ 2] 5115 	jra 1$
      001A7C 5C               [ 2] 5116 2$: incw x ; skip ending 0. 
      001A7D A6 20            [ 1] 5117 	ld a,#SPACE 
      001A7F CD 01 B3         [ 4] 5118 	call putc 
                                   5119 ; get file size 	
      001A82 92 AF 00 16      [ 5] 5120 	ldf a,([farptr],x)
      001A86 90 95            [ 1] 5121 	ld yh,a 
      001A88 5C               [ 2] 5122 	incw x 
      001A89 92 AF 00 16      [ 5] 5123 	ldf a,([farptr],x)
      001A8D 5C               [ 2] 5124 	incw x 
      001A8E 90 97            [ 1] 5125 	ld yl,a 
      001A90 90 89            [ 2] 5126 	pushw y 
      001A92 72 FB 01         [ 2] 5127 	addw x,(1,sp)
      001A95 5C               [ 2] 5128 	incw x ; skip EOF marker 
                                   5129 ; skip to next file 
      001A96 CD 18 2B         [ 4] 5130 	call incr_farptr 
                                   5131 ; print file size 
      001A99 85               [ 2] 5132 	popw x ; file size 
      001A9A CD 08 4A         [ 4] 5133 	call print_int 
      001A9D A6 0D            [ 1] 5134 	ld a,#CR 
      001A9F CD 01 B3         [ 4] 5135 	call putc
      001AA2 1E 01            [ 2] 5136 	ldw x,(COUNT,sp)
      001AA4 5C               [ 2] 5137 	incw x
      001AA5 1F 01            [ 2] 5138 	ldw (COUNT,sp),x  
      001AA7 20 C0            [ 2] 5139 	jra dir_loop 
      001AA9                       5140 8$: ; print number of files 
      001AA9 1E 01            [ 2] 5141 	ldw x,(COUNT,sp)
      001AAB CD 08 4A         [ 4] 5142 	call print_int 
      001AAE AE 1A DE         [ 2] 5143 	ldw x,#file_count 
      001AB1 CD 01 C6         [ 4] 5144 	call puts  
                                   5145 ; print drive free space 	
      001AB4 A6 FF            [ 1] 5146 	ld a,#0xff 
      001AB6 C0 00 1B         [ 1] 5147 	sub a,ffree+2 
      001AB9 C7 00 0D         [ 1] 5148 	ld acc8,a 
      001ABC A6 7F            [ 1] 5149 	ld a,#0x7f 
      001ABE C2 00 1A         [ 1] 5150 	sbc a,ffree+1 
      001AC1 C7 00 0C         [ 1] 5151 	ld acc16,a 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 99.
Hexadecimal [24-Bits]



      001AC4 A6 02            [ 1] 5152 	ld a,#2 
      001AC6 C2 00 19         [ 1] 5153 	sbc a,ffree 
      001AC9 C7 00 0B         [ 1] 5154 	ld acc24,a 
      001ACC 5F               [ 1] 5155 	clrw x  
      001ACD A6 06            [ 1] 5156 	ld a,#6 
      001ACF 97               [ 1] 5157 	ld xl,a 
      001AD0 A6 0A            [ 1] 5158 	ld a,#10 
      001AD2 CD 08 02         [ 4] 5159 	call prti24 
      001AD5 AE 1A E6         [ 2] 5160 	ldw x,#drive_free
      001AD8 CD 01 C6         [ 4] 5161 	call puts 
      001ADB                       5162 	_drop VSIZE 
      001ADB 5B 02            [ 2]    1     addw sp,#VSIZE 
      001ADD 81               [ 4] 5163 	ret
      001ADE 20 66 69 6C 65 73 0A  5164 file_count: .asciz " files\n"
             00
      001AE6 20 62 79 74 65 73 20  5165 drive_free: .asciz " bytes free\n" 
             66 72 65 65 0A 00
                                   5166 
                                   5167 ;---------------------
                                   5168 ; BASIC: WRITE expr1,expr2[,expr]* 
                                   5169 ; write 1 or more byte to FLASH or EEPROM
                                   5170 ; starting at address  
                                   5171 ; input:
                                   5172 ;   expr1  	is address 
                                   5173 ;   expr2,...,exprn   are bytes to write
                                   5174 ; output:
                                   5175 ;   none 
                                   5176 ;---------------------
                           000001  5177 	ADDR=1
                           000002  5178 	VSIZ=2 
      001AF3                       5179 write:
      001AF3                       5180 	_vars VSIZE 
      001AF3 52 02            [ 2]    1     sub sp,#VSIZE 
      001AF5 72 5F 00 16      [ 1] 5181 	clr farptr ; expect 16 bits address 
      001AF9 CD 0F 90         [ 4] 5182 	call expression
      001AFC A1 04            [ 1] 5183 	cp a,#TK_INTGR 
      001AFE 27 03            [ 1] 5184 	jreq 0$
      001B00 CC 07 01         [ 2] 5185 	jp syntax_error
      001B03 1F 01            [ 2] 5186 0$: ldw (ADDR,sp),x 
      001B05 CD 07 B5         [ 4] 5187 	call next_token 
      001B08 A1 0D            [ 1] 5188 	cp a,#TK_COMMA 
      001B0A 27 02            [ 1] 5189 	jreq 1$ 
      001B0C 20 19            [ 2] 5190 	jra 9$ 
      001B0E CD 0F 90         [ 4] 5191 1$:	call expression
      001B11 A1 04            [ 1] 5192 	cp a,#TK_INTGR
      001B13 27 03            [ 1] 5193 	jreq 2$
      001B15 CC 07 01         [ 2] 5194 	jp syntax_error
      001B18 9F               [ 1] 5195 2$:	ld a,xl 
      001B19 1E 01            [ 2] 5196 	ldw x,(ADDR,sp) 
      001B1B CF 00 17         [ 2] 5197 	ldw farptr+1,x 
      001B1E 5F               [ 1] 5198 	clrw x 
      001B1F CD 00 E0         [ 4] 5199 	call write_byte
      001B22 1E 01            [ 2] 5200 	ldw x,(ADDR,sp)
      001B24 5C               [ 2] 5201 	incw x 
      001B25 20 DC            [ 2] 5202 	jra 0$ 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 100.
Hexadecimal [24-Bits]



      001B27                       5203 9$:
      001B27                       5204 	_drop VSIZE
      001B27 5B 02            [ 2]    1     addw sp,#VSIZE 
      001B29 81               [ 4] 5205 	ret 
                                   5206 
                                   5207 
                                   5208 ;---------------------
                                   5209 ;BASIC: CHAR(expr)
                                   5210 ; évaluate expression 
                                   5211 ; and take the 7 least 
                                   5212 ; bits as ASCII character
                                   5213 ;---------------------
      001B2A                       5214 char:
      001B2A CD 0E AB         [ 4] 5215 	call func_args 
      001B2D A1 01            [ 1] 5216 	cp a,#1
      001B2F 27 03            [ 1] 5217 	jreq 1$
      001B31 CC 07 01         [ 2] 5218 	jp syntax_error
      001B34 85               [ 2] 5219 1$:	popw x 
      001B35 9F               [ 1] 5220 	ld a,xl 
      001B36 A4 7F            [ 1] 5221 	and a,#0x7f 
      001B38 97               [ 1] 5222 	ld xl,a
      001B39 A6 03            [ 1] 5223 	ld a,#TK_CHAR
      001B3B 81               [ 4] 5224 	ret
                                   5225 
                                   5226 ;---------------------
                                   5227 ; BASIC: ASC(string|char)
                                   5228 ; extract first character 
                                   5229 ; of string argument 
                                   5230 ; return it as TK_INTGR 
                                   5231 ;---------------------
      001B3C                       5232 ascii:
      001B3C A6 0B            [ 1] 5233 	ld a,#TK_LPAREN
      001B3E CD 0E 77         [ 4] 5234 	call expect 
      001B41 CD 07 B5         [ 4] 5235 	call next_token 
      001B44 A1 0A            [ 1] 5236 	cp a,#TK_QSTR 
      001B46 27 07            [ 1] 5237 	jreq 1$
      001B48 A1 03            [ 1] 5238 	cp a,#TK_CHAR 
      001B4A 27 06            [ 1] 5239 	jreq 2$ 
      001B4C CC 07 01         [ 2] 5240 	jp syntax_error
      001B4F                       5241 1$: 
      001B4F F6               [ 1] 5242 	ld a,(x) 
      001B50 5F               [ 1] 5243 	clrw x
      001B51 97               [ 1] 5244 	ld xl,a 
      001B52                       5245 2$: 
      001B52 89               [ 2] 5246 	pushw x 
      001B53 A6 0C            [ 1] 5247 	ld a,#TK_RPAREN 
      001B55 CD 0E 77         [ 4] 5248 	call expect
      001B58 85               [ 2] 5249 	popw x 
      001B59 A6 04            [ 1] 5250 	ld a,#TK_INTGR 
      001B5B 81               [ 4] 5251 	ret 
                                   5252 
                                   5253 ;---------------------
                                   5254 ;BASIC: KEY
                                   5255 ; wait for a character 
                                   5256 ; received from STDIN 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 101.
Hexadecimal [24-Bits]



                                   5257 ; input:
                                   5258 ;	none 
                                   5259 ; output:
                                   5260 ;	X 		ASCII character 
                                   5261 ;---------------------
      001B5C                       5262 key:
      001B5C CD 01 BC         [ 4] 5263 	call getc 
      001B5F 5F               [ 1] 5264 	clrw x 
      001B60 97               [ 1] 5265 	ld xl,a 
      001B61 A6 04            [ 1] 5266 	ld a,#TK_INTGR
      001B63 81               [ 4] 5267 	ret
                                   5268 
                                   5269 ;----------------------
                                   5270 ; BASIC: QKEY
                                   5271 ; Return true if there 
                                   5272 ; is a character in 
                                   5273 ; waiting in STDIN 
                                   5274 ; input:
                                   5275 ;  none 
                                   5276 ; output:
                                   5277 ;   X 		0|-1 
                                   5278 ;-----------------------
      001B64                       5279 qkey: 
      001B64 5F               [ 1] 5280 	clrw x 
      001B65 72 5D 00 27      [ 1] 5281 	tnz rx_char
      001B69 27 01            [ 1] 5282 	jreq 9$ 
      001B6B 53               [ 2] 5283 	cplw x 
      001B6C A6 04            [ 1] 5284 9$: ld a,#TK_INTGR
      001B6E 81               [ 4] 5285 	ret 
                                   5286 
                                   5287 ;---------------------
                                   5288 ; BASIC: GPIO(expr,reg)
                                   5289 ; return gpio address 
                                   5290 ; expr {0..8}
                                   5291 ; input:
                                   5292 ;   none 
                                   5293 ; output:
                                   5294 ;   X 		gpio register address
                                   5295 ;----------------------------
                           000003  5296 	PORT=3
                           000001  5297 	REG=1 
                           000004  5298 	VSIZE=4 
      001B6F                       5299 gpio:
      001B6F CD 0E AB         [ 4] 5300 	call func_args 
      001B72 A1 02            [ 1] 5301 	cp a,#2
      001B74 27 03            [ 1] 5302 	jreq 1$
      001B76 CC 07 01         [ 2] 5303 	jp syntax_error  
      001B79                       5304 1$:	
      001B79 1E 03            [ 2] 5305 	ldw x,(PORT,sp)
      001B7B 2B 17            [ 1] 5306 	jrmi bad_port
      001B7D A3 00 09         [ 2] 5307 	cpw x,#9
      001B80 2A 12            [ 1] 5308 	jrpl bad_port
      001B82 A6 05            [ 1] 5309 	ld a,#5
      001B84 42               [ 4] 5310 	mul x,a
      001B85 1C 50 00         [ 2] 5311 	addw x,#GPIO_BASE 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 102.
Hexadecimal [24-Bits]



      001B88 1F 03            [ 2] 5312 	ldw (PORT,sp),x  
      001B8A 1E 01            [ 2] 5313 	ldw x,(REG,sp) 
      001B8C 72 FB 03         [ 2] 5314 	addw x,(PORT,sp)
      001B8F A6 04            [ 1] 5315 	ld a,#TK_INTGR
      001B91                       5316 	_drop VSIZE 
      001B91 5B 04            [ 2]    1     addw sp,#VSIZE 
      001B93 81               [ 4] 5317 	ret
      001B94                       5318 bad_port:
      001B94 A6 0A            [ 1] 5319 	ld a,#ERR_BAD_VALUE
      001B96 CC 07 03         [ 2] 5320 	jp tb_error
                                   5321 
                                   5322 
                                   5323 ;-------------------------
                                   5324 ; BASIC: UFLASH 
                                   5325 ; return user flash address
                                   5326 ; input:
                                   5327 ;  none 
                                   5328 ; output:
                                   5329 ;	A		TK_INTGR
                                   5330 ;   X 		user address 
                                   5331 ;---------------------------
      001B99                       5332 uflash:
      001B99 AE 25 00         [ 2] 5333 	ldw x,#user_space 
      001B9C A6 04            [ 1] 5334 	ld a,#TK_INTGR 
      001B9E 81               [ 4] 5335 	ret 
                                   5336 
                                   5337 
                                   5338 ;---------------------
                                   5339 ; BASIC: USR(addr[,arg])
                                   5340 ; execute a function written 
                                   5341 ; in binary code.
                                   5342 ; binary fonction should 
                                   5343 ; return token attribute in A 
                                   5344 ; and value in X. 
                                   5345 ; input:
                                   5346 ;   addr	routine address 
                                   5347 ;   arg 	is an optional argument 
                                   5348 ; output:
                                   5349 ;   A 		token attribute 
                                   5350 ;   X       returned value 
                                   5351 ;---------------------
      001B9F                       5352 usr:
      001B9F 90 89            [ 2] 5353 	pushw y 	
      001BA1 CD 0E AB         [ 4] 5354 	call func_args 
      001BA4 A1 01            [ 1] 5355 	cp a,#1 
      001BA6 27 07            [ 1] 5356 	jreq 2$
      001BA8 A1 02            [ 1] 5357 	cp a,#2
      001BAA 27 03            [ 1] 5358 	jreq 2$  
      001BAC CC 07 01         [ 2] 5359 	jp syntax_error 
      001BAF 90 85            [ 2] 5360 2$: popw y  ; arg|addr 
      001BB1 A1 01            [ 1] 5361 	cp a,#1
      001BB3 27 02            [ 1] 5362 	jreq 3$
      001BB5 85               [ 2] 5363 	popw x ; addr
      001BB6 51               [ 1] 5364 	exgw x,y 
      001BB7 90 FD            [ 4] 5365 3$: call (y)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 103.
Hexadecimal [24-Bits]



      001BB9 90 85            [ 2] 5366 	popw y 
      001BBB 81               [ 4] 5367 	ret 
                                   5368 
                                   5369 ;------------------------------
                                   5370 ; BASIC: BYE 
                                   5371 ; halt mcu in its lowest power mode 
                                   5372 ; wait for reset or external interrupt
                                   5373 ; do a cold start on wakeup.
                                   5374 ;------------------------------
      001BBC                       5375 bye:
      001BBC 72 0D 52 30 FB   [ 2] 5376 	btjf UART1_SR,#UART_SR_TC,.
      001BC1 8E               [10] 5377 	halt
      001BC2 CC 04 D4         [ 2] 5378 	jp cold_start  
                                   5379 
                                   5380 ;----------------------------------
                                   5381 ; BASIC: AUTORUN "file_name" 
                                   5382 ; record in eeprom at adrress AUTORUN_NAME
                                   5383 ; the name of file to load and execute
                                   5384 ; at startup 
                                   5385 ; input:
                                   5386 ;   file_name   file to execute 
                                   5387 ; output:
                                   5388 ;   none
                                   5389 ;-----------------------------------
      001BC5                       5390 autorun: 
      001BC5 72 01 00 25 07   [ 2] 5391 	btjf flags,#FRUN,0$ 
      001BCA 27 05            [ 1] 5392 	jreq 0$ 
      001BCC A6 07            [ 1] 5393 	ld a,#ERR_CMD_ONLY 
      001BCE CC 07 03         [ 2] 5394 	jp tb_error 
      001BD1                       5395 0$:	
      001BD1 CD 07 B5         [ 4] 5396 	call next_token 
      001BD4 A1 0A            [ 1] 5397 	cp a,#TK_QSTR
      001BD6 27 03            [ 1] 5398 	jreq 1$
      001BD8 CC 07 01         [ 2] 5399 	jp syntax_error 
      001BDB                       5400 1$:	
      001BDB 89               [ 2] 5401 	pushw x ; file name char*
      001BDC 90 93            [ 1] 5402 	ldw y,x  
      001BDE CD 18 97         [ 4] 5403 	call search_file 
      001BE1 25 05            [ 1] 5404 	jrc 2$ 
      001BE3 A6 09            [ 1] 5405 	ld a,#ERR_NOT_FILE
      001BE5 CC 07 03         [ 2] 5406 	jp tb_error  
      001BE8                       5407 2$: 
      001BE8 55 00 03 00 01   [ 1] 5408 	mov in,count 
      001BED 72 5F 00 16      [ 1] 5409 	clr farptr 
      001BF1 AE 40 00         [ 2] 5410 	ldw x,#AUTORUN_NAME
      001BF4 CF 00 17         [ 2] 5411 	ldw farptr+1,x 
      001BF7 1E 01            [ 2] 5412 	ldw x,(1,sp)  
      001BF9 CD 01 FA         [ 4] 5413 	call strlen  ; return length in X 
      001BFC 90 85            [ 2] 5414 	popw y 
      001BFE 89               [ 2] 5415 	pushw x 
      001BFF 5F               [ 1] 5416 	clrw x 
      001C00 CD 01 55         [ 4] 5417 	call write_block 
      001C03                       5418 	_drop 2 
      001C03 5B 02            [ 2]    1     addw sp,#2 
      001C05 81               [ 4] 5419 	ret 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 104.
Hexadecimal [24-Bits]



                                   5420 
                                   5421 ;----------------------------------
                                   5422 ; BASIC: SLEEP 
                                   5423 ; halt mcu until reset or external
                                   5424 ; interrupt.
                                   5425 ; Resume progam after SLEEP command
                                   5426 ;----------------------------------
      001C06                       5427 sleep:
      001C06 72 0D 52 30 FB   [ 2] 5428 	btjf UART1_SR,#UART_SR_TC,.
      001C0B 72 16 00 25      [ 1] 5429 	bset flags,#FSLEEP
      001C0F 8E               [10] 5430 	halt 
      001C10 81               [ 4] 5431 	ret 
                                   5432 
                                   5433 ;-------------------------------
                                   5434 ; BASIC: PAUSE expr 
                                   5435 ; suspend execution for n msec.
                                   5436 ; input:
                                   5437 ;	none
                                   5438 ; output:
                                   5439 ;	none 
                                   5440 ;------------------------------
      001C11                       5441 pause:
      001C11 CD 0F 90         [ 4] 5442 	call expression
      001C14 A1 04            [ 1] 5443 	cp a,#TK_INTGR
      001C16 27 03            [ 1] 5444 	jreq pause02 
      001C18 CC 07 01         [ 2] 5445 	jp syntax_error
      001C1B                       5446 pause02: 
      001C1B 5D               [ 2] 5447 1$: tnzw x 
      001C1C 27 04            [ 1] 5448 	jreq 2$
      001C1E 8F               [10] 5449 	wfi 
      001C1F 5A               [ 2] 5450 	decw x 
      001C20 26 F9            [ 1] 5451 	jrne 1$
      001C22 4F               [ 1] 5452 2$:	clr a 
      001C23 81               [ 4] 5453 	ret 
                                   5454 
                                   5455 ;------------------------------
                                   5456 ; BASIC: AWU expr
                                   5457 ; halt mcu for 'expr' milliseconds
                                   5458 ; use Auto wakeup peripheral
                                   5459 ; all oscillators stopped except LSI
                                   5460 ; range: 1ms - 511ms
                                   5461 ; input:
                                   5462 ;  none
                                   5463 ; output:
                                   5464 ;  none:
                                   5465 ;------------------------------
      001C24                       5466 awu:
      001C24 CD 0F 90         [ 4] 5467   call expression
      001C27 A1 04            [ 1] 5468   cp a,#TK_INTGR
      001C29 27 03            [ 1] 5469   jreq awu02
      001C2B CC 07 01         [ 2] 5470   jp syntax_error
      001C2E                       5471 awu02:
      001C2E A3 14 00         [ 2] 5472   cpw x,#5120
      001C31 2B 0C            [ 1] 5473   jrmi 1$ 
      001C33 35 0F 50 F2      [ 1] 5474   mov AWU_TBR,#15 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 105.
Hexadecimal [24-Bits]



      001C37 A6 1E            [ 1] 5475   ld a,#30
      001C39 62               [ 2] 5476   div x,a
      001C3A A6 10            [ 1] 5477   ld a,#16
      001C3C 62               [ 2] 5478   div x,a 
      001C3D 20 1E            [ 2] 5479   jra 4$
      001C3F                       5480 1$: 
      001C3F A3 08 00         [ 2] 5481   cpw x,#2048
      001C42 2B 09            [ 1] 5482   jrmi 2$ 
      001C44 35 0E 50 F2      [ 1] 5483   mov AWU_TBR,#14
      001C48 A6 50            [ 1] 5484   ld a,#80
      001C4A 62               [ 2] 5485   div x,a 
      001C4B 20 10            [ 2] 5486   jra 4$   
      001C4D                       5487 2$:
      001C4D 35 07 50 F2      [ 1] 5488   mov AWU_TBR,#7
      001C51                       5489 3$:  
                                   5490 ; while X > 64  divide by 2 and increment AWU_TBR 
      001C51 A3 00 40         [ 2] 5491   cpw x,#64 
      001C54 23 07            [ 2] 5492   jrule 4$ 
      001C56 72 5C 50 F2      [ 1] 5493   inc AWU_TBR 
      001C5A 54               [ 2] 5494   srlw x 
      001C5B 20 F4            [ 2] 5495   jra 3$ 
      001C5D                       5496 4$:
      001C5D 9F               [ 1] 5497   ld a, xl
      001C5E 4A               [ 1] 5498   dec a 
      001C5F 27 01            [ 1] 5499   jreq 5$
      001C61 4A               [ 1] 5500   dec a 	
      001C62                       5501 5$: 
      001C62 A4 3E            [ 1] 5502   and a,#0x3e 
      001C64 C7 50 F1         [ 1] 5503   ld AWU_APR,a 
      001C67 72 18 50 F0      [ 1] 5504   bset AWU_CSR,#AWU_CSR_AWUEN
      001C6B 8E               [10] 5505   halt 
                                   5506 
      001C6C 81               [ 4] 5507   ret 
                                   5508 
                                   5509 ;------------------------------
                                   5510 ; BASIC: TICKS
                                   5511 ; return msec ticks counter value 
                                   5512 ; input:
                                   5513 ; 	none 
                                   5514 ; output:
                                   5515 ;	X 		TK_INTGR
                                   5516 ;-------------------------------
      001C6D                       5517 get_ticks:
      001C6D CE 00 0E         [ 2] 5518 	ldw x,ticks 
      001C70 A6 04            [ 1] 5519 	ld a,#TK_INTGR
      001C72 81               [ 4] 5520 	ret 
                                   5521 
                                   5522 
                                   5523 
                                   5524 ;------------------------------
                                   5525 ; BASIC: ABS(expr)
                                   5526 ; return absolute value of expr.
                                   5527 ; input:
                                   5528 ;   none
                                   5529 ; output:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 106.
Hexadecimal [24-Bits]



                                   5530 ;   X     	positive integer
                                   5531 ;-------------------------------
      001C73                       5532 abs:
      001C73 CD 0E AB         [ 4] 5533 	call func_args 
      001C76 A1 01            [ 1] 5534 	cp a,#1 
      001C78 27 03            [ 1] 5535 	jreq 0$ 
      001C7A CC 07 01         [ 2] 5536 	jp syntax_error
      001C7D                       5537 0$:  
      001C7D 85               [ 2] 5538     popw x   
      001C7E 9E               [ 1] 5539 	ld a,xh 
      001C7F A5 80            [ 1] 5540 	bcp a,#0x80 
      001C81 27 01            [ 1] 5541 	jreq 2$ 
      001C83 50               [ 2] 5542 	negw x 
      001C84 A6 04            [ 1] 5543 2$: ld a,#TK_INTGR 
      001C86 81               [ 4] 5544 	ret 
                                   5545 
                                   5546 ;------------------------------
                                   5547 ; BASIC: AND(expr1,expr2)
                                   5548 ; Apply bit AND relation between
                                   5549 ; the 2 arguments, i.e expr1 & expr2 
                                   5550 ; output:
                                   5551 ; 	A 		TK_INTGR
                                   5552 ;   X 		result 
                                   5553 ;------------------------------
      001C87                       5554 bit_and:
      001C87 CD 0E AB         [ 4] 5555 	call func_args 
      001C8A A1 02            [ 1] 5556 	cp a,#2
      001C8C 27 03            [ 1] 5557 	jreq 1$
      001C8E CC 07 01         [ 2] 5558 	jp syntax_error 
      001C91 85               [ 2] 5559 1$:	popw x 
      001C92 9E               [ 1] 5560 	ld a,xh 
      001C93 14 01            [ 1] 5561 	and a,(1,sp)
      001C95 95               [ 1] 5562 	ld xh,a 
      001C96 9F               [ 1] 5563 	ld a,xl
      001C97 14 02            [ 1] 5564 	and a,(2,sp)
      001C99 97               [ 1] 5565 	ld xl,a 
      001C9A                       5566 	_drop 2 
      001C9A 5B 02            [ 2]    1     addw sp,#2 
      001C9C A6 04            [ 1] 5567 	ld a,#TK_INTGR
      001C9E 81               [ 4] 5568 	ret
                                   5569 
                                   5570 ;------------------------------
                                   5571 ; BASIC: OR(expr1,expr2)
                                   5572 ; Apply bit OR relation between
                                   5573 ; the 2 arguments, i.e expr1 | expr2 
                                   5574 ; output:
                                   5575 ; 	A 		TK_INTGR
                                   5576 ;   X 		result 
                                   5577 ;------------------------------
      001C9F                       5578 bit_or:
      001C9F CD 0E AB         [ 4] 5579 	call func_args 
      001CA2 A1 02            [ 1] 5580 	cp a,#2
      001CA4 27 03            [ 1] 5581 	jreq 1$
      001CA6 CC 07 01         [ 2] 5582 	jp syntax_error 
      001CA9                       5583 1$: 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 107.
Hexadecimal [24-Bits]



      001CA9 85               [ 2] 5584 	popw x 
      001CAA 9E               [ 1] 5585 	ld a,xh 
      001CAB 1A 01            [ 1] 5586 	or a,(1,sp)
      001CAD 95               [ 1] 5587 	ld xh,a 
      001CAE 9F               [ 1] 5588 	ld a,xl 
      001CAF 1A 02            [ 1] 5589 	or a,(2,sp)
      001CB1 97               [ 1] 5590 	ld xl,a 
      001CB2                       5591 	_drop 2 
      001CB2 5B 02            [ 2]    1     addw sp,#2 
      001CB4 A6 04            [ 1] 5592 	ld a,#TK_INTGR 
      001CB6 81               [ 4] 5593 	ret
                                   5594 
                                   5595 ;------------------------------
                                   5596 ; BASIC: XOR(expr1,expr2)
                                   5597 ; Apply bit XOR relation between
                                   5598 ; the 2 arguments, i.e expr1 ^ expr2 
                                   5599 ; output:
                                   5600 ; 	A 		TK_INTGR
                                   5601 ;   X 		result 
                                   5602 ;------------------------------
      001CB7                       5603 bit_xor:
      001CB7 CD 0E AB         [ 4] 5604 	call func_args 
      001CBA A1 02            [ 1] 5605 	cp a,#2
      001CBC 27 03            [ 1] 5606 	jreq 1$
      001CBE CC 07 01         [ 2] 5607 	jp syntax_error 
      001CC1                       5608 1$: 
      001CC1 85               [ 2] 5609 	popw x 
      001CC2 9E               [ 1] 5610 	ld a,xh 
      001CC3 18 01            [ 1] 5611 	xor a,(1,sp)
      001CC5 95               [ 1] 5612 	ld xh,a 
      001CC6 9F               [ 1] 5613 	ld a,xl 
      001CC7 18 02            [ 1] 5614 	xor a,(2,sp)
      001CC9 97               [ 1] 5615 	ld xl,a 
      001CCA                       5616 	_drop 2 
      001CCA 5B 02            [ 2]    1     addw sp,#2 
      001CCC A6 04            [ 1] 5617 	ld a,#TK_INTGR 
      001CCE 81               [ 4] 5618 	ret 
                                   5619 
                                   5620 ;------------------------------
                                   5621 ; BASIC: LSHIFT(expr1,expr2)
                                   5622 ; logical shift left expr1 by 
                                   5623 ; expr2 bits 
                                   5624 ; output:
                                   5625 ; 	A 		TK_INTGR
                                   5626 ;   X 		result 
                                   5627 ;------------------------------
      001CCF                       5628 lshift:
      001CCF CD 0E AB         [ 4] 5629 	call func_args
      001CD2 A1 02            [ 1] 5630 	cp a,#2 
      001CD4 27 03            [ 1] 5631 	jreq 1$
      001CD6 CC 07 01         [ 2] 5632 	jp syntax_error
      001CD9 90 85            [ 2] 5633 1$: popw y   
      001CDB 85               [ 2] 5634 	popw x 
      001CDC 90 5D            [ 2] 5635 	tnzw y 
      001CDE 27 05            [ 1] 5636 	jreq 4$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 108.
Hexadecimal [24-Bits]



      001CE0 58               [ 2] 5637 2$:	sllw x 
      001CE1 90 5A            [ 2] 5638 	decw y 
      001CE3 26 FB            [ 1] 5639 	jrne 2$
      001CE5                       5640 4$:  
      001CE5 A6 04            [ 1] 5641 	ld a,#TK_INTGR
      001CE7 81               [ 4] 5642 	ret
                                   5643 
                                   5644 ;------------------------------
                                   5645 ; BASIC: RSHIFT(expr1,expr2)
                                   5646 ; logical shift right expr1 by 
                                   5647 ; expr2 bits.
                                   5648 ; output:
                                   5649 ; 	A 		TK_INTGR
                                   5650 ;   X 		result 
                                   5651 ;------------------------------
      001CE8                       5652 rshift:
      001CE8 CD 0E AB         [ 4] 5653 	call func_args
      001CEB A1 02            [ 1] 5654 	cp a,#2 
      001CED 27 03            [ 1] 5655 	jreq 1$
      001CEF CC 07 01         [ 2] 5656 	jp syntax_error
      001CF2 90 85            [ 2] 5657 1$: popw y  
      001CF4 85               [ 2] 5658 	popw x
      001CF5 90 5D            [ 2] 5659 	tnzw y 
      001CF7 27 05            [ 1] 5660 	jreq 4$
      001CF9 54               [ 2] 5661 2$:	srlw x 
      001CFA 90 5A            [ 2] 5662 	decw y 
      001CFC 26 FB            [ 1] 5663 	jrne 2$
      001CFE                       5664 4$:  
      001CFE A6 04            [ 1] 5665 	ld a,#TK_INTGR
      001D00 81               [ 4] 5666 	ret
                                   5667 
                                   5668 ;--------------------------
                                   5669 ; BASIC: FCPU integer
                                   5670 ; set CPU frequency 
                                   5671 ;-------------------------- 
                                   5672 
      001D01                       5673 fcpu:
      001D01 A6 04            [ 1] 5674 	ld a,#TK_INTGR
      001D03 CD 0E 77         [ 4] 5675 	call expect 
      001D06 9F               [ 1] 5676 	ld a,xl 
      001D07 A4 07            [ 1] 5677 	and a,#7 
      001D09 C7 50 C6         [ 1] 5678 	ld CLK_CKDIVR,a 
      001D0C 81               [ 4] 5679 	ret 
                                   5680 
                                   5681 ;------------------------------
                                   5682 ; BASIC: PMODE pin#, mode 
                                   5683 ; Arduino pin. 
                                   5684 ; define pin as input or output
                                   5685 ; pin#: {0..15}
                                   5686 ; mode: INPUT|OUTPUT  
                                   5687 ;------------------------------
                           000001  5688 	PINNO=1
                           000001  5689 	VSIZE=1
      001D0D                       5690 pin_mode:
      001D0D                       5691 	_vars VSIZE 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 109.
Hexadecimal [24-Bits]



      001D0D 52 01            [ 2]    1     sub sp,#VSIZE 
      001D0F CD 0E 84         [ 4] 5692 	call arg_list 
      001D12 A1 02            [ 1] 5693 	cp a,#2 
      001D14 27 03            [ 1] 5694 	jreq 1$
      001D16 CC 07 01         [ 2] 5695 	jp syntax_error 
      001D19 90 85            [ 2] 5696 1$: popw y ; mode 
      001D1B 85               [ 2] 5697 	popw x ; Dx pin 
      001D1C CD 1D 4E         [ 4] 5698 	call select_pin 
      001D1F 6B 01            [ 1] 5699 	ld (PINNO,sp),a  
      001D21 A6 01            [ 1] 5700 	ld a,#1 
      001D23 0D 01            [ 1] 5701 	tnz (PINNO,sp)
      001D25 27 0B            [ 1] 5702 	jreq 4$
      001D27 48               [ 1] 5703 2$:	sll a 
      001D28 0A 01            [ 1] 5704 	dec (PINNO,sp)
      001D2A 26 FB            [ 1] 5705 	jrne 2$ 
      001D2C 6B 01            [ 1] 5706 	ld (PINNO,sp),a
      001D2E EA 03            [ 1] 5707 	or a,(GPIO_CR1,x) ;if input->pull-up else push-pull 
      001D30 E7 03            [ 1] 5708 	ld (GPIO_CR1,x),a 
      001D32 90 A3 00 01      [ 2] 5709 4$:	cpw y,#OUTP 
      001D36 27 07            [ 1] 5710 	jreq 6$
                                   5711 ; input mode
      001D38 7B 01            [ 1] 5712 	ld a,(PINNO,sp)
      001D3A 43               [ 1] 5713 	cpl a 
      001D3B E4 02            [ 1] 5714 	and a,(GPIO_DDR,x)	; bit==0 for input. 
      001D3D 20 0A            [ 2] 5715 	jra 9$
      001D3F                       5716 6$: ;output mode  
      001D3F 7B 01            [ 1] 5717 	ld a,(PINNO,sp)
      001D41 EA 04            [ 1] 5718 	or a,(GPIO_CR2,x) ;port speed 10 Mhz 
      001D43 E7 04            [ 1] 5719 	ld (GPIO_CR2,x),a 
      001D45 7B 01            [ 1] 5720 	ld a,(PINNO,sp)
      001D47 EA 02            [ 1] 5721 	or a,(GPIO_DDR,x) ; bit==1 for output 
      001D49 E7 02            [ 1] 5722 9$:	ld (GPIO_DDR,x),a 
      001D4B                       5723 	_drop VSIZE 
      001D4B 5B 01            [ 2]    1     addw sp,#VSIZE 
      001D4D 81               [ 4] 5724 	ret
                                   5725 
                                   5726 ;------------------------
                                   5727 ; select Arduino pin 
                                   5728 ; input:
                                   5729 ;   X 	 {0..15} Arduino Dx 
                                   5730 ; output:
                                   5731 ;   A     stm8s208 pin 
                                   5732 ;   X     base address s208 GPIO port 
                                   5733 ;---------------------------
      001D4E                       5734 select_pin:
      001D4E 58               [ 2] 5735 	sllw x 
      001D4F 1C 1D 5E         [ 2] 5736 	addw x,#arduino_to_8s208 
      001D52 FE               [ 2] 5737 	ldw x,(x)
      001D53 9F               [ 1] 5738 	ld a,xl 
      001D54 88               [ 1] 5739 	push a 
      001D55 5E               [ 1] 5740 	swapw x 
      001D56 A6 05            [ 1] 5741 	ld a,#5 
      001D58 42               [ 4] 5742 	mul x,a 
      001D59 1C 50 00         [ 2] 5743 	addw x,#GPIO_BASE 
      001D5C 84               [ 1] 5744 	pop a 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 110.
Hexadecimal [24-Bits]



      001D5D 81               [ 4] 5745 	ret 
                                   5746 ; translation from Arduino D0..D15 to stm8s208rb 
      001D5E                       5747 arduino_to_8s208:
      001D5E 03 06                 5748 .byte 3,6 ; D0 
      001D60 03 05                 5749 .byte 3,5 ; D1 
      001D62 04 00                 5750 .byte 4,0 ; D2 
      001D64 02 01                 5751 .byte 2,1 ; D3
      001D66 06 00                 5752 .byte 6,0 ; D4
      001D68 02 02                 5753 .byte 2,2 ; D5
      001D6A 02 03                 5754 .byte 2,3 ; D6
      001D6C 03 01                 5755 .byte 3,1 ; D7
      001D6E 03 03                 5756 .byte 3,3 ; D8
      001D70 02 04                 5757 .byte 2,4 ; D9
      001D72 04 05                 5758 .byte 4,5 ; D10
      001D74 02 06                 5759 .byte 2,6 ; D11
      001D76 02 07                 5760 .byte 2,7 ; D12
      001D78 02 05                 5761 .byte 2,5 ; D13
      001D7A 04 02                 5762 .byte 4,2 ; D14
      001D7C 04 01                 5763 .byte 4,1 ; D15
                                   5764 
                                   5765 
                                   5766 ;------------------------------
                                   5767 ; BASIC: RND(expr)
                                   5768 ; return random number 
                                   5769 ; between 1 and expr inclusive
                                   5770 ; xorshift16 ref: http://b2d-f9r.blogspot.com/2010/08/16-bit-xorshift-rng-now-with-more.html
                                   5771 ; input:
                                   5772 ; 	none 
                                   5773 ; output:
                                   5774 ;	X 		random positive integer 
                                   5775 ;------------------------------
      001D7E                       5776 random:
      001D7E CD 0E AB         [ 4] 5777 	call func_args 
      001D81 A1 01            [ 1] 5778 	cp a,#1
      001D83 27 03            [ 1] 5779 	jreq 1$
      001D85 CC 07 01         [ 2] 5780 	jp syntax_error
      001D88                       5781 1$:  
      001D88 A6 80            [ 1] 5782 	ld a,#0x80 
      001D8A 15 01            [ 1] 5783 	bcp a,(1,sp)
      001D8C 27 05            [ 1] 5784 	jreq 2$
      001D8E A6 0A            [ 1] 5785 	ld a,#ERR_BAD_VALUE
      001D90 CC 07 03         [ 2] 5786 	jp tb_error
      001D93                       5787 2$: 
                                   5788 ; acc16=(x<<5)^x 
      001D93 CE 00 12         [ 2] 5789 	ldw x,seedx 
      001D96 58               [ 2] 5790 	sllw x 
      001D97 58               [ 2] 5791 	sllw x 
      001D98 58               [ 2] 5792 	sllw x 
      001D99 58               [ 2] 5793 	sllw x 
      001D9A 58               [ 2] 5794 	sllw x 
      001D9B 9E               [ 1] 5795 	ld a,xh 
      001D9C C8 00 12         [ 1] 5796 	xor a,seedx 
      001D9F C7 00 0C         [ 1] 5797 	ld acc16,a 
      001DA2 9F               [ 1] 5798 	ld a,xl 
      001DA3 C8 00 13         [ 1] 5799 	xor a,seedx+1 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 111.
Hexadecimal [24-Bits]



      001DA6 C7 00 0D         [ 1] 5800 	ld acc8,a 
                                   5801 ; seedx=seedy 
      001DA9 CE 00 14         [ 2] 5802 	ldw x,seedy 
      001DAC CF 00 12         [ 2] 5803 	ldw seedx,x  
                                   5804 ; seedy=seedy^(seedy>>1)
      001DAF 90 54            [ 2] 5805 	srlw y 
      001DB1 90 9E            [ 1] 5806 	ld a,yh 
      001DB3 C8 00 14         [ 1] 5807 	xor a,seedy 
      001DB6 C7 00 14         [ 1] 5808 	ld seedy,a  
      001DB9 90 9F            [ 1] 5809 	ld a,yl 
      001DBB C8 00 15         [ 1] 5810 	xor a,seedy+1 
      001DBE C7 00 15         [ 1] 5811 	ld seedy+1,a 
                                   5812 ; acc16>>3 
      001DC1 CE 00 0C         [ 2] 5813 	ldw x,acc16 
      001DC4 54               [ 2] 5814 	srlw x 
      001DC5 54               [ 2] 5815 	srlw x 
      001DC6 54               [ 2] 5816 	srlw x 
                                   5817 ; x=acc16^x 
      001DC7 9E               [ 1] 5818 	ld a,xh 
      001DC8 C8 00 0C         [ 1] 5819 	xor a,acc16 
      001DCB 95               [ 1] 5820 	ld xh,a 
      001DCC 9F               [ 1] 5821 	ld a,xl 
      001DCD C8 00 0D         [ 1] 5822 	xor a,acc8 
      001DD0 97               [ 1] 5823 	ld xl,a 
                                   5824 ; seedy=x^seedy 
      001DD1 C8 00 15         [ 1] 5825 	xor a,seedy+1
      001DD4 97               [ 1] 5826 	ld xl,a 
      001DD5 9E               [ 1] 5827 	ld a,xh 
      001DD6 C8 00 14         [ 1] 5828 	xor a,seedy
      001DD9 95               [ 1] 5829 	ld xh,a 
      001DDA CF 00 14         [ 2] 5830 	ldw seedy,x 
                                   5831 ; return seedy modulo expr + 1 
      001DDD 90 85            [ 2] 5832 	popw y 
      001DDF 65               [ 2] 5833 	divw x,y 
      001DE0 93               [ 1] 5834 	ldw x,y 
      001DE1 5C               [ 2] 5835 	incw x 
      001DE2                       5836 10$:
      001DE2 A6 04            [ 1] 5837 	ld a,#TK_INTGR
      001DE4 81               [ 4] 5838 	ret 
                                   5839 
                                   5840 ;---------------------------------
                                   5841 ; BASIC: WORDS 
                                   5842 ; affiche la listes des mots du
                                   5843 ; dictionnaire.
                                   5844 ;---------------------------------
                           000001  5845 	WLEN=1
                           000002  5846 	LLEN=2  
                           000002  5847 	VSIZE=2 
      001DE5                       5848 words:
      001DE5                       5849 	_vars VSIZE
      001DE5 52 02            [ 2]    1     sub sp,#VSIZE 
      001DE7 0F 02            [ 1] 5850 	clr (LLEN,sp)
      001DE9 90 AE 24 90      [ 2] 5851 	ldw y,#kword_dict+2
      001DED 93               [ 1] 5852 0$:	ldw x,y
      001DEE F6               [ 1] 5853 	ld a,(x)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 112.
Hexadecimal [24-Bits]



      001DEF A4 0F            [ 1] 5854 	and a,#15 
      001DF1 6B 01            [ 1] 5855 	ld (WLEN,sp),a 
      001DF3 5C               [ 2] 5856 1$:	incw x 
      001DF4 F6               [ 1] 5857 	ld a,(x)
      001DF5 CD 01 B3         [ 4] 5858 	call putc 
      001DF8 0C 02            [ 1] 5859 	inc (LLEN,sp)
      001DFA 0A 01            [ 1] 5860 	dec (WLEN,sp)
      001DFC 26 F5            [ 1] 5861 	jrne 1$
      001DFE A6 46            [ 1] 5862 	ld a,#70
      001E00 11 02            [ 1] 5863 	cp a,(LLEN,sp)
      001E02 2B 09            [ 1] 5864 	jrmi 2$   
      001E04 A6 20            [ 1] 5865 	ld a,#SPACE 
      001E06 CD 01 B3         [ 4] 5866 	call putc 
      001E09 0C 02            [ 1] 5867 	inc (LLEN,sp) 
      001E0B 20 07            [ 2] 5868 	jra 3$
      001E0D A6 0D            [ 1] 5869 2$: ld a,#CR 
      001E0F CD 01 B3         [ 4] 5870 	call putc 
      001E12 0F 02            [ 1] 5871 	clr (LLEN,sp)
      001E14 72 A2 00 02      [ 2] 5872 3$:	subw y,#2 
      001E18 90 FE            [ 2] 5873 	ldw y,(y)
      001E1A 26 D1            [ 1] 5874 	jrne 0$  
      001E1C                       5875 	_drop VSIZE 
      001E1C 5B 02            [ 2]    1     addw sp,#VSIZE 
      001E1E 81               [ 4] 5876 	ret 
                                   5877 
                                   5878 
                                   5879 ;-----------------------------
                                   5880 ; BASIC: TIMER expr 
                                   5881 ; initialize count down timer 
                                   5882 ;-----------------------------
      001E1F                       5883 set_timer:
      001E1F CD 0E 84         [ 4] 5884 	call arg_list
      001E22 A1 01            [ 1] 5885 	cp a,#1 
      001E24 27 03            [ 1] 5886 	jreq 1$
      001E26 CC 07 01         [ 2] 5887 	jp syntax_error
      001E29                       5888 1$: 
      001E29 85               [ 2] 5889 	popw x 
      001E2A CF 00 10         [ 2] 5890 	ldw timer,x 
      001E2D 81               [ 4] 5891 	ret 
                                   5892 
                                   5893 ;------------------------------
                                   5894 ; BASIC: TIMEOUT 
                                   5895 ; return state of timer 
                                   5896 ;------------------------------
      001E2E                       5897 timeout:
      001E2E CE 00 10         [ 2] 5898 	ldw x,timer 
      001E31                       5899 logical_complement:
      001E31 53               [ 2] 5900 	cplw x 
      001E32 A3 FF FF         [ 2] 5901 	cpw x,#-1
      001E35 27 01            [ 1] 5902 	jreq 2$
      001E37 5F               [ 1] 5903 	clrw x 
      001E38 A6 04            [ 1] 5904 2$:	ld a,#TK_INTGR
      001E3A 81               [ 4] 5905 	ret 
                                   5906 
                                   5907 ;--------------------------------
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 113.
Hexadecimal [24-Bits]



                                   5908 ; BASIC NOT(expr) 
                                   5909 ; return logical complement of expr
                                   5910 ;--------------------------------
      001E3B                       5911 func_not:
      001E3B CD 0E AB         [ 4] 5912 	call func_args  
      001E3E A1 01            [ 1] 5913 	cp a,#1
      001E40 27 03            [ 1] 5914 	jreq 1$
      001E42 CC 07 01         [ 2] 5915 	jp syntax_error
      001E45 85               [ 2] 5916 1$:	popw x 
      001E46 20 E9            [ 2] 5917 	jra logical_complement
                                   5918 
                                   5919 
                                   5920 
                                   5921 ;-----------------------------------
                                   5922 ; BASIC: IWDGEN expr1 
                                   5923 ; enable independant watchdog timer
                                   5924 ; expr1 is delay in multiple of 62.5µsec
                                   5925 ; expr1 -> {1..16383}
                                   5926 ;-----------------------------------
      001E48                       5927 enable_iwdg:
      001E48 CD 0E 84         [ 4] 5928 	call arg_list
      001E4B A1 01            [ 1] 5929 	cp a,#1 
      001E4D 27 03            [ 1] 5930 	jreq 1$
      001E4F CC 07 01         [ 2] 5931 	jp syntax_error 
      001E52 85               [ 2] 5932 1$: popw x 
      001E53 4B 00            [ 1] 5933 	push #0
      001E55 35 CC 50 E0      [ 1] 5934 	mov IWDG_KR,#IWDG_KEY_ENABLE
      001E59 9E               [ 1] 5935 	ld a,xh 
      001E5A A4 3F            [ 1] 5936 	and a,#0x3f
      001E5C 95               [ 1] 5937 	ld xh,a  
      001E5D A3 00 FF         [ 2] 5938 2$:	cpw x,#255
      001E60 23 06            [ 2] 5939 	jrule 3$
      001E62 0C 01            [ 1] 5940 	inc (1,sp)
      001E64 98               [ 1] 5941 	rcf 
      001E65 56               [ 2] 5942 	rrcw x 
      001E66 20 F5            [ 2] 5943 	jra 2$
      001E68 35 55 50 E0      [ 1] 5944 3$:	mov IWDG_KR,#IWDG_KEY_ACCESS 
      001E6C 84               [ 1] 5945 	pop a  
      001E6D C7 50 E1         [ 1] 5946 	ld IWDG_PR,a 
      001E70 9F               [ 1] 5947 	ld a,xl
      001E71 4A               [ 1] 5948 	dec a 
      001E72 35 55 50 E0      [ 1] 5949 	mov IWDG_KR,#IWDG_KEY_ACCESS 
      001E76 C7 50 E2         [ 1] 5950 	ld IWDG_RLR,a 
      001E79 35 AA 50 E0      [ 1] 5951 	mov IWDG_KR,#IWDG_KEY_REFRESH
      001E7D 81               [ 4] 5952 	ret 
                                   5953 
                                   5954 
                                   5955 ;-----------------------------------
                                   5956 ; BASIC: IWDGREF  
                                   5957 ; refresh independant watchdog count down 
                                   5958 ; timer before it reset MCU. 
                                   5959 ;-----------------------------------
      001E7E                       5960 refresh_iwdg:
      001E7E 35 AA 50 E0      [ 1] 5961 	mov IWDG_KR,#IWDG_KEY_REFRESH 
      001E82 81               [ 4] 5962 	ret 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 114.
Hexadecimal [24-Bits]



                                   5963 
                                   5964 
                                   5965 ;-------------------------------------
                                   5966 ; BASIC: LOG(expr)
                                   5967 ; return logarithm base 2 of expr 
                                   5968 ; this is the position of most significant
                                   5969 ; bit set. 
                                   5970 ; input: 
                                   5971 ; output:
                                   5972 ;   X     log2 
                                   5973 ;   A     TK_INTGR 
                                   5974 ;*********************************
      001E83                       5975 log2:
      001E83 CD 0E AB         [ 4] 5976 	call func_args 
      001E86 A1 01            [ 1] 5977 	cp a,#1 
      001E88 27 03            [ 1] 5978 	jreq 1$
      001E8A CC 07 01         [ 2] 5979 	jp syntax_error 
      001E8D 85               [ 2] 5980 1$: popw x 
      001E8E                       5981 leading_one:
      001E8E 5D               [ 2] 5982 	tnzw x 
      001E8F 27 0A            [ 1] 5983 	jreq 4$
      001E91 A6 0F            [ 1] 5984 	ld a,#15 
      001E93 59               [ 2] 5985 2$: rlcw x 
      001E94 25 03            [ 1] 5986     jrc 3$
      001E96 4A               [ 1] 5987 	dec a 
      001E97 20 FA            [ 2] 5988 	jra 2$
      001E99 5F               [ 1] 5989 3$: clrw x 
      001E9A 97               [ 1] 5990     ld xl,a
      001E9B A6 04            [ 1] 5991 4$:	ld a,#TK_INTGR
      001E9D 81               [ 4] 5992 	ret 
                                   5993 
                                   5994 ;-----------------------------------
                                   5995 ; BASIC: BIT(expr) 
                                   5996 ; expr ->{0..15}
                                   5997 ; return 2^expr 
                                   5998 ; output:
                                   5999 ;    x    2^expr 
                                   6000 ;-----------------------------------
      001E9E                       6001 bitmask:
      001E9E CD 0E AB         [ 4] 6002     call func_args 
      001EA1 A1 01            [ 1] 6003 	cp a,#1
      001EA3 27 03            [ 1] 6004 	jreq 1$
      001EA5 CC 07 01         [ 2] 6005 	jp syntax_error 
      001EA8 85               [ 2] 6006 1$: popw x 
      001EA9 9F               [ 1] 6007 	ld a,xl 
      001EAA A4 0F            [ 1] 6008 	and a,#15
      001EAC 5F               [ 1] 6009 	clrw x 
      001EAD 5C               [ 2] 6010 	incw x 
      001EAE 4D               [ 1] 6011 2$: tnz a 
      001EAF 27 04            [ 1] 6012 	jreq 3$
      001EB1 58               [ 2] 6013 	slaw x 
      001EB2 4A               [ 1] 6014 	dec a 
      001EB3 20 F9            [ 2] 6015 	jra 2$ 
      001EB5 A6 04            [ 1] 6016 3$: ld a,#TK_INTGR
      001EB7 81               [ 4] 6017 	ret 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 115.
Hexadecimal [24-Bits]



                                   6018 
                                   6019 ;------------------------------
                                   6020 ; BASIC: INVERT(expr)
                                   6021 ; 1's complement 
                                   6022 ;--------------------------------
      001EB8                       6023 invert:
      001EB8 CD 0E AB         [ 4] 6024 	call func_args
      001EBB A1 01            [ 1] 6025 	cp a,#1 
      001EBD 27 03            [ 1] 6026 	jreq 1$
      001EBF CC 07 01         [ 2] 6027 	jp syntax_error
      001EC2 85               [ 2] 6028 1$: popw x  
      001EC3 53               [ 2] 6029 	cplw x 
      001EC4 A6 04            [ 1] 6030 	ld a,#TK_INTGR 
      001EC6 81               [ 4] 6031 	ret 
                                   6032 
                                   6033 ;------------------------------
                                   6034 ; BASIC: DO 
                                   6035 ; initiate a DO ... UNTIL loop 
                                   6036 ;------------------------------
                           000003  6037 	DOLP_ADR=3 
                           000005  6038 	DOLP_INW=5
                           000004  6039 	VSIZE=4 
      001EC7                       6040 do_loop:
      001EC7 85               [ 2] 6041 	popw x 
      001EC8                       6042 	_vars VSIZE 
      001EC8 52 04            [ 2]    1     sub sp,#VSIZE 
      001ECA 89               [ 2] 6043 	pushw x 
      001ECB 90 CE 00 04      [ 2] 6044 	ldw y,basicptr 
      001ECF 17 03            [ 2] 6045 	ldw (DOLP_ADR,sp),y
      001ED1 90 CE 00 00      [ 2] 6046 	ldw y,in.w 
      001ED5 17 05            [ 2] 6047 	ldw (DOLP_INW,sp),y
      001ED7 72 5C 00 22      [ 1] 6048 	inc loop_depth 
      001EDB 81               [ 4] 6049 	ret 
                                   6050 
                                   6051 ;--------------------------------
                                   6052 ; BASIC: UNTIL expr 
                                   6053 ; loop if exprssion is false 
                                   6054 ; else terminate loop
                                   6055 ;--------------------------------
      001EDC                       6056 until: 
      001EDC 72 5D 00 22      [ 1] 6057 	tnz loop_depth 
      001EE0 26 03            [ 1] 6058 	jrne 1$ 
      001EE2 CC 07 01         [ 2] 6059 	jp syntax_error 
      001EE5                       6060 1$: 
      001EE5 CD 0F D4         [ 4] 6061 	call relation 
      001EE8 A1 04            [ 1] 6062 	cp a,#TK_INTGR
      001EEA 27 03            [ 1] 6063 	jreq 2$
      001EEC CC 07 01         [ 2] 6064 	jp syntax_error
      001EEF                       6065 2$: 
      001EEF 5D               [ 2] 6066 	tnzw x 
      001EF0 26 10            [ 1] 6067 	jrne 9$
      001EF2 1E 03            [ 2] 6068 	ldw x,(DOLP_ADR,sp)
      001EF4 CF 00 04         [ 2] 6069 	ldw basicptr,x 
      001EF7 E6 02            [ 1] 6070 	ld a,(2,x)
      001EF9 C7 00 03         [ 1] 6071 	ld count,a 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 116.
Hexadecimal [24-Bits]



      001EFC 1E 05            [ 2] 6072 	ldw x,(DOLP_INW,sp)
      001EFE CF 00 00         [ 2] 6073 	ldw in.w,x 
      001F01 81               [ 4] 6074 	ret 
      001F02                       6075 9$:	; remove loop data from stack  
      001F02 85               [ 2] 6076 	popw x
      001F03                       6077 	_drop VSIZE
      001F03 5B 04            [ 2]    1     addw sp,#VSIZE 
      001F05 72 5A 00 22      [ 1] 6078 	dec loop_depth 
      001F09 FC               [ 2] 6079 	jp (x)
                                   6080 
                                   6081 ;--------------------------
                                   6082 ; BASIC: PRTA...PRTI  
                                   6083 ;  return constant value 
                                   6084 ;  PORT  offset in GPIO
                                   6085 ;  array
                                   6086 ;---------------------------
      001F0A                       6087 const_porta:
      001F0A AE 00 00         [ 2] 6088 	ldw x,#0
      001F0D A6 04            [ 1] 6089 	ld a,#TK_INTGR 
      001F0F 81               [ 4] 6090 	ret 
      001F10                       6091 const_portb:
      001F10 AE 00 01         [ 2] 6092 	ldw x,#1
      001F13 A6 04            [ 1] 6093 	ld a,#TK_INTGR 
      001F15 81               [ 4] 6094 	ret 
      001F16                       6095 const_portc:
      001F16 AE 00 02         [ 2] 6096 	ldw x,#2
      001F19 A6 04            [ 1] 6097 	ld a,#TK_INTGR 
      001F1B 81               [ 4] 6098 	ret 
      001F1C                       6099 const_portd:
      001F1C AE 00 03         [ 2] 6100 	ldw x,#3
      001F1F A6 04            [ 1] 6101 	ld a,#TK_INTGR 
      001F21 81               [ 4] 6102 	ret 
      001F22                       6103 const_porte:
      001F22 AE 00 04         [ 2] 6104 	ldw x,#4
      001F25 A6 04            [ 1] 6105 	ld a,#TK_INTGR 
      001F27 81               [ 4] 6106 	ret 
      001F28                       6107 const_portf:
      001F28 AE 00 05         [ 2] 6108 	ldw x,#5
      001F2B A6 04            [ 1] 6109 	ld a,#TK_INTGR 
      001F2D 81               [ 4] 6110 	ret 
      001F2E                       6111 const_portg:
      001F2E AE 00 06         [ 2] 6112 	ldw x,#6
      001F31 A6 04            [ 1] 6113 	ld a,#TK_INTGR 
      001F33 81               [ 4] 6114 	ret 
      001F34                       6115 const_porth:
      001F34 AE 00 07         [ 2] 6116 	ldw x,#7
      001F37 A6 04            [ 1] 6117 	ld a,#TK_INTGR 
      001F39 81               [ 4] 6118 	ret 
      001F3A                       6119 const_porti:
      001F3A AE 00 08         [ 2] 6120 	ldw x,#8
      001F3D A6 04            [ 1] 6121 	ld a,#TK_INTGR 
      001F3F 81               [ 4] 6122 	ret 
                                   6123 
                                   6124 ;-------------------------------
                                   6125 ; following return constant 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 117.
Hexadecimal [24-Bits]



                                   6126 ; related to GPIO register offset 
                                   6127 ;---------------------------------
      001F40                       6128 const_odr:
      001F40 A6 04            [ 1] 6129 	ld a,#TK_INTGR 
      001F42 AE 00 00         [ 2] 6130 	ldw x,#GPIO_ODR
      001F45 81               [ 4] 6131 	ret 
      001F46                       6132 const_idr:
      001F46 A6 04            [ 1] 6133 	ld a,#TK_INTGR 
      001F48 AE 00 01         [ 2] 6134 	ldw x,#GPIO_IDR
      001F4B 81               [ 4] 6135 	ret 
      001F4C                       6136 const_ddr:
      001F4C A6 04            [ 1] 6137 	ld a,#TK_INTGR 
      001F4E AE 00 02         [ 2] 6138 	ldw x,#GPIO_DDR
      001F51 81               [ 4] 6139 	ret 
      001F52                       6140 const_cr1:
      001F52 A6 04            [ 1] 6141 	ld a,#TK_INTGR 
      001F54 AE 00 03         [ 2] 6142 	ldw x,#GPIO_CR1
      001F57 81               [ 4] 6143 	ret 
      001F58                       6144 const_cr2:
      001F58 A6 04            [ 1] 6145 	ld a,#TK_INTGR 
      001F5A AE 00 04         [ 2] 6146 	ldw x,#GPIO_CR2
      001F5D 81               [ 4] 6147 	ret 
                                   6148 ;-------------------------
                                   6149 ;  constant for port mode
                                   6150 ;  used by PMODE 
                                   6151 ;  input or output
                                   6152 ;------------------------
      001F5E                       6153 const_output:
      001F5E A6 04            [ 1] 6154 	ld a,#TK_INTGR 
      001F60 AE 00 01         [ 2] 6155 	ldw x,#OUTP
      001F63 81               [ 4] 6156 	ret 
      001F64                       6157 const_input:
      001F64 A6 04            [ 1] 6158 	ld a,#TK_INTGR 
      001F66 AE 00 00         [ 2] 6159 	ldw x,#INP 
      001F69 81               [ 4] 6160 	ret 
                                   6161 ;-----------------------
                                   6162 ; memory area constants
                                   6163 ;-----------------------
      001F6A                       6164 const_eeprom_base:
      001F6A A6 04            [ 1] 6165 	ld a,#TK_INTGR 
      001F6C AE 40 00         [ 2] 6166 	ldw x,#EEPROM_BASE 
      001F6F 81               [ 4] 6167 	ret 
                                   6168 
                                   6169 ;---------------------------
                                   6170 ; BASIC: DATA 
                                   6171 ; when the interpreter find 
                                   6172 ; a DATA line it skip it.
                                   6173 ;---------------------------
      001F70                       6174 data:
      001F70 55 00 03 00 01   [ 1] 6175 	mov in,count
      001F75 81               [ 4] 6176 	ret 
                                   6177 
                                   6178 ;---------------------------
                                   6179 ; BASIC: DATLN  *expr*
                                   6180 ; set DATA pointer at line# 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 118.
Hexadecimal [24-Bits]



                                   6181 ; specified by *expr* 
                                   6182 ;---------------------------
      001F76                       6183 data_line:
      001F76 CD 0F 90         [ 4] 6184 	call expression
      001F79 A1 04            [ 1] 6185 	cp a,#TK_INTGR
      001F7B 27 03            [ 1] 6186 	jreq 1$
      001F7D CC 07 01         [ 2] 6187 	jp syntax_error 
      001F80 CD 02 68         [ 4] 6188 1$: call search_lineno
      001F83 5D               [ 2] 6189 	tnzw x 
      001F84 26 05            [ 1] 6190 	jrne 3$
      001F86 A6 05            [ 1] 6191 2$:	ld a,#ERR_NO_LINE 
      001F88 CC 07 03         [ 2] 6192 	jp tb_error
      001F8B                       6193 3$: ; check if valid data line 
      001F8B 90 93            [ 1] 6194     ldw y,x 
      001F8D EE 04            [ 2] 6195 	ldw x,(4,x)
      001F8F A3 1F 70         [ 2] 6196 	cpw x,#data 
      001F92 26 F2            [ 1] 6197 	jrne 2$ 
      001F94 90 CF 00 06      [ 2] 6198 	ldw data_ptr,y
      001F98 90 E6 02         [ 1] 6199 	ld a,(2,y)
      001F9B C7 00 09         [ 1] 6200 	ld data_len,a 
      001F9E 35 06 00 08      [ 1] 6201 	mov data_ofs,#FIRST_DATA_ITEM 
      001FA2 81               [ 4] 6202 	ret
                                   6203 
                                   6204 ;---------------------------------
                                   6205 ; BASIC: RESTORE 
                                   6206 ; set data_ptr to first data line
                                   6207 ; if not DATA found pointer set to
                                   6208 ; zero 
                                   6209 ;---------------------------------
      001FA3                       6210 restore:
      001FA3 72 5F 00 06      [ 1] 6211 	clr data_ptr 
      001FA7 72 5F 00 07      [ 1] 6212 	clr data_ptr+1
      001FAB 72 5F 00 08      [ 1] 6213 	clr data_ofs 
      001FAF 72 5F 00 09      [ 1] 6214 	clr data_len
      001FB3 CE 00 1E         [ 2] 6215 	ldw x,txtbgn
      001FB6                       6216 data_search_loop: 	
      001FB6 C3 00 20         [ 2] 6217 	cpw x,txtend
      001FB9 24 17            [ 1] 6218 	jruge 9$
      001FBB 90 93            [ 1] 6219 	ldw y,x 
      001FBD EE 04            [ 2] 6220 	ldw x,(4,x)
      001FBF A3 1F 70         [ 2] 6221 	cpw x,#data 
      001FC2 26 1A            [ 1] 6222 	jrne try_next_line 
      001FC4 90 CF 00 06      [ 2] 6223 	ldw data_ptr,y 
      001FC8 90 E6 02         [ 1] 6224 	ld a,(2,y)
      001FCB C7 00 09         [ 1] 6225 	ld data_len,a 
      001FCE 35 06 00 08      [ 1] 6226 	mov data_ofs,#FIRST_DATA_ITEM
      001FD2 72 5D 00 09      [ 1] 6227 9$:	tnz data_len 
      001FD6 26 05            [ 1] 6228     jrne 10$
      001FD8 A6 0C            [ 1] 6229 	ld a,#ERR_NO_DATA 
      001FDA CC 07 03         [ 2] 6230 	jp tb_error 
      001FDD 81               [ 4] 6231 10$:ret
      001FDE                       6232 try_next_line:
      001FDE 93               [ 1] 6233 	ldw x,y 
      001FDF E6 02            [ 1] 6234 	ld a,(2,x)
      001FE1 C7 00 0D         [ 1] 6235 	ld acc8,a 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 119.
Hexadecimal [24-Bits]



      001FE4 72 5F 00 0C      [ 1] 6236 	clr acc16 
      001FE8 72 BB 00 0C      [ 2] 6237 	addw x,acc16 
      001FEC 20 C8            [ 2] 6238 	jra data_search_loop
                                   6239 
                                   6240 
                                   6241 ;---------------------------------
                                   6242 ; BASIC: READ 
                                   6243 ; return next data item | 0 
                                   6244 ;---------------------------------
                           000001  6245 	CTX_BPTR=1 
                           000003  6246 	CTX_IN=3 
                           000004  6247 	CTX_COUNT=4 
                           000005  6248 	XSAVE=5
                           000006  6249 	VSIZE=6
      001FEE                       6250 read:
      001FEE                       6251 	_vars  VSIZE 
      001FEE 52 06            [ 2]    1     sub sp,#VSIZE 
      001FF0                       6252 read01:	
      001FF0 C6 00 08         [ 1] 6253 	ld a,data_ofs
      001FF3 C1 00 09         [ 1] 6254 	cp a,data_len 
      001FF6 27 37            [ 1] 6255 	jreq 2$ ; end of line  
      001FF8 CD 13 C2         [ 4] 6256 	call save_context
      001FFB CE 00 06         [ 2] 6257 	ldw x,data_ptr 
      001FFE CF 00 04         [ 2] 6258 	ldw basicptr,x 
      002001 55 00 08 00 01   [ 1] 6259 	mov in,data_ofs 
      002006 55 00 09 00 03   [ 1] 6260 	mov count,data_len  
      00200B CD 0F 90         [ 4] 6261 	call expression 
      00200E A1 04            [ 1] 6262 	cp a,#TK_INTGR 
      002010 27 03            [ 1] 6263 	jreq 1$ 
      002012 CC 07 01         [ 2] 6264 	jp syntax_error 
      002015                       6265 1$:
      002015 1F 05            [ 2] 6266 	ldw (XSAVE,SP),x
      002017 CD 07 B5         [ 4] 6267 	call next_token ; skip comma
      00201A CE 00 04         [ 2] 6268 	ldw x,basicptr 
      00201D CF 00 06         [ 2] 6269 	ldw data_ptr,x 
      002020 55 00 01 00 08   [ 1] 6270 	mov data_ofs,in 
      002025 CD 13 D2         [ 4] 6271 	call rest_context
      002028 1E 05            [ 2] 6272 	ldw x,(XSAVE,sp)
      00202A A6 04            [ 1] 6273 	ld a,#TK_INTGR
      00202C                       6274 	_drop VSIZE 
      00202C 5B 06            [ 2]    1     addw sp,#VSIZE 
      00202E 81               [ 4] 6275 	ret 
      00202F                       6276 2$: ; end of line reached 
      00202F 90 CE 00 06      [ 2] 6277 	ldw y, data_ptr 
      002033 72 5F 00 06      [ 1] 6278 	clr data_ptr
      002037 72 5F 00 07      [ 1] 6279 	clr data_ptr+1   
      00203B 72 5F 00 08      [ 1] 6280 	clr data_ofs 
      00203F 72 5F 00 09      [ 1] 6281 	clr data_len 
      002043 CD 1F DE         [ 4] 6282 	call try_next_line 
      002046 20 A8            [ 2] 6283 	jra read01
                                   6284 
                                   6285 
                                   6286 ;---------------------------------
                                   6287 ; BASIC: SPIEN clkdiv, 0|1  
                                   6288 ; clkdiv -> {0..7} Fspi=Fclk/2^(n+1)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 120.
Hexadecimal [24-Bits]



                                   6289 ; if clkdiv==-1 disable SPI
                                   6290 ; 0|1 -> disable|enable  
                                   6291 ;--------------------------------- 
                           000005  6292 SPI_CS_BIT=5
      002048                       6293 spi_enable:
      002048 CD 0E 84         [ 4] 6294 	call arg_list 
      00204B A1 02            [ 1] 6295 	cp a,#2
      00204D 27 03            [ 1] 6296 	jreq 1$
      00204F CC 07 01         [ 2] 6297 	jp syntax_error 
      002052                       6298 1$: 
      002052 72 12 50 C7      [ 1] 6299 	bset CLK_PCKENR1,#CLK_PCKENR1_SPI ; enable clock signal 
      002056 85               [ 2] 6300 	popw x  
      002057 27 21            [ 1] 6301 	jreq spi_disable 
      002059 85               [ 2] 6302 	popw x 
      00205A A6 08            [ 1] 6303 	ld a,#(1<<SPI_CR1_BR)
      00205C 42               [ 4] 6304 	mul x,a 
      00205D 9F               [ 1] 6305 	ld a,xl 
      00205E C7 52 00         [ 1] 6306 	ld SPI_CR1,a 
                                   6307 ; configure ~CS on PE5 (D10 on CN8) as output. 
      002061 72 1A 50 14      [ 1] 6308 	bset PE_ODR,#SPI_CS_BIT	; set ~CS high  
      002065 72 1A 50 16      [ 1] 6309 	bset PE_DDR,#SPI_CS_BIT  ; pin as output 
                                   6310 ; configure SPI as master mode 0.	
      002069 72 14 52 00      [ 1] 6311 	bset SPI_CR1,#SPI_CR1_MSTR
                                   6312 ; ~CS line controlled by sofware 	
      00206D 72 12 52 01      [ 1] 6313 	bset SPI_CR2,#SPI_CR2_SSM 
      002071 72 10 52 01      [ 1] 6314     bset SPI_CR2,#SPI_CR2_SSI 
                                   6315 ; enable SPI
      002075 72 1C 52 00      [ 1] 6316 	bset SPI_CR1,#SPI_CR1_SPE 	
      002079 81               [ 4] 6317 	ret 
      00207A                       6318 spi_disable:
      00207A                       6319 	_drop #2; throw first argument.
      00207A 5B 02            [ 2]    1     addw sp,##2 
                                   6320 ; wait spi idle 
      00207C A6 82            [ 1] 6321 1$:	ld a,#0x82 
      00207E C4 52 03         [ 1] 6322 	and a,SPI_SR
      002081 A1 02            [ 1] 6323 	cp a,#2 
      002083 26 F7            [ 1] 6324 	jrne 1$
      002085 72 1D 52 00      [ 1] 6325 	bres SPI_CR1,#SPI_CR1_SPE
      002089 72 13 50 C7      [ 1] 6326 	bres CLK_PCKENR1,#CLK_PCKENR1_SPI 
      00208D 72 1B 50 16      [ 1] 6327 	bres PE_DDR,#SPI_CS_BIT 
      002091 81               [ 4] 6328 	ret 
                                   6329 
      002092                       6330 spi_clear_error:
      002092 A6 78            [ 1] 6331 	ld a,#0x78 
      002094 C5 52 03         [ 1] 6332 	bcp a,SPI_SR 
      002097 27 04            [ 1] 6333 	jreq 1$
      002099 72 5F 52 03      [ 1] 6334 	clr SPI_SR 
      00209D 81               [ 4] 6335 1$: ret 
                                   6336 
      00209E                       6337 spi_send_byte:
      00209E 88               [ 1] 6338 	push a 
      00209F CD 20 92         [ 4] 6339 	call spi_clear_error
      0020A2 84               [ 1] 6340 	pop a 
      0020A3 72 03 52 03 FB   [ 2] 6341 	btjf SPI_SR,#SPI_SR_TXE,.
      0020A8 C7 52 04         [ 1] 6342 	ld SPI_DR,a
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 121.
Hexadecimal [24-Bits]



      0020AB 72 01 52 03 FB   [ 2] 6343 	btjf SPI_SR,#SPI_SR_RXNE,.  
      0020B0 C6 52 04         [ 1] 6344 	ld a,SPI_DR 
      0020B3 81               [ 4] 6345 	ret 
                                   6346 
      0020B4                       6347 spi_rcv_byte:
      0020B4 A6 FF            [ 1] 6348 	ld a,#255
      0020B6 72 01 52 03 E3   [ 2] 6349 	btjf SPI_SR,#SPI_SR_RXNE,spi_send_byte 
      0020BB C6 52 04         [ 1] 6350 	ld a,SPI_DR 
      0020BE 81               [ 4] 6351 	ret
                                   6352 
                                   6353 ;------------------------------
                                   6354 ; BASIC: SPIWR byte [,byte]
                                   6355 ; write 1 or more byte
                                   6356 ;------------------------------
      0020BF                       6357 spi_write:
      0020BF CD 0F 90         [ 4] 6358 	call expression
      0020C2 A1 04            [ 1] 6359 	cp a,#TK_INTGR 
      0020C4 27 03            [ 1] 6360 	jreq 1$
      0020C6 CC 07 01         [ 2] 6361 	jp syntax_error 
      0020C9                       6362 1$:	
      0020C9 9F               [ 1] 6363 	ld a,xl 
      0020CA CD 20 9E         [ 4] 6364 	call spi_send_byte 
      0020CD CD 07 B5         [ 4] 6365 	call next_token 
      0020D0 A1 0D            [ 1] 6366 	cp a,#TK_COMMA 
      0020D2 26 02            [ 1] 6367 	jrne 2$ 
      0020D4 20 E9            [ 2] 6368 	jra spi_write 
      0020D6 4D               [ 1] 6369 2$:	tnz a 
      0020D7 27 05            [ 1] 6370 	jreq 3$
      0020D9                       6371 	_unget_token  
      0020D9 55 00 02 00 01   [ 1]    1     mov in,in.saved
      0020DE 81               [ 4] 6372 3$:	ret 
                                   6373 
                                   6374 
                                   6375 ;-------------------------------
                                   6376 ; BASIC: SPIRD 	
                                   6377 ; read one byte from SPI 
                                   6378 ;-------------------------------
      0020DF                       6379 spi_read:
      0020DF CD 20 B4         [ 4] 6380 	call spi_rcv_byte 
      0020E2 5F               [ 1] 6381 	clrw x 
      0020E3 97               [ 1] 6382 	ld xl,a 
      0020E4 A6 04            [ 1] 6383 	ld a,#TK_INTGR 
      0020E6 81               [ 4] 6384 	ret 
                                   6385 
                                   6386 ;------------------------------
                                   6387 ; BASIC: SPISEL 0|1 
                                   6388 ; set state of ~CS line
                                   6389 ; 0|1 deselect|select  
                                   6390 ;------------------------------
      0020E7                       6391 spi_select:
      0020E7 CD 07 B5         [ 4] 6392 	call next_token 
      0020EA A1 04            [ 1] 6393 	cp a,#TK_INTGR 
      0020EC 27 03            [ 1] 6394 	jreq 1$
      0020EE CC 07 01         [ 2] 6395 	jp syntax_error 
      0020F1 5D               [ 2] 6396 1$: tnzw x  
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 122.
Hexadecimal [24-Bits]



      0020F2 27 05            [ 1] 6397 	jreq cs_high 
      0020F4 72 1B 50 14      [ 1] 6398 	bres PE_ODR,#SPI_CS_BIT
      0020F8 81               [ 4] 6399 	ret 
      0020F9                       6400 cs_high: 
      0020F9 72 1A 50 14      [ 1] 6401 	bset PE_ODR,#SPI_CS_BIT
      0020FD 81               [ 4] 6402 	ret 
                                   6403 
                                   6404 ;------------------------------
                                   6405 ;      dictionary 
                                   6406 ; format:
                                   6407 ;   link:   2 bytes 
                                   6408 ;   name_length+flags:  1 byte, bits 0:4 lenght,5:8 flags  
                                   6409 ;   cmd_name: 16 byte max 
                                   6410 ;   code_address: 2 bytes 
                                   6411 ;------------------------------
                                   6412 	.macro _dict_entry len,name,cmd 
                                   6413 	.word LINK 
                                   6414 	LINK=.
                                   6415 name:
                                   6416 	.byte len 	
                                   6417 	.ascii "name"
                                   6418 	.word cmd 
                                   6419 	.endm 
                                   6420 
                           000000  6421 	LINK=0
                                   6422 ; respect alphabetic order for BASIC names from Z-A
                                   6423 ; this sort order is for a cleaner WORDS cmd output. 	
      0020FE                       6424 kword_end:
      0020FE                       6425 	_dict_entry,5+F_IFUNC,XPEEK,xpeek 
      0020FE 00 00                    1 	.word LINK 
                           002100     2 	LINK=.
      002100                          3 XPEEK:
      002100 45                       4 	.byte 5+F_IFUNC 	
      002101 58 50 45 45 4B           5 	.ascii "XPEEK"
      002106 14 E9                    6 	.word xpeek 
      002108                       6426 	_dict_entry,3+F_IFUNC,XOR,bit_xor
      002108 21 00                    1 	.word LINK 
                           00210A     2 	LINK=.
      00210A                          3 XOR:
      00210A 43                       4 	.byte 3+F_IFUNC 	
      00210B 58 4F 52                 5 	.ascii "XOR"
      00210E 1C B7                    6 	.word bit_xor 
      002110                       6427 	_dict_entry,5,WRITE,write  
      002110 21 0A                    1 	.word LINK 
                           002112     2 	LINK=.
      002112                          3 WRITE:
      002112 05                       4 	.byte 5 	
      002113 57 52 49 54 45           5 	.ascii "WRITE"
      002118 1A F3                    6 	.word write 
      00211A                       6428 	_dict_entry,5,WORDS,words 
      00211A 21 12                    1 	.word LINK 
                           00211C     2 	LINK=.
      00211C                          3 WORDS:
      00211C 05                       4 	.byte 5 	
      00211D 57 4F 52 44 53           5 	.ascii "WORDS"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 123.
Hexadecimal [24-Bits]



      002122 1D E5                    6 	.word words 
      002124                       6429 	_dict_entry 4,WAIT,wait 
      002124 21 1C                    1 	.word LINK 
                           002126     2 	LINK=.
      002126                          3 WAIT:
      002126 04                       4 	.byte 4 	
      002127 57 41 49 54              5 	.ascii "WAIT"
      00212B 14 4C                    6 	.word wait 
      00212D                       6430 	_dict_entry,3+F_IFUNC,USR,usr
      00212D 21 26                    1 	.word LINK 
                           00212F     2 	LINK=.
      00212F                          3 USR:
      00212F 43                       4 	.byte 3+F_IFUNC 	
      002130 55 53 52                 5 	.ascii "USR"
      002133 1B 9F                    6 	.word usr 
      002135                       6431 	_dict_entry,5,UNTIL,until 
      002135 21 2F                    1 	.word LINK 
                           002137     2 	LINK=.
      002137                          3 UNTIL:
      002137 05                       4 	.byte 5 	
      002138 55 4E 54 49 4C           5 	.ascii "UNTIL"
      00213D 1E DC                    6 	.word until 
      00213F                       6432 	_dict_entry,6+F_IFUNC,UFLASH,uflash 
      00213F 21 37                    1 	.word LINK 
                           002141     2 	LINK=.
      002141                          3 UFLASH:
      002141 46                       4 	.byte 6+F_IFUNC 	
      002142 55 46 4C 41 53 48        5 	.ascii "UFLASH"
      002148 1B 99                    6 	.word uflash 
      00214A                       6433 	_dict_entry,6+F_IFUNC,UBOUND,ubound 
      00214A 21 41                    1 	.word LINK 
                           00214C     2 	LINK=.
      00214C                          3 UBOUND:
      00214C 46                       4 	.byte 6+F_IFUNC 	
      00214D 55 42 4F 55 4E 44        5 	.ascii "UBOUND"
      002153 10 E1                    6 	.word ubound 
      002155                       6434 	_dict_entry,4,TONE,tone  
      002155 21 4C                    1 	.word LINK 
                           002157     2 	LINK=.
      002157                          3 TONE:
      002157 04                       4 	.byte 4 	
      002158 54 4F 4E 45              5 	.ascii "TONE"
      00215C 16 B0                    6 	.word tone 
      00215E                       6435 	_dict_entry,2,TO,to
      00215E 21 57                    1 	.word LINK 
                           002160     2 	LINK=.
      002160                          3 TO:
      002160 02                       4 	.byte 2 	
      002161 54 4F                    5 	.ascii "TO"
      002163 15 42                    6 	.word to 
      002165                       6436 	_dict_entry,7+F_IFUNC,TIMEOUT,timeout 
      002165 21 60                    1 	.word LINK 
                           002167     2 	LINK=.
      002167                          3 TIMEOUT:
      002167 47                       4 	.byte 7+F_IFUNC 	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 124.
Hexadecimal [24-Bits]



      002168 54 49 4D 45 4F 55 54     5 	.ascii "TIMEOUT"
      00216F 1E 2E                    6 	.word timeout 
      002171                       6437 	_dict_entry,5,TIMER,set_timer
      002171 21 67                    1 	.word LINK 
                           002173     2 	LINK=.
      002173                          3 TIMER:
      002173 05                       4 	.byte 5 	
      002174 54 49 4D 45 52           5 	.ascii "TIMER"
      002179 1E 1F                    6 	.word set_timer 
      00217B                       6438 	_dict_entry,5+F_IFUNC,TICKS,get_ticks
      00217B 21 73                    1 	.word LINK 
                           00217D     2 	LINK=.
      00217D                          3 TICKS:
      00217D 45                       4 	.byte 5+F_IFUNC 	
      00217E 54 49 43 4B 53           5 	.ascii "TICKS"
      002183 1C 6D                    6 	.word get_ticks 
      002185                       6439 	_dict_entry,4,STOP,stop 
      002185 21 7D                    1 	.word LINK 
                           002187     2 	LINK=.
      002187                          3 STOP:
      002187 04                       4 	.byte 4 	
      002188 53 54 4F 50              5 	.ascii "STOP"
      00218C 17 D4                    6 	.word stop 
      00218E                       6440 	_dict_entry,4,STEP,step 
      00218E 21 87                    1 	.word LINK 
                           002190     2 	LINK=.
      002190                          3 STEP:
      002190 04                       4 	.byte 4 	
      002191 53 54 45 50              5 	.ascii "STEP"
      002195 15 72                    6 	.word step 
      002197                       6441 	_dict_entry,5,SPIWR,spi_write
      002197 21 90                    1 	.word LINK 
                           002199     2 	LINK=.
      002199                          3 SPIWR:
      002199 05                       4 	.byte 5 	
      00219A 53 50 49 57 52           5 	.ascii "SPIWR"
      00219F 20 BF                    6 	.word spi_write 
      0021A1                       6442 	_dict_entry,6,SPISEL,spi_select
      0021A1 21 99                    1 	.word LINK 
                           0021A3     2 	LINK=.
      0021A3                          3 SPISEL:
      0021A3 06                       4 	.byte 6 	
      0021A4 53 50 49 53 45 4C        5 	.ascii "SPISEL"
      0021AA 20 E7                    6 	.word spi_select 
      0021AC                       6443 	_dict_entry,5,SPIEN,spi_enable 
      0021AC 21 A3                    1 	.word LINK 
                           0021AE     2 	LINK=.
      0021AE                          3 SPIEN:
      0021AE 05                       4 	.byte 5 	
      0021AF 53 50 49 45 4E           5 	.ascii "SPIEN"
      0021B4 20 48                    6 	.word spi_enable 
      0021B6                       6444 	_dict_entry,5+F_IFUNC,SPIRD, spi_read 
      0021B6 21 AE                    1 	.word LINK 
                           0021B8     2 	LINK=.
      0021B8                          3 SPIRD:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 125.
Hexadecimal [24-Bits]



      0021B8 45                       4 	.byte 5+F_IFUNC 	
      0021B9 53 50 49 52 44           5 	.ascii "SPIRD"
      0021BE 20 DF                    6 	.word spi_read 
      0021C0                       6445 	_dict_entry,5,SLEEP,sleep 
      0021C0 21 B8                    1 	.word LINK 
                           0021C2     2 	LINK=.
      0021C2                          3 SLEEP:
      0021C2 05                       4 	.byte 5 	
      0021C3 53 4C 45 45 50           5 	.ascii "SLEEP"
      0021C8 1C 06                    6 	.word sleep 
      0021CA                       6446 	_dict_entry,4+F_IFUNC,SIZE,size
      0021CA 21 C2                    1 	.word LINK 
                           0021CC     2 	LINK=.
      0021CC                          3 SIZE:
      0021CC 44                       4 	.byte 4+F_IFUNC 	
      0021CD 53 49 5A 45              5 	.ascii "SIZE"
      0021D1 10 D7                    6 	.word size 
      0021D3                       6447     _dict_entry,4,SHOW,show 
      0021D3 21 CC                    1 	.word LINK 
                           0021D5     2 	LINK=.
      0021D5                          3 SHOW:
      0021D5 04                       4 	.byte 4 	
      0021D6 53 48 4F 57              5 	.ascii "SHOW"
      0021DA 10 2B                    6 	.word show 
      0021DC                       6448 	_dict_entry,4,SAVE,save
      0021DC 21 D5                    1 	.word LINK 
                           0021DE     2 	LINK=.
      0021DE                          3 SAVE:
      0021DE 04                       4 	.byte 4 	
      0021DF 53 41 56 45              5 	.ascii "SAVE"
      0021E3 18 E2                    6 	.word save 
      0021E5                       6449 	_dict_entry 3,RUN,run
      0021E5 21 DE                    1 	.word LINK 
                           0021E7     2 	LINK=.
      0021E7                          3 RUN:
      0021E7 03                       4 	.byte 3 	
      0021E8 52 55 4E                 5 	.ascii "RUN"
      0021EB 16 52                    6 	.word run 
      0021ED                       6450 	_dict_entry,6+F_IFUNC,RSHIFT,rshift
      0021ED 21 E7                    1 	.word LINK 
                           0021EF     2 	LINK=.
      0021EF                          3 RSHIFT:
      0021EF 46                       4 	.byte 6+F_IFUNC 	
      0021F0 52 53 48 49 46 54        5 	.ascii "RSHIFT"
      0021F6 1C E8                    6 	.word rshift 
      0021F8                       6451 	_dict_entry,3+F_IFUNC,RND,random 
      0021F8 21 EF                    1 	.word LINK 
                           0021FA     2 	LINK=.
      0021FA                          3 RND:
      0021FA 43                       4 	.byte 3+F_IFUNC 	
      0021FB 52 4E 44                 5 	.ascii "RND"
      0021FE 1D 7E                    6 	.word random 
      002200                       6452 	_dict_entry,6,RETURN,return 
      002200 21 FA                    1 	.word LINK 
                           002202     2 	LINK=.
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 126.
Hexadecimal [24-Bits]



      002202                          3 RETURN:
      002202 06                       4 	.byte 6 	
      002203 52 45 54 55 52 4E        5 	.ascii "RETURN"
      002209 16 34                    6 	.word return 
      00220B                       6453 	_dict_entry,7,RESTORE,restore 
      00220B 22 02                    1 	.word LINK 
                           00220D     2 	LINK=.
      00220D                          3 RESTORE:
      00220D 07                       4 	.byte 7 	
      00220E 52 45 53 54 4F 52 45     5 	.ascii "RESTORE"
      002215 1F A3                    6 	.word restore 
      002217                       6454 	_dict_entry 6,REMARK,rem 
      002217 22 0D                    1 	.word LINK 
                           002219     2 	LINK=.
      002219                          3 REMARK:
      002219 06                       4 	.byte 6 	
      00221A 52 45 4D 41 52 4B        5 	.ascii "REMARK"
      002220 14 46                    6 	.word rem 
      002222                       6455 	_dict_entry,6,REBOOT,cold_start
      002222 22 19                    1 	.word LINK 
                           002224     2 	LINK=.
      002224                          3 REBOOT:
      002224 06                       4 	.byte 6 	
      002225 52 45 42 4F 4F 54        5 	.ascii "REBOOT"
      00222B 04 D4                    6 	.word cold_start 
      00222D                       6456 	_dict_entry,4+F_IFUNC,READ,read  
      00222D 22 24                    1 	.word LINK 
                           00222F     2 	LINK=.
      00222F                          3 READ:
      00222F 44                       4 	.byte 4+F_IFUNC 	
      002230 52 45 41 44              5 	.ascii "READ"
      002234 1F EE                    6 	.word read 
      002236                       6457 	_dict_entry,4+F_IFUNC,QKEY,qkey  
      002236 22 2F                    1 	.word LINK 
                           002238     2 	LINK=.
      002238                          3 QKEY:
      002238 44                       4 	.byte 4+F_IFUNC 	
      002239 51 4B 45 59              5 	.ascii "QKEY"
      00223D 1B 64                    6 	.word qkey 
      00223F                       6458 	_dict_entry,4+F_IFUNC,PRTI,const_porti 
      00223F 22 38                    1 	.word LINK 
                           002241     2 	LINK=.
      002241                          3 PRTI:
      002241 44                       4 	.byte 4+F_IFUNC 	
      002242 50 52 54 49              5 	.ascii "PRTI"
      002246 1F 3A                    6 	.word const_porti 
      002248                       6459 	_dict_entry,4+F_IFUNC,PRTH,const_porth 
      002248 22 41                    1 	.word LINK 
                           00224A     2 	LINK=.
      00224A                          3 PRTH:
      00224A 44                       4 	.byte 4+F_IFUNC 	
      00224B 50 52 54 48              5 	.ascii "PRTH"
      00224F 1F 34                    6 	.word const_porth 
      002251                       6460 	_dict_entry,4+F_IFUNC,PRTG,const_portg 
      002251 22 4A                    1 	.word LINK 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 127.
Hexadecimal [24-Bits]



                           002253     2 	LINK=.
      002253                          3 PRTG:
      002253 44                       4 	.byte 4+F_IFUNC 	
      002254 50 52 54 47              5 	.ascii "PRTG"
      002258 1F 2E                    6 	.word const_portg 
      00225A                       6461 	_dict_entry,4+F_IFUNC,PRTF,const_portf
      00225A 22 53                    1 	.word LINK 
                           00225C     2 	LINK=.
      00225C                          3 PRTF:
      00225C 44                       4 	.byte 4+F_IFUNC 	
      00225D 50 52 54 46              5 	.ascii "PRTF"
      002261 1F 28                    6 	.word const_portf 
      002263                       6462 	_dict_entry,4+F_IFUNC,PRTE,const_porte
      002263 22 5C                    1 	.word LINK 
                           002265     2 	LINK=.
      002265                          3 PRTE:
      002265 44                       4 	.byte 4+F_IFUNC 	
      002266 50 52 54 45              5 	.ascii "PRTE"
      00226A 1F 22                    6 	.word const_porte 
      00226C                       6463 	_dict_entry,4+F_IFUNC,PRTD,const_portd
      00226C 22 65                    1 	.word LINK 
                           00226E     2 	LINK=.
      00226E                          3 PRTD:
      00226E 44                       4 	.byte 4+F_IFUNC 	
      00226F 50 52 54 44              5 	.ascii "PRTD"
      002273 1F 1C                    6 	.word const_portd 
      002275                       6464 	_dict_entry,4+F_IFUNC,PRTC,const_portc
      002275 22 6E                    1 	.word LINK 
                           002277     2 	LINK=.
      002277                          3 PRTC:
      002277 44                       4 	.byte 4+F_IFUNC 	
      002278 50 52 54 43              5 	.ascii "PRTC"
      00227C 1F 16                    6 	.word const_portc 
      00227E                       6465 	_dict_entry,4+F_IFUNC,PRTB,const_portb
      00227E 22 77                    1 	.word LINK 
                           002280     2 	LINK=.
      002280                          3 PRTB:
      002280 44                       4 	.byte 4+F_IFUNC 	
      002281 50 52 54 42              5 	.ascii "PRTB"
      002285 1F 10                    6 	.word const_portb 
      002287                       6466 	_dict_entry,4+F_IFUNC,PRTA,const_porta 
      002287 22 80                    1 	.word LINK 
                           002289     2 	LINK=.
      002289                          3 PRTA:
      002289 44                       4 	.byte 4+F_IFUNC 	
      00228A 50 52 54 41              5 	.ascii "PRTA"
      00228E 1F 0A                    6 	.word const_porta 
      002290                       6467 	_dict_entry 5,PRINT,print 
      002290 22 89                    1 	.word LINK 
                           002292     2 	LINK=.
      002292                          3 PRINT:
      002292 05                       4 	.byte 5 	
      002293 50 52 49 4E 54           5 	.ascii "PRINT"
      002298 13 58                    6 	.word print 
      00229A                       6468 	_dict_entry,4+F_IFUNC,POUT,const_output
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 128.
Hexadecimal [24-Bits]



      00229A 22 92                    1 	.word LINK 
                           00229C     2 	LINK=.
      00229C                          3 POUT:
      00229C 44                       4 	.byte 4+F_IFUNC 	
      00229D 50 4F 55 54              5 	.ascii "POUT"
      0022A1 1F 5E                    6 	.word const_output 
      0022A3                       6469 	_dict_entry,4,POKE,poke 
      0022A3 22 9C                    1 	.word LINK 
                           0022A5     2 	LINK=.
      0022A5                          3 POKE:
      0022A5 04                       4 	.byte 4 	
      0022A6 50 4F 4B 45              5 	.ascii "POKE"
      0022AA 14 C9                    6 	.word poke 
      0022AC                       6470 	_dict_entry,4+F_IFUNC,PINP,const_input
      0022AC 22 A5                    1 	.word LINK 
                           0022AE     2 	LINK=.
      0022AE                          3 PINP:
      0022AE 44                       4 	.byte 4+F_IFUNC 	
      0022AF 50 49 4E 50              5 	.ascii "PINP"
      0022B3 1F 64                    6 	.word const_input 
      0022B5                       6471 	_dict_entry,4+F_IFUNC,PEEK,peek 
      0022B5 22 AE                    1 	.word LINK 
                           0022B7     2 	LINK=.
      0022B7                          3 PEEK:
      0022B7 44                       4 	.byte 4+F_IFUNC 	
      0022B8 50 45 45 4B              5 	.ascii "PEEK"
      0022BC 14 D8                    6 	.word peek 
      0022BE                       6472 	_dict_entry,5,PMODE,pin_mode 
      0022BE 22 B7                    1 	.word LINK 
                           0022C0     2 	LINK=.
      0022C0                          3 PMODE:
      0022C0 05                       4 	.byte 5 	
      0022C1 50 4D 4F 44 45           5 	.ascii "PMODE"
      0022C6 1D 0D                    6 	.word pin_mode 
      0022C8                       6473 	_dict_entry,5,PAUSE,pause 
      0022C8 22 C0                    1 	.word LINK 
                           0022CA     2 	LINK=.
      0022CA                          3 PAUSE:
      0022CA 05                       4 	.byte 5 	
      0022CB 50 41 55 53 45           5 	.ascii "PAUSE"
      0022D0 1C 11                    6 	.word pause 
      0022D2                       6474 	_dict_entry,2+F_IFUNC,OR,bit_or
      0022D2 22 CA                    1 	.word LINK 
                           0022D4     2 	LINK=.
      0022D4                          3 OR:
      0022D4 42                       4 	.byte 2+F_IFUNC 	
      0022D5 4F 52                    5 	.ascii "OR"
      0022D7 1C 9F                    6 	.word bit_or 
      0022D9                       6475 	_dict_entry,3+F_IFUNC,ODR,const_odr 
      0022D9 22 D4                    1 	.word LINK 
                           0022DB     2 	LINK=.
      0022DB                          3 ODR:
      0022DB 43                       4 	.byte 3+F_IFUNC 	
      0022DC 4F 44 52                 5 	.ascii "ODR"
      0022DF 1F 40                    6 	.word const_odr 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 129.
Hexadecimal [24-Bits]



      0022E1                       6476 	_dict_entry,3+F_IFUNC,NOT,func_not 
      0022E1 22 DB                    1 	.word LINK 
                           0022E3     2 	LINK=.
      0022E3                          3 NOT:
      0022E3 43                       4 	.byte 3+F_IFUNC 	
      0022E4 4E 4F 54                 5 	.ascii "NOT"
      0022E7 1E 3B                    6 	.word func_not 
      0022E9                       6477 	_dict_entry,3,NEW,new
      0022E9 22 E3                    1 	.word LINK 
                           0022EB     2 	LINK=.
      0022EB                          3 NEW:
      0022EB 03                       4 	.byte 3 	
      0022EC 4E 45 57                 5 	.ascii "NEW"
      0022EF 18 20                    6 	.word new 
      0022F1                       6478 	_dict_entry,4,NEXT,next 
      0022F1 22 EB                    1 	.word LINK 
                           0022F3     2 	LINK=.
      0022F3                          3 NEXT:
      0022F3 04                       4 	.byte 4 	
      0022F4 4E 45 58 54              5 	.ascii "NEXT"
      0022F8 15 99                    6 	.word next 
      0022FA                       6479 	_dict_entry,6+F_IFUNC,LSHIFT,lshift
      0022FA 22 F3                    1 	.word LINK 
                           0022FC     2 	LINK=.
      0022FC                          3 LSHIFT:
      0022FC 46                       4 	.byte 6+F_IFUNC 	
      0022FD 4C 53 48 49 46 54        5 	.ascii "LSHIFT"
      002303 1C CF                    6 	.word lshift 
      002305                       6480 	_dict_entry,3+F_IFUNC,LOG,log2 
      002305 22 FC                    1 	.word LINK 
                           002307     2 	LINK=.
      002307                          3 LOG:
      002307 43                       4 	.byte 3+F_IFUNC 	
      002308 4C 4F 47                 5 	.ascii "LOG"
      00230B 1E 83                    6 	.word log2 
      00230D                       6481 	_dict_entry,4,LOAD,load 
      00230D 23 07                    1 	.word LINK 
                           00230F     2 	LINK=.
      00230F                          3 LOAD:
      00230F 04                       4 	.byte 4 	
      002310 4C 4F 41 44              5 	.ascii "LOAD"
      002314 19 D7                    6 	.word load 
      002316                       6482 	_dict_entry 4,LIST,list
      002316 23 0F                    1 	.word LINK 
                           002318     2 	LINK=.
      002318                          3 LIST:
      002318 04                       4 	.byte 4 	
      002319 4C 49 53 54              5 	.ascii "LIST"
      00231D 11 27                    6 	.word list 
      00231F                       6483 	_dict_entry 3,LET,let 
      00231F 23 18                    1 	.word LINK 
                           002321     2 	LINK=.
      002321                          3 LET:
      002321 03                       4 	.byte 3 	
      002322 4C 45 54                 5 	.ascii "LET"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 130.
Hexadecimal [24-Bits]



      002325 11 03                    6 	.word let 
      002327                       6484 	_dict_entry,3+F_IFUNC,KEY,key 
      002327 23 21                    1 	.word LINK 
                           002329     2 	LINK=.
      002329                          3 KEY:
      002329 43                       4 	.byte 3+F_IFUNC 	
      00232A 4B 45 59                 5 	.ascii "KEY"
      00232D 1B 5C                    6 	.word key 
      00232F                       6485 	_dict_entry,7,IWDGREF,refresh_iwdg
      00232F 23 29                    1 	.word LINK 
                           002331     2 	LINK=.
      002331                          3 IWDGREF:
      002331 07                       4 	.byte 7 	
      002332 49 57 44 47 52 45 46     5 	.ascii "IWDGREF"
      002339 1E 7E                    6 	.word refresh_iwdg 
      00233B                       6486 	_dict_entry,6,IWDGEN,enable_iwdg
      00233B 23 31                    1 	.word LINK 
                           00233D     2 	LINK=.
      00233D                          3 IWDGEN:
      00233D 06                       4 	.byte 6 	
      00233E 49 57 44 47 45 4E        5 	.ascii "IWDGEN"
      002344 1E 48                    6 	.word enable_iwdg 
      002346                       6487 	_dict_entry,6+F_IFUNC,INVERT,invert 
      002346 23 3D                    1 	.word LINK 
                           002348     2 	LINK=.
      002348                          3 INVERT:
      002348 46                       4 	.byte 6+F_IFUNC 	
      002349 49 4E 56 45 52 54        5 	.ascii "INVERT"
      00234F 1E B8                    6 	.word invert 
      002351                       6488 	_dict_entry,5,INPUT,input_var  
      002351 23 48                    1 	.word LINK 
                           002353     2 	LINK=.
      002353                          3 INPUT:
      002353 05                       4 	.byte 5 	
      002354 49 4E 50 55 54           5 	.ascii "INPUT"
      002359 13 E2                    6 	.word input_var 
      00235B                       6489 	_dict_entry,2,IF,if 
      00235B 23 53                    1 	.word LINK 
                           00235D     2 	LINK=.
      00235D                          3 IF:
      00235D 02                       4 	.byte 2 	
      00235E 49 46                    5 	.ascii "IF"
      002360 15 05                    6 	.word if 
      002362                       6490 	_dict_entry,3+F_IFUNC,IDR,const_idr 
      002362 23 5D                    1 	.word LINK 
                           002364     2 	LINK=.
      002364                          3 IDR:
      002364 43                       4 	.byte 3+F_IFUNC 	
      002365 49 44 52                 5 	.ascii "IDR"
      002368 1F 46                    6 	.word const_idr 
      00236A                       6491 	_dict_entry,3,HEX,hex_base
      00236A 23 64                    1 	.word LINK 
                           00236C     2 	LINK=.
      00236C                          3 HEX:
      00236C 03                       4 	.byte 3 	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 131.
Hexadecimal [24-Bits]



      00236D 48 45 58                 5 	.ascii "HEX"
      002370 10 CD                    6 	.word hex_base 
      002372                       6492 	_dict_entry,4+F_IFUNC,GPIO,gpio 
      002372 23 6C                    1 	.word LINK 
                           002374     2 	LINK=.
      002374                          3 GPIO:
      002374 44                       4 	.byte 4+F_IFUNC 	
      002375 47 50 49 4F              5 	.ascii "GPIO"
      002379 1B 6F                    6 	.word gpio 
      00237B                       6493 	_dict_entry,4,GOTO,goto 
      00237B 23 74                    1 	.word LINK 
                           00237D     2 	LINK=.
      00237D                          3 GOTO:
      00237D 04                       4 	.byte 4 	
      00237E 47 4F 54 4F              5 	.ascii "GOTO"
      002382 15 F9                    6 	.word goto 
      002384                       6494 	_dict_entry,5,GOSUB,gosub 
      002384 23 7D                    1 	.word LINK 
                           002386     2 	LINK=.
      002386                          3 GOSUB:
      002386 05                       4 	.byte 5 	
      002387 47 4F 53 55 42           5 	.ascii "GOSUB"
      00238C 16 14                    6 	.word gosub 
      00238E                       6495 	_dict_entry,6,FORGET,forget 
      00238E 23 86                    1 	.word LINK 
                           002390     2 	LINK=.
      002390                          3 FORGET:
      002390 06                       4 	.byte 6 	
      002391 46 4F 52 47 45 54        5 	.ascii "FORGET"
      002397 1A 12                    6 	.word forget 
      002399                       6496 	_dict_entry,3,FOR,for 
      002399 23 90                    1 	.word LINK 
                           00239B     2 	LINK=.
      00239B                          3 FOR:
      00239B 03                       4 	.byte 3 	
      00239C 46 4F 52                 5 	.ascii "FOR"
      00239F 15 19                    6 	.word for 
      0023A1                       6497 	_dict_entry,4,FCPU,fcpu 
      0023A1 23 9B                    1 	.word LINK 
                           0023A3     2 	LINK=.
      0023A3                          3 FCPU:
      0023A3 04                       4 	.byte 4 	
      0023A4 46 43 50 55              5 	.ascii "FCPU"
      0023A8 1D 01                    6 	.word fcpu 
      0023AA                       6498 	_dict_entry,6+F_IFUNC,EEPROM,const_eeprom_base   
      0023AA 23 A3                    1 	.word LINK 
                           0023AC     2 	LINK=.
      0023AC                          3 EEPROM:
      0023AC 46                       4 	.byte 6+F_IFUNC 	
      0023AD 45 45 50 52 4F 4D        5 	.ascii "EEPROM"
      0023B3 1F 6A                    6 	.word const_eeprom_base 
      0023B5                       6499 	_dict_entry,3,END,cmd_end  
      0023B5 23 AC                    1 	.word LINK 
                           0023B7     2 	LINK=.
      0023B7                          3 END:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 132.
Hexadecimal [24-Bits]



      0023B7 03                       4 	.byte 3 	
      0023B8 45 4E 44                 5 	.ascii "END"
      0023BB 16 A1                    6 	.word cmd_end 
      0023BD                       6500 	_dict_entry,6+F_CMD,DWRITE,digital_write
      0023BD 23 B7                    1 	.word LINK 
                           0023BF     2 	LINK=.
      0023BF                          3 DWRITE:
      0023BF 06                       4 	.byte 6+F_CMD 	
      0023C0 44 57 52 49 54 45        5 	.ascii "DWRITE"
      0023C6 17 99                    6 	.word digital_write 
      0023C8                       6501 	_dict_entry,5+F_IFUNC,DREAD,digital_read
      0023C8 23 BF                    1 	.word LINK 
                           0023CA     2 	LINK=.
      0023CA                          3 DREAD:
      0023CA 45                       4 	.byte 5+F_IFUNC 	
      0023CB 44 52 45 41 44           5 	.ascii "DREAD"
      0023D0 17 69                    6 	.word digital_read 
      0023D2                       6502 	_dict_entry,2,DO,do_loop
      0023D2 23 CA                    1 	.word LINK 
                           0023D4     2 	LINK=.
      0023D4                          3 DO:
      0023D4 02                       4 	.byte 2 	
      0023D5 44 4F                    5 	.ascii "DO"
      0023D7 1E C7                    6 	.word do_loop 
      0023D9                       6503 	_dict_entry,3,DIR,directory 
      0023D9 23 D4                    1 	.word LINK 
                           0023DB     2 	LINK=.
      0023DB                          3 DIR:
      0023DB 03                       4 	.byte 3 	
      0023DC 44 49 52                 5 	.ascii "DIR"
      0023DF 1A 5D                    6 	.word directory 
      0023E1                       6504 	_dict_entry,3,DEC,dec_base
      0023E1 23 DB                    1 	.word LINK 
                           0023E3     2 	LINK=.
      0023E3                          3 DEC:
      0023E3 03                       4 	.byte 3 	
      0023E4 44 45 43                 5 	.ascii "DEC"
      0023E7 10 D2                    6 	.word dec_base 
      0023E9                       6505 	_dict_entry,3+F_IFUNC,DDR,const_ddr 
      0023E9 23 E3                    1 	.word LINK 
                           0023EB     2 	LINK=.
      0023EB                          3 DDR:
      0023EB 43                       4 	.byte 3+F_IFUNC 	
      0023EC 44 44 52                 5 	.ascii "DDR"
      0023EF 1F 4C                    6 	.word const_ddr 
      0023F1                       6506 	_dict_entry,6,DATALN,data_line  
      0023F1 23 EB                    1 	.word LINK 
                           0023F3     2 	LINK=.
      0023F3                          3 DATALN:
      0023F3 06                       4 	.byte 6 	
      0023F4 44 41 54 41 4C 4E        5 	.ascii "DATALN"
      0023FA 1F 76                    6 	.word data_line 
      0023FC                       6507 	_dict_entry,4,DATA,data  
      0023FC 23 F3                    1 	.word LINK 
                           0023FE     2 	LINK=.
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 133.
Hexadecimal [24-Bits]



      0023FE                          3 DATA:
      0023FE 04                       4 	.byte 4 	
      0023FF 44 41 54 41              5 	.ascii "DATA"
      002403 1F 70                    6 	.word data 
      002405                       6508 	_dict_entry,3+F_IFUNC,CRL,const_cr1 
      002405 23 FE                    1 	.word LINK 
                           002407     2 	LINK=.
      002407                          3 CRL:
      002407 43                       4 	.byte 3+F_IFUNC 	
      002408 43 52 4C                 5 	.ascii "CRL"
      00240B 1F 52                    6 	.word const_cr1 
      00240D                       6509 	_dict_entry,3+F_IFUNC,CRH,const_cr2 
      00240D 24 07                    1 	.word LINK 
                           00240F     2 	LINK=.
      00240F                          3 CRH:
      00240F 43                       4 	.byte 3+F_IFUNC 	
      002410 43 52 48                 5 	.ascii "CRH"
      002413 1F 58                    6 	.word const_cr2 
      002415                       6510 	_dict_entry,4+F_CFUNC,CHAR,char
      002415 24 0F                    1 	.word LINK 
                           002417     2 	LINK=.
      002417                          3 CHAR:
      002417 84                       4 	.byte 4+F_CFUNC 	
      002418 43 48 41 52              5 	.ascii "CHAR"
      00241C 1B 2A                    6 	.word char 
      00241E                       6511 	_dict_entry,3,BYE,bye 
      00241E 24 17                    1 	.word LINK 
                           002420     2 	LINK=.
      002420                          3 BYE:
      002420 03                       4 	.byte 3 	
      002421 42 59 45                 5 	.ascii "BYE"
      002424 1B BC                    6 	.word bye 
      002426                       6512 	_dict_entry,5,BTOGL,bit_toggle
      002426 24 20                    1 	.word LINK 
                           002428     2 	LINK=.
      002428                          3 BTOGL:
      002428 05                       4 	.byte 5 	
      002429 42 54 4F 47 4C           5 	.ascii "BTOGL"
      00242E 14 92                    6 	.word bit_toggle 
      002430                       6513 	_dict_entry,5+F_IFUNC,BTEST,bit_test 
      002430 24 28                    1 	.word LINK 
                           002432     2 	LINK=.
      002432                          3 BTEST:
      002432 45                       4 	.byte 5+F_IFUNC 	
      002433 42 54 45 53 54           5 	.ascii "BTEST"
      002438 14 A2                    6 	.word bit_test 
      00243A                       6514 	_dict_entry,4,BSET,bit_set 
      00243A 24 32                    1 	.word LINK 
                           00243C     2 	LINK=.
      00243C                          3 BSET:
      00243C 04                       4 	.byte 4 	
      00243D 42 53 45 54              5 	.ascii "BSET"
      002441 14 71                    6 	.word bit_set 
      002443                       6515 	_dict_entry,4,BRES,bit_reset
      002443 24 3C                    1 	.word LINK 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 134.
Hexadecimal [24-Bits]



                           002445     2 	LINK=.
      002445                          3 BRES:
      002445 04                       4 	.byte 4 	
      002446 42 52 45 53              5 	.ascii "BRES"
      00244A 14 81                    6 	.word bit_reset 
      00244C                       6516 	_dict_entry,3+F_IFUNC,BIT,bitmask
      00244C 24 45                    1 	.word LINK 
                           00244E     2 	LINK=.
      00244E                          3 BIT:
      00244E 43                       4 	.byte 3+F_IFUNC 	
      00244F 42 49 54                 5 	.ascii "BIT"
      002452 1E 9E                    6 	.word bitmask 
      002454                       6517 	_dict_entry,3,AWU,awu 
      002454 24 4E                    1 	.word LINK 
                           002456     2 	LINK=.
      002456                          3 AWU:
      002456 03                       4 	.byte 3 	
      002457 41 57 55                 5 	.ascii "AWU"
      00245A 1C 24                    6 	.word awu 
      00245C                       6518 	_dict_entry,7,AUTORUN,autorun
      00245C 24 56                    1 	.word LINK 
                           00245E     2 	LINK=.
      00245E                          3 AUTORUN:
      00245E 07                       4 	.byte 7 	
      00245F 41 55 54 4F 52 55 4E     5 	.ascii "AUTORUN"
      002466 1B C5                    6 	.word autorun 
      002468                       6519 	_dict_entry,3+F_IFUNC,ASC,ascii
      002468 24 5E                    1 	.word LINK 
                           00246A     2 	LINK=.
      00246A                          3 ASC:
      00246A 43                       4 	.byte 3+F_IFUNC 	
      00246B 41 53 43                 5 	.ascii "ASC"
      00246E 1B 3C                    6 	.word ascii 
      002470                       6520 	_dict_entry,3+F_IFUNC,AND,bit_and
      002470 24 6A                    1 	.word LINK 
                           002472     2 	LINK=.
      002472                          3 AND:
      002472 43                       4 	.byte 3+F_IFUNC 	
      002473 41 4E 44                 5 	.ascii "AND"
      002476 1C 87                    6 	.word bit_and 
      002478                       6521 	_dict_entry,7+F_IFUNC,ADCREAD,analog_read
      002478 24 72                    1 	.word LINK 
                           00247A     2 	LINK=.
      00247A                          3 ADCREAD:
      00247A 47                       4 	.byte 7+F_IFUNC 	
      00247B 41 44 43 52 45 41 44     5 	.ascii "ADCREAD"
      002482 17 35                    6 	.word analog_read 
      002484                       6522 	_dict_entry,5,ADCON,power_adc 
      002484 24 7A                    1 	.word LINK 
                           002486     2 	LINK=.
      002486                          3 ADCON:
      002486 05                       4 	.byte 5 	
      002487 41 44 43 4F 4E           5 	.ascii "ADCON"
      00248C 16 F9                    6 	.word power_adc 
      00248E                       6523 kword_dict:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 135.
Hexadecimal [24-Bits]



      00248E                       6524 	_dict_entry,3+F_IFUNC,ABS,abs
      00248E 24 86                    1 	.word LINK 
                           002490     2 	LINK=.
      002490                          3 ABS:
      002490 43                       4 	.byte 3+F_IFUNC 	
      002491 41 42 53                 5 	.ascii "ABS"
      002494 1C 73                    6 	.word abs 
                                   6525 	
                                   6526 
      002500                       6527 	.bndry 128 ; align on FLASH block.
                                   6528 ; free space for user application  
      002500                       6529 user_space:
                                   6530 ; USR() function test
      002500 89               [ 2] 6531 	pushw x 
      002501 72 1A 50 0A      [ 1] 6532 	bset PC_ODR,#5 
      002505 85               [ 2] 6533 	popw x 
      002506 CD 1C 1B         [ 4] 6534 	call pause02 
      002509 72 1B 50 0A      [ 1] 6535 	bres PC_ODR,#5 
      00250D 81               [ 4] 6536 	ret
                                   6537 
                                   6538 	.area FLASH_DRIVE (ABS)
      010000                       6539 	.org 0x10000
      010000                       6540 fdrive:
                                   6541 ;.byte 0,0,0,0
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 136.
Hexadecimal [24-Bits]

Symbol Table

    .__.$$$.=  002710 L   |     .__.ABS.=  000000 G   |     .__.CPU.=  000000 L
    .__.H$L.=  000001 L   |   5 ABS        002490 R   |   5 ADCON      002486 R
  5 ADCREAD    00247A R   |     ADC_CR1 =  005401     |     ADC_CR1_=  000000 
    ADC_CR1_=  000001     |     ADC_CR1_=  000004     |     ADC_CR1_=  000005 
    ADC_CR1_=  000006     |     ADC_CR2 =  005402     |     ADC_CR2_=  000003 
    ADC_CR2_=  000004     |     ADC_CR2_=  000005     |     ADC_CR2_=  000006 
    ADC_CR2_=  000001     |     ADC_CR3 =  005403     |     ADC_CR3_=  000007 
    ADC_CR3_=  000006     |     ADC_CSR =  005400     |     ADC_CSR_=  000006 
    ADC_CSR_=  000004     |     ADC_CSR_=  000000     |     ADC_CSR_=  000001 
    ADC_CSR_=  000002     |     ADC_CSR_=  000003     |     ADC_CSR_=  000007 
    ADC_CSR_=  000005     |     ADC_DRH =  005404     |     ADC_DRL =  005405 
    ADC_TDRH=  005406     |     ADC_TDRL=  005407     |     ADDR    =  000001 
    ADD_SPAC=  000003     |     ADR     =  000002     |     AFR     =  004803 
    AFR0_ADC=  000000     |     AFR1_TIM=  000001     |     AFR2_CCO=  000002 
    AFR3_TIM=  000003     |     AFR4_TIM=  000004     |     AFR5_TIM=  000005 
    AFR6_I2C=  000006     |     AFR7_BEE=  000007     |   5 AND        002472 R
    ARG_OFS =  000002     |   5 ASC        00246A R   |     ATTRIB  =  000002 
  5 AUTORUN    00245E R   |     AUTORUN_=  004000     |   5 AWU        002456 R
  5 AWUHandl   000001 R   |     AWU_APR =  0050F1     |     AWU_CSR =  0050F0 
    AWU_CSR_=  000004     |     AWU_TBR =  0050F2     |     B0_MASK =  000001 
    B115200 =  000006     |     B19200  =  000003     |     B1_MASK =  000002 
    B230400 =  000007     |     B2400   =  000000     |     B2_MASK =  000004 
    B38400  =  000004     |     B3_MASK =  000008     |     B460800 =  000008 
    B4800   =  000001     |     B4_MASK =  000010     |     B57600  =  000005 
    B5_MASK =  000020     |     B6_MASK =  000040     |     B7_MASK =  000080 
    B921600 =  000009     |     B9600   =  000002     |     BASE    =  000002 
    BASE_SAV=  000001     |     BEEP_BIT=  000004     |     BEEP_CSR=  0050F3 
    BEEP_MAS=  000010     |     BEEP_POR=  00000F     |     BELL    =  000007 
    BINARY  =  000001     |   5 BIT        00244E R   |     BIT0    =  000000 
    BIT1    =  000001     |     BIT2    =  000002     |     BIT3    =  000003 
    BIT4    =  000004     |     BIT5    =  000005     |     BIT6    =  000006 
    BIT7    =  000007     |     BLOCK_SI=  000080     |     BOOT_ROM=  006000 
    BOOT_ROM=  007FFF     |     BPTR    =  00000B     |   5 BRES       002445 R
    BSAVE   =  000002     |   5 BSET       00243C R   |     BSIZE   =  000001 
    BSP     =  000008     |   5 BTEST      002432 R   |   5 BTOGL      002428 R
    BTW     =  000001     |     BUFIDX  =  000003     |   5 BYE        002420 R
    C       =  000001     |     CAN_DGR =  005426     |     CAN_FPSR=  005427 
    CAN_IER =  005425     |     CAN_MCR =  005420     |     CAN_MSR =  005421 
    CAN_P0  =  005428     |     CAN_P1  =  005429     |     CAN_P2  =  00542A 
    CAN_P3  =  00542B     |     CAN_P4  =  00542C     |     CAN_P5  =  00542D 
    CAN_P6  =  00542E     |     CAN_P7  =  00542F     |     CAN_P8  =  005430 
    CAN_P9  =  005431     |     CAN_PA  =  005432     |     CAN_PB  =  005433 
    CAN_PC  =  005434     |     CAN_PD  =  005435     |     CAN_PE  =  005436 
    CAN_PF  =  005437     |     CAN_RFR =  005424     |     CAN_TPR =  005423 
    CAN_TSR =  005422     |     CC_C    =  000000     |     CC_H    =  000004 
    CC_I0   =  000003     |     CC_I1   =  000005     |     CC_N    =  000002 
    CC_V    =  000007     |     CC_Z    =  000001     |     CELL_SIZ=  000002 
    CFG_GCR =  007F60     |     CFG_GCR_=  000001     |     CFG_GCR_=  000000 
  5 CHAR       002417 R   |     CLKOPT  =  004807     |     CLKOPT_C=  000002 
    CLKOPT_E=  000003     |     CLKOPT_P=  000000     |     CLKOPT_P=  000001 
    CLK_CCOR=  0050C9     |     CLK_CKDI=  0050C6     |     CLK_CKDI=  000000 
    CLK_CKDI=  000001     |     CLK_CKDI=  000002     |     CLK_CKDI=  000003 
    CLK_CKDI=  000004     |     CLK_CMSR=  0050C3     |     CLK_CSSR=  0050C8 
    CLK_ECKR=  0050C1     |     CLK_ECKR=  000000     |     CLK_ECKR=  000001 
    CLK_HSIT=  0050CC     |     CLK_ICKR=  0050C0     |     CLK_ICKR=  000002 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 137.
Hexadecimal [24-Bits]

Symbol Table

    CLK_ICKR=  000000     |     CLK_ICKR=  000001     |     CLK_ICKR=  000003 
    CLK_ICKR=  000004     |     CLK_ICKR=  000005     |     CLK_PCKE=  0050C7 
    CLK_PCKE=  000000     |     CLK_PCKE=  000001     |     CLK_PCKE=  000007 
    CLK_PCKE=  000005     |     CLK_PCKE=  000006     |     CLK_PCKE=  000004 
    CLK_PCKE=  000002     |     CLK_PCKE=  000003     |     CLK_PCKE=  0050CA 
    CLK_PCKE=  000003     |     CLK_PCKE=  000002     |     CLK_PCKE=  000007 
    CLK_SWCR=  0050C5     |     CLK_SWCR=  000000     |     CLK_SWCR=  000001 
    CLK_SWCR=  000002     |     CLK_SWCR=  000003     |     CLK_SWIM=  0050CD 
    CLK_SWR =  0050C4     |     CLK_SWR_=  0000B4     |     CLK_SWR_=  0000E1 
    CLK_SWR_=  0000D2     |     CMD_END =  000002     |     CNT     =  000006 
    COMMA   =  000001     |     COUNT   =  000001     |     CPU_A   =  007F00 
    CPU_CCR =  007F0A     |     CPU_PCE =  007F01     |     CPU_PCH =  007F02 
    CPU_PCL =  007F03     |     CPU_SPH =  007F08     |     CPU_SPL =  007F09 
    CPU_XH  =  007F04     |     CPU_XL  =  007F05     |     CPU_YH  =  007F06 
    CPU_YL  =  007F07     |     CR      =  00000D     |   5 CRH        00240F R
  5 CRL        002407 R   |     CTRL_A  =  000001     |     CTRL_B  =  000002 
    CTRL_C  =  000003     |     CTRL_D  =  000004     |     CTRL_E  =  000005 
    CTRL_F  =  000006     |     CTRL_G  =  000007     |     CTRL_H  =  000008 
    CTRL_I  =  000009     |     CTRL_J  =  00000A     |     CTRL_K  =  00000B 
    CTRL_L  =  00000C     |     CTRL_M  =  00000D     |     CTRL_N  =  00000E 
    CTRL_O  =  00000F     |     CTRL_P  =  000010     |     CTRL_Q  =  000011 
    CTRL_R  =  000012     |     CTRL_S  =  000013     |     CTRL_T  =  000014 
    CTRL_U  =  000015     |     CTRL_V  =  000016     |     CTRL_W  =  000017 
    CTRL_X  =  000018     |     CTRL_Y  =  000019     |     CTRL_Z  =  00001A 
    CTXT_SIZ=  000004     |     CTX_BPTR=  000001     |     CTX_COUN=  000004 
    CTX_IN  =  000003     |     CURR    =  000002     |     CVAR    =  000007 
    CX_BPTR =  000001     |     CX_CNT  =  000004     |     CX_IN   =  000003 
  5 DATA       0023FE R   |   5 DATALN     0023F3 R   |     DBG_A   =  000005 
    DBG_CC  =  000006     |     DBG_X   =  000003     |     DBG_Y   =  000001 
  5 DDR        0023EB R   |     DEBUG   =  000000     |     DEBUG_BA=  007F00 
    DEBUG_EN=  007FFF     |   5 DEC        0023E3 R   |     DEST    =  000001 
    DEVID_BA=  0048CD     |     DEVID_EN=  0048D8     |     DEVID_LO=  0048D2 
    DEVID_LO=  0048D3     |     DEVID_LO=  0048D4     |     DEVID_LO=  0048D5 
    DEVID_LO=  0048D6     |     DEVID_LO=  0048D7     |     DEVID_LO=  0048D8 
    DEVID_WA=  0048D1     |     DEVID_XH=  0048CE     |     DEVID_XL=  0048CD 
    DEVID_YH=  0048D0     |     DEVID_YL=  0048CF     |   5 DIR        0023DB R
    DIVIDND =  000007     |     DIVISR  =  000005     |     DIVSOR  =  000001 
    DM_BK1RE=  007F90     |     DM_BK1RH=  007F91     |     DM_BK1RL=  007F92 
    DM_BK2RE=  007F93     |     DM_BK2RH=  007F94     |     DM_BK2RL=  007F95 
    DM_CR1  =  007F96     |     DM_CR2  =  007F97     |     DM_CSR1 =  007F98 
    DM_CSR2 =  007F99     |     DM_ENFCT=  007F9A     |   5 DO         0023D4 R
    DOLP_ADR=  000003     |     DOLP_INW=  000005     |   5 DREAD      0023CA R
  5 DWRITE     0023BF R   |   5 EEPROM     0023AC R   |     EEPROM_B=  004000 
    EEPROM_E=  0047FF     |     EEPROM_S=  000800     |   5 END        0023B7 R
    EOF     =  0000FF     |     ERR_BAD_=  00000A     |     ERR_CMD_=  000007 
    ERR_DIV0=  000004     |     ERR_DUPL=  000008     |     ERR_MATH=  000003 
    ERR_MEM_=  000001     |     ERR_NONE=  000000     |     ERR_NOT_=  000009 
    ERR_NO_A=  00000B     |     ERR_NO_D=  00000C     |     ERR_NO_L=  000005 
    ERR_RUN_=  000006     |     ERR_SYNT=  000002     |     ESC     =  00001B 
    EXTI_CR1=  0050A0     |     EXTI_CR2=  0050A1     |     FBREAK  =  000004 
    FCOMP   =  000005     |   5 FCPU       0023A3 R   |     FF      =  00000C 
    FHSE    =  7A1200     |     FHSI    =  F42400     |     FIRST   =  000001 
    FIRST_DA=  000006     |     FLASH_BA=  008000     |     FLASH_CR=  00505A 
    FLASH_CR=  000002     |     FLASH_CR=  000000     |     FLASH_CR=  000003 
    FLASH_CR=  000001     |     FLASH_CR=  00505B     |     FLASH_CR=  000005 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 138.
Hexadecimal [24-Bits]

Symbol Table

    FLASH_CR=  000004     |     FLASH_CR=  000007     |     FLASH_CR=  000000 
    FLASH_CR=  000006     |     FLASH_DU=  005064     |     FLASH_DU=  0000AE 
    FLASH_DU=  000056     |     FLASH_EN=  027FFF     |     FLASH_FP=  00505D 
    FLASH_FP=  000000     |     FLASH_FP=  000001     |     FLASH_FP=  000002 
    FLASH_FP=  000003     |     FLASH_FP=  000004     |     FLASH_FP=  000005 
    FLASH_IA=  00505F     |     FLASH_IA=  000003     |     FLASH_IA=  000002 
    FLASH_IA=  000006     |     FLASH_IA=  000001     |     FLASH_IA=  000000 
    FLASH_NC=  00505C     |     FLASH_NF=  00505E     |     FLASH_NF=  000000 
    FLASH_NF=  000001     |     FLASH_NF=  000002     |     FLASH_NF=  000003 
    FLASH_NF=  000004     |     FLASH_NF=  000005     |     FLASH_PU=  005062 
    FLASH_PU=  000056     |     FLASH_PU=  0000AE     |     FLASH_SI=  020000 
    FLASH_WS=  00480D     |     FLOOP   =  000002     |     FLSI    =  01F400 
  5 FOR        00239B R   |   5 FORGET     002390 R   |     FRUN    =  000000 
    FSIZE   =  000001     |     FSLEEP  =  000003     |     FSTEP   =  000003 
    FTRAP   =  000001     |     F_CFUNC =  000080     |     F_CMD   =  000000 
    F_CONST =  0000C0     |     F_IFUNC =  000040     |   5 GOSUB      002386 R
  5 GOTO       00237D R   |   5 GPIO       002374 R   |     GPIO_BAS=  005000 
    GPIO_CR1=  000003     |     GPIO_CR2=  000004     |     GPIO_DDR=  000002 
    GPIO_IDR=  000001     |     GPIO_ODR=  000000     |     GPIO_SIZ=  000005 
  5 HEX        00236C R   |     HSECNT  =  004809     |     I2C_CCRH=  00521C 
    I2C_CCRH=  000080     |     I2C_CCRH=  0000C0     |     I2C_CCRH=  000080 
    I2C_CCRH=  000000     |     I2C_CCRH=  000001     |     I2C_CCRH=  000000 
    I2C_CCRL=  00521B     |     I2C_CCRL=  00001A     |     I2C_CCRL=  000002 
    I2C_CCRL=  00000D     |     I2C_CCRL=  000050     |     I2C_CCRL=  000090 
    I2C_CCRL=  0000A0     |     I2C_CR1 =  005210     |     I2C_CR1_=  000006 
    I2C_CR1_=  000007     |     I2C_CR1_=  000000     |     I2C_CR2 =  005211 
    I2C_CR2_=  000002     |     I2C_CR2_=  000003     |     I2C_CR2_=  000000 
    I2C_CR2_=  000001     |     I2C_CR2_=  000007     |     I2C_DR  =  005216 
    I2C_FREQ=  005212     |     I2C_ITR =  00521A     |     I2C_ITR_=  000002 
    I2C_ITR_=  000000     |     I2C_ITR_=  000001     |     I2C_OARH=  005214 
    I2C_OARH=  000001     |     I2C_OARH=  000002     |     I2C_OARH=  000006 
    I2C_OARH=  000007     |     I2C_OARL=  005213     |     I2C_OARL=  000000 
    I2C_OAR_=  000813     |     I2C_OAR_=  000009     |     I2C_PECR=  00521E 
    I2C_READ=  000001     |     I2C_SR1 =  005217     |     I2C_SR1_=  000003 
    I2C_SR1_=  000001     |     I2C_SR1_=  000002     |     I2C_SR1_=  000006 
    I2C_SR1_=  000000     |     I2C_SR1_=  000004     |     I2C_SR1_=  000007 
    I2C_SR2 =  005218     |     I2C_SR2_=  000002     |     I2C_SR2_=  000001 
    I2C_SR2_=  000000     |     I2C_SR2_=  000003     |     I2C_SR2_=  000005 
    I2C_SR3 =  005219     |     I2C_SR3_=  000001     |     I2C_SR3_=  000007 
    I2C_SR3_=  000004     |     I2C_SR3_=  000000     |     I2C_SR3_=  000002 
    I2C_TRIS=  00521D     |     I2C_TRIS=  000005     |     I2C_TRIS=  000005 
    I2C_TRIS=  000005     |     I2C_TRIS=  000011     |     I2C_TRIS=  000011 
    I2C_TRIS=  000011     |     I2C_WRIT=  000000     |   5 IDR        002364 R
  5 IF         00235D R   |     IN      =  000005     |     INCR    =  000001 
    INP     =  000000     |   5 INPUT      002353 R   |     INPUT_DI=  000000 
    INPUT_EI=  000001     |     INPUT_FL=  000000     |     INPUT_PU=  000001 
    INT_ADC2=  000016     |     INT_AUAR=  000012     |     INT_AWU =  000001 
    INT_CAN_=  000008     |     INT_CAN_=  000009     |     INT_CLK =  000002 
    INT_EXTI=  000003     |     INT_EXTI=  000004     |     INT_EXTI=  000005 
    INT_EXTI=  000006     |     INT_EXTI=  000007     |     INT_FLAS=  000018 
    INT_I2C =  000013     |     INT_SPI =  00000A     |     INT_TIM1=  00000C 
    INT_TIM1=  00000B     |     INT_TIM2=  00000E     |     INT_TIM2=  00000D 
    INT_TIM3=  000010     |     INT_TIM3=  00000F     |     INT_TIM4=  000017 
    INT_TLI =  000000     |     INT_UART=  000011     |     INT_UART=  000015 
    INT_UART=  000014     |     INT_VECT=  008060     |     INT_VECT=  00800C 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 139.
Hexadecimal [24-Bits]

Symbol Table

    INT_VECT=  008028     |     INT_VECT=  00802C     |     INT_VECT=  008010 
    INT_VECT=  008014     |     INT_VECT=  008018     |     INT_VECT=  00801C 
    INT_VECT=  008020     |     INT_VECT=  008024     |     INT_VECT=  008068 
    INT_VECT=  008054     |     INT_VECT=  008000     |     INT_VECT=  008030 
    INT_VECT=  008038     |     INT_VECT=  008034     |     INT_VECT=  008040 
    INT_VECT=  00803C     |     INT_VECT=  008048     |     INT_VECT=  008044 
    INT_VECT=  008064     |     INT_VECT=  008008     |     INT_VECT=  008004 
    INT_VECT=  008050     |     INT_VECT=  00804C     |     INT_VECT=  00805C 
    INT_VECT=  008058     |   5 INVERT     002348 R   |     INW     =  000009 
    ITC_SPR1=  007F70     |     ITC_SPR2=  007F71     |     ITC_SPR3=  007F72 
    ITC_SPR4=  007F73     |     ITC_SPR5=  007F74     |     ITC_SPR6=  007F75 
    ITC_SPR7=  007F76     |     ITC_SPR8=  007F77     |   5 IWDGEN     00233D R
  5 IWDGREF    002331 R   |     IWDG_KEY=  000055     |     IWDG_KEY=  0000CC 
    IWDG_KEY=  0000AA     |     IWDG_KR =  0050E0     |     IWDG_PR =  0050E1 
    IWDG_RLR=  0050E2     |   5 KEY        002329 R   |     LAST    =  000003 
    LB      =  000002     |     LED2_BIT=  000005     |     LED2_MAS=  000020 
    LED2_POR=  00500A     |     LEN     =  000005     |   5 LET        002321 R
    LIMIT   =  000005     |     LINENO  =  000005     |   5 LINK    =  002490 R
  5 LIST       002318 R   |     LL      =  000002     |     LLEN    =  000002 
    LL_HB   =  000001     |     LN_PTR  =  000005     |   5 LOAD       00230F R
  5 LOG        002307 R   |   5 LSHIFT     0022FC R   |     MAJOR   =  000001 
    MASK    =  000002     |     MATH_OVF=  000000     |     MAX_LINE=  007FFF 
    MINOR   =  000000     |     MULOP   =  000005     |     N1      =  000001 
    N1_HB   =  000006     |     N1_LB   =  000007     |     N2      =  000003 
    N2_HB   =  000008     |     N2_LB   =  000009     |     NAFR    =  004804 
    NAMEPTR =  000003     |     NCLKOPT =  004808     |     NEG     =  000001 
  5 NEW        0022EB R   |   5 NEXT       0022F3 R   |     NFLASH_W=  00480E 
    NHSECNT =  00480A     |     NL      =  00000A     |     NLEN    =  000001 
    NOPT1   =  004802     |     NOPT2   =  004804     |     NOPT3   =  004806 
    NOPT4   =  004808     |     NOPT5   =  00480A     |     NOPT6   =  00480C 
    NOPT7   =  00480E     |     NOPTBL  =  00487F     |   5 NOT        0022E3 R
    NUBC    =  004802     |     NWDGOPT =  004806     |     NWDGOPT_=  FFFFFFFD 
    NWDGOPT_=  FFFFFFFC     |     NWDGOPT_=  FFFFFFFF     |     NWDGOPT_=  FFFFFFFE 
  5 NonHandl   000000 R   |   5 ODR        0022DB R   |     ONOFF   =  000003 
    OP      =  000005     |     OPT     =  000002     |     OPT0    =  004800 
    OPT1    =  004801     |     OPT2    =  004803     |     OPT3    =  004805 
    OPT4    =  004807     |     OPT5    =  004809     |     OPT6    =  00480B 
    OPT7    =  00480D     |     OPTBL   =  00487E     |     OPTION_B=  004800 
    OPTION_E=  00487F     |     OPTION_S=  000080     |   5 OR         0022D4 R
    OUTP    =  000001     |     OUTPUT_F=  000001     |     OUTPUT_O=  000000 
    OUTPUT_P=  000001     |     OUTPUT_S=  000000     |     OVFH    =  000001 
    OVFL    =  000002     |     PA      =  000000     |     PAD_SIZE=  000028 
  5 PAUSE      0022CA R   |     PA_BASE =  005000     |     PA_CR1  =  005003 
    PA_CR2  =  005004     |     PA_DDR  =  005002     |     PA_IDR  =  005001 
    PA_ODR  =  005000     |     PB      =  000005     |     PB_BASE =  005005 
    PB_CR1  =  005008     |     PB_CR2  =  005009     |     PB_DDR  =  005007 
    PB_IDR  =  005006     |     PB_ODR  =  005005     |     PC      =  00000A 
    PC_BASE =  00500A     |     PC_CR1  =  00500D     |     PC_CR2  =  00500E 
    PC_DDR  =  00500C     |     PC_IDR  =  00500B     |     PC_ODR  =  00500A 
    PD      =  00000F     |     PD_BASE =  00500F     |     PD_CR1  =  005012 
    PD_CR2  =  005013     |     PD_DDR  =  005011     |     PD_IDR  =  005010 
    PD_ODR  =  00500F     |     PE      =  000014     |   5 PEEK       0022B7 R
    PE_BASE =  005014     |     PE_CR1  =  005017     |     PE_CR2  =  005018 
    PE_DDR  =  005016     |     PE_IDR  =  005015     |     PE_ODR  =  005014 
    PF      =  000019     |     PF_BASE =  005019     |     PF_CR1  =  00501C 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 140.
Hexadecimal [24-Bits]

Symbol Table

    PF_CR2  =  00501D     |     PF_DDR  =  00501B     |     PF_IDR  =  00501A 
    PF_ODR  =  005019     |     PG      =  00001E     |     PG_BASE =  00501E 
    PG_CR1  =  005021     |     PG_CR2  =  005022     |     PG_DDR  =  005020 
    PG_IDR  =  00501F     |     PG_ODR  =  00501E     |     PH      =  000023 
    PH_BASE =  005023     |     PH_CR1  =  005026     |     PH_CR2  =  005027 
    PH_DDR  =  005025     |     PH_IDR  =  005024     |     PH_ODR  =  005023 
    PI      =  000028     |     PINNO   =  000001     |   5 PINP       0022AE R
    PINVAL  =  000002     |     PI_BASE =  005028     |     PI_CR1  =  00502B 
    PI_CR2  =  00502C     |     PI_DDR  =  00502A     |     PI_IDR  =  005029 
    PI_ODR  =  005028     |   5 PMODE      0022C0 R   |   5 POKE       0022A5 R
    PORT    =  000003     |   5 POUT       00229C R   |     PREV    =  000001 
  5 PRINT      002292 R   |     PROD    =  000002     |   5 PRTA       002289 R
  5 PRTB       002280 R   |   5 PRTC       002277 R   |   5 PRTD       00226E R
  5 PRTE       002265 R   |   5 PRTF       00225C R   |   5 PRTG       002253 R
  5 PRTH       00224A R   |   5 PRTI       002241 R   |   5 QKEY       002238 R
    RAM_BASE=  000000     |     RAM_END =  0017FF     |     RAM_SIZE=  001800 
  5 READ       00222F R   |   5 REBOOT     002224 R   |     REG     =  000001 
    RELOP   =  000005     |   5 REMARK     002219 R   |   5 RESTORE    00220D R
    RETL1   =  000001     |   5 RETURN     002202 R   |     RET_ADDR=  000003 
    RET_INW =  000005     |   5 RND        0021FA R   |     ROP     =  004800 
  5 RSHIFT     0021EF R   |     RST_SR  =  0050B3     |   5 RUN        0021E7 R
    RXCHAR  =  000001     |   5 SAVE       0021DE R   |     SDIVD   =  000002 
    SFR_BASE=  005000     |     SFR_END =  0057FF     |     SHARP   =  000023 
  5 SHOW       0021D5 R   |     SIGN    =  000001     |   5 SIZE       0021CC R
    SKIP    =  000005     |   5 SLEEP      0021C2 R   |     SPACE   =  000020 
  5 SPIEN      0021AE R   |   5 SPIRD      0021B8 R   |   5 SPISEL     0021A3 R
  5 SPIWR      002199 R   |     SPI_CR1 =  005200     |     SPI_CR1_=  000003 
    SPI_CR1_=  000000     |     SPI_CR1_=  000001     |     SPI_CR1_=  000007 
    SPI_CR1_=  000002     |     SPI_CR1_=  000006     |     SPI_CR2 =  005201 
    SPI_CR2_=  000007     |     SPI_CR2_=  000006     |     SPI_CR2_=  000005 
    SPI_CR2_=  000004     |     SPI_CR2_=  000002     |     SPI_CR2_=  000000 
    SPI_CR2_=  000001     |     SPI_CRCP=  005205     |     SPI_CS_B=  000005 
    SPI_DR  =  005204     |     SPI_ICR =  005202     |     SPI_RXCR=  005206 
    SPI_SR  =  005203     |     SPI_SR_B=  000007     |     SPI_SR_C=  000004 
    SPI_SR_M=  000005     |     SPI_SR_O=  000006     |     SPI_SR_R=  000000 
    SPI_SR_T=  000001     |     SPI_SR_W=  000003     |     SPI_TXCR=  005207 
    SQUOT   =  000001     |     SRC     =  000003     |     STACK_EM=  0017FF 
    STACK_SI=  0000A0     |   5 STEP       002190 R   |   5 STOP       002187 R
    SWIM_CSR=  007F80     |     TAB     =  000009     |     TAB_WIDT=  000004 
    TCHAR   =  000001     |     TEMP    =  000003     |     TIB_SIZE=  000050 
    TICK    =  000027     |   5 TICKS      00217D R   |     TIM1_ARR=  005262 
    TIM1_ARR=  005263     |     TIM1_BKR=  00526D     |     TIM1_CCE=  00525C 
    TIM1_CCE=  00525D     |     TIM1_CCM=  005258     |     TIM1_CCM=  000000 
    TIM1_CCM=  000001     |     TIM1_CCM=  000004     |     TIM1_CCM=  000005 
    TIM1_CCM=  000006     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000003     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000004     |     TIM1_CCM=  000005     |     TIM1_CCM=  000006 
    TIM1_CCM=  000003     |     TIM1_CCM=  005259     |     TIM1_CCM=  000000 
    TIM1_CCM=  000001     |     TIM1_CCM=  000004     |     TIM1_CCM=  000005 
    TIM1_CCM=  000006     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000003     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000004     |     TIM1_CCM=  000005     |     TIM1_CCM=  000006 
    TIM1_CCM=  000003     |     TIM1_CCM=  00525A     |     TIM1_CCM=  000000 
    TIM1_CCM=  000001     |     TIM1_CCM=  000004     |     TIM1_CCM=  000005 
    TIM1_CCM=  000006     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 141.
Hexadecimal [24-Bits]

Symbol Table

    TIM1_CCM=  000003     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000004     |     TIM1_CCM=  000005     |     TIM1_CCM=  000006 
    TIM1_CCM=  000003     |     TIM1_CCM=  00525B     |     TIM1_CCM=  000000 
    TIM1_CCM=  000001     |     TIM1_CCM=  000004     |     TIM1_CCM=  000005 
    TIM1_CCM=  000006     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000003     |     TIM1_CCM=  000007     |     TIM1_CCM=  000002 
    TIM1_CCM=  000004     |     TIM1_CCM=  000005     |     TIM1_CCM=  000006 
    TIM1_CCM=  000003     |     TIM1_CCR=  005265     |     TIM1_CCR=  005266 
    TIM1_CCR=  005267     |     TIM1_CCR=  005268     |     TIM1_CCR=  005269 
    TIM1_CCR=  00526A     |     TIM1_CCR=  00526B     |     TIM1_CCR=  00526C 
    TIM1_CNT=  00525E     |     TIM1_CNT=  00525F     |     TIM1_CR1=  005250 
    TIM1_CR2=  005251     |     TIM1_CR2=  000000     |     TIM1_CR2=  000002 
    TIM1_CR2=  000004     |     TIM1_CR2=  000005     |     TIM1_CR2=  000006 
    TIM1_DTR=  00526E     |     TIM1_EGR=  005257     |     TIM1_EGR=  000007 
    TIM1_EGR=  000001     |     TIM1_EGR=  000002     |     TIM1_EGR=  000003 
    TIM1_EGR=  000004     |     TIM1_EGR=  000005     |     TIM1_EGR=  000006 
    TIM1_EGR=  000000     |     TIM1_ETR=  005253     |     TIM1_ETR=  000006 
    TIM1_ETR=  000000     |     TIM1_ETR=  000001     |     TIM1_ETR=  000002 
    TIM1_ETR=  000003     |     TIM1_ETR=  000007     |     TIM1_ETR=  000004 
    TIM1_ETR=  000005     |     TIM1_IER=  005254     |     TIM1_IER=  000007 
    TIM1_IER=  000001     |     TIM1_IER=  000002     |     TIM1_IER=  000003 
    TIM1_IER=  000004     |     TIM1_IER=  000005     |     TIM1_IER=  000006 
    TIM1_IER=  000000     |     TIM1_OIS=  00526F     |     TIM1_PSC=  005260 
    TIM1_PSC=  005261     |     TIM1_RCR=  005264     |     TIM1_SMC=  005252 
    TIM1_SMC=  000007     |     TIM1_SMC=  000000     |     TIM1_SMC=  000001 
    TIM1_SMC=  000002     |     TIM1_SMC=  000004     |     TIM1_SMC=  000005 
    TIM1_SMC=  000006     |     TIM1_SR1=  005255     |     TIM1_SR1=  000007 
    TIM1_SR1=  000001     |     TIM1_SR1=  000002     |     TIM1_SR1=  000003 
    TIM1_SR1=  000004     |     TIM1_SR1=  000005     |     TIM1_SR1=  000006 
    TIM1_SR1=  000000     |     TIM1_SR2=  005256     |     TIM1_SR2=  000001 
    TIM1_SR2=  000002     |     TIM1_SR2=  000003     |     TIM1_SR2=  000004 
    TIM2_ARR=  00530D     |     TIM2_ARR=  00530E     |     TIM2_CCE=  005308 
    TIM2_CCE=  000000     |     TIM2_CCE=  000001     |     TIM2_CCE=  000004 
    TIM2_CCE=  000005     |     TIM2_CCE=  005309     |     TIM2_CCM=  005305 
    TIM2_CCM=  005306     |     TIM2_CCM=  005307     |     TIM2_CCM=  000000 
    TIM2_CCM=  000004     |     TIM2_CCM=  000003     |     TIM2_CCR=  00530F 
    TIM2_CCR=  005310     |     TIM2_CCR=  005311     |     TIM2_CCR=  005312 
    TIM2_CCR=  005313     |     TIM2_CCR=  005314     |     TIM2_CLK=  00F424 
    TIM2_CNT=  00530A     |     TIM2_CNT=  00530B     |     TIM2_CR1=  005300 
    TIM2_CR1=  000007     |     TIM2_CR1=  000000     |     TIM2_CR1=  000003 
    TIM2_CR1=  000001     |     TIM2_CR1=  000002     |     TIM2_EGR=  005304 
    TIM2_EGR=  000001     |     TIM2_EGR=  000002     |     TIM2_EGR=  000003 
    TIM2_EGR=  000006     |     TIM2_EGR=  000000     |     TIM2_IER=  005301 
    TIM2_PSC=  00530C     |     TIM2_SR1=  005302     |     TIM2_SR2=  005303 
    TIM3_ARR=  00532B     |     TIM3_ARR=  00532C     |     TIM3_CCE=  005327 
    TIM3_CCE=  000000     |     TIM3_CCE=  000001     |     TIM3_CCE=  000004 
    TIM3_CCE=  000005     |     TIM3_CCE=  000000     |     TIM3_CCE=  000001 
    TIM3_CCM=  005325     |     TIM3_CCM=  005326     |     TIM3_CCM=  000000 
    TIM3_CCM=  000004     |     TIM3_CCM=  000003     |     TIM3_CCR=  00532D 
    TIM3_CCR=  00532E     |     TIM3_CCR=  00532F     |     TIM3_CCR=  005330 
    TIM3_CNT=  005328     |     TIM3_CNT=  005329     |     TIM3_CR1=  005320 
    TIM3_CR1=  000007     |     TIM3_CR1=  000000     |     TIM3_CR1=  000003 
    TIM3_CR1=  000001     |     TIM3_CR1=  000002     |     TIM3_EGR=  005324 
    TIM3_IER=  005321     |     TIM3_PSC=  00532A     |     TIM3_SR1=  005322 
    TIM3_SR2=  005323     |     TIM4_ARR=  005346     |     TIM4_CNT=  005344 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 142.
Hexadecimal [24-Bits]

Symbol Table

    TIM4_CR1=  005340     |     TIM4_CR1=  000007     |     TIM4_CR1=  000000 
    TIM4_CR1=  000003     |     TIM4_CR1=  000001     |     TIM4_CR1=  000002 
    TIM4_EGR=  005343     |     TIM4_EGR=  000000     |     TIM4_IER=  005341 
    TIM4_IER=  000000     |     TIM4_PSC=  005345     |     TIM4_PSC=  000000 
    TIM4_PSC=  000007     |     TIM4_PSC=  000004     |     TIM4_PSC=  000001 
    TIM4_PSC=  000005     |     TIM4_PSC=  000002     |     TIM4_PSC=  000006 
    TIM4_PSC=  000003     |     TIM4_PSC=  000000     |     TIM4_PSC=  000001 
    TIM4_PSC=  000002     |     TIM4_SR =  005342     |     TIM4_SR_=  000000 
  5 TIMEOUT    002167 R   |   5 TIMER      002173 R   |     TIM_CR1_=  000007 
    TIM_CR1_=  000000     |     TIM_CR1_=  000006     |     TIM_CR1_=  000005 
    TIM_CR1_=  000004     |     TIM_CR1_=  000003     |     TIM_CR1_=  000001 
    TIM_CR1_=  000002     |     TK_ARRAY=  000002     |     TK_CFUNC=  000008 
    TK_CHAR =  000003     |     TK_CMD  =  000006     |     TK_COLON=  000001 
    TK_COMMA=  00000D     |     TK_DIV  =  000021     |     TK_EQUAL=  000032 
    TK_GE   =  000033     |     TK_GRP_A=  000010     |     TK_GRP_M=  000030 
    TK_GRP_M=  000000     |     TK_GRP_M=  000020     |     TK_GRP_R=  000030 
    TK_GT   =  000031     |     TK_IFUNC=  000007     |     TK_INTGR=  000004 
    TK_LE   =  000036     |     TK_LPARE=  00000B     |     TK_LT   =  000034 
    TK_MINUS=  000011     |     TK_MOD  =  000022     |     TK_MULT =  000020 
    TK_NE   =  000035     |     TK_NONE =  000000     |     TK_PLUS =  000010 
    TK_QSTR =  00000A     |     TK_RPARE=  00000C     |     TK_SHARP=  00000E 
    TK_VAR  =  000005     |   5 TO         002160 R   |   5 TONE       002157 R
    TWSAVE  =  000001     |   5 Timer4Up   000026 R   |     U8      =  000003 
    UART1   =  000000     |     UART1_BA=  005230     |     UART1_BR=  005232 
    UART1_BR=  005233     |     UART1_CR=  005234     |     UART1_CR=  005235 
    UART1_CR=  005236     |     UART1_CR=  005237     |     UART1_CR=  005238 
    UART1_DR=  005231     |     UART1_GT=  005239     |     UART1_PO=  000000 
    UART1_PS=  00523A     |     UART1_RX=  000004     |     UART1_SR=  005230 
    UART1_TX=  000005     |     UART3   =  000001     |     UART3_BA=  005240 
    UART3_BR=  005242     |     UART3_BR=  005243     |     UART3_CR=  005244 
    UART3_CR=  005245     |     UART3_CR=  005246     |     UART3_CR=  005247 
    UART3_CR=  004249     |     UART3_DR=  005241     |     UART3_PO=  00000F 
    UART3_RX=  000006     |     UART3_SR=  005240     |     UART3_TX=  000005 
    UART_BRR=  000002     |     UART_BRR=  000003     |     UART_CR1=  000004 
    UART_CR1=  000004     |     UART_CR1=  000002     |     UART_CR1=  000000 
    UART_CR1=  000001     |     UART_CR1=  000007     |     UART_CR1=  000006 
    UART_CR1=  000005     |     UART_CR1=  000003     |     UART_CR2=  000005 
    UART_CR2=  000004     |     UART_CR2=  000002     |     UART_CR2=  000005 
    UART_CR2=  000001     |     UART_CR2=  000000     |     UART_CR2=  000006 
    UART_CR2=  000003     |     UART_CR2=  000007     |     UART_CR3=  000006 
    UART_CR3=  000003     |     UART_CR3=  000001     |     UART_CR3=  000002 
    UART_CR3=  000000     |     UART_CR3=  000006     |     UART_CR3=  000004 
    UART_CR3=  000005     |     UART_CR4=  000007     |     UART_CR4=  000000 
    UART_CR4=  000001     |     UART_CR4=  000002     |     UART_CR4=  000003 
    UART_CR4=  000004     |     UART_CR4=  000006     |     UART_CR4=  000005 
    UART_CR5=  000008     |     UART_CR5=  000003     |     UART_CR5=  000001 
    UART_CR5=  000002     |     UART_CR5=  000004     |     UART_CR5=  000005 
    UART_CR6=  000009     |     UART_CR6=  000004     |     UART_CR6=  000007 
    UART_CR6=  000001     |     UART_CR6=  000002     |     UART_CR6=  000000 
    UART_CR6=  000005     |     UART_DR =  000001     |     UART_GTR=  000009 
    UART_PSC=  00000A     |     UART_SR =  000000     |     UART_SR_=  000001 
    UART_SR_=  000004     |     UART_SR_=  000002     |     UART_SR_=  000003 
    UART_SR_=  000000     |     UART_SR_=  000005     |     UART_SR_=  000006 
    UART_SR_=  000007     |     UBC     =  004801     |   5 UBOUND     00214C R
  5 UBTN_Han   000069 R   |   5 UFLASH     002141 R   |   5 UNTIL      002137 R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 143.
Hexadecimal [24-Bits]

Symbol Table

  5 USER_ABO   000071 R   |     USE_BLOC=  000000     |   5 USR        00212F R
    USR_BTN_=  000004     |     USR_BTN_=  000010     |     USR_BTN_=  005015 
  5 Uart1RxH   00000F R   |   5 UserButt   00003C R   |     VAR_ADDR=  000006 
    VSIZ    =  000002     |     VSIZE   =  000006     |     VT      =  00000B 
  5 WAIT       002126 R   |     WDGOPT  =  004805     |     WDGOPT_I=  000002 
    WDGOPT_L=  000003     |     WDGOPT_W=  000000     |     WDGOPT_W=  000001 
    WIDTH   =  000001     |     WIDTH_SA=  000002     |     WLEN    =  000001 
  5 WORDS      00211C R   |   5 WRITE      002112 R   |     WWDG_CR =  0050D1 
    WWDG_WR =  0050D2     |     XADR    =  000001     |     XMASK   =  000001 
  5 XOR        00210A R   |   5 XPEEK      002100 R   |     XSAVE   =  000005 
    YSAVE   =  000003     |   5 abs        001C73 R   |   1 acc16      00000C R
  1 acc24      00000B R   |   1 acc8       00000D R   |   5 accept_c   0009A0 R
  5 add        000D45 R   |   5 analog_r   001735 R   |   5 ansi_seq   000962 R
  5 arduino_   001D5E R   |   5 arg_list   000E84 R   |   1 array_si   000023 R
  5 ascii      001B3C R   |   5 at_tst     000B73 R   |   5 atoi24     000C86 R
  5 atoi_exi   000CF4 R   |   5 autorun    001BC5 R   |   5 autorun_   0005B6 R
  5 awu        001C24 R   |   5 awu02      001C2E R   |   5 bad_port   001B94 R
  1 base       00000A R   |   1 basicptr   000004 R   |   5 beep       0016BD R
  5 bin_exit   000A77 R   |   5 bit_and    001C87 R   |   5 bit_or     001C9F R
  5 bit_rese   001481 R   |   5 bit_set    001471 R   |   5 bit_test   0014A2 R
  5 bit_togg   001492 R   |   5 bit_xor    001CB7 R   |   5 bitmask    001E9E R
  5 bkslsh_t   000B1E R   |   5 bksp       0001D0 R   |   5 break_po   001802 R
  5 bye        001BBC R   |   5 char       001B2A R   |   5 check_fu   000365 R
  5 clear_ba   0005CB R   |   5 clear_va   00046F R   |   5 clock_in   00008C R
  5 cmd_end    0016A1 R   |   5 cmd_line   000773 R   |   5 cmd_name   000DF0 R
  5 cmp_name   001876 R   |   5 cold_sta   0004D4 R   |   5 colon_ts   000B47 R
  5 comma_ts   000B52 R   |   5 compile    000374 R   |   5 const_cr   001F52 R
  5 const_cr   001F58 R   |   5 const_dd   001F4C R   |   5 const_ee   001F6A R
  5 const_id   001F46 R   |   5 const_in   001F64 R   |   5 const_od   001F40 R
  5 const_ou   001F5E R   |   5 const_po   001F0A R   |   5 const_po   001F10 R
  5 const_po   001F16 R   |   5 const_po   001F1C R   |   5 const_po   001F22 R
  5 const_po   001F28 R   |   5 const_po   001F2E R   |   5 const_po   001F34 R
  5 const_po   001F3A R   |   5 convert_   0009FF R   |   1 count      000003 R
  5 cp_loop    000E33 R   |   5 create_g   0002C4 R   |   5 cs_high    0020F9 R
  5 cstk_pro   001077 R   |   5 dash_tst   000B68 R   |   5 data       001F70 R
  1 data_len   000009 R   |   5 data_lin   001F76 R   |   1 data_ofs   000008 R
  1 data_ptr   000006 R   |   5 data_sea   001FB6 R   |   5 dec_base   0010D2 R
  5 del_back   000991 R   |   5 del_line   00028C R   |   5 del_ln     000982 R
  5 delete     0001E0 R   |   5 digital_   001769 R   |   5 digital_   001799 R
  5 dir_loop   001A69 R   |   5 director   001A5D R   |   5 divide     000D9B R
  5 divu24_8   0008EF R   |   5 do_loop    001EC7 R   |   5 dotr_loo   001047 R
  5 drive_fr   001AE6 R   |   1 dstkptr    00001C R   |   5 enable_i   001E48 R
  5 eql_tst    000BD3 R   |   5 equal      00134B R   |   5 err_bad_   0006AA R
  5 err_cmd_   00066B R   |   5 err_div0   00062D R   |   5 err_dupl   000686 R
  5 err_math   000613 R   |   5 err_mem_   0005F6 R   |   5 err_msg    0005DC R
  5 err_no_a   0006B7 R   |   5 err_no_d   0006EB R   |   5 err_no_l   00063D R
  5 err_not_   000698 R   |   5 err_run_   000654 R   |   5 err_synt   000604 R
  5 escaped    000A14 R   |   5 expect     000E77 R   |   5 expr_exi   000FD1 R
  5 expressi   000F90 R   |   5 factor     000EE7 R   |   1 farptr     000016 R
  5 fcpu       001D01 R   |   7 fdrive     010000 R   |   1 ffree      000019 R
  5 file_cou   001ADE R   |   5 final_te   00095C R   |   5 first_li   001152 R
  1 flags      000025 R   |   5 for        001519 R   |   5 forget     001A12 R
  1 free_ram   00005C R   |   5 func_arg   000EAB R   |   5 func_not   001E3B R
  5 ge         00134D R   |   5 get_arra   000EC2 R   |   5 get_targ   0015E3 R
  5 get_tick   001C6D R   |   5 get_toke   000AB9 R   |   5 getc       0001BC R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 144.
Hexadecimal [24-Bits]

Symbol Table

  5 gosub      001614 R   |   5 goto       0015F9 R   |   5 gpio       001B6F R
  5 gt         001349 R   |   5 gt_tst     000BDE R   |   5 hex_base   0010CD R
  5 if         001505 R   |   1 in         000001 R   |   1 in.saved   000002 R
  1 in.w       000000 R   |   5 incr_far   00182B R   |   5 input_ex   001443 R
  5 input_lo   0013E4 R   |   5 input_va   0013E2 R   |   5 insert_l   0002FD R
  5 insert_l   000362 R   |   5 interp     000747 R   |   5 interp_l   000787 R
  5 invert     001EB8 R   |   5 is_alpha   00047D R   |   5 is_digit   000C71 R
  5 itoa       0008A8 R   |   5 itoa_loo   0008C0 R   |   5 jp_to_ta   001607 R
  5 key        001B5C R   |   5 kword_di   00248E R   |   5 kword_en   0020FE R
  5 le         001352 R   |   5 leading_   001E8E R   |   5 left_arr   000962 R
  5 let        001103 R   |   5 let02      00110D R   |   5 lines_sk   001155 R
  5 list       001127 R   |   5 list_exi   00119E R   |   5 list_sta   001178 R
  5 load       0019D7 R   |   5 load_aut   000592 R   |   5 load_fil   0019A6 R
  5 log2       001E83 R   |   5 logical_   001E31 R   |   5 loop_bac   0015C6 R
  1 loop_dep   000022 R   |   5 loop_don   0015DB R   |   5 lshift     001CCF R
  5 lt         001350 R   |   5 lt_tst     000C17 R   |   5 modulo     000DDF R
  5 move       000226 R   |   5 move_dow   000244 R   |   5 move_exi   000265 R
  5 move_loo   000249 R   |   5 move_up    000236 R   |   5 mul_char   00133A R
  5 multiply   000D53 R   |   5 mulu24_8   000CF8 R   |   5 nbr_tst    000AF4 R
  5 ne         001355 R   |   5 neg_acc2   000917 R   |   5 new        001820 R
  5 next       001599 R   |   5 next_tok   0007B5 R   |   5 no_match   000E45 R
  5 none       000AB9 R   |   5 other      000C4F R   |   3 pad        001738 R
  5 parse_bi   000A57 R   |   5 parse_in   000A1C R   |   5 parse_ke   000A7F R
  5 parse_qu   0009C4 R   |   5 pause      001C11 R   |   5 pause02    001C1B R
  5 peek       0014D8 R   |   5 pin_mode   001D0D R   |   5 plus_tst   000BA7 R
  5 poke       0014C9 R   |   5 power_ad   0016F9 R   |   5 prcnt_ts   000BC8 R
  5 print      001358 R   |   5 print_ex   0013B6 R   |   5 print_in   00084A R
  5 prt_basi   0011F1 R   |   5 prt_cmd_   0011A1 R   |   5 prt_loop   00135C R
  5 prt_quot   0011B5 R   |   5 prti24     000802 R   |   1 ptr16      000017 R
  1 ptr8       000018 R   |   5 putc       0001B3 R   |   5 puts       0001C6 R
  5 qkey       001B64 R   |   5 qmark_ts   000B7E R   |   5 random     001D7E R
  5 read       001FEE R   |   5 read01     001FF0 R   |   5 readln     00093A R
  5 readln_l   000940 R   |   5 readln_q   0009B5 R   |   5 refresh_   001E7E R
  5 rel_exit   001028 R   |   5 relation   000FD4 R   |   5 relop_st   00133D R
  5 rem        001446 R   |   5 reprint    000962 R   |   5 reset_co   00135A R
  5 rest_con   0013D2 R   |   5 restore    001FA3 R   |   5 return     001634 R
  5 right_ar   000962 R   |   5 row_loop   0010B0 R   |   5 rparnt_t   000B3C R
  5 rshift     001CE8 R   |   5 run        001652 R   |   5 run_it     00167A R
  1 rx_char    000027 R   |   5 save       0018E2 R   |   5 save_con   0013C2 R
  5 search_d   000E22 R   |   5 search_e   000E73 R   |   5 search_f   001897 R
  5 search_l   000268 R   |   5 search_l   000270 R   |   5 search_n   000E26 R
  1 seedx      000012 R   |   1 seedy      000014 R   |   5 seek_fdr   001839 R
  5 select_p   001D4E R   |   5 set_time   001E1F R   |   5 sharp_ts   000B5D R
  5 show       00102B R   |   5 show_row   00109E R   |   5 single_c   001336 R
  5 size       0010D7 R   |   5 skip       000D32 R   |   5 slash_ts   000BBD R
  5 sleep      001C06 R   |   5 software   00048E R   |   5 spaces     0001EE R
  5 spi_clea   002092 R   |   5 spi_disa   00207A R   |   5 spi_enab   002048 R
  5 spi_rcv_   0020B4 R   |   5 spi_read   0020DF R   |   5 spi_sele   0020E7 R
  5 spi_send   00209E R   |   5 spi_writ   0020BF R   |   3 stack_fu   001760 R
  3 stack_un   001800 R   |   5 star_tst   000BB2 R   |   5 step       001572 R
  5 stop       0017D4 R   |   5 store_lo   001586 R   |   5 str_matc   000E54 R
  5 str_tst    000AE3 R   |   5 strcmp     000207 R   |   5 strcpy     000218 R
  5 strlen     0001FA R   |   5 substrac   000D4D R   |   5 syntax_e   000701 R
  1 tab_widt   000026 R   |   5 tb_error   000703 R   |   5 term       000F41 R
  5 term01     000F4A R   |   5 term_exi   000F8D R   |   3 tib        0016E8 R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 145.
Hexadecimal [24-Bits]

Symbol Table

  5 tick_tst   000B95 R   |   1 ticks      00000E R   |   5 timeout    001E2E R
  1 timer      000010 R   |   5 timer2_i   0000A2 R   |   5 timer4_i   0000AF R
  5 to         001542 R   |   5 to_upper   000C7A GR  |   5 token_ch   000C5E R
  5 token_ex   000C6E R   |   5 tone       0016B0 R   |   5 try_next   001FDE R
  1 txtbgn     00001E R   |   1 txtend     000020 R   |   5 uart1_in   000178 R
  5 uart1_se   000188 R   |   5 ubound     0010E1 R   |   5 uflash     001B99 R
  5 unlock_e   0000C4 R   |   5 unlock_f   0000D2 R   |   5 until      001EDC R
  5 user_int   00004F R   |   5 user_spa   002500 R   |   5 usr        001B9F R
  1 vars       000028 R   |   5 wait       00144C R   |   5 warm_ini   00057B R
  5 warm_sta   000744 R   |   5 words      001DE5 R   |   5 write      001AF3 R
  5 write_bl   000155 R   |   5 write_by   0000E0 R   |   5 write_ee   00011C R
  5 write_ex   000150 R   |   5 write_fl   000106 R   |   5 xpeek      0014E9 R

ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 146.
Hexadecimal [24-Bits]

Area Table

   0 _CODE      size      0   flags    0
   1 DATA       size     5C   flags    0
   2 SSEG       size      0   flags    8
   3 SSEG0      size    118   flags    8
   4 HOME       size     80   flags    0
   5 CODE       size   250E   flags    0
   6 FLASH_DR   size      0   flags    8
   7 FLASH_DR   size      0   flags    8

