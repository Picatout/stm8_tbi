ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 1.
Hexadecimal [24-Bits]



                                      1 ;;
                                      2 ; Copyright Jacques Deschênes 2019,2020 
                                      3 ; This file is part of PABasic 
                                      4 ;
                                      5 ;     PABasic is free software: you can redistribute it and/or modify
                                      6 ;     it under the terms of the GNU General Public License as published by
                                      7 ;     the Free Software Foundation, either version 3 of the License, or
                                      8 ;     (at your option) any later version.
                                      9 ;
                                     10 ;     PABasic is distributed in the hope that it will be useful,
                                     11 ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                     12 ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                     13 ;     GNU General Public License for more details.
                                     14 ;
                                     15 ;     You should have received a copy of the GNU General Public License
                                     16 ;     along with PABasic.  If not, see <http://www.gnu.org/licenses/>.
                                     17 ;;
                                     18 ;--------------------------------------
                                     19 ;   Implementation of Tiny BASIC
                                     20 ;   REF: https://en.wikipedia.org/wiki/Li-Chen_Wang#Palo_Alto_Tiny_BASIC
                                     21 ;   Palo Alto BASIC is 4th version of TinyBasic
                                     22 ;   DATE: 2019-12-17
                                     23 ;
                                     24 ;--------------------------------------------------
                                     25 
                                     26     .module TBI_STM8
                                     27 
                                        	.include "inc/nucleo_8s208.inc"
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of MONA 
                                        ;
                                        ;     MONA is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     MONA is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with MONA.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ; NUCLEO-8S208RB board specific definitions
                                        ; Date: 2019/10/29
                                        ; author: Jacques Deschênes, copyright 2018,2019
                                        ; licence: GPLv3
                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        
                                        ; mcu on board is stm8s208rbt6
                                        
                                        ; crystal on board is 8Mhz
                                 
                                        
                                        ; LED2 is user LED
                                        ; connected to PC5 via Q2 -> 2N7002 MOSFET
                                 
                                 
                                 
                                        
                                        ; B1 on schematic is user button
                                        ; connected to PE4
                                        ; external pullup resistor R6 4k7 and debounce capacitor C5 100nF
                                 
                                 
                                 
                                        
                                        
                                        	.include "inc/stm8s208.inc"
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of MONA 
                                        ;
                                        ;     MONA is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     MONA is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with MONA.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        ; 2019/10/18
                                        ; STM8S208RB µC registers map
                                        ; sdas source file
                                        ; author: Jacques Deschênes, copyright 2018,2019
                                        ; licence: GPLv3
                                        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                        	.module stm8s208rb
                                        
                                        ;;;;;;;;;;;;
                                        ; bits
                                        ;;;;;;;;;;;;
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                         	
                                        ;;;;;;;;;;;;
                                        ; bits masks
                                        ;;;;;;;;;;;;
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; HSI oscillator frequency 16Mhz
                                 
                                        ; LSI oscillator frequency 128Khz
                                 
                                        
                                        ; controller memory regions
                                 
                                 
                                        ; STM8S208RB have 128K flash
                                 
                                        ; erase block size 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; options bytes
                                        ; this one can be programmed only from SWIM  (ICP)
                                 
                                        ; these can be programmed at runtime (IAP)
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; option registers usage
                                        ; read out protection, value 0xAA enable ROP
                                 
                                        ; user boot code, {0..0x3e} 512 bytes row
                                 
                                 
                                        ; alternate function register
                                 
                                 
                                        ; miscelinous options
                                 
                                 
                                        ; clock options
                                 
                                 
                                        ; HSE clock startup delay
                                 
                                 
                                        ; flash wait state
                                 
                                 
                                        
                                        ; watchdog options bits
                                 
                                 
                                 
                                 
                                        ; NWDGOPT bits
                                 
                                 
                                 
                                 
                                        
                                        ; CLKOPT bits
                                 
                                 
                                 
                                 
                                        
                                        ; AFR option, remapable functions
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; device ID = (read only)
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        
                                 
                                 
                                        ; PORTS SFR OFFSET
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; GPIO
                                        ; gpio register offset to base
                                 
                                 
                                 
                                 
                                 
                                 
                                         
                                        ; port A
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port B
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port C
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port D
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port E
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port F
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port G
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port H not present on LQFP48/LQFP64 package
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; port I ; only bit 0 on LQFP64 package, not present on LQFP48
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; input modes CR1
                                 
                                 
                                        ; output mode CR1
                                 
                                 
                                        ; input modes CR2
                                 
                                 
                                        ; output speed CR2
                                 
                                 
                                        
                                        
                                        ; Flash memory
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; data memory unlock keys
                                 
                                 
                                        ; flash memory unlock keys
                                 
                                 
                                        ; FLASH_CR1 bits
                                 
                                 
                                 
                                 
                                        ; FLASH_CR2 bits
                                 
                                 
                                 
                                 
                                 
                                        ; FLASH_FPR bits
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; FLASH_NFPR bits
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; FLASH_IAPSR bits
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Interrupt control
                                 
                                 
                                        
                                        ; Reset Status
                                 
                                        
                                        ; Clock Registers
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Peripherals clock gating
                                        ; CLK_PCKENR1 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        ; CLK_PCKENR2
                                 
                                 
                                 
                                        
                                        ; Clock bits
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                        ; clock source
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Watchdog
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                         
                                 
                                 
                                 
                                 
                                        
                                        
                                        
                                        ; Beeper
                                        ; beeper output is alternate function AFR7 on PD4
                                        ; connected to CN9-6
                                 
                                 
                                 
                                 
                                        
                                        ; SPI
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; SPI_CR1 bit fields 
                                 
                                 
                                 
                                 
                                 
                                 
                                          
                                        ; SPI_CR2 bit fields 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; SPI_SR bit fields 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; I2C
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                        
                                        ; Precalculated values, all in KHz
                                 
                                 
                                        ;
                                        ; Fast I2C mode max rise time = 300ns
                                        ; I2C_FREQR = 16 = (MHz) => tMASTER = 1/16 = 62.5 ns
                                        ; TRISER = = (300/62.5) + 1 = floor(4.8) + 1 = 5.
                                        
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                        ;
                                        ; Standard I2C mode max rise time = 1000ns
                                        ; I2C_FREQR = 16 = (MHz) => tMASTER = 1/16 = 62.5 ns
                                        ; TRISER = = (1000/62.5) + 1 = floor(16) + 1 = 17.
                                        
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                        
                                        ; baudrate constant for brr_value table access
                                        ; to be used by uart_init 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; UART registers offset from
                                        ; base address 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; uart identifier
                                        ; to be used by uart_init
                                 
                                 
                                        
                                        ; pins used by uart 
                                 
                                 
                                 
                                 
                                        ; uart port base address 
                                 
                                 
                                        
                                        ; UART1 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; UART3
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; UART Status Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Uart Control Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        ; LIN mode config register
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; TIMERS
                                        ; Timer 1 - 16-bit timer with complementary PWM outputs
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Control Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Slave Mode Control bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer External Trigger Enable bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Interrupt Enable bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Status Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                        
                                        ; Timer Event Generation Register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 1 - channel configured in output
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 1 - channel configured in input
                                 
                                 
                                 
                                 
                                 
                                 
                                        ;  TIM1_CCMR1_CC1S1 = (1)
                                 
                                        
                                        ; Capture/Compare Mode Register 2 - channel configured in output
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 2 - channel configured in input
                                 
                                 
                                 
                                 
                                 
                                 
                                        ;  TIM1_CCMR2_CC2S1 = (1)
                                 
                                        
                                        ; Capture/Compare Mode Register 3 - channel configured in output
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 3 - channel configured in input
                                 
                                 
                                 
                                 
                                 
                                 
                                        ;  TIM1_CCMR3_CC3S1 = (1)
                                 
                                        
                                        ; Capture/Compare Mode Register 4 - channel configured in output
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Capture/Compare Mode Register 4 - channel configured in input
                                 
                                 
                                 
                                 
                                 
                                 
                                        ;  TIM1_CCMR4_CC4S1 = (1)
                                 
                                        
                                        ; Timer 2 - 16-bit timer
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; TIM2_CR1 bitfields
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; TIMER2_CCMR bitfields 
                                 
                                 
                                 
                                        
                                        ; TIMER2_CCER1 bitfields
                                 
                                 
                                 
                                 
                                        
                                        ; TIMER2_EGR bitfields
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer 3
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; TIM3_CR1  fields
                                 
                                 
                                 
                                 
                                 
                                        ; TIM3_CCR2  fields
                                 
                                 
                                 
                                        ; TIM3_CCER1 fields
                                 
                                 
                                 
                                 
                                        ; TIM3_CCER2 fields
                                 
                                 
                                        
                                        ; Timer 4
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Timer 4 bitmasks
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                        
                                 
                                        
                                 
                                        
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; ADC2
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                         
                                        ; ADC bitmasks
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                        
                                        ; beCAN
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        
                                        ; CPU
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; global configuration register
                                 
                                 
                                 
                                        
                                        ; interrupt control registers
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; SWIM, control and status register
                                 
                                        ; debug registers
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Interrupt Numbers
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Interrupt Vectors
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ; Condition code register bits
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        	.include "inc/ascii.inc"
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of MONA 
                                        ;
                                        ;     MONA is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     MONA is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with MONA.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        
                                        ;-------------------------------------------------------
                                        ;     ASCII control  values
                                        ;     CTRL_x   are VT100 keyboard values  
                                        ;-------------------------------------------------------
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                        
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        	.include "inc/gen_macros.inc" 
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of STM8_NUCLEO 
                                        ;
                                        ;     STM8_NUCLEO is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     STM8_NUCLEO is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with STM8_NUCLEO.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        ;--------------------------------------
                                        ;   console Input/Output module
                                        ;   DATE: 2019-12-11
                                        ;    
                                        ;   General usage macros.   
                                        ;
                                        ;--------------------------------------
                                        
                                            ; reserve space on stack
                                            ; for local variabls
                                            .macro _vars n 
                                            
                                            ; free space on stack
                                            .macro _drop n 
                                        
                                            ; declare ARG_OFS for arguments 
                                            ; displacement on stack. This 
                                            ; value depend on local variables 
                                            ; size.
                                            .macro _argofs n 
                                        
                                            ; declare a function argument 
                                            ; position relative to stack pointer 
                                            ; _argofs must be called before it.
                                            .macro _arg name ofs 
                                        	.include "pab_macros.inc" 
                                        ;;
                                        ; Copyright Jacques Deschênes 2019 
                                        ; This file is part of STM8_NUCLEO 
                                        ;
                                        ;     STM8_NUCLEO is free software: you can redistribute it and/or modify
                                        ;     it under the terms of the GNU General Public License as published by
                                        ;     the Free Software Foundation, either version 3 of the License, or
                                        ;     (at your option) any later version.
                                        ;
                                        ;     STM8_NUCLEO is distributed in the hope that it will be useful,
                                        ;     but WITHOUT ANY WARRANTY; without even the implied warranty of
                                        ;     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
                                        ;     GNU General Public License for more details.
                                        ;
                                        ;     You should have received a copy of the GNU General Public License
                                        ;     along with STM8_NUCLEO.  If not, see <http://www.gnu.org/licenses/>.
                                        ;;
                                        ;--------------------------------------
                                 
                                 
                                                ; keyword types 
                                 
                                 
                                 
                                 
                                        
                                        ;--------------------------------------
                                        ;   constantes related to Arduino 
                                        ;   API mapping 
                                        ;-------------------------------------
                                 
                                 
                                        
                                        ;--------------------------------------
                                        ;       token attribute
                                        ;--------------------------------------
                                                ; bits 4:5 identify token group 
                                                ; 0x0n -> miscelinous 
                                                ; 0x1n -> +|- operators 
                                                ; 0x2n -> *|/|% operators
                                                ; 0x3n -> relational operators 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                                ; don't change these token values 
                                                ; values chosen to be used as a mask.
                                                ; bits 7:6  always 0 
                                                ; bits 5:4 identify group 
                                                ; bits 3:0 token identifier inside group  
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                        
                                        ;--------------------------------------
                                        ;   error codes 
                                        ;--------------------------------------
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                 
                                            
                                        ;--------------------------------------
                                        ;   assembler flags 
                                        ;-------------------------------------
                                 
                                        
                                        
                                            .macro _usec_dly n 
                                            
                                        ;---------------------------------------
                                        ;  data stack macros 
                                        ;---------------------------------------
                                 
                                        
                                            ; move dp up 1 element 
                                            .macro _dp_up 
                                        
                                            ;move dp down 1 element
                                            .macro _dp_down 
                                        
                                            ; load X register with 
                                            ; entry point of dictionary
                                            ; before calling 'search_dict'
                                            .macro _ldx_dict dict_name
                                        
                                        ;-------------------------------
                                        ;  macros used to help debugging
                                        ;-------------------------------
                                 
                                            .macro _dbg 
                                        
                                            .macro _nodbg
                                        
                                 
                                 
                                 
                                 
                                            .macro _dbg_save_regs 
                                        
                                            .macro _dbg_restore_regs 
                                        
                                            .macro _dbg_getc 
                                        
                                            .macro _dbg_putc 
                                        
                                            .macro _dbg_puts 
                                        
                                            .macro _dbg_prti24 
                                        
                                            .macro _dbg_prt_regs
                                        
                                            .macro _dbg_peek addr 
                                        
                                            .macro _dbg_parser_init 
                                        
                                            .macro _dbg_readln
                                        
                                            .macro _dbg_number
                                        
                                            .macro _dbg_nextword
                                        
                                            .macro _dbg_dots 
                                        
                                            .macro _dbg_trap
                                        
                                            .macro _dbg_mark n  
                                            
                                            .macro _dbg_prt_var var 
                                        
                                            .macro _dbg_show 
                                        
                                            ; software reset 
                                            .macro _swreset
                                     34     .list 
                                     35 
                                     36 ;_dbg 
                                     37 
                                     38 	
                                     39 ;--------------------------------------
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 2.
Hexadecimal [24-Bits]



                                     40     .area DATA 
                                     41 ;--------------------------------------	
                                     42 
                           000050    43 	TIB_SIZE=80
                           000028    44     PAD_SIZE=40
                           000020    45 	DSTACK_SIZE=32 
                           000080    46 	STACK_SIZE=128
                           0017FF    47 	STACK_EMPTY=RAM_SIZE-1  
                           000000    48 	FRUN=0 ; flags run code in variable flags
                           000001    49 	FTRAP=1 ; inside trap handler 
                           000002    50 	FLOOP=2 ; FOR loop in preparation 
                           000003    51 	FSLEEP=3 ; halt produit par la commande SLEEP 
                           000004    52 	FBREAK=4 ; break point flag 
                           000005    53 	FCOMP=5  ; compiling flags 
                                     54 
                           004000    55 	AUTORUN_NAME=0x4000 ; address in EEPROM where auto run file name is saved 
                                     56 
                           000006    57     FIRST_DATA_ITEM=6 ; first DATA item offset on line.
                                     58 
      000000                         59 in.w:  .blkb 1 ; parser position in text line
      000001                         60 in:    .blkb 1 ; low byte of in.w
      000002                         61 in.saved: .blkb 1 ; set by get_token before parsing next token, used by unget_token
      000003                         62 count: .blkb 1 ; current BASIC line length and tib text length  
      000004                         63 basicptr:  .blkb 2  ; point to current BASIC line address.
      000006                         64 data_ptr:  .blkw 1  ; point to DATA address
      000008                         65 data_ofs:  .blkb 1  ; index to next data item 
      000009                         66 data_len:  .blkb 1  ; length of data line 
      00000A                         67 base:  .blkb 1 ; nemeric base used to print integer 
      00000B                         68 acc24: .blkb 1 ; 24 bit accumulator
      00000C                         69 acc16: .blkb 1 ; 16 bit accumulator, middle byte of acc24
      00000D                         70 acc8:  .blkb 1 ;  8 bit accumulator, least byte of acc24 
      00000E                         71 ticks: .blkw 1 ; milliseconds ticks counter (see Timer4UpdateHandler)
      000010                         72 timer: .blkw 1 ;  milliseconds count down timer 
      000012                         73 seedx: .blkw 1  ; xorshift 16 seed x  used by RND() function 
      000014                         74 seedy: .blkw 1  ; xorshift 16 seed y  used by RND() funcion
      000016                         75 farptr: .blkb 1 ; 24 bits pointer used by file system
      000017                         76 ptr16:  .blkb 1 ; 16 bits pointer ,  middle byte of farptr
      000018                         77 ptr8:   .blkb 1 ; 8 bits pointer, least byte of farptr 
      000019                         78 ffree: .blkb 3 ; flash free address ; file system free space pointer
      00001C                         79 dstkptr: .blkw 1  ; data stack pointer 
      00001E                         80 txtbgn: .blkw 1 ; tokenized BASIC text beginning address 
      000020                         81 txtend: .blkw 1 ; tokenized BASIC text end address 
      000022                         82 loop_depth: .blkb 1 ; level of nested loop. Conformity check   
      000023                         83 array_size: .blkw 1 ; array size, free RAM left after BASIC code.  
      000025                         84 flags: .blkb 1 ; various boolean flags
      000026                         85 tab_width: .blkb 1 ; print colon width (4)
      000027                         86 rx_char: .blkb 1 ; last received character 
      000028                         87 vars: .blkw 26 ; BASIC variables A-Z, keep it as but last .
                                     88 ; keep as last variable 
      00005C                         89 free_ram: ; from here RAM free for BASIC text 
                                     90 
                                     91 ;-----------------------------------
                                     92     .area SSEG (ABS)
                                     93 ;-----------------------------------
                                     94 ;;;; working buffers and stacks at end of RAM. 	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 3.
Hexadecimal [24-Bits]



      0016E8                         95     .org RAM_SIZE-STACK_SIZE-TIB_SIZE-PAD_SIZE-DSTACK_SIZE 
      0016E8                         96 tib: .ds TIB_SIZE             ; transaction input buffer
      001738                         97 pad: .ds PAD_SIZE             ; working buffer
      001760                         98 dstack: .ds DSTACK_SIZE 	  ; data stack used by FOR...NEXT, and func/proc arguments  
      001780                         99 dstack_empty: ; dstack underflow ; data stack bottom 
      001780                        100 stack_full: .ds STACK_SIZE   ; control stack 
      001800                        101 stack_unf: ; stack underflow ; control_stack bottom 
                                    102 
                                    103 ;--------------------------------------
                                    104     .area HOME 
                                    105 ;--------------------------------------
      000000 82 00 04 D4            106     int cold_start			; RESET vector 
                           000000   107 .if DEBUG
                                    108 	int TrapHandler 		;TRAP  software interrupt
                           000001   109 .else
      000004 82 00 00 00            110 	int NonHandledInterrupt ;TRAP  software interrupt
                                    111 .endif
      000008 82 00 00 00            112 	int NonHandledInterrupt ;int0 TLI   external top level interrupt
      00000C 82 00 00 01            113 	int AWUHandler          ;int1 AWU   auto wake up from halt
      000010 82 00 00 00            114 	int NonHandledInterrupt ;int2 CLK   clock controller
      000014 82 00 00 00            115 	int NonHandledInterrupt ;int3 EXTI0 gpio A external interrupts
      000018 82 00 00 00            116 	int NonHandledInterrupt ;int4 EXTI1 gpio B external interrupts
      00001C 82 00 00 00            117 	int NonHandledInterrupt ;int5 EXTI2 gpio C external interrupts
      000020 82 00 00 00            118 	int NonHandledInterrupt ;int6 EXTI3 gpio D external interrupts
      000024 82 00 00 3C            119 	int UserButtonHandler   ;int7 EXTI4 gpio E external interrupts
      000028 82 00 00 00            120 	int NonHandledInterrupt ;int8 beCAN RX interrupt
      00002C 82 00 00 00            121 	int NonHandledInterrupt ;int9 beCAN TX/ER/SC interrupt
      000030 82 00 00 00            122 	int NonHandledInterrupt ;int10 SPI End of transfer
      000034 82 00 00 00            123 	int NonHandledInterrupt ;int11 TIM1 update/overflow/underflow/trigger/break
      000038 82 00 00 00            124 	int NonHandledInterrupt ;int12 TIM1 capture/compare
      00003C 82 00 00 00            125 	int NonHandledInterrupt ;int13 TIM2 update /overflow
      000040 82 00 00 00            126 	int NonHandledInterrupt ;int14 TIM2 capture/compare
      000044 82 00 00 00            127 	int NonHandledInterrupt ;int15 TIM3 Update/overflow
      000048 82 00 00 00            128 	int NonHandledInterrupt ;int16 TIM3 Capture/compare
      00004C 82 00 00 00            129 	int NonHandledInterrupt ;int17 UART1 TX completed
      000050 82 00 00 0F            130 	int Uart1RxHandler		;int18 UART1 RX full ; user communication channel.
      000054 82 00 00 00            131 	int NonHandledInterrupt ;int19 I2C 
      000058 82 00 00 00            132 	int NonHandledInterrupt ;int20 UART1 TX completed
      00005C 82 00 00 00            133 	int NonHandledInterrupt ;int21 UART1 RX full
      000060 82 00 00 00            134 	int NonHandledInterrupt ;int22 ADC2 end of conversion
      000064 82 00 00 26            135 	int Timer4UpdateHandler	;int23 TIM4 update/overflow ; used as msec ticks counter
      000068 82 00 00 00            136 	int NonHandledInterrupt ;int24 flash writing EOP/WR_PG_DIS
      00006C 82 00 00 00            137 	int NonHandledInterrupt ;int25  not used
      000070 82 00 00 00            138 	int NonHandledInterrupt ;int26  not used
      000074 82 00 00 00            139 	int NonHandledInterrupt ;int27  not used
      000078 82 00 00 00            140 	int NonHandledInterrupt ;int28  not used
      00007C 82 00 00 00            141 	int NonHandledInterrupt ;int29  not used
                                    142 
                                    143 ;---------------------------------------
                                    144     .area CODE
                                    145 ;---------------------------------------
                           000000   146 .if DEBUG
                                    147 .asciz "STM8_TBI" ; I like to put module name here.
                                    148 .endif 
                                    149 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 4.
Hexadecimal [24-Bits]



                                    150 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    151 ; non handled interrupt 
                                    152 ; reset MCU
                                    153 ;;;;;;;;;;;;;;;;;;;;;;;;;;;
      000000                        154 NonHandledInterrupt:
      000000 71                     155     .byte 0x71  ; invalid opcode reinitialize MCU
                                    156 
                                    157 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    158 ; auto wakeup from halt
                                    159 ; at iret, program continue 
                                    160 ; after hatl instruction
                                    161 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      000001                        162 AWUHandler:
      000001 72 19 50 F0      [ 1]  163 	bres AWU_CSR,#AWU_CSR_AWUEN
      000005 55 00 3F 50 F1   [ 1]  164 	mov AWU_APR,0x3F
      00000A 72 5F 50 F2      [ 1]  165 	clr AWU_TBR 
      00000E 80               [11]  166 	iret
                                    167 
                                    168 ;--------------------------
                                    169 ; UART1 receive character
                                    170 ; CTRL-C (ASCII 3)
                                    171 ; cancel program execution
                                    172 ; and fall back to command line
                                    173 ;--------------------------
      00000F                        174 Uart1RxHandler:
      00000F 72 0B 52 30 FB   [ 2]  175 	btjf UART1_SR,#UART_SR_RXNE,.
      000014 C6 52 31         [ 1]  176 	ld a,UART1_DR 
      000017 A1 03            [ 1]  177 	cp a,#CTRL_C 
      000019 26 07            [ 1]  178 	jrne 1$
      00001B 72 5F 00 27      [ 1]  179 	clr rx_char 
      00001F CC 00 4F         [ 2]  180 	jp user_interrupted
      000022                        181 1$:
      000022 C7 00 27         [ 1]  182 	ld rx_char,a 	
      000025 80               [11]  183 	iret 
                                    184 
                                    185 ;------------------------------------
                                    186 ; software interrupt handler  
                                    187 ;------------------------------------
                           000000   188 .if DEBUG 
                                    189 TrapHandler:
                                    190 	bset flags,#FTRAP 
                                    191 	call print_registers
                                    192 	call cmd_itf
                                    193 	bres flags,#FTRAP 	
                                    194 	iret
                                    195 .endif 
                                    196 
                                    197 ;------------------------------
                                    198 ; TIMER 4 is used to maintain 
                                    199 ; a milliseconds 'ticks' counter
                                    200 ; and decrement 'timer' varaiable
                                    201 ;--------------------------------
      000026                        202 Timer4UpdateHandler:
      000026 72 5F 53 42      [ 1]  203 	clr TIM4_SR 
      00002A CE 00 0E         [ 2]  204 	ldw x,ticks
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 5.
Hexadecimal [24-Bits]



      00002D 5C               [ 2]  205 	incw x
      00002E CF 00 0E         [ 2]  206 	ldw ticks,x 
      000031 CE 00 10         [ 2]  207 	ldw x,timer
      000034 5D               [ 2]  208 	tnzw x 
      000035 27 04            [ 1]  209 	jreq 1$
      000037 5A               [ 2]  210 	decw x 
      000038 CF 00 10         [ 2]  211 	ldw timer,x 
      00003B                        212 1$:	
      00003B 80               [11]  213 	iret 
                                    214 
                                    215 
                                    216 ;------------------------------------
                                    217 ; Triggered by pressing USER UserButton 
                                    218 ; on NUCLEO card.
                                    219 ; This is used to abort a progam lock 
                                    220 ; in infinite loop. 
                                    221 ;------------------------------------
      00003C                        222 UserButtonHandler:
                                    223 ; wait button release
      00003C 5F               [ 1]  224 	clrw x
      00003D 5A               [ 2]  225 1$: decw x 
      00003E 26 FD            [ 1]  226 	jrne 1$
      000040 72 09 50 15 F8   [ 2]  227 	btjf USR_BTN_PORT,#USR_BTN_BIT, 1$
                                    228 ; if MCU suspended by SLEEP resume program
      000045 72 07 00 25 05   [ 2]  229     btjf flags,#FSLEEP,2$
      00004A 72 17 00 25      [ 1]  230 	bres flags,#FSLEEP 
      00004E 80               [11]  231 	iret
      00004F                        232 2$:	
      00004F                        233 user_interrupted:
      00004F 72 00 00 25 02   [ 2]  234     btjt flags,#FRUN,4$
      000054 20 13            [ 2]  235 	jra UBTN_Handler_exit 
      000056                        236 4$:	; program interrupted by user 
      000056 72 11 00 25      [ 1]  237 	bres flags,#FRUN 
      00005A AE 00 71         [ 2]  238 	ldw x,#USER_ABORT
      00005D CD 01 C6         [ 4]  239 	call puts 
      000060 CE 00 04         [ 2]  240 	ldw x,basicptr 
      000063 C6 00 01         [ 1]  241 	ld a,in 
      000066 CD 12 46         [ 4]  242 	call prt_basic_line
      000069                        243 UBTN_Handler_exit:
      000069 AE 17 FF         [ 2]  244     ldw x,#STACK_EMPTY 
      00006C 94               [ 1]  245     ldw sp,x
      00006D 9A               [ 1]  246 	rim 
      00006E CC 07 55         [ 2]  247 	jp warm_start
                                    248 
      000071 0A 50 72 6F 67 72 61   249 USER_ABORT: .asciz "\nProgram aborted by user.\n"
             6D 20 61 62 6F 72 74
             65 64 20 62 79 20 75
             73 65 72 2E 0A 00
                                    250 
                                    251 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    252 ;    peripherals initialization
                                    253 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    254 
                                    255 ;----------------------------------------
                                    256 ; inialize MCU clock 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 6.
Hexadecimal [24-Bits]



                                    257 ; input:
                                    258 ;   A 		source  HSI | 1 HSE 
                                    259 ;   XL      CLK_CKDIVR , clock divisor 
                                    260 ; output:
                                    261 ;   none 
                                    262 ;----------------------------------------
      00008C                        263 clock_init:	
      00008C C1 50 C3         [ 1]  264 	cp a,CLK_CMSR 
      00008F 27 0C            [ 1]  265 	jreq 2$ ; no switching required 
                                    266 ; select clock source 
      000091 72 12 50 C5      [ 1]  267 	bset CLK_SWCR,#CLK_SWCR_SWEN
      000095 C7 50 C4         [ 1]  268 	ld CLK_SWR,a
      000098 C1 50 C3         [ 1]  269 1$:	cp a,CLK_CMSR
      00009B 26 FB            [ 1]  270 	jrne 1$
      00009D                        271 2$: 	
                                    272 ; HSI and cpu clock divisor 
      00009D 9F               [ 1]  273 	ld a,xl 
      00009E C7 50 C6         [ 1]  274 	ld CLK_CKDIVR,a  
      0000A1 81               [ 4]  275 	ret
                                    276 
                                    277 ;----------------------------------
                                    278 ; TIMER2 used as audio tone output 
                                    279 ; on port D:5.
                                    280 ; channel 1 configured as PWM mode 1 
                                    281 ;-----------------------------------  
                           00F424   282 TIM2_CLK_FREQ=62500
      0000A2                        283 timer2_init:
      0000A2 72 1A 50 C7      [ 1]  284 	bset CLK_PCKENR1,#CLK_PCKENR1_TIM2 ; enable TIMER2 clock 
      0000A6 35 60 53 05      [ 1]  285  	mov TIM2_CCMR1,#(6<<TIM2_CCMR_OCM) ; PWM mode 1 
      0000AA 35 08 53 0C      [ 1]  286 	mov TIM2_PSCR,#8 ; 16Mhz/256=62500
      0000AE 81               [ 4]  287 	ret 
                                    288 
                                    289 ;---------------------------------
                                    290 ; TIM4 is configured to generate an 
                                    291 ; interrupt every millisecond 
                                    292 ;----------------------------------
      0000AF                        293 timer4_init:
      0000AF 72 18 50 C7      [ 1]  294 	bset CLK_PCKENR1,#CLK_PCKENR1_TIM4
      0000B3 35 07 53 45      [ 1]  295 	mov TIM4_PSCR,#7 ; prescale 128  
      0000B7 35 7D 53 46      [ 1]  296 	mov TIM4_ARR,#125 ; set for 1msec.
      0000BB 35 05 53 40      [ 1]  297 	mov TIM4_CR1,#((1<<TIM4_CR1_CEN)|(1<<TIM4_CR1_URS))
      0000BF 72 10 53 41      [ 1]  298 	bset TIM4_IER,#TIM4_IER_UIE
      0000C3 81               [ 4]  299 	ret
                                    300 
                                    301 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    302 ;  routines to write to FLASH, EEPROM 
                                    303 ;  and OPTION 
                                    304 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    305 
                                    306 ;----------------------------------
                                    307 ; unlock EEPROM/OPT for writing/erasing
                                    308 ; wait endlessly for FLASH_IAPSR_DUL bit.
                                    309 ; input:
                                    310 ;  none
                                    311 ; output:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 7.
Hexadecimal [24-Bits]



                                    312 ;  none 
                                    313 ;----------------------------------
      0000C4                        314 unlock_eeprom:
      0000C4 35 AE 50 64      [ 1]  315 	mov FLASH_DUKR,#FLASH_DUKR_KEY1
      0000C8 35 56 50 64      [ 1]  316     mov FLASH_DUKR,#FLASH_DUKR_KEY2
      0000CC 72 07 50 5F FB   [ 2]  317 	btjf FLASH_IAPSR,#FLASH_IAPSR_DUL,.
      0000D1 81               [ 4]  318 	ret
                                    319 
                                    320 ;----------------------------------
                                    321 ; unlock FLASH for writing/erasing
                                    322 ; wait endlessly for FLASH_IAPSR_PUL bit.
                                    323 ; input:
                                    324 ;  none
                                    325 ; output:
                                    326 ;  none
                                    327 ;----------------------------------
      0000D2                        328 unlock_flash:
      0000D2 35 56 50 62      [ 1]  329 	mov FLASH_PUKR,#FLASH_PUKR_KEY1
      0000D6 35 AE 50 62      [ 1]  330 	mov FLASH_PUKR,#FLASH_PUKR_KEY2
      0000DA 72 03 50 5F FB   [ 2]  331 	btjf FLASH_IAPSR,#FLASH_IAPSR_PUL,.
      0000DF 81               [ 4]  332 	ret
                                    333 
                           000000   334 USE_BLOCK_ERASE=0 
                           000000   335 .if USE_BLOCK_ERASE 
                                    336 ; this code is copied to RAM 
                                    337 
                                    338 ;----------------------------
                                    339 ; erase block code must be 
                                    340 ; executed from RAM
                                    341 ;-----------------------------
                                    342 erase_start:
                                    343 	clr a 
                                    344     bset FLASH_CR2,#FLASH_CR2_ERASE
                                    345     bres FLASH_NCR2,#FLASH_CR2_ERASE
                                    346 	ldf [farptr],a
                                    347     inc farptr+2 
                                    348     ldf [farptr],a
                                    349     inc farptr+2 
                                    350     ldf [farptr],a
                                    351     inc farptr+2 
                                    352     ldf [farptr],a
                                    353 	btjf FLASH_IAPSR,#FLASH_IAPSR_EOP,.
                                    354 	ret
                                    355 erase_end:
                                    356 
                                    357 ; copy erase_start in RAM 
                                    358 move_code_in_ram:
                                    359 	ldw x,#erase_end 
                                    360 	subw x,#erase_start
                                    361 	ldw acc16,x 
                                    362 	ldw x,#pad 
                                    363 	ldw y,#erase_start 
                                    364 	call move 
                                    365 	ret 
                                    366 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 8.
Hexadecimal [24-Bits]



                                    367 ;-----------------------------------
                                    368 ; erase flash or EEPROM block 
                                    369 ; a block is 128 bytes 
                                    370 ; input:
                                    371 ;   farptr  address block begin
                                    372 ; output:
                                    373 ;   none
                                    374 ;--------------------------------------
                                    375 erase_block:
                                    376 	ldw x,farptr+1 
                                    377 	pushw x 
                                    378 	call move_code_in_ram 
                                    379 	popw x 
                                    380 	ldw farptr+1,x 
                                    381 	tnz farptr
                                    382 	jrne erase_flash 
                                    383 	ldw x,#FLASH_BASE 
                                    384 	cpw x,farptr+1 
                                    385 	jrpl erase_flash 
                                    386 ; erase eeprom block
                                    387 	call unlock_eeprom 
                                    388 	sim 
                                    389 	call pad   
                                    390 	bres FLASH_IAPSR,#FLASH_IAPSR_DUL
                                    391 	rim 
                                    392 	ret 
                                    393 ; erase flash block:
                                    394 erase_flash:
                                    395 	call unlock_flash 
                                    396 	bset FLASH_CR2,#FLASH_CR2_ERASE
                                    397 	bres FLASH_NCR2,#FLASH_CR2_ERASE
                                    398 	clr a 
                                    399 	sim 
                                    400 	call pad 
                                    401     bres FLASH_IAPSR,#FLASH_IAPSR_PUL
                                    402 	rim 
                                    403 	ret 
                                    404 .endif ;;;; USE_BLOCK_ERASE ;;;;
                                    405 
                                    406 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
                                    407 ; write a byte to FLASH or EEPROM/OPTION  
                                    408 ; input:
                                    409 ;    a  		byte to write
                                    410 ;    farptr  	address
                                    411 ;    x          farptr[x]
                                    412 ; output:
                                    413 ;    none
                                    414 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    415 	; variables locales
                           000001   416 	BTW = 1   ; byte to write offset on stack
                           000002   417 	OPT = 2   ; OPTION flag offset on stack
                           000002   418 	VSIZE = 2
      0000E0                        419 write_byte:
      0000E0 90 89            [ 2]  420 	pushw y
      0000E2                        421 	_vars VSIZE
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 9.
Hexadecimal [24-Bits]



      0000E2 52 02            [ 2]    1     sub sp,#VSIZE 
      0000E4 6B 01            [ 1]  422 	ld (BTW,sp),a ; byte to write 
      0000E6 0F 02            [ 1]  423 	clr (OPT,sp)  ; OPTION flag
                                    424 ; put addr[15:0] in Y, for bounds check.
      0000E8 90 CE 00 17      [ 2]  425 	ldw y,farptr+1   ; Y=addr15:0
                                    426 ; check addr[23:16], if <> 0 then it is extened flash memory
      0000EC 72 5D 00 16      [ 1]  427 	tnz farptr 
      0000F0 26 14            [ 1]  428 	jrne write_flash
      0000F2 90 A3 25 80      [ 2]  429     cpw y,#user_space
      0000F6 24 0E            [ 1]  430     jruge write_flash
      0000F8 90 A3 40 00      [ 2]  431 	cpw y,#EEPROM_BASE  
      0000FC 25 52            [ 1]  432     jrult write_exit
      0000FE 90 A3 48 7F      [ 2]  433 	cpw y,#OPTION_END 
      000102 22 4C            [ 1]  434 	jrugt write_exit
      000104 20 16            [ 2]  435 	jra write_eeprom 
                                    436 ; write program memory
      000106                        437 write_flash:
      000106 CD 00 D2         [ 4]  438 	call unlock_flash 
      000109 9B               [ 1]  439 1$:	sim 
      00010A 7B 01            [ 1]  440 	ld a,(BTW,sp)
      00010C 92 A7 00 16      [ 4]  441 	ldf ([farptr],x),a ; farptr[x]=A
      000110 72 05 50 5F FB   [ 2]  442 	btjf FLASH_IAPSR,#FLASH_IAPSR_EOP,.
      000115 9A               [ 1]  443     rim 
      000116 72 13 50 5F      [ 1]  444     bres FLASH_IAPSR,#FLASH_IAPSR_PUL
      00011A 20 34            [ 2]  445     jra write_exit
                                    446 ; write eeprom and option
      00011C                        447 write_eeprom:
      00011C CD 00 C4         [ 4]  448 	call unlock_eeprom
                                    449 	; check for data eeprom or option eeprom
      00011F 90 A3 48 00      [ 2]  450 	cpw y,#OPTION_BASE
      000123 2B 08            [ 1]  451 	jrmi 1$
      000125 90 A3 48 80      [ 2]  452 	cpw y,#OPTION_END+1
      000129 2A 02            [ 1]  453 	jrpl 1$
      00012B 03 02            [ 1]  454 	cpl (OPT,sp)
      00012D                        455 1$: 
      00012D 0D 02            [ 1]  456     tnz (OPT,sp)
      00012F 27 08            [ 1]  457     jreq 2$
                                    458 	; pour modifier une option il faut modifier ces 2 bits
      000131 72 1E 50 5B      [ 1]  459     bset FLASH_CR2,#FLASH_CR2_OPT
      000135 72 1F 50 5C      [ 1]  460     bres FLASH_NCR2,#FLASH_CR2_OPT 
      000139                        461 2$: 
      000139 7B 01            [ 1]  462     ld a,(BTW,sp)
      00013B 92 A7 00 16      [ 4]  463     ldf ([farptr],x),a
      00013F 0D 02            [ 1]  464     tnz (OPT,sp)
      000141 27 08            [ 1]  465     jreq 3$
      000143 5C               [ 2]  466     incw x
      000144 7B 01            [ 1]  467     ld a,(BTW,sp)
      000146 43               [ 1]  468     cpl a
      000147 92 A7 00 16      [ 4]  469     ldf ([farptr],x),a
      00014B 72 05 50 5F FB   [ 2]  470 3$: btjf FLASH_IAPSR,#FLASH_IAPSR_EOP,.
      000150                        471 write_exit:
      000150                        472 	_drop VSIZE 
      000150 5B 02            [ 2]    1     addw sp,#VSIZE 
      000152 90 85            [ 2]  473 	popw y
      000154 81               [ 4]  474     ret
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 10.
Hexadecimal [24-Bits]



                                    475 
                                    476 ;--------------------------------------------
                                    477 ; write a data block to eeprom or flash 
                                    478 ; input:
                                    479 ;   Y        source address   
                                    480 ;   X        array index  destination  farptr[x]
                                    481 ;   BSIZE    block size bytes 
                                    482 ;   farptr   write address , byte* 
                                    483 ; output:
                                    484 ;	X 		after last byte written 
                                    485 ;   Y 		after last byte read 
                                    486 ;  farptr   point after block
                                    487 ;---------------------------------------------
      000155                        488 	_argofs 2 
                           000004     1     ARG_OFS=2+2 
      000155                        489 	_arg BSIZE 1  ; block size
                           000005     1     BSIZE=ARG_OFS+1 
                                    490 	; local var 
                           000001   491 	XSAVE=1 
                           000002   492 	VSIZE=2 
      000155                        493 write_block:
      000155                        494 	_vars VSIZE
      000155 52 02            [ 2]    1     sub sp,#VSIZE 
      000157 1F 01            [ 2]  495 	ldw (XSAVE,sp),x 
      000159 1E 05            [ 2]  496 	ldw x,(BSIZE,sp) 
      00015B 27 13            [ 1]  497 	jreq 9$
      00015D 1E 01            [ 2]  498 1$:	ldw x,(XSAVE,sp)
      00015F 90 F6            [ 1]  499 	ld a,(y)
      000161 CD 00 E0         [ 4]  500 	call write_byte 
      000164 5C               [ 2]  501 	incw x 
      000165 90 5C            [ 2]  502 	incw y 
      000167 1F 01            [ 2]  503 	ldw (XSAVE,sp),x
      000169 1E 05            [ 2]  504 	ldw x,(BSIZE,sp)
      00016B 5A               [ 2]  505 	decw x
      00016C 1F 05            [ 2]  506 	ldw (BSIZE,sp),x 
      00016E 26 ED            [ 1]  507 	jrne 1$
      000170                        508 9$:
      000170 1E 01            [ 2]  509 	ldw x,(XSAVE,sp)
      000172 CD 18 E9         [ 4]  510 	call incr_farptr
      000175                        511 	_drop VSIZE
      000175 5B 02            [ 2]    1     addw sp,#VSIZE 
      000177 81               [ 4]  512 	ret 
                                    513 
                                    514 
                                    515 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    516 ;;   UART1 subroutines
                                    517 ;;   used for user interface 
                                    518 ;;   communication channel.
                                    519 ;;   settings: 
                                    520 ;;		115200 8N1 no flow control
                                    521 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                    522 
                                    523 ;---------------------------------------------
                                    524 ; initialize UART1, 115200 8N1
                                    525 ; input:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 11.
Hexadecimal [24-Bits]



                                    526 ;	none
                                    527 ; output:
                                    528 ;   none
                                    529 ;---------------------------------------------
      000178                        530 uart1_init:
      000178 72 1A 50 02      [ 1]  531     bset PA_DDR,#UART1_TX_PIN
      00017C 72 1A 50 03      [ 1]  532     bset PA_CR1,#UART1_TX_PIN 
      000180 72 1A 50 04      [ 1]  533     bset PA_CR2,#UART1_TX_PIN 
                                    534 ; enable UART1 clock
      000184 72 14 50 C7      [ 1]  535 	bset CLK_PCKENR1,#CLK_PCKENR1_UART1	
      000188                        536 uart1_set_baud: 
                                    537 ; baud rate 115200 Fmaster=8Mhz  8000000/115200=69=0x45
                                    538 ; 1) check clock source, HSI at 16Mhz or HSE at 8Mhz  
      000188 A6 E1            [ 1]  539 	ld a,#CLK_SWR_HSI
      00018A C1 50 C3         [ 1]  540 	cp a,CLK_CMSR 
      00018D 27 0A            [ 1]  541 	jreq 2$ 
      00018F                        542 1$: ; 8 Mhz 	
      00018F 35 05 52 33      [ 1]  543 	mov UART1_BRR2,#0x05 ; must be loaded first
      000193 35 04 52 32      [ 1]  544 	mov UART1_BRR1,#0x4
      000197 20 08            [ 2]  545 	jra 3$
      000199                        546 2$: ; 16 Mhz 	
      000199 35 0B 52 33      [ 1]  547 	mov UART1_BRR2,#0x0b ; must be loaded first
      00019D 35 08 52 32      [ 1]  548 	mov UART1_BRR1,#0x08
      0001A1                        549 3$:
      0001A1 72 5F 52 31      [ 1]  550     clr UART1_DR
      0001A5 35 2C 52 35      [ 1]  551 	mov UART1_CR2,#((1<<UART_CR2_TEN)|(1<<UART_CR2_REN)|(1<<UART_CR2_RIEN));
      0001A9 72 10 52 35      [ 1]  552 	bset UART1_CR2,#UART_CR2_SBK
      0001AD 72 0D 52 30 FB   [ 2]  553     btjf UART1_SR,#UART_SR_TC,.
      0001B2 81               [ 4]  554     ret
                                    555 
                                    556 ;---------------------------------
                                    557 ; send character to UART1 
                                    558 ; input:
                                    559 ;   A 
                                    560 ; output:
                                    561 ;   none 
                                    562 ;--------------------------------	
      0001B3                        563 putc:
      0001B3 72 0F 52 30 FB   [ 2]  564 	btjf UART1_SR,#UART_SR_TXE,.
      0001B8 C7 52 31         [ 1]  565 	ld UART1_DR,a 
      0001BB 81               [ 4]  566 	ret 
                                    567 
                                    568 ;---------------------------------
                                    569 ; wait character from UART1 
                                    570 ; input:
                                    571 ;   none
                                    572 ; output:
                                    573 ;   A 			char  
                                    574 ;--------------------------------	
      0001BC                        575 getc:
      0001BC C6 00 27         [ 1]  576 	ld a,rx_char 
      0001BF 27 FB            [ 1]  577 	jreq getc 
      0001C1 72 5F 00 27      [ 1]  578 	clr rx_char 
      0001C5 81               [ 4]  579 	ret 
                                    580 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 12.
Hexadecimal [24-Bits]



                                    581 ;-----------------------------
                                    582 ; send an ASCIZ string to UART1 
                                    583 ; input: 
                                    584 ;   x 		char * 
                                    585 ; output:
                                    586 ;   none 
                                    587 ;-------------------------------
      0001C6                        588 puts:
      0001C6 F6               [ 1]  589     ld a,(x)
      0001C7 27 06            [ 1]  590 	jreq 1$
      0001C9 CD 01 B3         [ 4]  591 	call putc 
      0001CC 5C               [ 2]  592 	incw x 
      0001CD 20 F7            [ 2]  593 	jra puts 
      0001CF 81               [ 4]  594 1$:	ret 
                                    595 
                                    596 
                                    597 ;---------------------------
                                    598 ; delete character at left 
                                    599 ; of cursor on terminal 
                                    600 ; input:
                                    601 ;   none 
                                    602 ; output:
                                    603 ;	none 
                                    604 ;---------------------------
      0001D0                        605 bksp:
      0001D0 A6 08            [ 1]  606 	ld a,#BSP 
      0001D2 CD 01 B3         [ 4]  607 	call putc 
      0001D5 A6 20            [ 1]  608 	ld a,#SPACE 
      0001D7 CD 01 B3         [ 4]  609 	call putc 
      0001DA A6 08            [ 1]  610 	ld a,#BSP 
      0001DC CD 01 B3         [ 4]  611 	call putc 
      0001DF 81               [ 4]  612 	ret 
                                    613 ;---------------------------
                                    614 ; delete n character left of cursor 
                                    615 ; at terminal.
                                    616 ; input: 
                                    617 ;   A   number of characters to delete.
                                    618 ; output:
                                    619 ;    none 
                                    620 ;--------------------------	
      0001E0                        621 delete:
      0001E0 88               [ 1]  622 	push a 
      0001E1 0D 01            [ 1]  623 0$:	tnz (1,sp)
      0001E3 27 07            [ 1]  624 	jreq 1$
      0001E5 CD 01 D0         [ 4]  625 	call bksp 
      0001E8 0A 01            [ 1]  626 	dec (1,sp)
      0001EA 20 F5            [ 2]  627 	jra 0$
      0001EC 84               [ 1]  628 1$:	pop a 
      0001ED 81               [ 4]  629 	ret
                                    630 
                                    631 ;--------------------------
                                    632 ; print n spaces on terminal
                                    633 ; input:
                                    634 ;  X 		number of spaces 
                                    635 ; output:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 13.
Hexadecimal [24-Bits]



                                    636 ;	none 
                                    637 ;---------------------------
      0001EE                        638 spaces:
      0001EE A6 20            [ 1]  639 	ld a,#SPACE 
      0001F0 5D               [ 2]  640 1$:	tnzw x
      0001F1 27 06            [ 1]  641 	jreq 9$
      0001F3 CD 01 B3         [ 4]  642 	call putc 
      0001F6 5A               [ 2]  643 	decw x
      0001F7 20 F7            [ 2]  644 	jra 1$
      0001F9                        645 9$: 
      0001F9 81               [ 4]  646 	ret 
                                    647 
                           000000   648 .if DEBUG 
                                    649 ;---------------------------------
                                    650 ;; print actual registers states 
                                    651 ;; as pushed on stack 
                                    652 ;; {Y,X,CC,A}
                                    653 ;---------------------------------
                                    654 	_argofs 0  
                                    655 	_arg R_Y 1 
                                    656 	_arg R_X 3
                                    657 	_arg R_A 5
                                    658 	_arg R_CC 6
                                    659 prt_regs:
                                    660 	ldw x,#regs_state 
                                    661 	call puts
                                    662 ; register PC
                                    663 	ldw y,(1,sp)
                                    664 	ldw x,#REG_EPC 
                                    665 	call prt_reg16 
                                    666 ; register CC 
                                    667 	ld a,(R_CC,sp)
                                    668 	ldw x,#REG_CC 
                                    669 	call prt_reg8 
                                    670 ; register A 
                                    671 	ld a,(R_A,sp)
                                    672 	ldw x,#REG_A 
                                    673 	call prt_reg8 
                                    674 ; register X 
                                    675 	ldw y,(R_X,sp)
                                    676 	ldw x,#REG_X 
                                    677 	call prt_reg16 
                                    678 ; register Y 
                                    679 	ldw y,(R_Y,sp)
                                    680 	ldw x,#REG_Y 
                                    681 	call prt_reg16 
                                    682 ; register SP 
                                    683 	ldw y,sp
                                    684 	addw y,#6+ARG_OFS  
                                    685 	ldw x,#REG_SP
                                    686 	call prt_reg16
                                    687 	ld a,#CR 
                                    688 	call putc
                                    689 	call putc   
                                    690 	ret 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 14.
Hexadecimal [24-Bits]



                                    691 
                                    692 regs_state: .asciz "\nregisters state\n--------------------\n"
                                    693 
                                    694 
                                    695 ;--------------------
                                    696 ; print content at address in hex.
                                    697 ; input:
                                    698 ;   X 	address to peek 
                                    699 ; output:
                                    700 ;	none 
                                    701 ;--------------------	
                                    702 prt_peek:
                                    703 	pushw x 
                                    704 	ldw acc16,x 
                                    705 	clr acc24 
                                    706 	clrw x 
                                    707 	ld a,#16 
                                    708 	call prti24 
                                    709 	ld a,#': 
                                    710 	call putc 
                                    711 	ld a,#SPACE 
                                    712 	call putc 
                                    713 	popw x 
                                    714 	ld a,(x)
                                    715 	ld acc8,a 
                                    716 	clrw x 
                                    717 	ld a,#16 
                                    718 	call prti24
                                    719 	ret 
                                    720 .endif ; DEBUG  
                                    721 
                                    722 ;-------------------------------------
                                    723 ; retrun string length
                                    724 ; input:
                                    725 ;   X         .asciz  pointer 
                                    726 ; output:
                                    727 ;   X         length 
                                    728 ;-------------------------------------
      0001FA                        729 strlen:
      0001FA 90 93            [ 1]  730 	ldw y,x 
      0001FC 5F               [ 1]  731 	clrw x 
      0001FD 90 7D            [ 1]  732 1$:	tnz (y) 
      0001FF 27 05            [ 1]  733 	jreq 9$ 
      000201 5C               [ 2]  734 	incw x
      000202 90 5C            [ 2]  735 	incw y 
      000204 20 F7            [ 2]  736 	jra 1$ 
      000206 81               [ 4]  737 9$: ret 
                                    738 
                                    739 ;------------------------------------
                                    740 ; compare 2 strings
                                    741 ; input:
                                    742 ;   X 		char* first string 
                                    743 ;   Y       char* second string 
                                    744 ; output:
                                    745 ;   A 		0|1 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 15.
Hexadecimal [24-Bits]



                                    746 ;-------------------------------------
      000207                        747 strcmp:
      000207 F6               [ 1]  748 	ld a,(x)
      000208 27 0B            [ 1]  749 	jreq 5$ 
      00020A 90 F1            [ 1]  750 	cp a,(y) 
      00020C 26 05            [ 1]  751 	jrne 4$ 
      00020E 5C               [ 2]  752 	incw x 
      00020F 90 5C            [ 2]  753 	incw y 
      000211 20 F4            [ 2]  754 	jra strcmp 
      000213                        755 4$: ; not same  
      000213 4F               [ 1]  756 	clr a 
      000214 81               [ 4]  757 	ret 
      000215                        758 5$: ; same 
      000215 A6 01            [ 1]  759 	ld a,#1 
      000217 81               [ 4]  760 	ret 
                                    761 
                                    762 
                                    763 ;---------------------------------------
                                    764 ;  copy src to dest 
                                    765 ; input:
                                    766 ;   X 		dest 
                                    767 ;   Y 		src 
                                    768 ; output: 
                                    769 ;   X 		dest 
                                    770 ;----------------------------------
      000218                        771 strcpy:
      000218 89               [ 2]  772 	pushw x 
      000219 90 F6            [ 1]  773 1$: ld a,(y)
      00021B 27 06            [ 1]  774 	jreq 9$ 
      00021D F7               [ 1]  775 	ld (x),a 
      00021E 5C               [ 2]  776 	incw x 
      00021F 90 5C            [ 2]  777 	incw y 
      000221 20 F6            [ 2]  778 	jra 1$ 
      000223 7F               [ 1]  779 9$:	clr (x)
      000224 85               [ 2]  780 	popw x 
      000225 81               [ 4]  781 	ret 
                                    782 
                                    783 ;---------------------------------------
                                    784 ; move memory block 
                                    785 ; input:
                                    786 ;   X 		destination 
                                    787 ;   Y 	    source 
                                    788 ;   acc16	bytes count 
                                    789 ; output:
                                    790 ;   none 
                                    791 ;--------------------------------------
                           000001   792 	INCR=1 ; increament high byte 
                           000002   793 	LB=2 ; increament low byte 
                           000002   794 	VSIZE=2
      000226                        795 move:
      000226                        796 	_vars VSIZE 
      000226 52 02            [ 2]    1     sub sp,#VSIZE 
      000228 0F 01            [ 1]  797 	clr (INCR,sp)
      00022A 0F 02            [ 1]  798 	clr (LB,sp)
      00022C 90 89            [ 2]  799 	pushw y 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 16.
Hexadecimal [24-Bits]



      00022E 13 01            [ 2]  800 	cpw x,(1,sp) ; compare DEST to SRC 
      000230 90 85            [ 2]  801 	popw y 
      000232 27 31            [ 1]  802 	jreq move_exit ; x==y 
      000234 2B 0E            [ 1]  803 	jrmi move_down
      000236                        804 move_up: ; start from top address with incr=-1
      000236 72 BB 00 0C      [ 2]  805 	addw x,acc16
      00023A 72 B9 00 0C      [ 2]  806 	addw y,acc16
      00023E 03 01            [ 1]  807 	cpl (INCR,sp)
      000240 03 02            [ 1]  808 	cpl (LB,sp)   ; increment = -1 
      000242 20 05            [ 2]  809 	jra move_loop  
      000244                        810 move_down: ; start from bottom address with incr=1 
      000244 5A               [ 2]  811     decw x 
      000245 90 5A            [ 2]  812 	decw y
      000247 0C 02            [ 1]  813 	inc (LB,sp) ; incr=1 
      000249                        814 move_loop:	
      000249 C6 00 0C         [ 1]  815     ld a, acc16 
      00024C CA 00 0D         [ 1]  816 	or a, acc8
      00024F 27 14            [ 1]  817 	jreq move_exit 
      000251 72 FB 01         [ 2]  818 	addw x,(INCR,sp)
      000254 72 F9 01         [ 2]  819 	addw y,(INCR,sp) 
      000257 90 F6            [ 1]  820 	ld a,(y)
      000259 F7               [ 1]  821 	ld (x),a 
      00025A 89               [ 2]  822 	pushw x 
      00025B CE 00 0C         [ 2]  823 	ldw x,acc16 
      00025E 5A               [ 2]  824 	decw x 
      00025F CF 00 0C         [ 2]  825 	ldw acc16,x 
      000262 85               [ 2]  826 	popw x 
      000263 20 E4            [ 2]  827 	jra move_loop
      000265                        828 move_exit:
      000265                        829 	_drop VSIZE
      000265 5B 02            [ 2]    1     addw sp,#VSIZE 
      000267 81               [ 4]  830 	ret 	
                                    831 
                                    832 ;-------------------------------------
                                    833 ; search text area for a line with 
                                    834 ; same number as line#  
                                    835 ; input:
                                    836 ;	X 			line# 
                                    837 ; output:
                                    838 ;   X 			addr of line | 0 
                                    839 ;   Y           line#|insert address if not found  
                                    840 ;-------------------------------------
                           000001   841 	LL=1 ; line length 
                           000002   842 	LB=2 ; line length low byte 
                           000002   843 	VSIZE=2 
      000268                        844 search_lineno:
      000268                        845 	_vars VSIZE
      000268 52 02            [ 2]    1     sub sp,#VSIZE 
      00026A 0F 01            [ 1]  846 	clr (LL,sp)
      00026C 90 CE 00 1E      [ 2]  847 	ldw y,txtbgn
      000270                        848 search_ln_loop:
      000270 90 C3 00 20      [ 2]  849 	cpw y,txtend 
      000274 2A 10            [ 1]  850 	jrpl 8$
      000276 90 F3            [ 1]  851 	cpw x,(y)
      000278 27 0E            [ 1]  852 	jreq 9$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 17.
Hexadecimal [24-Bits]



      00027A 2B 0A            [ 1]  853 	jrmi 8$ 
      00027C 90 E6 02         [ 1]  854 	ld a,(2,y)
      00027F 6B 02            [ 1]  855 	ld (LB,sp),a 
      000281 72 F9 01         [ 2]  856 	addw y,(LL,sp)
      000284 20 EA            [ 2]  857 	jra search_ln_loop 
      000286                        858 8$: 
      000286 5F               [ 1]  859 	clrw x 	
      000287 51               [ 1]  860 	exgw x,y 
      000288                        861 9$: _drop VSIZE
      000288 5B 02            [ 2]    1     addw sp,#VSIZE 
      00028A 51               [ 1]  862 	exgw x,y   
      00028B 81               [ 4]  863 	ret 
                                    864 
                                    865 ;-------------------------------------
                                    866 ; delete line at addr
                                    867 ; move new line to insert with end of text 
                                    868 ; otherwise it would be overwritten.
                                    869 ; input:
                                    870 ;   X 		addr of line i.e DEST for move 
                                    871 ;-------------------------------------
                           000001   872 	LLEN=1
                           000003   873 	SRC=3
                           000004   874 	VSIZE=4
      00028C                        875 del_line: 
      00028C                        876 	_vars VSIZE 
      00028C 52 04            [ 2]    1     sub sp,#VSIZE 
      00028E E6 02            [ 1]  877 	ld a,(2,x) ; line length
      000290 6B 02            [ 1]  878 	ld (LLEN+1,sp),a 
      000292 0F 01            [ 1]  879 	clr (LLEN,sp)
      000294 90 93            [ 1]  880 	ldw y,x  
      000296 72 F9 01         [ 2]  881 	addw y,(LLEN,sp) ;SRC  
      000299 17 03            [ 2]  882 	ldw (SRC,sp),y  ;save source 
      00029B 90 CE 00 20      [ 2]  883 	ldw y,txtend 
      00029F 90 E6 02         [ 1]  884 	ld a,(2,y)
      0002A2 90 5F            [ 1]  885 	clrw y 
      0002A4 90 97            [ 1]  886 	ld yl,a  
      0002A6 72 B9 00 20      [ 2]  887 	addw y,txtend
      0002AA 72 F2 03         [ 2]  888 	subw y,(SRC,sp) ; y=count 
      0002AD 90 CF 00 0C      [ 2]  889 	ldw acc16,y 
      0002B1 16 03            [ 2]  890 	ldw y,(SRC,sp)    ; source
      0002B3 CD 02 26         [ 4]  891 	call move
      0002B6 90 CE 00 20      [ 2]  892 	ldw y,txtend 
      0002BA 72 F2 01         [ 2]  893 	subw y,(LLEN,sp)
      0002BD 90 CF 00 20      [ 2]  894 	ldw txtend,y  
      0002C1                        895 	_drop VSIZE     
      0002C1 5B 04            [ 2]    1     addw sp,#VSIZE 
      0002C3 81               [ 4]  896 	ret 
                                    897 
                                    898 ;---------------------------------------------
                                    899 ; create a gap in text area 
                                    900 ; move new line to insert in gap with end of text
                                    901 ; otherwise it would be overwritten.
                                    902 ; input:
                                    903 ;    X 			addr gap start 
                                    904 ;    Y 			gap length 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 18.
Hexadecimal [24-Bits]



                                    905 ; output:
                                    906 ;    X 			addr gap start 
                                    907 ;--------------------------------------------
                           000001   908 	DEST=1
                           000003   909 	SRC=3
                           000005   910 	LEN=5
                           000006   911 	VSIZE=6 
      0002C4                        912 create_gap:
      0002C4                        913 	_vars VSIZE
      0002C4 52 06            [ 2]    1     sub sp,#VSIZE 
      0002C6 1F 03            [ 2]  914 	ldw (SRC,sp),x 
      0002C8 17 05            [ 2]  915 	ldw (LEN,sp),y 
      0002CA 90 CF 00 0C      [ 2]  916 	ldw acc16,y 
      0002CE 90 93            [ 1]  917 	ldw y,x ; SRC
      0002D0 72 BB 00 0C      [ 2]  918 	addw x,acc16  
      0002D4 1F 01            [ 2]  919 	ldw (DEST,sp),x 
                                    920 ;compute size to move 	
      0002D6 CE 00 20         [ 2]  921 	ldw x,txtend 
      0002D9 E6 02            [ 1]  922 	ld a,(2,x) ; pending line length 
      0002DB C7 00 0D         [ 1]  923 	ld acc8,a 
      0002DE 72 5F 00 0C      [ 1]  924 	clr acc16 
      0002E2 72 BB 00 0C      [ 2]  925 	addw x,acc16 
      0002E6 72 F0 03         [ 2]  926 	subw x,(SRC,sp)
      0002E9 CF 00 0C         [ 2]  927 	ldw acc16,x ; size to move
      0002EC 1E 01            [ 2]  928 	ldw x,(DEST,sp) 
      0002EE CD 02 26         [ 4]  929 	call move
      0002F1 CE 00 20         [ 2]  930 	ldw x,txtend
      0002F4 72 FB 05         [ 2]  931 	addw x,(LEN,sp)
      0002F7 CF 00 20         [ 2]  932 	ldw txtend,x
      0002FA                        933 9$:	_drop VSIZE 
      0002FA 5B 06            [ 2]    1     addw sp,#VSIZE 
      0002FC 81               [ 4]  934 	ret 
                                    935 
                                    936 
                                    937 ;--------------------------------------------
                                    938 ; insert line in tib into text area 
                                    939 ; first search for already existing 
                                    940 ; replace existing 
                                    941 ; if strlen(tib)==0 delete existing line
                                    942 ; input:
                                    943 ;   ptr16 				pointer to tokenized line  
                                    944 ; output:
                                    945 ;   none
                                    946 ;---------------------------------------------
                           000001   947 	DEST=1  ; text area insertion address 
                           000003   948 	SRC=3   ; str to insert address 
                           000005   949 	LINENO=5 ; line number 
                           000007   950 	LLEN=7 ; line length 
                           000008   951 	VSIZE=8  
      0002FD                        952 insert_line:
      0002FD                        953 	_vars VSIZE 
      0002FD 52 08            [ 2]    1     sub sp,#VSIZE 
      0002FF CE 00 17         [ 2]  954 	ldw x,ptr16  
      000302 C3 00 1E         [ 2]  955 	cpw x,txtbgn 
      000305 26 0D            [ 1]  956 	jrne 0$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 19.
Hexadecimal [24-Bits]



                                    957 ;first text line 
      000307 AE 00 02         [ 2]  958 	ldw x,#2 
      00030A 72 D6 00 17      [ 4]  959 	ld a,([ptr16],x)
      00030E 5F               [ 1]  960 	clrw x 
      00030F 97               [ 1]  961 	ld xl,a
      000310 1F 07            [ 2]  962 	ldw (LLEN,sp),x  
      000312 20 45            [ 2]  963 	jra 5$
      000314 72 CE 00 17      [ 5]  964 0$:	ldw x,[ptr16]
                                    965 ; new line number
      000318 1F 05            [ 2]  966 	ldw (LINENO,sp),x 
      00031A AE 00 02         [ 2]  967 	ldw x,#2 
      00031D 72 D6 00 17      [ 4]  968 	ld a,([ptr16],x)
      000321 97               [ 1]  969 	ld xl,a
                                    970 ; new line length
      000322 1F 07            [ 2]  971 	ldw (LLEN,sp),x
                                    972 ; check if that line number already exit 	
      000324 1E 05            [ 2]  973 	ldw x,(LINENO,sp)
      000326 CD 02 68         [ 4]  974 	call search_lineno 
      000329 5D               [ 2]  975 	tnzw x 
      00032A 26 04            [ 1]  976 	jrne 2$
                                    977 ; line doesn't exit
                                    978 ; it will be inserted at this point.  	
      00032C 17 01            [ 2]  979 	ldw (DEST,sp),y 
      00032E 20 05            [ 2]  980 	jra 3$
                                    981 ; line exit delete it.
                                    982 ; it will be replaced by new one 	
      000330 1F 01            [ 2]  983 2$: ldw (DEST,sp),x 
      000332 CD 02 8C         [ 4]  984 	call del_line
      000335                        985 3$: 
                                    986 ; insert new line or leave if LLEN==3
                                    987 ; LLEN==3 means empty line 
      000335 A6 03            [ 1]  988 	ld a,#3
      000337 11 08            [ 1]  989 	cp a,(LLEN+1,sp)
      000339 27 27            [ 1]  990 	jreq insert_ln_exit ; empty line exit.
                                    991 ; if insertion point at txtend 
                                    992 ; no move required 
      00033B 1E 01            [ 2]  993 	ldw x,(DEST,sp)
      00033D C3 00 20         [ 2]  994 	cpw x,txtend 
      000340 2A 17            [ 1]  995 	jrpl 5$ 
                                    996 ; must create a gap
                                    997 ; at insertion point  
      000342 1E 01            [ 2]  998 	ldw x,(DEST,sp)
      000344 16 07            [ 2]  999 	ldw y,(LLEN,sp)
      000346 CD 02 C4         [ 4] 1000 	call create_gap 
                                   1001 ; move new line in gap 
      000349 1E 07            [ 2] 1002 	ldw x,(LLEN,sp)
      00034B CF 00 0C         [ 2] 1003 	ldw acc16,x 
      00034E 90 CE 00 20      [ 2] 1004 	ldw y,txtend ;SRC 
      000352 1E 01            [ 2] 1005 	ldw x,(DEST,sp) ; dest address 
      000354 CD 02 26         [ 4] 1006 	call move 
      000357 20 09            [ 2] 1007 	jra insert_ln_exit  
      000359                       1008 5$: ; no move required 
      000359 1E 07            [ 2] 1009 	ldw x,(LLEN,sp) 
      00035B 72 BB 00 20      [ 2] 1010 	addw x,txtend 
      00035F CF 00 20         [ 2] 1011 	ldw txtend,x 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 20.
Hexadecimal [24-Bits]



      000362                       1012 insert_ln_exit:	
      000362                       1013 	_drop VSIZE
      000362 5B 08            [ 2]    1     addw sp,#VSIZE 
      000364 81               [ 4] 1014 	ret
                                   1015 
                                   1016 
                                   1017 ;-----------------------------
                                   1018 ; check if text buffer full
                                   1019 ; input:
                                   1020 ;   ptr16     addr start tokenize line 
                                   1021 ;   X         buffer index 
                                   1022 ; output:
                                   1023 ;   none 
                                   1024 ;-----------------------------------
      000365                       1025 check_full:
      000365 72 BB 00 17      [ 2] 1026 	addw x,ptr16 
      000369 A3 16 E8         [ 2] 1027 	cpw x,#tib 
      00036C 25 05            [ 1] 1028 	jrult 1$
      00036E A6 01            [ 1] 1029 	ld a,#ERR_MEM_FULL
      000370 CC 07 14         [ 2] 1030 	jp tb_error 
      000373 81               [ 4] 1031 1$: ret 
                                   1032 
                                   1033 
                                   1034 ;-----------------------------------
                                   1035 ; create token list form text line 
                                   1036 ; save this list in text area
                                   1037 ;  compiled line format: 
                                   1038 ;    line_no  2 bytes {0...32767}
                                   1039 ;    count    1 byte 
                                   1040 ;    tokens   variable 
                                   1041 ;   
                                   1042 ; input:
                                   1043 ;   none
                                   1044 ; output:
                                   1045 ;   basicptr     token list buffer address 
                                   1046 ;   in.w  		 cleared, index in buffer 
                                   1047 ;-----------------------------------
                           000001  1048 	XSAVE=1
                           000003  1049 	BUFIDX=3
                           000004  1050 	VSIZE=4
      000374                       1051 compile:
      000374                       1052 	_vars VSIZE 
      000374 52 04            [ 2]    1     sub sp,#VSIZE 
      000376 72 1A 00 25      [ 1] 1053 	bset flags,#FCOMP 
      00037A CE 00 20         [ 2] 1054 	ldw x,txtend
      00037D CF 00 17         [ 2] 1055 	ldw ptr16,x ; code buffer start address 
      000380 5F               [ 1] 1056 	clrw x 
      000381 AE 00 03         [ 2] 1057 	ldw x,#3
      000384 1F 03            [ 2] 1058 	ldw (BUFIDX,sp),X  
      000386 CD 03 65         [ 4] 1059 	call check_full
      000389 5F               [ 1] 1060 	clrw x 
      00038A 72 CF 00 17      [ 5] 1061 	ldw [ptr16],x ; initialize line# to zero 
      00038E CD 0A D2         [ 4] 1062 	call get_token
      000391 1F 01            [ 2] 1063 	ldw (XSAVE,sp),x 
      000393 A1 04            [ 1] 1064 	cp a,#TK_INTGR 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 21.
Hexadecimal [24-Bits]



      000395 26 13            [ 1] 1065 	jrne 3$
      000397 A3 00 00         [ 2] 1066 	cpw x,#0 
      00039A 2C 05            [ 1] 1067 	jrsgt 1$
      00039C A6 0A            [ 1] 1068 	ld a,#ERR_BAD_VALUE 
      00039E CC 07 14         [ 2] 1069 	jp tb_error ; line number must be in range {1..32767}
      0003A1 72 CF 00 17      [ 5] 1070 1$:	ldw [ptr16],x; line number
      0003A5 CD 0A D2         [ 4] 1071 2$:	call get_token
      0003A8 1F 01            [ 2] 1072 	ldw (XSAVE,sp),x 
      0003AA A1 00            [ 1] 1073 3$:	cp a,#TK_NONE 
      0003AC 26 03            [ 1] 1074 	jrne 30$
      0003AE CC 04 3F         [ 2] 1075 	jp 9$ ; end of line. 
      0003B1                       1076 30$: 	 
      0003B1 1E 03            [ 2] 1077 	ldw x,(BUFIDX,sp)
      0003B3 CD 03 65         [ 4] 1078 	call check_full 
      0003B6 16 03            [ 2] 1079 	ldw y,(BUFIDX,sp) 
      0003B8 91 D7 17         [ 4] 1080 	ld ([ptr16],y),a ; token attribute 
      0003BB 90 5C            [ 2] 1081 	incw y
      0003BD 17 03            [ 2] 1082 	ldw (BUFIDX,sp),y
      0003BF A1 01            [ 1] 1083 	cp a,#TK_COLON 
      0003C1 26 02            [ 1] 1084 	jrne 31$
      0003C3 20 E0            [ 2] 1085 	jra 2$ ; loop for next token 
      0003C5                       1086 31$: ; check for token type 
                                   1087 ; character token have 1 byte attribute, i.e. ASCII character 
      0003C5 A1 03            [ 1] 1088 	cp a,#TK_CHAR
      0003C7 26 0C            [ 1] 1089 	jrne 32$ 
      0003C9 1E 01            [ 2] 1090 	ldw x,(XSAVE,sp)
      0003CB 9F               [ 1] 1091 	ld a,xl 
      0003CC 91 D7 17         [ 4] 1092 	ld ([ptr16],y),a
      0003CF 90 5C            [ 2] 1093 	incw y 
      0003D1 17 03            [ 2] 1094 	ldw (BUFIDX,sp),y 
      0003D3 20 D0            [ 2] 1095 	jra 2$ 
      0003D5                       1096 32$:
      0003D5 A1 02            [ 1] 1097 	cp a,#TK_ARRAY 
                                   1098 ; this token have not attribute. 
      0003D7 27 CC            [ 1] 1099 	jreq 2$ 
      0003D9 A1 0A            [ 1] 1100 	cp a,#TK_QSTR 
      0003DB 26 25            [ 1] 1101 	jrne 4$
                                   1102 ; copy string as C string.	
      0003DD AE 17 38         [ 2] 1103 	ldw x,#pad 
      0003E0 CD 01 FA         [ 4] 1104 	call strlen
      0003E3 5C               [ 2] 1105 	incw x  
      0003E4 CD 03 65         [ 4] 1106 	call check_full 
      0003E7 90 AE 17 38      [ 2] 1107 	ldw y,#pad 
      0003EB CE 00 17         [ 2] 1108 	ldw x,ptr16
      0003EE 72 FB 03         [ 2] 1109 	addw x,(BUFIDX,sp)	
      0003F1 CD 02 18         [ 4] 1110 	call strcpy 
      0003F4 AE 17 38         [ 2] 1111 	ldw x,#pad 
      0003F7 CD 01 FA         [ 4] 1112 	call strlen 
      0003FA 5C               [ 2] 1113 	incw x
      0003FB 72 FB 03         [ 2] 1114 	addw x,(BUFIDX,sp) 
      0003FE 1F 03            [ 2] 1115 	ldw (BUFIDX,sp),x
      000400 20 A3            [ 2] 1116 	jra 2$  
      000402 A1 04            [ 1] 1117 4$: cp a,#TK_INTGR
      000404 25 9F            [ 1] 1118 	jrult 2$ ; 
      000406 A1 08            [ 1] 1119 	cp a,#TK_CFUNC 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 22.
Hexadecimal [24-Bits]



      000408 22 9B            [ 1] 1120 	Jrugt 2$ ; those tokens have no attributes 
      00040A 1E 01            [ 2] 1121 	ldw x,(XSAVE,sp) 
      00040C 16 03            [ 2] 1122 	ldw y,(BUFIDX,sp)
      00040E 91 DF 17         [ 5] 1123 	ldw ([ptr16],y),x ; the attribute is an address or integer. 
      000411 A3 14 9C         [ 2] 1124 	cpw x,#rem ; is this a comment? 
      000414 27 09            [ 1] 1125 	jreq 5$	
      000416 72 A9 00 02      [ 2] 1126 	addw y,#2 
      00041A 17 03            [ 2] 1127 	ldw (BUFIDX,sp),y 
      00041C CC 03 A5         [ 2] 1128 	jp 2$
      00041F                       1129 5$:
                                   1130 ; copy commment in code buffer and
                                   1131 ; skip to end of line.  
      00041F 72 A9 00 02      [ 2] 1132 	addw y,#2 ; skip exec address 
      000423 17 03            [ 2] 1133 	ldw (BUFIDX,sp),y 
      000425 CE 00 17         [ 2] 1134 	ldw x,ptr16 
      000428 72 FB 03         [ 2] 1135 	addw x,(BUFIDX,sp)
      00042B 90 CE 00 00      [ 2] 1136 	ldw y,in.w 
      00042F 72 A9 16 E8      [ 2] 1137 	addw y,#tib 
      000433 CD 02 18         [ 4] 1138 	call strcpy 	
      000436 CD 01 FA         [ 4] 1139 	call strlen 
      000439 5C               [ 2] 1140 	incw x ; skip string 0. 
      00043A 72 FB 03         [ 2] 1141 	addw x,(BUFIDX,sp)
      00043D 1F 03            [ 2] 1142 	ldw (BUFIDX,sp),x 
      00043F                       1143 9$: 
      00043F AE 00 02         [ 2] 1144 	ldw x,#2
      000442 16 03            [ 2] 1145 	ldw y,(BUFIDX,sp)
      000444 90 9F            [ 1] 1146 	ld a,yl 
      000446 72 D7 00 17      [ 4] 1147 	ld ([ptr16],x),a ; code byte count   	
      00044A 72 CE 00 17      [ 5] 1148 	ldw x,[ptr16]
      00044E 27 09            [ 1] 1149 	jreq 10$
      000450 CD 02 FD         [ 4] 1150 	call insert_line
      000453 72 5F 00 03      [ 1] 1151 	clr  count 
      000457 20 0F            [ 2] 1152 	jra  11$ 
      000459                       1153 10$: ; line# is zero 
      000459 CE 00 17         [ 2] 1154 	ldw x,ptr16 
      00045C CF 00 04         [ 2] 1155 	ldw basicptr,x 
      00045F E6 02            [ 1] 1156 	ld a,(2,x)
      000461 C7 00 03         [ 1] 1157 	ld count,a 
      000464 35 03 00 01      [ 1] 1158 	mov in,#3 
      000468                       1159 11$:
      000468                       1160 	_drop VSIZE 
      000468 5B 04            [ 2]    1     addw sp,#VSIZE 
      00046A 72 1B 00 25      [ 1] 1161 	bres flags,#FCOMP 
      00046E 81               [ 4] 1162 	ret 
                                   1163 
                                   1164 
                                   1165 ;------------------------------------
                                   1166 ;  set all variables to zero 
                                   1167 ; input:
                                   1168 ;   none 
                                   1169 ; output:
                                   1170 ;	none
                                   1171 ;------------------------------------
      00046F                       1172 clear_vars:
      00046F AE 00 28         [ 2] 1173 	ldw x,#vars 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 23.
Hexadecimal [24-Bits]



      000472 90 AE 00 34      [ 2] 1174 	ldw y,#2*26 
      000476 7F               [ 1] 1175 1$:	clr (x)
      000477 5C               [ 2] 1176 	incw x 
      000478 90 5A            [ 2] 1177 	decw y 
      00047A 26 FA            [ 1] 1178 	jrne 1$
      00047C 81               [ 4] 1179 	ret 
                                   1180 
                                   1181 ;-------------------------------------
                                   1182 ; check if A is a letter 
                                   1183 ; input:
                                   1184 ;   A 			character to test 
                                   1185 ; output:
                                   1186 ;   C flag      1 true, 0 false 
                                   1187 ;-------------------------------------
      00047D                       1188 is_alpha:
      00047D A1 41            [ 1] 1189 	cp a,#'A 
      00047F 8C               [ 1] 1190 	ccf
      000480 24 0B            [ 1] 1191 	jrnc 9$ 
      000482 A1 5B            [ 1] 1192 	cp a,#'Z+1 
      000484 25 07            [ 1] 1193 	jrc 9$ 
      000486 A1 61            [ 1] 1194 	cp a,#'a 
      000488 8C               [ 1] 1195 	ccf 
      000489 24 02            [ 1] 1196 	jrnc 9$
      00048B A1 7B            [ 1] 1197 	cp a,#'z+1   
      00048D 81               [ 4] 1198 9$: ret 	
                                   1199 
                                   1200 ;-------------------------------------
                                   1201 ;  program initialization entry point 
                                   1202 ;-------------------------------------
                           000001  1203 	MAJOR=1
                           000000  1204 	MINOR=0
      00048E 0A 0A 54 69 6E 79 20  1205 software: .asciz "\n\nTiny BASIC for STM8\nCopyright, Jacques Deschenes 2019,2020\nversion "
             42 41 53 49 43 20 66
             6F 72 20 53 54 4D 38
             0A 43 6F 70 79 72 69
             67 68 74 2C 20 4A 61
             63 71 75 65 73 20 44
             65 73 63 68 65 6E 65
             73 20 32 30 31 39 2C
             32 30 32 30 0A 76 65
             72 73 69 6F 6E 20 00
      0004D4                       1206 cold_start:
                                   1207 ;set stack 
      0004D4 AE 17 FF         [ 2] 1208 	ldw x,#STACK_EMPTY
      0004D7 94               [ 1] 1209 	ldw sp,x   
                                   1210 ; clear all ram 
      0004D8 7F               [ 1] 1211 0$: clr (x)
      0004D9 5A               [ 2] 1212 	decw x 
      0004DA 26 FC            [ 1] 1213 	jrne 0$
                                   1214 ; activate pull up on all inputs 
      0004DC A6 FF            [ 1] 1215 	ld a,#255 
      0004DE C7 50 03         [ 1] 1216 	ld PA_CR1,a 
      0004E1 C7 50 08         [ 1] 1217 	ld PB_CR1,a 
      0004E4 C7 50 0D         [ 1] 1218 	ld PC_CR1,a 
      0004E7 C7 50 12         [ 1] 1219 	ld PD_CR1,a 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 24.
Hexadecimal [24-Bits]



      0004EA C7 50 17         [ 1] 1220 	ld PE_CR1,a 
      0004ED C7 50 1C         [ 1] 1221 	ld PF_CR1,a 
      0004F0 C7 50 21         [ 1] 1222 	ld PG_CR1,a 
      0004F3 C7 50 2B         [ 1] 1223 	ld PI_CR1,a
                                   1224 ; set LD2 pin as output and turn it on
      0004F6 72 1A 50 0D      [ 1] 1225     bset PC_CR1,#LED2_BIT
      0004FA 72 1A 50 0E      [ 1] 1226     bset PC_CR2,#LED2_BIT
      0004FE 72 1A 50 0C      [ 1] 1227     bset PC_DDR,#LED2_BIT
      000502 72 1A 50 0A      [ 1] 1228 	bset PC_ODR,#LED2_BIT 
                                   1229 ; disable schmitt triggers on Arduino CN4 analog inputs
      000506 55 00 3F 54 07   [ 1] 1230 	mov ADC_TDRL,0x3f
                                   1231 ; disable peripherals clocks
                                   1232 ;	clr CLK_PCKENR1 
                                   1233 ;	clr CLK_PCKENR2
      00050B 72 5F 50 F2      [ 1] 1234 	clr AWU_TBR 
      00050F 72 14 50 CA      [ 1] 1235 	bset CLK_PCKENR2,#CLK_PCKENR2_AWU ; enable LSI for beeper
                                   1236 ; select internal clock no divisor: 16 Mhz 	
      000513 A6 E1            [ 1] 1237 	ld a,#CLK_SWR_HSI 
      000515 5F               [ 1] 1238 	clrw x  
      000516 CD 00 8C         [ 4] 1239     call clock_init 
      000519 CD 00 AF         [ 4] 1240 	call timer4_init
      00051C CD 00 A2         [ 4] 1241 	call timer2_init
                                   1242 ; UART1 at 115200 BAUD
      00051F CD 01 78         [ 4] 1243 	call uart1_init
                                   1244 ; activate PE_4 (user button interrupt)
      000522 72 18 50 18      [ 1] 1245     bset PE_CR2,#USR_BTN_BIT 
                                   1246 ; display system information
      000526 AE 04 8E         [ 2] 1247 	ldw x,#software 
      000529 CD 01 C6         [ 4] 1248 	call puts 
      00052C A6 01            [ 1] 1249 	ld a,#MAJOR 
      00052E C7 00 0D         [ 1] 1250 	ld acc8,a 
      000531 5F               [ 1] 1251 	clrw x 
      000532 CF 00 0B         [ 2] 1252 	ldw acc24,x 
      000535 A6 0A            [ 1] 1253 	ld a,#10 
      000537 CD 08 1B         [ 4] 1254 	call prti24 
      00053A A6 2E            [ 1] 1255 	ld a,#'.
      00053C CD 01 B3         [ 4] 1256 	call putc 
      00053F A6 00            [ 1] 1257 	ld a,#MINOR 
      000541 C7 00 0D         [ 1] 1258 	ld acc8,a 
      000544 5F               [ 1] 1259 	clrw x 
      000545 CF 00 0B         [ 2] 1260 	ldw acc24,x 
      000548 A6 0A            [ 1] 1261 	ld a,#10 
      00054A CD 08 1B         [ 4] 1262 	call prti24 
      00054D A6 0D            [ 1] 1263 	ld a,#CR 
      00054F CD 01 B3         [ 4] 1264 	call putc 
      000552 CD 18 F7         [ 4] 1265 	call seek_fdrive 
      000555 9A               [ 1] 1266 	rim 
      000556 72 5C 00 15      [ 1] 1267 	inc seedy+1 
      00055A 72 5C 00 13      [ 1] 1268 	inc seedx+1 
      00055E CD 05 DC         [ 4] 1269 	call clear_basic
      000561 CD 11 27         [ 4] 1270 	call ubound 
      000564 CD 0D 71         [ 4] 1271 	call dpop 
      000567 CF 00 23         [ 2] 1272 	ldw array_size,x
                                   1273 ; 200 msec beep 
      00056A AE 03 DC         [ 2] 1274 	ldw x,#988 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 25.
Hexadecimal [24-Bits]



      00056D CD 0D 64         [ 4] 1275 	call dpush 
      000570 AE 00 96         [ 2] 1276 	ldw x,#150 
      000573 CD 0D 64         [ 4] 1277 	call dpush 
      000576 CD 17 5A         [ 4] 1278 	call beep 
      000579 72 1B 50 0A      [ 1] 1279 	bres PC_ODR,#LED2_BIT	
      00057D CD 05 86         [ 4] 1280 	call warm_init
      000580 CD 05 A3         [ 4] 1281 	call load_autorun
      000583 CC 07 58         [ 2] 1282     jp interp 
                                   1283 
      000586                       1284 warm_init:
      000586 72 5F 00 25      [ 1] 1285 	clr flags 
      00058A 72 5F 00 22      [ 1] 1286 	clr loop_depth 
      00058E AE 17 80         [ 2] 1287 	ldw x,#dstack_empty 
      000591 CF 00 1C         [ 2] 1288 	ldw dstkptr,x 
      000594 35 04 00 26      [ 1] 1289 	mov tab_width,#TAB_WIDTH 
      000598 35 0A 00 0A      [ 1] 1290 	mov base,#10 
      00059C AE 16 E8         [ 2] 1291 	ldw x,#tib 
      00059F CF 00 04         [ 2] 1292 	ldw basicptr,x 
      0005A2 81               [ 4] 1293 	ret 
                                   1294 
                                   1295 ;--------------------------
                                   1296 ; if autorun file defined 
                                   1297 ; in eeprom address AUTORUN_NAME 
                                   1298 ; load and run it.
                                   1299 ;-------------------------
      0005A3                       1300 load_autorun:
      0005A3 AE 40 00         [ 2] 1301 	ldw x,#AUTORUN_NAME
      0005A6 F6               [ 1] 1302 	ld a,(x)
      0005A7 27 1D            [ 1] 1303 	jreq 9$
      0005A9 90 AE 40 00      [ 2] 1304 	ldw y,#AUTORUN_NAME
      0005AD CD 19 55         [ 4] 1305 	call search_file
      0005B0 25 02            [ 1] 1306 	jrc 2$ 
      0005B2 20 12            [ 2] 1307 	jra 9$ 
      0005B4 CD 1A 64         [ 4] 1308 2$:	call load_file
      0005B7 AE 40 00         [ 2] 1309 	ldw x,#AUTORUN_NAME 
      0005BA CD 01 C6         [ 4] 1310 	call puts
      0005BD AE 05 C7         [ 2] 1311 	ldw x,#autorun_msg 
      0005C0 CD 01 C6         [ 4] 1312 	call puts 
      0005C3 CC 17 1A         [ 2] 1313 	jp run_it    
      0005C6 81               [ 4] 1314 9$: ret 	
                                   1315 
      0005C7 20 6C 6F 61 64 65 64  1316 autorun_msg: .asciz " loaded and running\n"
             20 61 6E 64 20 72 75
             6E 6E 69 6E 67 0A 00
                                   1317 ;---------------------------
                                   1318 ; reset BASIC text variables 
                                   1319 ; and clear variables 
                                   1320 ;---------------------------
      0005DC                       1321 clear_basic:
      0005DC 72 5F 00 03      [ 1] 1322 	clr count 
      0005E0 AE 00 5C         [ 2] 1323 	ldw x,#free_ram 
      0005E3 CF 00 1E         [ 2] 1324 	ldw txtbgn,x 
      0005E6 CF 00 20         [ 2] 1325 	ldw txtend,x 
      0005E9 CD 04 6F         [ 4] 1326 	call clear_vars 
      0005EC 81               [ 4] 1327 	ret 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 26.
Hexadecimal [24-Bits]



                                   1328 
                                   1329 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   1330 ;;   Tiny BASIC error messages     ;;
                                   1331 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
      0005ED                       1332 err_msg:
      0005ED 00 00 06 07 06 15 06  1333 	.word 0,err_mem_full, err_syntax, err_math_ovf, err_div0,err_no_line    
             24 06 3E 06 4E
      0005F9 06 65 06 7C 06 97 06  1334 	.word err_run_only,err_cmd_only,err_duplicate,err_not_file,err_bad_value
             A9 06 BB
      000603 06 C8 06 FC           1335 	.word err_no_access,err_no_data  
                                   1336 
      000607 0A 4D 65 6D 6F 72 79  1337 err_mem_full: .asciz "\nMemory full\n" 
             20 66 75 6C 6C 0A 00
      000615 0A 73 79 6E 74 61 78  1338 err_syntax: .asciz "\nsyntax error\n" 
             20 65 72 72 6F 72 0A
             00
      000624 0A 6D 61 74 68 20 6F  1339 err_math_ovf: .asciz "\nmath operation overflow\n"
             70 65 72 61 74 69 6F
             6E 20 6F 76 65 72 66
             6C 6F 77 0A 00
      00063E 0A 64 69 76 69 73 69  1340 err_div0: .asciz "\ndivision by 0\n" 
             6F 6E 20 62 79 20 30
             0A 00
      00064E 0A 69 6E 76 61 6C 69  1341 err_no_line: .asciz "\ninvalid line number.\n"
             64 20 6C 69 6E 65 20
             6E 75 6D 62 65 72 2E
             0A 00
      000665 0A 72 75 6E 20 74 69  1342 err_run_only: .asciz "\nrun time only usage.\n" 
             6D 65 20 6F 6E 6C 79
             20 75 73 61 67 65 2E
             0A 00
      00067C 0A 63 6F 6D 6D 61 6E  1343 err_cmd_only: .asciz "\ncommand line only usage.\n"
             64 20 6C 69 6E 65 20
             6F 6E 6C 79 20 75 73
             61 67 65 2E 0A 00
      000697 0A 64 75 70 6C 69 63  1344 err_duplicate: .asciz "\nduplicate name.\n"
             61 74 65 20 6E 61 6D
             65 2E 0A 00
      0006A9 0A 46 69 6C 65 20 6E  1345 err_not_file: .asciz "\nFile not found.\n"
             6F 74 20 66 6F 75 6E
             64 2E 0A 00
      0006BB 0A 62 61 64 20 76 61  1346 err_bad_value: .asciz "\nbad value.\n"
             6C 75 65 2E 0A 00
      0006C8 0A 46 69 6C 65 20 69  1347 err_no_access: .asciz "\nFile in extended memory, can't be run from there.\n" 
             6E 20 65 78 74 65 6E
             64 65 64 20 6D 65 6D
             6F 72 79 2C 20 63 61
             6E 27 74 20 62 65 20
             72 75 6E 20 66 72 6F
             6D 20 74 68 65 72 65
             2E 0A 00
      0006FC 0A 4E 6F 20 64 61 74  1348 err_no_data: .asciz "\nNo data line found.\n"
             61 20 6C 69 6E 65 20
             66 6F 75 6E 64 2E 0A
             00
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 27.
Hexadecimal [24-Bits]



                                   1349 
                                   1350 ;rt_msg: .asciz "last token id: "
                                   1351 
      000712                       1352 syntax_error:
      000712 A6 02            [ 1] 1353 	ld a,#ERR_SYNTAX 
                                   1354 
      000714                       1355 tb_error:
      000714 AE 05 ED         [ 2] 1356 	ldw x, #err_msg 
      000717 72 5F 00 0C      [ 1] 1357 	clr acc16 
      00071B 48               [ 1] 1358 	sll a
      00071C 72 59 00 0C      [ 1] 1359 	rlc acc16  
      000720 C7 00 0D         [ 1] 1360 	ld acc8, a 
      000723 72 BB 00 0C      [ 2] 1361 	addw x,acc16 
      000727 FE               [ 2] 1362 	ldw x,(x)
      000728 CD 01 C6         [ 4] 1363 	call puts
      00072B 72 0B 00 25 18   [ 2] 1364 	btjf flags,#FCOMP, 1$
      000730 AE 16 E8         [ 2] 1365 	ldw x,#tib
      000733 CD 01 C6         [ 4] 1366 	call puts 
      000736 A6 0D            [ 1] 1367 	ld a,#CR 
      000738 CD 01 B3         [ 4] 1368 	call putc
      00073B CE 00 00         [ 2] 1369 	ldw x,in.w
      00073E CD 01 EE         [ 4] 1370 	call spaces
      000741 A6 5E            [ 1] 1371 	ld a,#'^
      000743 CD 01 B3         [ 4] 1372 	call putc 
      000746 20 09            [ 2] 1373 	jra 6$
      000748 CE 00 04         [ 2] 1374 1$:	ldw x,basicptr
      00074B C6 00 01         [ 1] 1375 	ld a,in 
      00074E CD 12 46         [ 4] 1376 	call prt_basic_line
                                   1377 ;	ldw x,#rt_msg 
                                   1378 ;	call puts 
                                   1379 ;	clrw x 
                                   1380 ;	ld a,in.saved 
                                   1381 ;	ld xl,a 
                                   1382 ;	ld a,([basicptr],x)
                                   1383 ;	clrw x 
                                   1384 ;	ld xl,a 
                                   1385 ;	call print_int 
      000751 AE 17 FF         [ 2] 1386 6$: ldw x,#STACK_EMPTY 
      000754 94               [ 1] 1387     ldw sp,x
      000755                       1388 warm_start:
      000755 CD 05 86         [ 4] 1389 	call warm_init
                                   1390 ;----------------------------
                                   1391 ;   BASIC interpreter
                                   1392 ;----------------------------
      000758                       1393 interp:
      000758 72 5F 00 00      [ 1] 1394 	clr in.w
      00075C 72 01 00 25 23   [ 2] 1395 	btjf flags,#FRUN,cmd_line
                                   1396 ; flag FRUN is set 
                                   1397 ; running program
                                   1398 ; goto next basic line 
      000761 CE 00 04         [ 2] 1399 	ldw x,basicptr
      000764 E6 02            [ 1] 1400 	ld a,(2,x) ; line length 
      000766 C7 00 0D         [ 1] 1401 	ld acc8,a 
      000769 72 5F 00 0C      [ 1] 1402 	clr acc16 
      00076D 72 BB 00 0C      [ 2] 1403 	addw x,acc16
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 28.
Hexadecimal [24-Bits]



      000771 C3 00 20         [ 2] 1404 	cpw x,txtend 
      000774 2A DF            [ 1] 1405 	jrpl warm_start
      000776 CF 00 04         [ 2] 1406 	ldw basicptr,x ; start of next line  
      000779 E6 02            [ 1] 1407 	ld a,(2,x)
      00077B C7 00 03         [ 1] 1408 	ld count,a 
      00077E 35 03 00 01      [ 1] 1409 	mov in,#3 ; skip first 3 bytes of line 
      000782 20 14            [ 2] 1410 	jra interp_loop 
      000784                       1411 cmd_line: ; commande line interface  	
      000784 72 5F 00 01      [ 1] 1412 	clr in
      000788 A6 0D            [ 1] 1413 	ld a,#CR 
      00078A CD 01 B3         [ 4] 1414 	call putc 
      00078D A6 3E            [ 1] 1415 	ld a,#'> 
      00078F CD 01 B3         [ 4] 1416 	call putc 
      000792 CD 09 53         [ 4] 1417 	call readln
      000795 CD 03 74         [ 4] 1418 	call compile
                                   1419 ; if text begin with a line number
                                   1420 ; the compile set count=0   
                                   1421 ; so code is not interpreted
                                   1422 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   1423 ;; This is the interpreter loop
                                   1424 ;; for each BASIC code line. 
                                   1425 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;	
      000798                       1426 interp_loop:  
      000798 C6 00 01         [ 1] 1427 	ld a,in 
      00079B C1 00 03         [ 1] 1428 	cp a,count  
      00079E 2A B8            [ 1] 1429 	jrpl interp
      0007A0 CD 07 C6         [ 4] 1430 	call next_token
      0007A3 A1 01            [ 1] 1431 	cp a,#TK_COLON 
      0007A5 27 F1            [ 1] 1432 	jreq interp_loop 
      0007A7                       1433 1$:
      0007A7 A1 05            [ 1] 1434 	cp a,#TK_VAR
      0007A9 26 05            [ 1] 1435 	jrne 2$
      0007AB CD 11 53         [ 4] 1436 	call let02  
      0007AE 20 E8            [ 2] 1437 	jra interp_loop 
      0007B0                       1438 2$:	
      0007B0 A1 02            [ 1] 1439 	cp a,#TK_ARRAY 
      0007B2 26 08            [ 1] 1440 	jrne 3$
      0007B4 CD 0F 9C         [ 4] 1441 	call get_array_element
      0007B7 CD 11 53         [ 4] 1442 	call let02 
      0007BA 20 DC            [ 2] 1443 	jra interp_loop 
      0007BC                       1444 3$:
      0007BC A1 06            [ 1] 1445 	cp a,#TK_CMD
      0007BE 26 03            [ 1] 1446 	jrne 4$
      0007C0 FD               [ 4] 1447 	call (x) 
      0007C1 20 D5            [ 2] 1448 	jra interp_loop 
      0007C3                       1449 4$:	
      0007C3 CC 07 12         [ 2] 1450 	jp syntax_error 
                                   1451 
                                   1452 ;--------------------------
                                   1453 ; extract next token from
                                   1454 ; token list 
                                   1455 ; basicptr -> base address 
                                   1456 ; in  -> offset in list array 
                                   1457 ; output:
                                   1458 ;   A 		token attribute
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 29.
Hexadecimal [24-Bits]



                                   1459 ;   X 		token value if there is one
                                   1460 ;----------------------------------------
      0007C6                       1461 next_token:
      0007C6 C6 00 01         [ 1] 1462 	ld a,in 
      0007C9 C0 00 03         [ 1] 1463 	sub a,count ; don't replace sub by cp.  
      0007CC 27 4C            [ 1] 1464 	jreq 9$
      0007CE 55 00 01 00 02   [ 1] 1465 	mov in.saved,in 
      0007D3 CE 00 04         [ 2] 1466 	ldw x,basicptr 
      0007D6 72 D6 00 00      [ 4] 1467 	ld a,([in.w],x)
      0007DA 72 5C 00 01      [ 1] 1468 	inc in 
      0007DE A1 02            [ 1] 1469 	cp a,#TK_ARRAY  
      0007E0 23 38            [ 2] 1470 	jrule 9$
      0007E2 A1 03            [ 1] 1471 	cp a,#TK_CHAR
      0007E4 26 0D            [ 1] 1472 	jrne 1$
      0007E6 72 D6 00 00      [ 4] 1473 	ld a,([in.w],x)
      0007EA 72 5C 00 01      [ 1] 1474 	inc in
      0007EE 5F               [ 1] 1475 	clrw x 
      0007EF 97               [ 1] 1476 	ld xl,a 
      0007F0 A6 03            [ 1] 1477 	ld a,#TK_CHAR
      0007F2 81               [ 4] 1478 	ret 
      0007F3 A1 0A            [ 1] 1479 1$:	cp a,#TK_QSTR 
      0007F5 25 17            [ 1] 1480 	jrult 4$
      0007F7 26 21            [ 1] 1481 	jrne 9$
      0007F9 72 BB 00 00      [ 2] 1482 	addw x,in.w 
      0007FD 89               [ 2] 1483 	pushw x 
      0007FE 7D               [ 1] 1484 2$:	tnz (x)
      0007FF 27 03            [ 1] 1485 	jreq 3$
      000801 5C               [ 2] 1486 	incw x 
      000802 20 FA            [ 2] 1487 	jra 2$ 
      000804 5C               [ 2] 1488 3$:	incw x 
      000805 72 B0 00 04      [ 2] 1489     subw x,basicptr 
      000809 CF 00 00         [ 2] 1490 	ldw in.w,x 
      00080C 85               [ 2] 1491 	popw x 
      00080D 81               [ 4] 1492 	ret 
      00080E 72 DE 00 00      [ 5] 1493 4$: ldw x,([in.w],x)
      000812 72 5C 00 01      [ 1] 1494 	inc in 
      000816 72 5C 00 01      [ 1] 1495 	inc in
      00081A                       1496 9$: 
      00081A 81               [ 4] 1497 	ret	
                                   1498 
                                   1499 
                                   1500 ;----------------------------------------
                                   1501 ;   DEBUG support functions
                                   1502 ;----------------------------------------
                           000000  1503 .if DEBUG 
                                   1504 
                                   1505 ; turn LED on 
                                   1506 ledon:
                                   1507     bset PC_ODR,#LED2_BIT
                                   1508     ret 
                                   1509 
                                   1510 ; turn LED off 
                                   1511 ledoff:
                                   1512     bres PC_ODR,#LED2_BIT 
                                   1513     ret 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 30.
Hexadecimal [24-Bits]



                                   1514 
                                   1515 ; invert LED status 
                                   1516 ledtoggle:
                                   1517     ld a,#LED2_MASK
                                   1518     xor a,PC_ODR
                                   1519     ld PC_ODR,a
                                   1520     ret 
                                   1521 
                                   1522 left_paren:
                                   1523 	ld a,#SPACE 
                                   1524 	call putc
                                   1525 	ld a,#'( 
                                   1526 	call putc 	
                                   1527 	ret 
                                   1528 
                                   1529 ;------------------------------
                                   1530 ; print 8 bit register 
                                   1531 ; input:
                                   1532 ;   X  point to register name 
                                   1533 ;   A  register value to print 
                                   1534 ; output:
                                   1535 ;   none
                                   1536 ;------------------------------- 
                                   1537 prt_reg8:
                                   1538 	push a 
                                   1539 	call puts 
                                   1540 	ld a,(1,sp) 
                                   1541 	ld acc8,a 
                                   1542 	clrw x 
                                   1543 	ld xl,a 
                                   1544 	mov base,#16
                                   1545 	call print_int 
                                   1546 	call left_paren 
                                   1547 	pop a 
                                   1548 	clrw x 
                                   1549 	ld xl,a 
                                   1550 	mov base,#10 
                                   1551 	call print_int  
                                   1552 	ld a,#') 
                                   1553 	call putc
                                   1554 	ret
                                   1555 
                                   1556 ;--------------------------------
                                   1557 ; print 16 bits register 
                                   1558 ; input:
                                   1559 ;   X   point register name 
                                   1560 ;   Y   register value to print 
                                   1561 ; output:
                                   1562 ;  none
                                   1563 ;--------------------------------
                                   1564 prt_reg16: 
                                   1565 	pushw y 
                                   1566 	call puts 
                                   1567 	ldw x,(1,sp) 
                                   1568 	mov base,#16 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 31.
Hexadecimal [24-Bits]



                                   1569 	call print_int  
                                   1570 	call left_paren 
                                   1571 	popw x 
                                   1572 	mov base,#10 
                                   1573 	call print_int  
                                   1574 	ld a,#') 
                                   1575 	call putc
                                   1576 	ret 
                                   1577 
                                   1578 ;------------------------------------
                                   1579 ; print registers contents saved on
                                   1580 ; stack by trap interrupt.
                                   1581 ;------------------------------------
                                   1582 print_registers:
                                   1583 	ldw x,#STATES
                                   1584 	call puts
                                   1585 ; print EPC 
                                   1586 	ldw x, #REG_EPC
                                   1587 	call puts 
                                   1588 	ld a, (11,sp)
                                   1589 	ld acc8,a 
                                   1590 	ld a, (10,sp) 
                                   1591 	ld acc16,a 
                                   1592 	ld a,(9,sp) 
                                   1593 	ld acc24,a
                                   1594 	clrw x  
                                   1595 	ld a,#16
                                   1596 	call prti24  
                                   1597 ; print X
                                   1598 	ldw x,#REG_X
                                   1599 	ldw y,(5,sp)
                                   1600 	call prt_reg16  
                                   1601 ; print Y 
                                   1602 	ldw x,#REG_Y
                                   1603 	ldw y, (7,sp)
                                   1604 	call prt_reg16  
                                   1605 ; print A 
                                   1606 	ldw x,#REG_A
                                   1607 	ld a, (4,sp) 
                                   1608 	call prt_reg8
                                   1609 ; print CC 
                                   1610 	ldw x,#REG_CC 
                                   1611 	ld a, (3,sp) 
                                   1612 	call prt_reg8 
                                   1613 ; print SP 
                                   1614 	ldw x,#REG_SP
                                   1615 	ldw y,sp 
                                   1616 	addw y,#12
                                   1617 	call prt_reg16  
                                   1618 	ld a,#'\n' 
                                   1619 	call putc
                                   1620 	ret
                                   1621 
                                   1622 STATES:  .asciz "\nRegisters state at abort point.\n--------------------------\n"
                                   1623 REG_EPC: .asciz "EPC:"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 32.
Hexadecimal [24-Bits]



                                   1624 REG_Y:   .asciz "\nY:" 
                                   1625 REG_X:   .asciz "\nX:"
                                   1626 REG_A:   .asciz "\nA:" 
                                   1627 REG_CC:  .asciz "\nCC:"
                                   1628 REG_SP:  .asciz "\nSP:"
                                   1629 
                                   1630 .endif ; DEBUG 
                                   1631 ;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   1632 
                                   1633 
                                   1634 ;------------------------------------
                                   1635 ; print integer in acc24 
                                   1636 ; input:
                                   1637 ;	acc24 		integer to print 
                                   1638 ;	A 			numerical base for conversion 
                                   1639 ;               if bit 7 is set add a space at print end.
                                   1640 ;   XL 			field width, 0 -> no fill.
                                   1641 ;  output:
                                   1642 ;    none 
                                   1643 ;------------------------------------
                           000001  1644 	WIDTH = 1
                           000002  1645 	BASE = 2
                           000003  1646 	ADD_SPACE=3 ; add a space after number 
                           000003  1647 	VSIZE = 3
      00081B                       1648 prti24:
      00081B                       1649 	_vars VSIZE 
      00081B 52 03            [ 2]    1     sub sp,#VSIZE 
      00081D 0F 03            [ 1] 1650 	clr (ADD_SPACE,sp)
      00081F A5 80            [ 1] 1651 	bcp a,#0x80 
      000821 27 02            [ 1] 1652 	jreq 0$ 
      000823 03 03            [ 1] 1653 	cpl (ADD_SPACE,sp)
      000825 A4 1F            [ 1] 1654 0$:	and a,#31 
      000827 6B 02            [ 1] 1655 	ld (BASE,sp),a
      000829 9F               [ 1] 1656 	ld a,xl
      00082A 6B 01            [ 1] 1657 	ld (WIDTH,sp),a 
      00082C 7B 02            [ 1] 1658 	ld a, (BASE,sp)  
      00082E CD 08 C1         [ 4] 1659     call itoa  ; conversion entier en  .asciz
      000831 7B 01            [ 1] 1660 1$: ld a,(WIDTH,sp)
      000833 27 1F            [ 1] 1661 	jreq 4$
      000835 C7 00 0D         [ 1] 1662 	ld acc8,a 
      000838 89               [ 2] 1663 	pushw x 
      000839 CD 01 FA         [ 4] 1664 	call strlen 
      00083C 9F               [ 1] 1665 	ld a,xl 
      00083D 85               [ 2] 1666 	popw x 
      00083E 31 00 0D         [ 3] 1667 	exg a,acc8 
      000841 C0 00 0D         [ 1] 1668 	sub a,acc8 
      000844 2B 0E            [ 1] 1669 	jrmi 4$
      000846 6B 01            [ 1] 1670 	ld (WIDTH,sp),a 
      000848 A6 20            [ 1] 1671 	ld  a,#SPACE
      00084A 0D 01            [ 1] 1672 3$: tnz (WIDTH,sp)
      00084C 27 06            [ 1] 1673 	jreq 4$
      00084E 5A               [ 2] 1674 	decw x 
      00084F F7               [ 1] 1675 	ld (x),a 
      000850 0A 01            [ 1] 1676 	dec (WIDTH,sp) 
      000852 20 F6            [ 2] 1677 	jra 3$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 33.
Hexadecimal [24-Bits]



      000854                       1678 4$: 
      000854 CD 01 C6         [ 4] 1679 	call puts 
      000857 0D 03            [ 1] 1680 	tnz (ADD_SPACE,sp)
      000859 27 05            [ 1] 1681 	jreq 5$
      00085B A6 20            [ 1] 1682     ld a,#SPACE 
      00085D CD 01 B3         [ 4] 1683 	call putc 
      000860                       1684 5$: _drop VSIZE 
      000860 5B 03            [ 2]    1     addw sp,#VSIZE 
      000862 81               [ 4] 1685     ret	
                                   1686 
                                   1687 ;-----------------------------------
                                   1688 ; print a 16 bit integer 
                                   1689 ; using variable 'base' as conversion
                                   1690 ; format.
                                   1691 ; input:
                                   1692 ;   X       integer to print 
                                   1693 ;   base    conversion base 
                                   1694 ; output:
                                   1695 ;   none 
                                   1696 ;-----------------------------------
                           000001  1697 	SIGN=1
                           000001  1698 	VSIZE=1
      000863                       1699 print_int: 
      000863                       1700 	_vars VSIZE 
      000863 52 01            [ 2]    1     sub sp,#VSIZE 
      000865 0F 01            [ 1] 1701 	clr (SIGN,sp)
      000867 90 AE 17 5F      [ 2] 1702 	ldw y,#pad+PAD_SIZE-1 
      00086B 90 7F            [ 1] 1703 	clr (y)
      00086D C6 00 0A         [ 1] 1704 	ld a,base  
      000870 A1 0A            [ 1] 1705 	cp a,#10 
      000872 26 06            [ 1] 1706 	jrne 1$ 
      000874 5D               [ 2] 1707 	tnzw x 
      000875 2A 03            [ 1] 1708 	jrpl 1$ 
      000877 03 01            [ 1] 1709 	cpl (SIGN,sp)
      000879 50               [ 2] 1710 	negw x 	 
      00087A                       1711 1$:	
      00087A C6 00 0A         [ 1] 1712 	ld a,base 
      00087D 62               [ 2] 1713 	div x,a 
      00087E AB 30            [ 1] 1714 	add a,#'0 
      000880 A1 3A            [ 1] 1715 	cp a,#'9+1 
      000882 2B 02            [ 1] 1716 	jrmi 2$ 
      000884 AB 07            [ 1] 1717 	add a,#7 
      000886 90 5A            [ 2] 1718 2$: decw y 
      000888 90 F7            [ 1] 1719 	ld (y),a 
      00088A 5D               [ 2] 1720 	tnzw x 
      00088B 26 ED            [ 1] 1721 	jrne 1$ 
      00088D A6 10            [ 1] 1722 	ld a,#16 
      00088F C1 00 0A         [ 1] 1723 	cp a,base 
      000892 26 08            [ 1] 1724 	jrne 3$
      000894 A6 24            [ 1] 1725 	ld a,#'$
      000896 90 5A            [ 2] 1726 	decw y  
      000898 90 F7            [ 1] 1727 	ld (y),a
      00089A 20 0A            [ 2] 1728 	jra 9$ 
      00089C 0D 01            [ 1] 1729 3$: tnz (SIGN,sp)
      00089E 27 06            [ 1] 1730 	jreq 9$ 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 34.
Hexadecimal [24-Bits]



      0008A0 A6 2D            [ 1] 1731 	ld a,#'-
      0008A2 90 5A            [ 2] 1732 	decw y  
      0008A4 90 F7            [ 1] 1733 	ld (y),a
      0008A6                       1734 9$:	
      0008A6 93               [ 1] 1735 	ldw x,y 
      0008A7 1D 17 5F         [ 2] 1736 	subw x,#pad+PAD_SIZE-1 
      0008AA 50               [ 2] 1737 	negw x  
      0008AB                       1738 10$:
      0008AB 9F               [ 1] 1739 	ld a,xl 
      0008AC C1 00 26         [ 1] 1740 	cp a,tab_width
      0008AF 24 09            [ 1] 1741 	jruge 12$
      0008B1 90 5A            [ 2] 1742 	decw y 
      0008B3 A6 20            [ 1] 1743 	ld a,#SPACE 
      0008B5 90 F7            [ 1] 1744 	ld (y),a
      0008B7 5C               [ 2] 1745 	incw x 
      0008B8 20 F1            [ 2] 1746 	jra 10$ 
      0008BA                       1747 12$:
      0008BA 93               [ 1] 1748     ldw x,y 
      0008BB CD 01 C6         [ 4] 1749 	call puts  
      0008BE                       1750 	_drop VSIZE 
      0008BE 5B 01            [ 2]    1     addw sp,#VSIZE 
      0008C0 81               [ 4] 1751 	ret 
                                   1752 
                                   1753 ;------------------------------------
                                   1754 ; convert integer in acc24 to string
                                   1755 ; input:
                                   1756 ;   A	  	base
                                   1757 ;	acc24	integer to convert
                                   1758 ; output:
                                   1759 ;   X  		pointer to string
                                   1760 ;------------------------------------
                           000001  1761 	SIGN=1  ; integer sign 
                           000002  1762 	BASE=2  ; numeric base 
                           000002  1763 	VSIZE=2  ;locals size
      0008C1                       1764 itoa:
      0008C1 52 02            [ 2] 1765 	sub sp,#VSIZE
      0008C3 6B 02            [ 1] 1766 	ld (BASE,sp), a  ; base
      0008C5 0F 01            [ 1] 1767 	clr (SIGN,sp)    ; sign
      0008C7 A1 0A            [ 1] 1768 	cp a,#10
      0008C9 26 0A            [ 1] 1769 	jrne 1$
                                   1770 	; base 10 string display with negative sign if bit 23==1
      0008CB 72 0F 00 0B 05   [ 2] 1771 	btjf acc24,#7,1$
      0008D0 03 01            [ 1] 1772 	cpl (SIGN,sp)
      0008D2 CD 09 30         [ 4] 1773 	call neg_acc24
      0008D5                       1774 1$:
                                   1775 ; initialize string pointer 
      0008D5 AE 17 5F         [ 2] 1776 	ldw x,#pad+PAD_SIZE-1
      0008D8 7F               [ 1] 1777 	clr (x)
      0008D9                       1778 itoa_loop:
      0008D9 7B 02            [ 1] 1779     ld a,(BASE,sp)
      0008DB CD 09 08         [ 4] 1780     call divu24_8 ; acc24/A 
      0008DE AB 30            [ 1] 1781     add a,#'0  ; remainder of division
      0008E0 A1 3A            [ 1] 1782     cp a,#'9+1
      0008E2 2B 02            [ 1] 1783     jrmi 2$
      0008E4 AB 07            [ 1] 1784     add a,#7 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 35.
Hexadecimal [24-Bits]



      0008E6 5A               [ 2] 1785 2$: decw x
      0008E7 F7               [ 1] 1786     ld (x),a
                                   1787 	; if acc24==0 conversion done
      0008E8 C6 00 0B         [ 1] 1788 	ld a,acc24
      0008EB CA 00 0C         [ 1] 1789 	or a,acc16
      0008EE CA 00 0D         [ 1] 1790 	or a,acc8
      0008F1 26 E6            [ 1] 1791     jrne itoa_loop
                                   1792 	;conversion done, next add '$' or '-' as required
      0008F3 7B 02            [ 1] 1793 	ld a,(BASE,sp)
      0008F5 A1 10            [ 1] 1794 	cp a,#16
      0008F7 27 08            [ 1] 1795 	jreq 8$
      0008F9 7B 01            [ 1] 1796 	ld a,(SIGN,sp)
      0008FB 27 08            [ 1] 1797     jreq 10$
      0008FD A6 2D            [ 1] 1798     ld a,#'-
      0008FF 20 02            [ 2] 1799 	jra 9$ 
      000901 A6 24            [ 1] 1800 8$: ld a,#'$ 
      000903 5A               [ 2] 1801 9$: decw x
      000904 F7               [ 1] 1802     ld (x),a
      000905                       1803 10$:
      000905 5B 02            [ 2] 1804 	addw sp,#VSIZE
      000907 81               [ 4] 1805 	ret
                                   1806 
                                   1807 ;-------------------------------------
                                   1808 ; divide uint24_t by uint8_t
                                   1809 ; used to convert uint24_t to string
                                   1810 ; input:
                                   1811 ;	acc24	dividend
                                   1812 ;   A 		divisor
                                   1813 ; output:
                                   1814 ;   acc24	quotient
                                   1815 ;   A		remainder
                                   1816 ;------------------------------------- 
                                   1817 ; offset  on sp of arguments and locals
                           000001  1818 	U8   = 1   ; divisor on stack
                           000001  1819 	VSIZE =1
      000908                       1820 divu24_8:
      000908 89               [ 2] 1821 	pushw x ; save x
      000909 88               [ 1] 1822 	push a 
                                   1823 	; ld dividend UU:MM bytes in X
      00090A C6 00 0B         [ 1] 1824 	ld a, acc24
      00090D 95               [ 1] 1825 	ld xh,a
      00090E C6 00 0C         [ 1] 1826 	ld a,acc24+1
      000911 97               [ 1] 1827 	ld xl,a
      000912 7B 01            [ 1] 1828 	ld a,(U8,SP) ; divisor
      000914 62               [ 2] 1829 	div x,a ; UU:MM/U8
      000915 88               [ 1] 1830 	push a  ;save remainder
      000916 9E               [ 1] 1831 	ld a,xh
      000917 C7 00 0B         [ 1] 1832 	ld acc24,a
      00091A 9F               [ 1] 1833 	ld a,xl
      00091B C7 00 0C         [ 1] 1834 	ld acc24+1,a
      00091E 84               [ 1] 1835 	pop a
      00091F 95               [ 1] 1836 	ld xh,a
      000920 C6 00 0D         [ 1] 1837 	ld a,acc24+2
      000923 97               [ 1] 1838 	ld xl,a
      000924 7B 01            [ 1] 1839 	ld a,(U8,sp) ; divisor
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 36.
Hexadecimal [24-Bits]



      000926 62               [ 2] 1840 	div x,a  ; R:LL/U8
      000927 6B 01            [ 1] 1841 	ld (U8,sp),a ; save remainder
      000929 9F               [ 1] 1842 	ld a,xl
      00092A C7 00 0D         [ 1] 1843 	ld acc24+2,a
      00092D 84               [ 1] 1844 	pop a
      00092E 85               [ 2] 1845 	popw x
      00092F 81               [ 4] 1846 	ret
                                   1847 
                                   1848 ;------------------------------------
                                   1849 ;  two's complement acc24
                                   1850 ;  input:
                                   1851 ;		acc24 variable
                                   1852 ;  output:
                                   1853 ;		acc24 variable
                                   1854 ;-------------------------------------
      000930                       1855 neg_acc24:
      000930 72 53 00 0D      [ 1] 1856 	cpl acc24+2
      000934 72 53 00 0C      [ 1] 1857 	cpl acc24+1
      000938 72 53 00 0B      [ 1] 1858 	cpl acc24
      00093C A6 01            [ 1] 1859 	ld a,#1
      00093E CB 00 0D         [ 1] 1860 	add a,acc24+2
      000941 C7 00 0D         [ 1] 1861 	ld acc24+2,a
      000944 4F               [ 1] 1862 	clr a
      000945 C9 00 0C         [ 1] 1863 	adc a,acc24+1
      000948 C7 00 0C         [ 1] 1864 	ld acc24+1,a 
      00094B 4F               [ 1] 1865 	clr a 
      00094C C9 00 0B         [ 1] 1866 	adc a,acc24 
      00094F C7 00 0B         [ 1] 1867 	ld acc24,a 
      000952 81               [ 4] 1868 	ret
                                   1869 
                                   1870 
                                   1871 ;------------------------------------
                                   1872 ; read a line of text from terminal
                                   1873 ; input:
                                   1874 ;	none
                                   1875 ; local variable on stack:
                                   1876 ;	LL  line length
                                   1877 ;   RXCHAR last received chaaracte 
                                   1878 ; output:
                                   1879 ;   text in tib  buffer
                                   1880 ;------------------------------------
                                   1881 	; local variables
                           000001  1882 	LL_HB=1
                           000001  1883 	RXCHAR = 1 ; last char received
                           000002  1884 	LL = 2  ; accepted line length
                           000002  1885 	VSIZE=2 
      000953                       1886 readln:
      000953 5F               [ 1] 1887 	clrw x 
      000954 89               [ 2] 1888 	pushw x 
      000955 90 AE 16 E8      [ 2] 1889  	ldw y,#tib ; input buffer
      000959                       1890 readln_loop:
      000959 CD 01 BC         [ 4] 1891 	call getc
      00095C 6B 01            [ 1] 1892 	ld (RXCHAR,sp),a
      00095E A1 0D            [ 1] 1893 	cp a,#CR
      000960 26 03            [ 1] 1894 	jrne 1$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 37.
Hexadecimal [24-Bits]



      000962 CC 09 CE         [ 2] 1895 	jp readln_quit
      000965 A1 0A            [ 1] 1896 1$:	cp a,#NL
      000967 27 65            [ 1] 1897 	jreq readln_quit
      000969 A1 08            [ 1] 1898 	cp a,#BSP
      00096B 27 3D            [ 1] 1899 	jreq del_back
      00096D A1 04            [ 1] 1900 	cp a,#CTRL_D
      00096F 27 2A            [ 1] 1901 	jreq del_ln
      000971 A1 12            [ 1] 1902 	cp a,#CTRL_R 
      000973 27 06            [ 1] 1903 	jreq reprint 
                                   1904 ;	cp a,#'[
                                   1905 ;	jreq ansi_seq
      000975                       1906 final_test:
      000975 A1 20            [ 1] 1907 	cp a,#SPACE
      000977 2A 40            [ 1] 1908 	jrpl accept_char
      000979 20 DE            [ 2] 1909 	jra readln_loop
      00097B                       1910 ansi_seq:
                                   1911 ;	call getc
                                   1912 ;	cp a,#'C 
                                   1913 ;	jreq rigth_arrow
                                   1914 ;	cp a,#'D 
                                   1915 ;	jreq left_arrow 
                                   1916 ;	jra final_test
      00097B                       1917 right_arrow:
                                   1918 ;	ld a,#BSP 
                                   1919 ;	call putc 
                                   1920 ;	jra realn_loop 
      00097B                       1921 left_arrow:
                                   1922 
                                   1923 ;	jra readln_loop
      00097B                       1924 reprint: 
      00097B 0D 02            [ 1] 1925 	tnz (LL,sp)
      00097D 26 DA            [ 1] 1926 	jrne readln_loop
      00097F AE 16 E8         [ 2] 1927 	ldw x,#tib 
      000982 CD 01 FA         [ 4] 1928 	call strlen 
      000985 90 AE 16 E8      [ 2] 1929 	ldw y,#tib 
      000989 9F               [ 1] 1930 	ld a,xl
      00098A 27 CD            [ 1] 1931 	jreq readln_loop
      00098C 6B 02            [ 1] 1932 	ld (LL,sp),a 
      00098E AE 16 E8         [ 2] 1933 	ldw x,#tib 
      000991 CD 01 C6         [ 4] 1934 	call puts
      000994 0F 01            [ 1] 1935 	clr (LL_HB,sp)
      000996 72 F9 01         [ 2] 1936 	addw y,(LL_HB,sp)
      000999 20 BE            [ 2] 1937 	jra readln_loop 
      00099B                       1938 del_ln:
      00099B 7B 02            [ 1] 1939 	ld a,(LL,sp)
      00099D CD 01 E0         [ 4] 1940 	call delete
      0009A0 90 AE 16 E8      [ 2] 1941 	ldw y,#tib
      0009A4 90 7F            [ 1] 1942 	clr (y)
      0009A6 0F 02            [ 1] 1943 	clr (LL,sp)
      0009A8 20 AF            [ 2] 1944 	jra readln_loop
      0009AA                       1945 del_back:
      0009AA 0D 02            [ 1] 1946     tnz (LL,sp)
      0009AC 27 AB            [ 1] 1947     jreq readln_loop
      0009AE 0A 02            [ 1] 1948     dec (LL,sp)
      0009B0 90 5A            [ 2] 1949     decw y
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 38.
Hexadecimal [24-Bits]



      0009B2 90 7F            [ 1] 1950     clr  (y)
      0009B4 CD 01 D0         [ 4] 1951     call bksp 
      0009B7 20 A0            [ 2] 1952     jra readln_loop	
      0009B9                       1953 accept_char:
      0009B9 A6 4F            [ 1] 1954 	ld a,#TIB_SIZE-1
      0009BB 11 02            [ 1] 1955 	cp a, (LL,sp)
      0009BD 27 9A            [ 1] 1956 	jreq readln_loop
      0009BF 7B 01            [ 1] 1957 	ld a,(RXCHAR,sp)
      0009C1 90 F7            [ 1] 1958 	ld (y),a
      0009C3 0C 02            [ 1] 1959 	inc (LL,sp)
      0009C5 90 5C            [ 2] 1960 	incw y
      0009C7 90 7F            [ 1] 1961 	clr (y)
      0009C9 CD 01 B3         [ 4] 1962 	call putc 
      0009CC 20 8B            [ 2] 1963 	jra readln_loop
      0009CE                       1964 readln_quit:
      0009CE 90 7F            [ 1] 1965 	clr (y)
      0009D0 7B 02            [ 1] 1966 	ld a,(LL,sp)
      0009D2 C7 00 03         [ 1] 1967 	ld count,a 
      0009D5                       1968 	_drop VSIZE 
      0009D5 5B 02            [ 2]    1     addw sp,#VSIZE 
      0009D7 A6 0D            [ 1] 1969 	ld a,#CR
      0009D9 CD 01 B3         [ 4] 1970 	call putc
      0009DC 81               [ 4] 1971 	ret
                                   1972 
                           000000  1973 .if DEBUG 	
                                   1974 ;----------------------------
                                   1975 ; command interface
                                   1976 ; only 3 commands:
                                   1977 ;  'q' to resume application
                                   1978 ;  'p [addr]' to print memory values 
                                   1979 ;  's addr' to print string 
                                   1980 ;----------------------------
                                   1981 ;local variable 
                                   1982 	PSIZE=1
                                   1983 	VSIZE=1 
                                   1984 cmd_itf:
                                   1985 	sub sp,#VSIZE 
                                   1986 	clr farptr 
                                   1987 	clr farptr+1 
                                   1988 	clr farptr+2  
                                   1989 repl:
                                   1990 	ld a,#CR 
                                   1991 	call putc 
                                   1992 	ld a,#'? 
                                   1993 	call putc
                                   1994 	clr in.w 
                                   1995 	clr in 
                                   1996 	call readln
                                   1997 	ldw y,#tib  
                                   1998 	ld a,(y)
                                   1999 	jreq repl  
                                   2000 	inc in 
                                   2001 	call to_upper 
                                   2002 	cp a,#'Q 
                                   2003 	jrne test_p
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 39.
Hexadecimal [24-Bits]



                                   2004 repl_exit:
                                   2005 	clr tib 
                                   2006 	clr count 
                                   2007 	clr in 
                                   2008 	_drop #VSIZE 	
                                   2009 	ret  
                                   2010 invalid:
                                   2011 	ldw x,#invalid_cmd 
                                   2012 	call puts 
                                   2013 	jra repl 
                                   2014 test_p:	
                                   2015     cp a,#'P 
                                   2016 	jreq mem_peek
                                   2017     cp a,#'S 
                                   2018 	jrne invalid 
                                   2019 print_string:	
                                   2020 	call get_token
                                   2021 	cp a,#TK_INTGR 
                                   2022 	jrne invalid 
                                   2023 	call puts
                                   2024 	jp repl 	
                                   2025 mem_peek:
                                   2026 	ld a,#SPACE 
                                   2027 	call skip  	 
                                   2028 	addw y,in.w 
                                   2029 	ldw x,#pad 
                                   2030 	call strcpy
                                   2031 	call atoi24 	
                                   2032 	ld a, acc24 
                                   2033 	or a,acc16 
                                   2034 	or a,acc8 
                                   2035 	jrne 1$ 
                                   2036 	jra peek_byte  
                                   2037 1$:	ldw x,acc24 
                                   2038 	ldw farptr,x 
                                   2039 	ld a,acc8 
                                   2040 	ld farptr+2,a 
                                   2041 peek_byte:
                                   2042 	call print_farptr 
                                   2043 	ld a,#8 
                                   2044 	ld (PSIZE,sp),a 
                                   2045 	clrw x 
                                   2046 1$:	call fetchc  
                                   2047 	pushw x 
                                   2048 	ld acc8,a 
                                   2049 	clrw x 
                                   2050 	ldw acc24,x 
                                   2051 	ld a,#16+128
                                   2052 	call prti24
                                   2053 	popw x 
                                   2054 	dec (PSIZE,sp)
                                   2055 	jrne 1$ 
                                   2056 	ld a,#8 
                                   2057 	add a,farptr+2 
                                   2058 	ld farptr+2,a
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 40.
Hexadecimal [24-Bits]



                                   2059 	clr a 
                                   2060 	adc a,farptr+1 
                                   2061 	ld farptr+1,a 
                                   2062 	clr a 
                                   2063 	adc a,farptr 
                                   2064 	ld farptr,a 
                                   2065 	jp repl  
                                   2066 
                                   2067 invalid_cmd: .asciz "not a command\n" 
                                   2068 
                                   2069 ;----------------------------
                                   2070 ; display farptr address
                                   2071 ;----------------------------
                                   2072 print_farptr:
                                   2073 	ld a ,farptr+2 
                                   2074 	ld acc8,a 
                                   2075 	ldw x,farptr 
                                   2076 	ldw acc24,x 
                                   2077 	clrw x 
                                   2078 	ld a,#16 
                                   2079 	call prti24
                                   2080 	ld a,#SPACE 
                                   2081 	call putc 
                                   2082 	call putc 
                                   2083 	ret
                                   2084 
                                   2085 ;------------------------------------
                                   2086 ; get byte at address farptr[X]
                                   2087 ; input:
                                   2088 ;	 farptr   address to peek
                                   2089 ;    X		  farptr index 	
                                   2090 ; output:
                                   2091 ;	 A 		  byte from memory  
                                   2092 ;    x		  incremented by 1
                                   2093 ;------------------------------------
                                   2094 fetchc: ; @C
                                   2095 	ldf a,([farptr],x)
                                   2096 	incw x
                                   2097 	ret
                                   2098 
                                   2099 
                                   2100 ;------------------------------------
                                   2101 ; expect a number from command line 
                                   2102 ; next argument
                                   2103 ;  input:
                                   2104 ;	  none
                                   2105 ;  output:
                                   2106 ;    acc24   int24_t 
                                   2107 ;------------------------------------
                                   2108 number::
                                   2109 	call get_token
                                   2110 	call atoi24
                                   2111 	ret
                                   2112 .endif ; DEBUG 
                                   2113 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 41.
Hexadecimal [24-Bits]



                                   2114 
                                   2115 
                                   2116 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2117 ;; compiler routines        ;;
                                   2118 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2119 ;------------------------------------
                                   2120 ; parse quoted string 
                                   2121 ; input:
                                   2122 ;   Y 	pointer to tib 
                                   2123 ;   X   pointer to pad
                                   2124 ; output:
                                   2125 ;	pad   parsed string
                                   2126 ;   TOS  char* to pad  
                                   2127 ;------------------------------------
                           000001  2128 	PREV = 1
                           000002  2129 	CURR =2 
                           000002  2130 	VSIZE=2 
      0009DD                       2131 parse_quote: ; { -- addr }
      0009DD                       2132 	_vars VSIZE 
      0009DD 52 02            [ 2]    1     sub sp,#VSIZE 
      0009DF 4F               [ 1] 2133 	clr a
      0009E0 6B 01            [ 1] 2134 1$:	ld (PREV,sp),a 
      0009E2 72 5C 00 01      [ 1] 2135 2$:	inc in
      0009E6 91 D6 00         [ 4] 2136 	ld a,([in.w],y)
      0009E9 27 24            [ 1] 2137 	jreq 6$
      0009EB 6B 02            [ 1] 2138 	ld (CURR,sp),a 
      0009ED A6 5C            [ 1] 2139 	ld a,#'\
      0009EF 11 01            [ 1] 2140 	cp a, (PREV,sp)
      0009F1 26 0A            [ 1] 2141 	jrne 3$
      0009F3 0F 01            [ 1] 2142 	clr (PREV,sp)
      0009F5 7B 02            [ 1] 2143 	ld a,(CURR,sp)
      0009F7 AD 1F            [ 4] 2144 	callr convert_escape
      0009F9 F7               [ 1] 2145 	ld (x),a 
      0009FA 5C               [ 2] 2146 	incw x 
      0009FB 20 E5            [ 2] 2147 	jra 2$
      0009FD                       2148 3$:
      0009FD 7B 02            [ 1] 2149 	ld a,(CURR,sp)
      0009FF A1 5C            [ 1] 2150 	cp a,#'\'
      000A01 27 DD            [ 1] 2151 	jreq 1$
      000A03 A1 22            [ 1] 2152 	cp a,#'"
      000A05 27 04            [ 1] 2153 	jreq 5$ 
      000A07 F7               [ 1] 2154 	ld (x),a 
      000A08 5C               [ 2] 2155 	incw x 
      000A09 20 D7            [ 2] 2156 	jra 2$
      000A0B 72 5C 00 01      [ 1] 2157 5$:	inc in 
      000A0F 7F               [ 1] 2158 6$: clr (x)
      000A10 AE 17 38         [ 2] 2159 	ldw x,#pad 
      000A13                       2160 	_drop VSIZE
      000A13 5B 02            [ 2]    1     addw sp,#VSIZE 
      000A15 A6 0A            [ 1] 2161 	ld a,#TK_QSTR  
      000A17 81               [ 4] 2162 	ret 
                                   2163 
                                   2164 ;---------------------------------------
                                   2165 ; called by parse_quote
                                   2166 ; subtitute escaped character 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 42.
Hexadecimal [24-Bits]



                                   2167 ; by their ASCII value .
                                   2168 ; input:
                                   2169 ;   A  character following '\'
                                   2170 ; output:
                                   2171 ;   A  substitued char or same if not valid.
                                   2172 ;---------------------------------------
      000A18                       2173 convert_escape:
      000A18 89               [ 2] 2174 	pushw x 
      000A19 AE 0A 2D         [ 2] 2175 	ldw x,#escaped 
      000A1C F1               [ 1] 2176 1$:	cp a,(x)
      000A1D 27 06            [ 1] 2177 	jreq 2$
      000A1F 7D               [ 1] 2178 	tnz (x)
      000A20 27 09            [ 1] 2179 	jreq 3$
      000A22 5C               [ 2] 2180 	incw x 
      000A23 20 F7            [ 2] 2181 	jra 1$
      000A25 1D 0A 2D         [ 2] 2182 2$: subw x,#escaped 
      000A28 9F               [ 1] 2183 	ld a,xl 
      000A29 AB 07            [ 1] 2184 	add a,#7
      000A2B 85               [ 2] 2185 3$:	popw x 
      000A2C 81               [ 4] 2186 	ret 
                                   2187 
      000A2D 61 62 74 6E 76 66 72  2188 escaped: .asciz "abtnvfr"
             00
                                   2189 
                                   2190 ;-------------------------
                                   2191 ; integer parser 
                                   2192 ; input:
                                   2193 ;   X 		point to pad 
                                   2194 ;   Y 		point to tib 
                                   2195 ;   A 	    first digit|'$' 
                                   2196 ; output:  
                                   2197 ;   pad     number string 
                                   2198 ;   X 		integer 
                                   2199 ;   A 		TK_INTGR
                                   2200 ;-------------------------
                           000001  2201 	BASE=1
                           000002  2202 	TCHAR=2 
                           000002  2203 	VSIZE=2 
      000A35                       2204 parse_integer: ; { -- n }
      000A35 4B 00            [ 1] 2205 	push #0 ; TCHAR 
      000A37 A1 24            [ 1] 2206 	cp a,#'$
      000A39 27 04            [ 1] 2207 	jreq 1$ 
      000A3B 4B 0A            [ 1] 2208 	push #10 ; BASE=10 
      000A3D 20 02            [ 2] 2209 	jra 2$ 
      000A3F 4B 10            [ 1] 2210 1$: push #16  ; BASE=16
      000A41 F7               [ 1] 2211 2$:	ld (x),a 
      000A42 5C               [ 2] 2212 	incw x 
      000A43 72 5C 00 01      [ 1] 2213 	inc in 
      000A47 91 D6 00         [ 4] 2214 	ld a,([in.w],y)
      000A4A CD 0C 93         [ 4] 2215 	call to_upper 
      000A4D 6B 02            [ 1] 2216 	ld (TCHAR,sp),a 
      000A4F CD 0C 8A         [ 4] 2217 	call is_digit 
      000A52 25 ED            [ 1] 2218 	jrc 2$
      000A54 A6 10            [ 1] 2219 	ld a,#16 
      000A56 11 01            [ 1] 2220 	cp a,(BASE,sp)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 43.
Hexadecimal [24-Bits]



      000A58 26 0A            [ 1] 2221 	jrne 3$ 
      000A5A 7B 02            [ 1] 2222 	ld a,(TCHAR,sp)
      000A5C A1 41            [ 1] 2223 	cp a,#'A 
      000A5E 2B 04            [ 1] 2224 	jrmi 3$ 
      000A60 A1 47            [ 1] 2225 	cp a,#'G 
      000A62 2B DD            [ 1] 2226 	jrmi 2$ 
      000A64 7F               [ 1] 2227 3$:	clr (x)
      000A65 CD 0C 9F         [ 4] 2228 	call atoi24
      000A68 CE 00 0C         [ 2] 2229 	ldw x,acc16 
      000A6B A6 04            [ 1] 2230 	ld a,#TK_INTGR
      000A6D                       2231 	_drop VSIZE  
      000A6D 5B 02            [ 2]    1     addw sp,#VSIZE 
      000A6F 81               [ 4] 2232 	ret 	
                                   2233 
                                   2234 ;-------------------------
                                   2235 ; binary integer parser 
                                   2236 ; input:
                                   2237 ;   X 		point to pad 
                                   2238 ;   Y 		point to tib 
                                   2239 ;   A 	    '%' 
                                   2240 ; output:  
                                   2241 ;   pad     number string 
                                   2242 ;   X 		integer 
                                   2243 ;   A 		TK_INTGR
                                   2244 ;   TOS     integer 
                                   2245 ;-------------------------
                           000001  2246 	BINARY=1
                           000002  2247 	VSIZE=2
      000A70                       2248 parse_binary: ; { -- n }
      000A70 4B 00            [ 1] 2249 	push #0
      000A72 4B 00            [ 1] 2250 	push #0
      000A74 F7               [ 1] 2251 1$: ld (x),a 
      000A75 5C               [ 2] 2252 	incw x 
      000A76 72 5C 00 01      [ 1] 2253 	inc in 
      000A7A 91 D6 00         [ 4] 2254 	ld a,([in.w],y)
      000A7D A1 30            [ 1] 2255 	cp a,#'0 
      000A7F 27 06            [ 1] 2256 	jreq 2$
      000A81 A1 31            [ 1] 2257 	cp a,#'1 
      000A83 27 02            [ 1] 2258 	jreq 2$ 
      000A85 20 09            [ 2] 2259 	jra bin_exit 
      000A87 A0 30            [ 1] 2260 2$: sub a,#'0	
      000A89 46               [ 1] 2261 	rrc a 
      000A8A 09 02            [ 1] 2262 	rlc (BINARY+1,sp)
      000A8C 09 01            [ 1] 2263 	rlc (BINARY,sp)
      000A8E 20 E4            [ 2] 2264 	jra 1$  
      000A90                       2265 bin_exit:
      000A90 7F               [ 1] 2266 	clr (x)
      000A91 1E 01            [ 2] 2267 	ldw x,(BINARY,sp)
      000A93 A6 04            [ 1] 2268 	ld a,#TK_INTGR 	
      000A95                       2269 	_drop VSIZE 
      000A95 5B 02            [ 2]    1     addw sp,#VSIZE 
      000A97 81               [ 4] 2270 	ret
                                   2271 
                                   2272 ;---------------------------
                                   2273 ;  token begin with a letter,
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 44.
Hexadecimal [24-Bits]



                                   2274 ;  is keyword or variable. 	
                                   2275 ; input:
                                   2276 ;   X 		point to pad 
                                   2277 ;   Y 		point to text
                                   2278 ;   A 	    first letter  
                                   2279 ; output:
                                   2280 ;   X		exec_addr|var_addr 
                                   2281 ;   A 		TK_CMD 
                                   2282 ;   pad 	keyword|var_name  
                                   2283 ;   TOS     exec_addr|var_addr 
                                   2284 ;--------------------------  
      000A98                       2285 parse_keyword: ; { -- exec_addr|var_addr}
      000A98 CD 0C 93         [ 4] 2286 	call to_upper 
      000A9B F7               [ 1] 2287 	ld (x),a 
      000A9C 5C               [ 2] 2288 	incw x 
      000A9D 72 5C 00 01      [ 1] 2289 	inc in 
      000AA1 91 D6 00         [ 4] 2290 	ld a,([in.w],y)
      000AA4 CD 04 7D         [ 4] 2291 	call is_alpha 
      000AA7 25 EF            [ 1] 2292 	jrc parse_keyword 
      000AA9 7F               [ 1] 2293 1$: clr (x)
      000AAA 72 5D 17 39      [ 1] 2294 	tnz pad+1 
      000AAE 26 15            [ 1] 2295 	jrne 2$
                                   2296 ; one letter variable name 
      000AB0 C6 17 38         [ 1] 2297 	ld a,pad 
      000AB3 A0 41            [ 1] 2298 	sub a,#'A 
      000AB5 48               [ 1] 2299 	sll a 
      000AB6 88               [ 1] 2300 	push a 
      000AB7 4B 00            [ 1] 2301 	push #0
      000AB9 AE 00 28         [ 2] 2302 	ldw x,#vars 
      000ABC 72 FB 01         [ 2] 2303 	addw x,(1,sp) ; X=var address 
      000ABF                       2304 	_drop 2 
      000ABF 5B 02            [ 2]    1     addw sp,#2 
      000AC1 A6 05            [ 1] 2305 	ld a,#TK_VAR 
      000AC3 20 0C            [ 2] 2306 	jra 4$ 
      000AC5                       2307 2$: ; check for keyword, otherwise syntax error.
      000AC5                       2308 	_ldx_dict kword_dict
      000AC5 AE 25 64         [ 2]    1     ldw x,#kword_dict+2
      000AC8 CD 0F 06         [ 4] 2309 	call search_dict
      000ACB 4D               [ 1] 2310 	tnz a
      000ACC 26 03            [ 1] 2311 	jrne 4$ 
      000ACE CC 07 12         [ 2] 2312 	jp syntax_error
      000AD1 81               [ 4] 2313 4$:	ret  	
                                   2314 
                                   2315 
                                   2316 ;------------------------------------
                                   2317 ; scan text for next token
                                   2318 ; move token in 'pad'
                                   2319 ; input: 
      000AD2                       2320 	none: 
                                   2321 ; use:
                                   2322 ;	Y   pointer to text
                                   2323 ;   X	pointer to pad 
                                   2324 ;   in.w   index in text buffer
                                   2325 ; output:
                                   2326 ;   A       token attribute 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 45.
Hexadecimal [24-Bits]



                                   2327 ;   pad 	token as .asciz
                                   2328 ;   X 		token value   
                                   2329 ;------------------------------------
                                   2330 	; use to check special character 
                                   2331 	.macro _case c t  
                                   2332 	ld a,#c 
                                   2333 	cp a,(TCHAR,sp) 
                                   2334 	jrne t
                                   2335 	.endm 
                                   2336 
                           000001  2337 	TCHAR=1
                           000002  2338 	ATTRIB=2 
                           000002  2339 	VSIZE=2
      000AD2                       2340 get_token: 
      000AD2 90 AE 16 E8      [ 2] 2341 	ldw y,#tib    	
      000AD6 C6 00 01         [ 1] 2342 	ld a,in 
      000AD9 C1 00 03         [ 1] 2343 	cp a,count 
      000ADC 2B 03            [ 1] 2344 	jrmi 1$
      000ADE A6 00            [ 1] 2345 	ld a,#TK_NONE 
      000AE0 81               [ 4] 2346 	ret 
      000AE1                       2347 1$:	
      000AE1                       2348 	_vars VSIZE
      000AE1 52 02            [ 2]    1     sub sp,#VSIZE 
      000AE3 AE 17 38         [ 2] 2349 	ldw x, #pad
      000AE6 A6 20            [ 1] 2350 	ld a,#SPACE
      000AE8 CD 0D 4B         [ 4] 2351 	call skip
      000AEB 55 00 01 00 02   [ 1] 2352 	mov in.saved,in 
      000AF0 91 D6 00         [ 4] 2353 	ld a,([in.w],y)
      000AF3 26 07            [ 1] 2354 	jrne str_tst
      000AF5 72 5F 17 38      [ 1] 2355 	clr pad 
      000AF9 CC 0C 87         [ 2] 2356 	jp token_exit ; end of line 
                                   2357 
      000AFC                       2358 str_tst: ; check for quoted string  	
      000AFC CD 0C 93         [ 4] 2359 	call to_upper 
      000AFF 6B 01            [ 1] 2360 	ld (TCHAR,sp),a 
      000B01                       2361 	_case '"' nbr_tst
      000B01 A6 22            [ 1]    1 	ld a,#'"' 
      000B03 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B05 26 06            [ 1]    3 	jrne nbr_tst
      000B07 CD 09 DD         [ 4] 2362 	call parse_quote
      000B0A CC 0C 87         [ 2] 2363 	jp token_exit
      000B0D                       2364 nbr_tst: ; check for number 
      000B0D A6 24            [ 1] 2365 	ld a,#'$'
      000B0F 11 01            [ 1] 2366 	cp a,(TCHAR,sp) 
      000B11 27 13            [ 1] 2367 	jreq 1$
      000B13 A6 26            [ 1] 2368 	ld a,#'&
      000B15 11 01            [ 1] 2369 	cp a,(TCHAR,sp)
      000B17 26 06            [ 1] 2370 	jrne 0$
      000B19 CD 0A 70         [ 4] 2371 	call parse_binary ; expect binary integer 
      000B1C CC 0C 87         [ 2] 2372 	jp token_exit 
      000B1F 7B 01            [ 1] 2373 0$:	ld a,(TCHAR,sp)
      000B21 CD 0C 8A         [ 4] 2374 	call is_digit
      000B24 24 06            [ 1] 2375 	jrnc 3$
      000B26 CD 0A 35         [ 4] 2376 1$:	call parse_integer 
      000B29 CC 0C 87         [ 2] 2377 	jp token_exit 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 46.
Hexadecimal [24-Bits]



      000B2C                       2378 3$: 
      000B2C                       2379 	_case '(' bkslsh_tst 
      000B2C A6 28            [ 1]    1 	ld a,#'(' 
      000B2E 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B30 26 05            [ 1]    3 	jrne bkslsh_tst
      000B32 A6 0B            [ 1] 2380 	ld a,#TK_LPAREN
      000B34 CC 0C 77         [ 2] 2381 	jp token_char   	
      000B37                       2382 bkslsh_tst: ; character token 
      000B37                       2383 	_case '\',rparnt_tst
      000B37 A6 5C            [ 1]    1 	ld a,#'\' 
      000B39 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B3B 26 18            [ 1]    3 	jrne rparnt_tst
      000B3D 7B 01            [ 1] 2384 	ld a,(TCHAR,sp)
      000B3F F7               [ 1] 2385 	ld (x),a 
      000B40 5C               [ 2] 2386 	incw x 
      000B41 72 5C 00 01      [ 1] 2387 	inc in 
      000B45 91 D6 00         [ 4] 2388 	ld a,([in.w],y)
      000B48 F7               [ 1] 2389 	ld (x),a 
      000B49 5C               [ 2] 2390 	incw x 
      000B4A 72 5C 00 01      [ 1] 2391 	inc in  
      000B4E 7F               [ 1] 2392 	clr (x) 
      000B4F 97               [ 1] 2393 	ld xl,a 
      000B50 A6 03            [ 1] 2394 	ld a,#TK_CHAR 
      000B52 CC 0C 87         [ 2] 2395 	jp token_exit 
      000B55                       2396 rparnt_tst:		
      000B55                       2397 	_case ')' colon_tst 
      000B55 A6 29            [ 1]    1 	ld a,#')' 
      000B57 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B59 26 05            [ 1]    3 	jrne colon_tst
      000B5B A6 0C            [ 1] 2398 	ld a,#TK_RPAREN 
      000B5D CC 0C 77         [ 2] 2399 	jp token_char 
      000B60                       2400 colon_tst:
      000B60                       2401 	_case ':' comma_tst 
      000B60 A6 3A            [ 1]    1 	ld a,#':' 
      000B62 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B64 26 05            [ 1]    3 	jrne comma_tst
      000B66 A6 01            [ 1] 2402 	ld a,#TK_COLON 
      000B68 CC 0C 77         [ 2] 2403 	jp token_char 
      000B6B                       2404 comma_tst:
      000B6B                       2405 	_case COMMA sharp_tst 
      000B6B A6 2C            [ 1]    1 	ld a,#COMMA 
      000B6D 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B6F 26 05            [ 1]    3 	jrne sharp_tst
      000B71 A6 0D            [ 1] 2406 	ld a,#TK_COMMA
      000B73 CC 0C 77         [ 2] 2407 	jp token_char
      000B76                       2408 sharp_tst:
      000B76                       2409 	_case SHARP dash_tst 
      000B76 A6 23            [ 1]    1 	ld a,#SHARP 
      000B78 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B7A 26 05            [ 1]    3 	jrne dash_tst
      000B7C A6 0E            [ 1] 2410 	ld a,#TK_SHARP
      000B7E CC 0C 77         [ 2] 2411 	jp token_char  	 	 
      000B81                       2412 dash_tst: 	
      000B81                       2413 	_case '-' at_tst 
      000B81 A6 2D            [ 1]    1 	ld a,#'-' 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 47.
Hexadecimal [24-Bits]



      000B83 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B85 26 05            [ 1]    3 	jrne at_tst
      000B87 A6 11            [ 1] 2414 	ld a,#TK_MINUS  
      000B89 CC 0C 77         [ 2] 2415 	jp token_char 
      000B8C                       2416 at_tst:
      000B8C                       2417 	_case '@' qmark_tst 
      000B8C A6 40            [ 1]    1 	ld a,#'@' 
      000B8E 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B90 26 05            [ 1]    3 	jrne qmark_tst
      000B92 A6 02            [ 1] 2418 	ld a,#TK_ARRAY 
      000B94 CC 0C 77         [ 2] 2419 	jp token_char
      000B97                       2420 qmark_tst:
      000B97                       2421 	_case '?' tick_tst 
      000B97 A6 3F            [ 1]    1 	ld a,#'?' 
      000B99 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000B9B 26 11            [ 1]    3 	jrne tick_tst
      000B9D 7B 01            [ 1] 2422 	ld a,(TCHAR,sp)
      000B9F F7               [ 1] 2423 	ld (x),a 
      000BA0 5C               [ 2] 2424 	incw x 
      000BA1 7F               [ 1] 2425 	clr (x)
      000BA2 72 5C 00 01      [ 1] 2426 	inc in 
      000BA6 A6 06            [ 1] 2427 	ld a,#TK_CMD 
      000BA8 AE 13 AD         [ 2] 2428 	ldw x,#print 
      000BAB CC 0C 87         [ 2] 2429 	jp token_exit
      000BAE                       2430 tick_tst: ; ignore comment 
      000BAE                       2431 	_case TICK plus_tst 
      000BAE A6 27            [ 1]    1 	ld a,#TICK 
      000BB0 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000BB2 26 0C            [ 1]    3 	jrne plus_tst
      000BB4 72 5C 00 01      [ 1] 2432 	inc in 
      000BB8 A6 06            [ 1] 2433 	ld a,#TK_CMD 
      000BBA AE 14 9C         [ 2] 2434 	ldw x,#rem 
      000BBD CC 0C 87         [ 2] 2435 	jp token_exit 
      000BC0                       2436 plus_tst:
      000BC0                       2437 	_case '+' star_tst 
      000BC0 A6 2B            [ 1]    1 	ld a,#'+' 
      000BC2 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000BC4 26 05            [ 1]    3 	jrne star_tst
      000BC6 A6 10            [ 1] 2438 	ld a,#TK_PLUS  
      000BC8 CC 0C 77         [ 2] 2439 	jp token_char 
      000BCB                       2440 star_tst:
      000BCB                       2441 	_case '*' slash_tst 
      000BCB A6 2A            [ 1]    1 	ld a,#'*' 
      000BCD 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000BCF 26 05            [ 1]    3 	jrne slash_tst
      000BD1 A6 20            [ 1] 2442 	ld a,#TK_MULT 
      000BD3 CC 0C 77         [ 2] 2443 	jp token_char 
      000BD6                       2444 slash_tst: 
      000BD6                       2445 	_case '/' prcnt_tst 
      000BD6 A6 2F            [ 1]    1 	ld a,#'/' 
      000BD8 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000BDA 26 05            [ 1]    3 	jrne prcnt_tst
      000BDC A6 21            [ 1] 2446 	ld a,#TK_DIV 
      000BDE CC 0C 77         [ 2] 2447 	jp token_char 
      000BE1                       2448 prcnt_tst:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 48.
Hexadecimal [24-Bits]



      000BE1                       2449 	_case '%' eql_tst 
      000BE1 A6 25            [ 1]    1 	ld a,#'%' 
      000BE3 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000BE5 26 05            [ 1]    3 	jrne eql_tst
      000BE7 A6 22            [ 1] 2450 	ld a,#TK_MOD
      000BE9 CC 0C 77         [ 2] 2451 	jp token_char  
                                   2452 ; 1 or 2 character tokens 	
      000BEC                       2453 eql_tst:
      000BEC                       2454 	_case '=' gt_tst 		
      000BEC A6 3D            [ 1]    1 	ld a,#'=' 
      000BEE 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000BF0 26 05            [ 1]    3 	jrne gt_tst
      000BF2 A6 32            [ 1] 2455 	ld a,#TK_EQUAL
      000BF4 CC 0C 77         [ 2] 2456 	jp token_char 
      000BF7                       2457 gt_tst:
      000BF7                       2458 	_case '>' lt_tst 
      000BF7 A6 3E            [ 1]    1 	ld a,#'>' 
      000BF9 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000BFB 26 33            [ 1]    3 	jrne lt_tst
      000BFD A6 31            [ 1] 2459 	ld a,#TK_GT 
      000BFF 6B 02            [ 1] 2460 	ld (ATTRIB,sp),a 
      000C01 72 5C 00 01      [ 1] 2461 	inc in 
      000C05 91 D6 00         [ 4] 2462 	ld a,([in.w],y)
      000C08 A1 3D            [ 1] 2463 	cp a,#'=
      000C0A 26 0C            [ 1] 2464 	jrne 1$
      000C0C 7B 01            [ 1] 2465 	ld a,(TCHAR,sp)
      000C0E F7               [ 1] 2466 	ld (x),a
      000C0F 5C               [ 2] 2467 	incw x 
      000C10 A6 3D            [ 1] 2468 	ld a,#'=
      000C12 6B 01            [ 1] 2469 	ld (TCHAR,sp),a 
      000C14 A6 33            [ 1] 2470 	ld a,#TK_GE 
      000C16 20 5F            [ 2] 2471 	jra token_char  
      000C18 A1 3C            [ 1] 2472 1$: cp a,#'<
      000C1A 26 0C            [ 1] 2473 	jrne 2$
      000C1C 7B 01            [ 1] 2474 	ld a,(TCHAR,sp)
      000C1E F7               [ 1] 2475 	ld (x),a
      000C1F 5C               [ 2] 2476 	incw x 
      000C20 A6 3C            [ 1] 2477 	ld a,#'<	
      000C22 6B 01            [ 1] 2478 	ld (TCHAR,sp),a 
      000C24 A6 35            [ 1] 2479 	ld a,#TK_NE 
      000C26 20 4F            [ 2] 2480 	jra token_char 
      000C28 72 5A 00 01      [ 1] 2481 2$: dec in
      000C2C 7B 02            [ 1] 2482 	ld a,(ATTRIB,sp)
      000C2E 20 47            [ 2] 2483 	jra token_char 
      000C30                       2484 lt_tst:
      000C30                       2485 	_case '<' other
      000C30 A6 3C            [ 1]    1 	ld a,#'<' 
      000C32 11 01            [ 1]    2 	cp a,(TCHAR,sp) 
      000C34 26 32            [ 1]    3 	jrne other
      000C36 A6 34            [ 1] 2486 	ld a,#TK_LT 
      000C38 6B 02            [ 1] 2487 	ld (ATTRIB,sp),a 
      000C3A 72 5C 00 01      [ 1] 2488 	inc in 
      000C3E 91 D6 00         [ 4] 2489 	ld a,([in.w],y)
      000C41 A1 3D            [ 1] 2490 	cp a,#'=
      000C43 26 0B            [ 1] 2491 	jrne 1$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 49.
Hexadecimal [24-Bits]



      000C45 7B 01            [ 1] 2492 	ld a,(TCHAR,sp)
      000C47 F7               [ 1] 2493 	ld (x),a 
      000C48 A6 3D            [ 1] 2494 	ld a,#'=
      000C4A 6B 01            [ 1] 2495 	ld (TCHAR,sp),a 
      000C4C A6 36            [ 1] 2496 	ld a,#TK_LE 
      000C4E 20 27            [ 2] 2497 	jra token_char 
      000C50 A1 3E            [ 1] 2498 1$: cp a,#'>
      000C52 26 0C            [ 1] 2499 	jrne 2$
      000C54 7B 01            [ 1] 2500 	ld a,(TCHAR,sp)
      000C56 F7               [ 1] 2501 	ld (x),a 
      000C57 5C               [ 2] 2502 	incw x 
      000C58 A6 3E            [ 1] 2503 	ld a,#'>
      000C5A 6B 01            [ 1] 2504 	ld (TCHAR,sp),a 
      000C5C A6 35            [ 1] 2505 	ld a,#TK_NE 
      000C5E 20 17            [ 2] 2506 	jra token_char 
      000C60 72 5A 00 01      [ 1] 2507 2$: dec in 
      000C64 7B 02            [ 1] 2508 	ld a,(ATTRIB,sp)
      000C66 20 0F            [ 2] 2509 	jra token_char 	
      000C68                       2510 other: ; not a special character 	 
      000C68 7B 01            [ 1] 2511 	ld a,(TCHAR,sp)
      000C6A CD 04 7D         [ 4] 2512 	call is_alpha 
      000C6D 25 03            [ 1] 2513 	jrc 30$ 
      000C6F CC 07 12         [ 2] 2514 	jp syntax_error 
      000C72                       2515 30$: 
      000C72 CD 0A 98         [ 4] 2516 	call parse_keyword
      000C75 20 10            [ 2] 2517 	jra token_exit 
      000C77                       2518 token_char:
      000C77 6B 02            [ 1] 2519 	ld (ATTRIB,sp),a 
      000C79 7B 01            [ 1] 2520 	ld a,(TCHAR,sp)
      000C7B F7               [ 1] 2521 	ld (x),a 
      000C7C 5C               [ 2] 2522 	incw x 
      000C7D 7F               [ 1] 2523 	clr(x)
      000C7E 72 5C 00 01      [ 1] 2524 	inc in 
      000C82 7B 02            [ 1] 2525 	ld a,(ATTRIB,sp)
      000C84 AE 17 38         [ 2] 2526 	ldw x,#pad 
      000C87                       2527 token_exit:
      000C87                       2528 	_drop VSIZE 
      000C87 5B 02            [ 2]    1     addw sp,#VSIZE 
      000C89 81               [ 4] 2529 	ret
                                   2530 
                                   2531 ;------------------------------------
                                   2532 ; check if character in {'0'..'9'}
                                   2533 ; input:
                                   2534 ;    A  character to test
                                   2535 ; output:
                                   2536 ;    Carry  0 not digit | 1 digit
                                   2537 ;------------------------------------
      000C8A                       2538 is_digit:
      000C8A A1 30            [ 1] 2539 	cp a,#'0
      000C8C 25 03            [ 1] 2540 	jrc 1$
      000C8E A1 3A            [ 1] 2541     cp a,#'9+1
      000C90 8C               [ 1] 2542 	ccf 
      000C91 8C               [ 1] 2543 1$:	ccf 
      000C92 81               [ 4] 2544     ret
                                   2545 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 50.
Hexadecimal [24-Bits]



                                   2546 ;------------------------------------
                                   2547 ; convert alpha to uppercase
                                   2548 ; input:
                                   2549 ;    a  character to convert
                                   2550 ; output:
                                   2551 ;    a  uppercase character
                                   2552 ;------------------------------------
      000C93                       2553 to_upper::
      000C93 A1 61            [ 1] 2554 	cp a,#'a
      000C95 2A 01            [ 1] 2555 	jrpl 1$
      000C97 81               [ 4] 2556 0$:	ret
      000C98 A1 7A            [ 1] 2557 1$: cp a,#'z	
      000C9A 22 FB            [ 1] 2558 	jrugt 0$
      000C9C A0 20            [ 1] 2559 	sub a,#32
      000C9E 81               [ 4] 2560 	ret
                                   2561 	
                                   2562 ;------------------------------------
                                   2563 ; convert pad content in integer
                                   2564 ; input:
                                   2565 ;    pad		.asciz to convert
                                   2566 ; output:
                                   2567 ;    acc24      int24_t
                                   2568 ;------------------------------------
                                   2569 	; local variables
                           000001  2570 	SIGN=1 ; 1 byte, 
                           000002  2571 	BASE=2 ; 1 byte, numeric base used in conversion
                           000003  2572 	TEMP=3 ; 1 byte, temporary storage
                           000003  2573 	VSIZE=3 ; 3 bytes reserved for local storage
      000C9F                       2574 atoi24:
      000C9F 89               [ 2] 2575 	pushw x ;save x
      000CA0 52 03            [ 2] 2576 	sub sp,#VSIZE
                                   2577 	; acc24=0 
      000CA2 72 5F 00 0B      [ 1] 2578 	clr acc24    
      000CA6 72 5F 00 0C      [ 1] 2579 	clr acc16
      000CAA 72 5F 00 0D      [ 1] 2580 	clr acc8 
      000CAE C6 17 38         [ 1] 2581 	ld a, pad 
      000CB1 27 5A            [ 1] 2582 	jreq atoi_exit
      000CB3 0F 01            [ 1] 2583 	clr (SIGN,sp)
      000CB5 A6 0A            [ 1] 2584 	ld a,#10
      000CB7 6B 02            [ 1] 2585 	ld (BASE,sp),a ; default base decimal
      000CB9 AE 17 38         [ 2] 2586 	ldw x,#pad ; pointer to string to convert
      000CBC F6               [ 1] 2587 	ld a,(x)
      000CBD 27 47            [ 1] 2588 	jreq 9$  ; completed if 0
      000CBF A1 2D            [ 1] 2589 	cp a,#'-
      000CC1 26 04            [ 1] 2590 	jrne 1$
      000CC3 03 01            [ 1] 2591 	cpl (SIGN,sp)
      000CC5 20 08            [ 2] 2592 	jra 2$
      000CC7 A1 24            [ 1] 2593 1$: cp a,#'$
      000CC9 26 06            [ 1] 2594 	jrne 3$
      000CCB A6 10            [ 1] 2595 	ld a,#16
      000CCD 6B 02            [ 1] 2596 	ld (BASE,sp),a
      000CCF 5C               [ 2] 2597 2$:	incw x
      000CD0 F6               [ 1] 2598 	ld a,(x)
      000CD1                       2599 3$:	
      000CD1 A1 61            [ 1] 2600 	cp a,#'a
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 51.
Hexadecimal [24-Bits]



      000CD3 2B 02            [ 1] 2601 	jrmi 4$
      000CD5 A0 20            [ 1] 2602 	sub a,#32
      000CD7 A1 30            [ 1] 2603 4$:	cp a,#'0
      000CD9 2B 2B            [ 1] 2604 	jrmi 9$
      000CDB A0 30            [ 1] 2605 	sub a,#'0
      000CDD A1 0A            [ 1] 2606 	cp a,#10
      000CDF 2B 06            [ 1] 2607 	jrmi 5$
      000CE1 A0 07            [ 1] 2608 	sub a,#7
      000CE3 11 02            [ 1] 2609 	cp a,(BASE,sp)
      000CE5 2A 1F            [ 1] 2610 	jrpl 9$
      000CE7 6B 03            [ 1] 2611 5$:	ld (TEMP,sp),a
      000CE9 7B 02            [ 1] 2612 	ld a,(BASE,sp)
      000CEB CD 0D 11         [ 4] 2613 	call mulu24_8
      000CEE 7B 03            [ 1] 2614 	ld a,(TEMP,sp)
      000CF0 CB 00 0D         [ 1] 2615 	add a,acc24+2
      000CF3 C7 00 0D         [ 1] 2616 	ld acc24+2,a
      000CF6 4F               [ 1] 2617 	clr a
      000CF7 C9 00 0C         [ 1] 2618 	adc a,acc24+1
      000CFA C7 00 0C         [ 1] 2619 	ld acc24+1,a
      000CFD 4F               [ 1] 2620 	clr a
      000CFE C9 00 0B         [ 1] 2621 	adc a,acc24
      000D01 C7 00 0B         [ 1] 2622 	ld acc24,a
      000D04 20 C9            [ 2] 2623 	jra 2$
      000D06 0D 01            [ 1] 2624 9$:	tnz (SIGN,sp)
      000D08 27 03            [ 1] 2625     jreq atoi_exit
      000D0A CD 09 30         [ 4] 2626     call neg_acc24
      000D0D                       2627 atoi_exit: 
      000D0D 5B 03            [ 2] 2628 	addw sp,#VSIZE
      000D0F 85               [ 2] 2629 	popw x ; restore x
      000D10 81               [ 4] 2630 	ret
                                   2631 
                                   2632 ;--------------------------------------
                                   2633 ; unsigned multiply uint24_t by uint8_t
                                   2634 ; use to convert numerical string to uint24_t
                                   2635 ; input:
                                   2636 ;	acc24	uint24_t 
                                   2637 ;   A		uint8_t
                                   2638 ; output:
                                   2639 ;   acc24   A*acc24
                                   2640 ;-------------------------------------
                                   2641 ; local variables offset  on sp
                           000003  2642 	U8   = 3   ; A pushed on stack
                           000002  2643 	OVFL = 2  ; multiplicaton overflow low byte
                           000001  2644 	OVFH = 1  ; multiplication overflow high byte
                           000003  2645 	VSIZE = 3
      000D11                       2646 mulu24_8:
      000D11 89               [ 2] 2647 	pushw x    ; save X
                                   2648 	; local variables
      000D12 88               [ 1] 2649 	push a     ; U8
      000D13 5F               [ 1] 2650 	clrw x     ; initialize overflow to 0
      000D14 89               [ 2] 2651 	pushw x    ; multiplication overflow
                                   2652 ; multiply low byte.
      000D15 C6 00 0D         [ 1] 2653 	ld a,acc24+2
      000D18 97               [ 1] 2654 	ld xl,a
      000D19 7B 03            [ 1] 2655 	ld a,(U8,sp)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 52.
Hexadecimal [24-Bits]



      000D1B 42               [ 4] 2656 	mul x,a
      000D1C 9F               [ 1] 2657 	ld a,xl
      000D1D C7 00 0D         [ 1] 2658 	ld acc24+2,a
      000D20 9E               [ 1] 2659 	ld a, xh
      000D21 6B 02            [ 1] 2660 	ld (OVFL,sp),a
                                   2661 ; multipy middle byte
      000D23 C6 00 0C         [ 1] 2662 	ld a,acc24+1
      000D26 97               [ 1] 2663 	ld xl,a
      000D27 7B 03            [ 1] 2664 	ld a, (U8,sp)
      000D29 42               [ 4] 2665 	mul x,a
                                   2666 ; add overflow to this partial product
      000D2A 72 FB 01         [ 2] 2667 	addw x,(OVFH,sp)
      000D2D 9F               [ 1] 2668 	ld a,xl
      000D2E C7 00 0C         [ 1] 2669 	ld acc24+1,a
      000D31 4F               [ 1] 2670 	clr a
      000D32 A9 00            [ 1] 2671 	adc a,#0
      000D34 6B 01            [ 1] 2672 	ld (OVFH,sp),a
      000D36 9E               [ 1] 2673 	ld a,xh
      000D37 6B 02            [ 1] 2674 	ld (OVFL,sp),a
                                   2675 ; multiply most signficant byte	
      000D39 C6 00 0B         [ 1] 2676 	ld a, acc24
      000D3C 97               [ 1] 2677 	ld xl, a
      000D3D 7B 03            [ 1] 2678 	ld a, (U8,sp)
      000D3F 42               [ 4] 2679 	mul x,a
      000D40 72 FB 01         [ 2] 2680 	addw x, (OVFH,sp)
      000D43 9F               [ 1] 2681 	ld a, xl
      000D44 C7 00 0B         [ 1] 2682 	ld acc24,a
      000D47 5B 03            [ 2] 2683     addw sp,#VSIZE
      000D49 85               [ 2] 2684 	popw x
      000D4A 81               [ 4] 2685 	ret
                                   2686 
                                   2687 ;------------------------------------
                                   2688 ; skip character c in text starting from 'in'
                                   2689 ; input:
                                   2690 ;	 y 		point to text buffer
                                   2691 ;    a 		character to skip
                                   2692 ; output:  
                                   2693 ;	'in' ajusted to new position
                                   2694 ;------------------------------------
                           000001  2695 	C = 1 ; local var
      000D4B                       2696 skip:
      000D4B 88               [ 1] 2697 	push a
      000D4C 91 D6 00         [ 4] 2698 1$:	ld a,([in.w],y)
      000D4F 27 0A            [ 1] 2699 	jreq 2$
      000D51 11 01            [ 1] 2700 	cp a,(C,sp)
      000D53 26 06            [ 1] 2701 	jrne 2$
      000D55 72 5C 00 01      [ 1] 2702 	inc in
      000D59 20 F1            [ 2] 2703 	jra 1$
      000D5B                       2704 2$: _drop 1 
      000D5B 5B 01            [ 2]    1     addw sp,#1 
      000D5D 81               [ 4] 2705 	ret
                                   2706 	
                                   2707 ;------------------------------
                                   2708 ; restore 'in.w' variable to 
                                   2709 ; its value before last call
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 53.
Hexadecimal [24-Bits]



                                   2710 ; to get_token.
                                   2711 ;------------------------------
      000D5E                       2712 unget_token:
      000D5E 55 00 02 00 01   [ 1] 2713 	mov in,in.saved
      000D63 81               [ 4] 2714 	ret 
                                   2715 
                                   2716 
                                   2717 ;******************************
                                   2718 ;  data stack manipulation
                                   2719 ;*****************************
                                   2720 ;----------------------	
                                   2721 ; push X on data stack 
                                   2722 ; input:
                                   2723 ;	X 
                                   2724 ; output:
                                   2725 ;	none 
                                   2726 ;----------------------	
      000D64                       2727 dpush:
      000D64                       2728     _dp_down
      000D64 72 5A 00 1D      [ 1]    1     dec dstkptr+1 
      000D68 72 5A 00 1D      [ 1]    2     dec dstkptr+1
      000D6C 72 CF 00 1C      [ 5] 2729     ldw [dstkptr],x  
      000D70 81               [ 4] 2730 	ret 
                                   2731 
                                   2732 
                                   2733 ;----------------------	
                                   2734 ; pop data stack in X 
                                   2735 ; input:
                                   2736 ;	none
                                   2737 ; output:
                                   2738 ;	X   
                                   2739 ;----------------------	
      000D71                       2740 dpop: 
      000D71 72 CE 00 1C      [ 5] 2741     ldw x, [dstkptr]
      000D75                       2742 	_dp_up
      000D75 72 5C 00 1D      [ 1]    1     inc dstkptr+1
      000D79 72 5C 00 1D      [ 1]    2     inc dstkptr+1
      000D7D 81               [ 4] 2743 	ret 
                                   2744 
                                   2745 ;-----------------------------
                                   2746 ; swap top 2 elements of dstack
                                   2747 ;  {n1 n2 -- n2 n1 }
                                   2748 ;-----------------------------
      000D7E                       2749 dswap:
      000D7E 72 CE 00 1C      [ 5] 2750 	ldw x,[dstkptr]
      000D82 89               [ 2] 2751 	pushw x 
      000D83 AE 00 02         [ 2] 2752 	ldw x,#2 
      000D86 72 DE 00 1C      [ 5] 2753 	ldw x,([dstkptr],x) 
      000D8A 72 CF 00 1C      [ 5] 2754 	ldw [dstkptr],x 
      000D8E AE 00 02         [ 2] 2755 	ldw x,#2
      000D91 90 85            [ 2] 2756 	popw y 
      000D93 72 DF 00 1C      [ 5] 2757 	ldw ([dstkptr],x),y 
      000D97 81               [ 4] 2758 	ret
                                   2759 
                                   2760 ;-----------------------------
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 54.
Hexadecimal [24-Bits]



                                   2761 ; drop TOS 
                                   2762 ;-----------------------------
      000D98                       2763 ddrop: ; { n -- }
      000D98                       2764 	_dp_up 
      000D98 72 5C 00 1D      [ 1]    1     inc dstkptr+1
      000D9C 72 5C 00 1D      [ 1]    2     inc dstkptr+1
      000DA0 81               [ 4] 2765 	ret
                                   2766 	
                                   2767 ;-----------------------------
                                   2768 ; duplicate TOS 
                                   2769 ;  dstack: { ix...n -- ix...n n }
                                   2770 ;-----------------------------
      000DA1                       2771 ddup:
                                   2772 ;	ldw x,[dstkptr]
                                   2773 ;	_dp_down
                                   2774 ;   ldw [dstkptr],x  
                                   2775 ;	ret 
                                   2776 
                                   2777 
                                   2778 ;----------------------------------
                                   2779 ; pick value n from dstack 
                                   2780 ; put it on TOS
                                   2781 ; dstack: {ix,..,p -- ix,...,np }
                                   2782 ;-----------------------------------
      000DA1                       2783 dpick:
                                   2784 ;	ldw x,[dstkptr]
                                   2785 ;	sllw x 
                                   2786 ;	addw x,dstkptr 
                                   2787 ;	ldw x,(x)
                                   2788 ;	ldw [dstkptr],x 
                                   2789 ;	ret
                                   2790 
                                   2791 ;---------------------------
                                   2792 ;  fetch variable in X 
                                   2793 ;  dstack:{ addr -- value }
                                   2794 ;---------------------------
      000DA1                       2795 fetch:
      000DA1 72 CE 00 1C      [ 5] 2796 	ldw x,[dstkptr]
      000DA5 FE               [ 2] 2797 	ldw x,(x)
      000DA6 72 CF 00 1C      [ 5] 2798 	ldw [dstkptr],x
      000DAA 81               [ 4] 2799 	ret 
                                   2800 
                                   2801 ;----------------------------
                                   2802 ; store variable 
                                   2803 ; dstack: {addr value -- }
                                   2804 ;----------------------------
      000DAB                       2805 store:
      000DAB CD 0D 71         [ 4] 2806 	call dpop 
      000DAE 90 93            [ 1] 2807 	ldw y,x   ; y=value 
      000DB0 CD 0D 71         [ 4] 2808 	call dpop 
      000DB3 FF               [ 2] 2809 	ldw (x),y 
      000DB4 81               [ 4] 2810 	ret 
                                   2811 
                                   2812 ;---------------------------------
                                   2813 ; drop n elements from data stack 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 55.
Hexadecimal [24-Bits]



                                   2814 ; input: 
                                   2815 ;   X 		n 
                                   2816 ; output:
                                   2817 ;   none 
                                   2818 ;-------------------------------------
      000DB5                       2819 ddrop_n:
      000DB5 58               [ 2] 2820 	sllw x
      000DB6 72 BB 00 1C      [ 2] 2821 	addw x,dstkptr 
      000DBA CF 00 1C         [ 2] 2822 	ldw dstkptr,x  
      000DBD 81               [ 4] 2823 	ret 
                                   2824 
      000DBE 0A 64 73 74 61 63 6B  2825 dstk_prompt: .asciz "\ndstack: " 
             3A 20 00
                                   2826 ;----------------------------
                                   2827 ; print dstack content 
                                   2828 ;---------------------------
                           000001  2829 	XSAVE=1
                           000002  2830 	VSIZE=2
      000DC8                       2831 dots:
      000DC8                       2832 	_vars VSIZE 
      000DC8 52 02            [ 2]    1     sub sp,#VSIZE 
      000DCA AE 0D BE         [ 2] 2833 	ldw x,#dstk_prompt 
      000DCD CD 01 C6         [ 4] 2834 	call puts
      000DD0 AE 17 7E         [ 2] 2835 	ldw x,#dstack_empty-CELL_SIZE
      000DD3 35 0A 00 0A      [ 1] 2836 	mov base,#10 
      000DD7 C3 00 1C         [ 2] 2837 1$:	cpw x,dstkptr 
      000DDA 25 0D            [ 1] 2838 	jrult 4$ 
      000DDC 1F 01            [ 2] 2839 	ldw (XSAVE,sp),x
      000DDE FE               [ 2] 2840 	ldw  x,(x)
      000DDF CD 08 63         [ 4] 2841 	call print_int 
      000DE2 1E 01            [ 2] 2842 	ldw x,(XSAVE,sp)
      000DE4 1D 00 02         [ 2] 2843 	subw x,#CELL_SIZE 
      000DE7 20 EE            [ 2] 2844 	jra 1$ 
      000DE9 A6 0D            [ 1] 2845 4$: ld a,#CR 
      000DEB CD 01 B3         [ 4] 2846 	call putc 
      000DEE                       2847 	_drop VSIZE
      000DEE 5B 02            [ 2]    1     addw sp,#VSIZE 
      000DF0 4F               [ 1] 2848 	clr a 
      000DF1 81               [ 4] 2849 	ret
                                   2850 
      000DF2 0A 63 73 74 61 63 6B  2851 cstk_prompt: .asciz "\ncstack: "
             3A 20 00
                                   2852 ;--------------------------------
                                   2853 ; print cstack content
                                   2854 ;--------------------------------
                           000001  2855 	XSAVE=1
                           000002  2856 	VSIZE=2 
      000DFC                       2857 dotr:
      000DFC                       2858 	_vars VSIZE 
      000DFC 52 02            [ 2]    1     sub sp,#VSIZE 
      000DFE AE 0D F2         [ 2] 2859 	ldw x,#cstk_prompt
      000E01 CD 01 C6         [ 4] 2860 	call puts 
      000E04 96               [ 1] 2861 	ldw x,sp 
      000E05 1C 00 07         [ 2] 2862 	addw x,#7 ; ignore XSAVE and 2 levels of return address.
      000E08 1F 01            [ 2] 2863 	ldw (XSAVE,sp),x  
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 56.
Hexadecimal [24-Bits]



      000E0A AE 17 FE         [ 2] 2864 	ldw x,#RAM_SIZE-2
      000E0D 35 10 00 0A      [ 1] 2865 	mov base,#16
      000E11                       2866 dotr_loop:
      000E11 13 01            [ 2] 2867 	cpw x,(XSAVE,sp)
      000E13 2B 0B            [ 1] 2868 	jrmi 9$
      000E15 89               [ 2] 2869 	pushw x  
      000E16 FE               [ 2] 2870 	ldw x,(x)
      000E17 CD 08 63         [ 4] 2871 	call print_int 
      000E1A 85               [ 2] 2872 	popw x  
      000E1B 1D 00 02         [ 2] 2873 	subw x,#CELL_SIZE
      000E1E 20 F1            [ 2] 2874 	jra dotr_loop 
      000E20 A6 0D            [ 1] 2875 9$:	ld a,#CR 
      000E22 CD 01 B3         [ 4] 2876 	call putc 
      000E25                       2877 	_drop VSIZE 
      000E25 5B 02            [ 2]    1     addw sp,#VSIZE 
      000E27 4F               [ 1] 2878 	clr a 
      000E28 81               [ 4] 2879 	ret
                                   2880 
                                   2881 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2882 ;;   TINY BASIC  operators,
                                   2883 ;;   commands and functions 
                                   2884 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2885 
                                   2886 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2887 ;;  Arithmetic operators
                                   2888 ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   2889 
                                   2890 ;--------------------------------
                                   2891 ;  add 2 integers
                                   2892 ;  input:
                                   2893 ;    N1     on cstack 
                                   2894 ;    N2     on cstack 
                                   2895 ;  output:
                                   2896 ;    X 		n2+n1 
                                   2897 ;--------------------------------
                                   2898 	;arugments on cstack 
      000E29                       2899 	_argofs 0 
                           000002     1     ARG_OFS=2+0 
      000E29                       2900 	_arg N1 1 
                           000003     1     N1=ARG_OFS+1 
      000E29                       2901 	_arg N2 3 
                           000005     1     N2=ARG_OFS+3 
      000E29                       2902 add:
      000E29 1E 05            [ 2] 2903 	ldw x ,(N2,sp)
      000E2B 72 FB 03         [ 2] 2904 	addw x,(N1,sp)
      000E2E 1F 03            [ 2] 2905 	ldw (N1,sp),x 
      000E30 81               [ 4] 2906 	ret 
                                   2907 
                                   2908 ;--------------------------------
                                   2909 ;  substract 2 ntegers
                                   2910 ;  input:
                                   2911 ;    N1     on cstack 
                                   2912 ;    N2     on cstack 
                                   2913 ;  output:
                                   2914 ;    X 		n2+n1 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 57.
Hexadecimal [24-Bits]



                                   2915 ;--------------------------------
      000E31                       2916 	_argofs 0 
                           000002     1     ARG_OFS=2+0 
      000E31                       2917 	_arg N1 1 
                           000003     1     N1=ARG_OFS+1 
      000E31                       2918 	_arg N2 3 
                           000005     1     N2=ARG_OFS+3 
      000E31                       2919 substract:
      000E31 1E 05            [ 2] 2920 	ldw x,(N2,sp)
      000E33 72 F0 03         [ 2] 2921 	subw x,(N1,sp)
      000E36 81               [ 4] 2922 	ret 
                                   2923 
                                   2924 ;-------------------------------------
                                   2925 ; multiply 2 integers
                                   2926 ; product overflow is ignored unless
                                   2927 ; MATH_OVF assembler flag is set to 1
                                   2928 ; input:
                                   2929 ;  	N1      on cstack
                                   2930 ;   N2 		on cstack 
                                   2931 ; output:
                                   2932 ;	X        N1*N2 
                                   2933 ;-------------------------------------
                                   2934 	;arguments 
      000E37                       2935 	_argofs 3
                           000005     1     ARG_OFS=2+3 
      000E37                       2936 	_arg N1_HB 1
                           000006     1     N1_HB=ARG_OFS+1 
      000E37                       2937 	_arg N1_LB 2
                           000007     1     N1_LB=ARG_OFS+2 
      000E37                       2938 	_arg N2_HB 3
                           000008     1     N2_HB=ARG_OFS+3 
      000E37                       2939 	_arg N2_LB 4 
                           000009     1     N2_LB=ARG_OFS+4 
                                   2940    ; local variables 
                           000001  2941 	SIGN=1
                           000002  2942 	PROD=2
                           000003  2943 	VSIZE=3
      000E37                       2944 multiply:
      000E37                       2945 	_vars VSIZE 
      000E37 52 03            [ 2]    1     sub sp,#VSIZE 
      000E39 0F 01            [ 1] 2946 	clr (SIGN,sp)
      000E3B 1E 06            [ 2] 2947 	ldw x,(N1_HB,sp)
      000E3D 9E               [ 1] 2948 	ld a,xh  
      000E3E A5 80            [ 1] 2949 	bcp a,#0x80 
      000E40 27 05            [ 1] 2950 	jreq 2$
      000E42 03 01            [ 1] 2951 	cpl (SIGN,sp)
      000E44 50               [ 2] 2952 	negw x 
      000E45 1F 06            [ 2] 2953 	ldw (N1_HB,sp),x 
      000E47 1E 08            [ 2] 2954 2$: ldw x,(N2_HB,sp)
      000E49 9E               [ 1] 2955 	ld a,xh  
      000E4A A5 80            [ 1] 2956 	bcp a,#0x80 
      000E4C 27 05            [ 1] 2957 	jreq 3$
      000E4E 03 01            [ 1] 2958 	cpl (SIGN,sp)
      000E50 50               [ 2] 2959 	negw x 
      000E51 1F 08            [ 2] 2960 	ldw (N2_HB,sp),x 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 58.
Hexadecimal [24-Bits]



                                   2961 ; N1_LB * N2_LB 	
      000E53 7B 07            [ 1] 2962 3$:	ld a,(N1_LB,sp)
      000E55 97               [ 1] 2963 	ld xl,a 
      000E56 7B 09            [ 1] 2964 	ld a,(N2_LB,sp) 
      000E58 42               [ 4] 2965 	mul x,a 
                           000000  2966 .if MATH_OVF 	
                                   2967 	ld a,xh 
                                   2968 	bcp a,#0x80 
                                   2969 	jreq 4$ 
                                   2970 	ld a,#ERR_MATH_OVF 
                                   2971 	jp tb_error
                                   2972 .endif 	 
      000E59 1F 02            [ 2] 2973 4$:	ldw (PROD,sp),x
                                   2974 ; N1_LB * N2_HB	 
      000E5B 7B 07            [ 1] 2975 	ld a,(N1_LB,sp) 
      000E5D 97               [ 1] 2976 	ld xl,a 
      000E5E 7B 08            [ 1] 2977 	ld a,(N2_HB,sp)
      000E60 42               [ 4] 2978 	mul x,a
      000E61 9F               [ 1] 2979 	ld a,xl 
      000E62 1B 02            [ 1] 2980 	add a,(PROD,sp)
                           000000  2981 .if MATH_OVF 	
                                   2982 	bcp a,#0x80 
                                   2983 	jreq 5$ 
                                   2984 	ld a,#ERR_MATH_OVF 
                                   2985 	jp tb_error
                                   2986 .endif 	 
      000E64 6B 02            [ 1] 2987 5$:	ld (PROD,sp),a 
                                   2988 ; N1_HB * N2_LB 
      000E66 7B 06            [ 1] 2989 	ld a,(N1_HB,sp)
      000E68 97               [ 1] 2990 	ld xl,a 
      000E69 7B 09            [ 1] 2991 	ld a,(N2_LB,sp)
      000E6B 42               [ 4] 2992 	mul x,a 
      000E6C 9F               [ 1] 2993 	ld a,xl 
      000E6D 1B 02            [ 1] 2994 	add a,(PROD,sp)
                           000000  2995 .if MATH_OVF 	
                                   2996 	bcp a,#0x80 
                                   2997 	jreq 6$ 
                                   2998 	ld a,#ERR_MATH_OVF 
                                   2999 	jp tb_error
                                   3000 .endif 	 
      000E6F 6B 02            [ 1] 3001 6$:	ld (PROD,sp),a 
                                   3002 ; N1_HB * N2_HB 	
                                   3003 ; it is pointless to multiply N1_HB*N2_HB 
                                   3004 ; as this product is over 65535 or 0 
                                   3005 ;
                                   3006 ; sign adjust product
      000E71 0D 01            [ 1] 3007 	tnz (SIGN,sp)
      000E73 27 05            [ 1] 3008 	jreq 7$
      000E75 1E 02            [ 2] 3009 	ldw x, (PROD,sp)
      000E77 50               [ 2] 3010 	negw x
      000E78 1F 02            [ 2] 3011 	ldw (PROD,sp),x  
      000E7A                       3012 7$: 
      000E7A 1E 02            [ 2] 3013 	ldw x,(PROD,sp) 
      000E7C                       3014 	_drop VSIZE 
      000E7C 5B 03            [ 2]    1     addw sp,#VSIZE 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 59.
Hexadecimal [24-Bits]



      000E7E 81               [ 4] 3015 	ret
                                   3016 
                                   3017 ;----------------------------------
                                   3018 ;  euclidian divide n2/n1 
                                   3019 ; input:
                                   3020 ;    N2 	on cstack
                                   3021 ;    N1 	on cstack
                                   3022 ; output:
                                   3023 ;    X      n2/n1 
                                   3024 ;    Y      remainder 
                                   3025 ;----------------------------------
      000E7F                       3026 	_argofs 2
                           000004     1     ARG_OFS=2+2 
      000E7F                       3027 	_arg DIVISR 1
                           000005     1     DIVISR=ARG_OFS+1 
      000E7F                       3028 	_arg DIVIDND 3
                           000007     1     DIVIDND=ARG_OFS+3 
                                   3029 	; local variables
                           000001  3030 	SQUOT=1 ; sign quotient
                           000002  3031 	SDIVD=2 ; sign dividend  
                           000002  3032 	VSIZE=2
      000E7F                       3033 divide:
      000E7F                       3034 	_vars VSIZE 
      000E7F 52 02            [ 2]    1     sub sp,#VSIZE 
      000E81 0F 01            [ 1] 3035 	clr (SQUOT,sp)
      000E83 0F 02            [ 1] 3036 	clr (SDIVD,sp)
                                   3037 ; check for 0 divisor
      000E85 1E 05            [ 2] 3038 	ldw x,(DIVISR,sp)
      000E87 5D               [ 2] 3039 	tnzw x 
      000E88 26 05            [ 1] 3040     jrne 0$
      000E8A A6 04            [ 1] 3041 	ld a,#ERR_DIV0 
      000E8C CC 07 14         [ 2] 3042 	jp tb_error 
                                   3043 ; check divisor sign 	
      000E8F 9E               [ 1] 3044 0$:	ld a,xh 
      000E90 A5 80            [ 1] 3045 	bcp a,#0x80 
      000E92 27 03            [ 1] 3046 	jreq 1$
      000E94 03 01            [ 1] 3047 	cpl (SQUOT,sp)
      000E96 50               [ 2] 3048 	negw x 
      000E97 1F 05            [ 2] 3049 1$:	ldw (DIVISR,sp),x
                                   3050 ; check dividend sign 	 
      000E99 1E 07            [ 2] 3051     ldw x,(DIVIDND,sp)
      000E9B 9E               [ 1] 3052 	ld a,xh 
      000E9C A5 80            [ 1] 3053 	bcp a,#0x80 
      000E9E 27 05            [ 1] 3054 	jreq 2$ 
      000EA0 03 01            [ 1] 3055 	cpl (SQUOT,sp)
      000EA2 03 02            [ 1] 3056 	cpl (SDIVD,sp)
      000EA4 50               [ 2] 3057 	negw x 
      000EA5 16 05            [ 2] 3058 2$:	ldw y,(DIVISR,sp)
      000EA7 65               [ 2] 3059 	divw x,y
      000EA8 90 CF 00 0C      [ 2] 3060 	ldw acc16,y 
                                   3061 ; if sign dividend is negative and remainder!=0 inc divisor 	 
      000EAC 0D 02            [ 1] 3062 	tnz (SDIVD,sp)
      000EAE 27 0B            [ 1] 3063 	jreq 7$
      000EB0 90 5D            [ 2] 3064 	tnzw y 
      000EB2 27 07            [ 1] 3065 	jreq 7$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 60.
Hexadecimal [24-Bits]



      000EB4 5C               [ 2] 3066 	incw x
      000EB5 16 05            [ 2] 3067 	ldw y,(DIVISR,sp)
      000EB7 72 B2 00 0C      [ 2] 3068 	subw y,acc16
      000EBB 0D 01            [ 1] 3069 7$: tnz (SQUOT,sp)
      000EBD 27 01            [ 1] 3070 	jreq 9$ 	 
      000EBF 50               [ 2] 3071 8$:	negw x 
      000EC0                       3072 9$: 
      000EC0                       3073 	_drop VSIZE 
      000EC0 5B 02            [ 2]    1     addw sp,#VSIZE 
      000EC2 81               [ 4] 3074 	ret 
                                   3075 
                                   3076 
                                   3077 ;----------------------------------
                                   3078 ;  remainder resulting from euclidian 
                                   3079 ;  division of n2/n1 
                                   3080 ; input:
                                   3081 ;   N1 		cstack 
                                   3082 ;   N2      cstack
                                   3083 ; output:
                                   3084 ;   X       N2%N1 
                                   3085 ;----------------------------------
                           000003  3086 	N1=3
                           000005  3087 	N2=5
                           000004  3088 	VSIZE=4
      000EC3                       3089 modulo:
      000EC3 1E 03            [ 2] 3090 	Ldw x,(N1,sp)
      000EC5 16 05            [ 2] 3091 	ldw y,(N2,sp)
      000EC7                       3092 	_vars VSIZE 
      000EC7 52 04            [ 2]    1     sub sp,#VSIZE 
      000EC9 1F 01            [ 2] 3093 	ldw (1,sp),x 
      000ECB 17 03            [ 2] 3094 	ldw (3,sp),y 
      000ECD CD 0E 7F         [ 4] 3095 	call divide 
      000ED0 93               [ 1] 3096 	ldw x,y
      000ED1                       3097 	_drop VSIZE 
      000ED1 5B 04            [ 2]    1     addw sp,#VSIZE 
      000ED3 81               [ 4] 3098 	ret 
                                   3099 
                                   3100 
                                   3101 ;----------------------------------
                                   3102 ; search in kword_dict name
                                   3103 ; from its execution address 
                                   3104 ; input:
                                   3105 ;   X       	execution address 
                                   3106 ; output:
                                   3107 ;   X 			cstr*  | 0 
                                   3108 ;--------------------------------
                           000001  3109 	XADR=1 
                           000003  3110 	LINK=3 
                           000004  3111 	VSIZE=4
      000ED4                       3112 cmd_name:
      000ED4                       3113 	_vars VSIZE 
      000ED4 52 04            [ 2]    1     sub sp,#VSIZE 
      000ED6 72 5F 00 0C      [ 1] 3114 	clr acc16 
      000EDA 1F 01            [ 2] 3115 	ldw (XADR,sp),x  
      000EDC AE 25 62         [ 2] 3116 	ldw x,#kword_dict	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 61.
Hexadecimal [24-Bits]



      000EDF 1F 03            [ 2] 3117 1$:	ldw (LINK,sp),x
      000EE1 E6 02            [ 1] 3118 	ld a,(2,x)
      000EE3 A4 0F            [ 1] 3119 	and a,#15 
      000EE5 C7 00 0D         [ 1] 3120 	ld acc8,a 
      000EE8 1C 00 03         [ 2] 3121 	addw x,#3
      000EEB 72 BB 00 0C      [ 2] 3122 	addw x,acc16
      000EEF FE               [ 2] 3123 	ldw x,(x) ; execution address 
      000EF0 13 01            [ 2] 3124 	cpw x,(XADR,sp)
      000EF2 27 0A            [ 1] 3125 	jreq 2$
      000EF4 1E 03            [ 2] 3126 	ldw x,(LINK,sp)
      000EF6 FE               [ 2] 3127 	ldw x,(x) 
      000EF7 1D 00 02         [ 2] 3128 	subw x,#2  
      000EFA 26 E3            [ 1] 3129 	jrne 1$
      000EFC 20 05            [ 2] 3130 	jra 9$
      000EFE 1E 03            [ 2] 3131 2$: ldw x,(LINK,sp)
      000F00 1C 00 02         [ 2] 3132 	addw x,#2 	
      000F03                       3133 9$:	_drop VSIZE
      000F03 5B 04            [ 2]    1     addw sp,#VSIZE 
      000F05 81               [ 4] 3134 	ret
                                   3135 
                                   3136 
                                   3137 ;---------------------------------
                                   3138 ; dictionary search 
                                   3139 ; input:
                                   3140 ;	X 		dictionary entry point 
                                   3141 ;  pad		.asciz name to search 
                                   3142 ; output:
                                   3143 ;  A 		TK_CMD|TK_IFUNC|TK_NONE 
                                   3144 ;  X		execution address | 0 
                                   3145 ;---------------------------------
                           000001  3146 	NLEN=1 ; cmd length 
                           000002  3147 	YSAVE=2
                           000003  3148 	VSIZE=3 
      000F06                       3149 search_dict:
      000F06                       3150 	_vars VSIZE 
      000F06 52 03            [ 2]    1     sub sp,#VSIZE 
      000F08 90 93            [ 1] 3151 	ldw y,x 
      000F0A                       3152 search_next:	
      000F0A 90 F6            [ 1] 3153 	ld a,(y)
      000F0C A4 0F            [ 1] 3154 	and a,#0xf 
      000F0E 6B 01            [ 1] 3155 	ld (NLEN,sp),a  
      000F10 AE 17 38         [ 2] 3156 	ldw x,#pad 
      000F13 17 02            [ 2] 3157 	ldw (YSAVE,sp),y
      000F15 90 5C            [ 2] 3158 	incw y  
      000F17                       3159 cp_loop:
      000F17 F6               [ 1] 3160 	ld a,(x)
      000F18 27 1E            [ 1] 3161 	jreq str_match 
      000F1A 0D 01            [ 1] 3162 	tnz (NLEN,sp)
      000F1C 27 0B            [ 1] 3163 	jreq no_match  
      000F1E 90 F1            [ 1] 3164 	cp a,(y)
      000F20 26 07            [ 1] 3165 	jrne no_match 
      000F22 90 5C            [ 2] 3166 	incw y 
      000F24 5C               [ 2] 3167 	incw x
      000F25 0A 01            [ 1] 3168 	dec (NLEN,sp)
      000F27 20 EE            [ 2] 3169 	jra cp_loop 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 62.
Hexadecimal [24-Bits]



      000F29                       3170 no_match:
      000F29 16 02            [ 2] 3171 	ldw y,(YSAVE,sp) 
      000F2B 72 A2 00 02      [ 2] 3172 	subw y,#2 ; move Y to link field
      000F2F 4B 00            [ 1] 3173 	push #TK_NONE 
      000F31 90 FE            [ 2] 3174 	ldw y,(y) ; next word link 
      000F33 84               [ 1] 3175 	pop a ; TK_NONE 
      000F34 27 21            [ 1] 3176 	jreq search_exit  ; not found  
                                   3177 ;try next 
      000F36 20 D2            [ 2] 3178 	jra search_next
      000F38                       3179 str_match:
      000F38 16 02            [ 2] 3180 	ldw y,(YSAVE,sp)
      000F3A 90 F6            [ 1] 3181 	ld a,(y)
      000F3C 6B 01            [ 1] 3182 	ld (NLEN,sp),a ; needed to test keyword type  
      000F3E A4 0F            [ 1] 3183 	and a,#0xf 
                                   3184 ; move y to procedure address field 	
      000F40 4C               [ 1] 3185 	inc a 
      000F41 C7 00 0D         [ 1] 3186 	ld acc8,a 
      000F44 72 5F 00 0C      [ 1] 3187 	clr acc16 
      000F48 72 B9 00 0C      [ 2] 3188 	addw y,acc16 
      000F4C 90 FE            [ 2] 3189 	ldw y,(y) ; routine entry point 
                                   3190 ;determine keyword type bits 7:6 
      000F4E 7B 01            [ 1] 3191 	ld a,(NLEN,sp)
      000F50 4E               [ 1] 3192 	swap a 
      000F51 A4 0C            [ 1] 3193 	and a,#0xc
      000F53 44               [ 1] 3194 	srl a
      000F54 44               [ 1] 3195 	srl a 
      000F55 AB 06            [ 1] 3196 	add a,#6
      000F57                       3197 search_exit: 
      000F57 93               [ 1] 3198 	ldw x,y ; x=routine address 
      000F58                       3199 	_drop VSIZE 	 
      000F58 5B 03            [ 2]    1     addw sp,#VSIZE 
      000F5A 81               [ 4] 3200 	ret 
                                   3201 
                                   3202 ;---------------------
                                   3203 ; check if next token
                                   3204 ;  is of expected type 
                                   3205 ; input:
                                   3206 ;   A 		 expected token attribute
                                   3207 ;  ouput:
                                   3208 ;   none     if fail call syntax_error 
                                   3209 ;--------------------
      000F5B                       3210 expect:
      000F5B 88               [ 1] 3211 	push a 
      000F5C CD 07 C6         [ 4] 3212 	call next_token 
      000F5F 11 01            [ 1] 3213 	cp a,(1,sp)
      000F61 27 03            [ 1] 3214 	jreq 1$
      000F63 CC 07 12         [ 2] 3215 	jp syntax_error
      000F66 84               [ 1] 3216 1$: pop a 
      000F67 81               [ 4] 3217 	ret 
                                   3218 
                                   3219 
                                   3220 ;-------------------------------
                                   3221 ; parse embedded BASIC routines 
                                   3222 ; arguments list.
                                   3223 ; arg_list::=  rel[','rel]*
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 63.
Hexadecimal [24-Bits]



                                   3224 ; all arguments are of integer type
                                   3225 ; and pushed on dstack 
                                   3226 ; input:
                                   3227 ;   none
                                   3228 ; output:
                                   3229 ;   A 	number of arguments pushed on dstack  
                                   3230 ;--------------------------------
                           000001  3231 	ARG_CNT=1 
      000F68                       3232 arg_list:
      000F68 4B 00            [ 1] 3233 	push #0  
      000F6A CD 10 AC         [ 4] 3234 1$: call relation
      000F6D A1 00            [ 1] 3235 	cp a,#TK_NONE 
      000F6F 27 19            [ 1] 3236 	jreq 5$
      000F71 A1 04            [ 1] 3237 	cp a,#TK_INTGR
      000F73 26 12            [ 1] 3238 	jrne 4$
      000F75 CD 0D 64         [ 4] 3239 3$: call dpush 
      000F78 0C 01            [ 1] 3240     inc (ARG_CNT,sp)
      000F7A CD 07 C6         [ 4] 3241 	call next_token 
      000F7D A1 00            [ 1] 3242 	cp a,#TK_NONE 
      000F7F 27 09            [ 1] 3243 	jreq 5$ 
      000F81 A1 0D            [ 1] 3244 	cp a,#TK_COMMA 
      000F83 26 02            [ 1] 3245 	jrne 4$
      000F85 20 E3            [ 2] 3246 	jra 1$ 
      000F87 CD 0D 5E         [ 4] 3247 4$:	call unget_token 
      000F8A 84               [ 1] 3248 5$:	pop a 
      000F8B 81               [ 4] 3249 	ret 
                                   3250 
                                   3251 ;;;;;;;;;;;;;;;;;;;;;;;;;;
                                   3252 ; parse arguments list 
                                   3253 ; between ()
                                   3254 ;;;;;;;;;;;;;;;;;;;;;;;;;;
      000F8C                       3255 func_args:
      000F8C A6 0B            [ 1] 3256 	ld a,#TK_LPAREN 
      000F8E CD 0F 5B         [ 4] 3257 	call expect 
      000F91 CD 0F 68         [ 4] 3258 	call arg_list 
      000F94 88               [ 1] 3259 	push a 
      000F95 A6 0C            [ 1] 3260 	ld a,#TK_RPAREN 
      000F97 CD 0F 5B         [ 4] 3261 	call expect 
      000F9A 84               [ 1] 3262 	pop a 
      000F9B 81               [ 4] 3263 	ret 
                                   3264 
                                   3265 
                                   3266 ;--------------------------------
                                   3267 ;   BASIC commnands 
                                   3268 ;--------------------------------
                                   3269 
                                   3270 ;--------------------------------
                                   3271 ;  arithmetic and relational 
                                   3272 ;  routines
                                   3273 ;  operators precedence
                                   3274 ;  highest to lowest
                                   3275 ;  operators on same row have 
                                   3276 ;  same precedence and are executed
                                   3277 ;  from left to right.
                                   3278 ;	'*','/','%'
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 64.
Hexadecimal [24-Bits]



                                   3279 ;   '-','+'
                                   3280 ;   '=','>','<','>=','<=','<>','><'
                                   3281 ;   '<>' and '><' are equivalent for not equal.
                                   3282 ;--------------------------------
                                   3283 
                                   3284 ;---------------------
                                   3285 ; return array element
                                   3286 ; address from @(expr)
                                   3287 ; input:
                                   3288 ;   A 		TK_ARRAY
                                   3289 ; output:
                                   3290 ;   A 		TK_INTGR
                                   3291 ;	X 		element address 
                                   3292 ;----------------------
      000F9C                       3293 get_array_element:
      000F9C CD 0F 8C         [ 4] 3294 	call func_args 
      000F9F A1 01            [ 1] 3295 	cp a,#1
      000FA1 27 03            [ 1] 3296 	jreq 1$
      000FA3 CC 07 12         [ 2] 3297 	jp syntax_error
      000FA6 CD 0D 71         [ 4] 3298 1$: call dpop  
                                   3299 	; check for bounds 
      000FA9 C3 00 23         [ 2] 3300 	cpw x,array_size 
      000FAC 23 05            [ 2] 3301 	jrule 3$
                                   3302 ; bounds {1..array_size}	
      000FAE A6 0A            [ 1] 3303 2$: ld a,#ERR_BAD_VALUE 
      000FB0 CC 07 14         [ 2] 3304 	jp tb_error 
      000FB3 5D               [ 2] 3305 3$: tnzw  x
      000FB4 27 F8            [ 1] 3306 	jreq 2$ 
      000FB6 58               [ 2] 3307 	sllw x 
      000FB7 89               [ 2] 3308 	pushw x 
      000FB8 AE 16 E8         [ 2] 3309 	ldw x,#tib
      000FBB 72 F0 01         [ 2] 3310 	subw x,(1,sp)
      000FBE                       3311 	_drop 2   
      000FBE 5B 02            [ 2]    1     addw sp,#2 
      000FC0 A6 04            [ 1] 3312 	ld a,#TK_INTGR
      000FC2 81               [ 4] 3313 	ret 
                                   3314 
                                   3315 ;***********************************
                                   3316 ;   expression parse,execute 
                                   3317 ;***********************************
                                   3318 ;-----------------------------------
                                   3319 ; factor ::= ['+'|'-'|e] var | @ |
                                   3320 ;			 integer | function |
                                   3321 ;			 '('relation')' 
                                   3322 ; output:
                                   3323 ;   A    token attribute 
                                   3324 ;   X 	 integer
                                   3325 ; ---------------------------------
                           000001  3326 	NEG=1
                           000001  3327 	VSIZE=1
      000FC3                       3328 factor:
      000FC3                       3329 	_vars VSIZE 
      000FC3 52 01            [ 2]    1     sub sp,#VSIZE 
      000FC5 CD 07 C6         [ 4] 3330 	call next_token
      000FC8 A1 02            [ 1] 3331 	cp a,#CMD_END 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 65.
Hexadecimal [24-Bits]



      000FCA 2B 4C            [ 1] 3332 	jrmi 20$
      000FCC 6B 01            [ 1] 3333 1$:	ld (NEG,sp),a 
      000FCE A4 30            [ 1] 3334 	and a,#TK_GRP_MASK
      000FD0 A1 10            [ 1] 3335 	cp a,#TK_GRP_ADD 
      000FD2 27 04            [ 1] 3336 	jreq 2$
      000FD4 7B 01            [ 1] 3337 	ld a,(NEG,sp)
      000FD6 20 03            [ 2] 3338 	jra 4$  
      000FD8                       3339 2$:	
      000FD8 CD 07 C6         [ 4] 3340 	call next_token 
      000FDB                       3341 4$:	
      000FDB A1 07            [ 1] 3342 	cp a,#TK_IFUNC 
      000FDD 26 03            [ 1] 3343 	jrne 5$ 
      000FDF FD               [ 4] 3344 	call (x) 
      000FE0 20 2D            [ 2] 3345 	jra 18$ 
      000FE2                       3346 5$:
      000FE2 A1 04            [ 1] 3347 	cp a,#TK_INTGR
      000FE4 26 02            [ 1] 3348 	jrne 6$
      000FE6 20 27            [ 2] 3349 	jra 18$
      000FE8                       3350 6$:
      000FE8 A1 02            [ 1] 3351 	cp a,#TK_ARRAY
      000FEA 26 06            [ 1] 3352 	jrne 10$
      000FEC CD 0F 9C         [ 4] 3353 	call get_array_element
      000FEF FE               [ 2] 3354 	ldw x,(x)
      000FF0 20 1D            [ 2] 3355 	jra 18$ 
      000FF2                       3356 10$:
      000FF2 A1 05            [ 1] 3357 	cp a,#TK_VAR 
      000FF4 26 03            [ 1] 3358 	jrne 12$
      000FF6 FE               [ 2] 3359 	ldw x,(x)
      000FF7 20 16            [ 2] 3360 	jra 18$
      000FF9                       3361 12$:			
      000FF9 A1 0B            [ 1] 3362 	cp a,#TK_LPAREN
      000FFB 26 0C            [ 1] 3363 	jrne 16$
      000FFD CD 10 AC         [ 4] 3364 	call relation
      001000 89               [ 2] 3365 	pushw x 
      001001 A6 0C            [ 1] 3366 	ld a,#TK_RPAREN 
      001003 CD 0F 5B         [ 4] 3367 	call expect
      001006 85               [ 2] 3368 	popw x 
      001007 20 06            [ 2] 3369 	jra 18$	
      001009                       3370 16$:
      001009 CD 0D 5E         [ 4] 3371 	call unget_token
      00100C 4F               [ 1] 3372 	clr a 
      00100D 20 09            [ 2] 3373 	jra 20$ 
      00100F                       3374 18$: 
      00100F A6 11            [ 1] 3375 	ld a,#TK_MINUS 
      001011 11 01            [ 1] 3376 	cp a,(NEG,sp)
      001013 26 01            [ 1] 3377 	jrne 19$
      001015 50               [ 2] 3378 	negw x
      001016                       3379 19$:
      001016 A6 04            [ 1] 3380 	ld a,#TK_INTGR
      001018                       3381 20$:
      001018                       3382 	_drop VSIZE
      001018 5B 01            [ 2]    1     addw sp,#VSIZE 
      00101A 81               [ 4] 3383 	ret
                                   3384 
                                   3385 ;-----------------------------------
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 66.
Hexadecimal [24-Bits]



                                   3386 ; term ::= factor [['*'|'/'|'%'] factor]* 
                                   3387 ; output:
                                   3388 ;   A    	token attribute 
                                   3389 ;	X		integer
                                   3390 ;-----------------------------------
                           000001  3391 	N1=1
                           000003  3392 	N2=3
                           000005  3393 	MULOP=5
                           000005  3394 	VSIZE=5
      00101B                       3395 term:
      00101B                       3396 	_vars VSIZE
      00101B 52 05            [ 2]    1     sub sp,#VSIZE 
      00101D CD 0F C3         [ 4] 3397 	call factor
      001020 A1 02            [ 1] 3398 	cp a,#CMD_END
      001022 2B 41            [ 1] 3399 	jrmi term_exit
      001024                       3400 term01:	 ; check for  operator 
      001024 1F 03            [ 2] 3401 	ldw (N2,sp),x  ; save first factor 
      001026 CD 07 C6         [ 4] 3402 	call next_token
      001029 A1 02            [ 1] 3403 	cp a,#2
      00102B 2B 34            [ 1] 3404 	jrmi 9$
      00102D 6B 05            [ 1] 3405 0$:	ld (MULOP,sp),a
      00102F A4 30            [ 1] 3406 	and a,#TK_GRP_MASK
      001031 A1 20            [ 1] 3407 	cp a,#TK_GRP_MULT
      001033 27 07            [ 1] 3408 	jreq 1$
      001035 7B 05            [ 1] 3409 	ld a,(MULOP,sp) 
      001037 CD 0D 5E         [ 4] 3410 	call unget_token 
      00103A 20 25            [ 2] 3411 	jra 9$
      00103C                       3412 1$:	; got *|/|%
      00103C CD 0F C3         [ 4] 3413 	call factor
      00103F A1 04            [ 1] 3414 	cp a,#TK_INTGR
      001041 27 03            [ 1] 3415 	jreq 2$ 
      001043 CC 07 12         [ 2] 3416 	jp syntax_error
      001046 1F 01            [ 2] 3417 2$:	ldw (N1,sp),x  
      001048 7B 05            [ 1] 3418 	ld a,(MULOP,sp) 
      00104A A1 20            [ 1] 3419 	cp a,#TK_MULT 
      00104C 26 05            [ 1] 3420 	jrne 3$
      00104E CD 0E 37         [ 4] 3421 	call multiply 
      001051 20 D1            [ 2] 3422 	jra term01
      001053 A1 21            [ 1] 3423 3$: cp a,#TK_DIV 
      001055 26 05            [ 1] 3424 	jrne 4$ 
      001057 CD 0E 7F         [ 4] 3425 	call divide 
      00105A 20 C8            [ 2] 3426 	jra term01 
      00105C CD 0E C3         [ 4] 3427 4$: call modulo
      00105F 20 C3            [ 2] 3428 	jra term01 
      001061 1E 03            [ 2] 3429 9$: ldw x,(N2,sp)  
      001063 A6 04            [ 1] 3430 	ld a,#TK_INTGR 	
      001065                       3431 term_exit:
      001065                       3432 	_drop VSIZE 
      001065 5B 05            [ 2]    1     addw sp,#VSIZE 
      001067 81               [ 4] 3433 	ret 
                                   3434 
                                   3435 ;-------------------------------
                                   3436 ;  expr ::= term [['+'|'-'] term]*
                                   3437 ;  result range {-32768..32767}
                                   3438 ;  output:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 67.
Hexadecimal [24-Bits]



                                   3439 ;   A    token attribute 
                                   3440 ;   X	 integer   
                                   3441 ;-------------------------------
                           000001  3442 	N1=1 
                           000003  3443 	N2=3
                           000005  3444 	OP=5 
                           000005  3445 	VSIZE=5 
      001068                       3446 expression:
      001068                       3447 	_vars VSIZE 
      001068 52 05            [ 2]    1     sub sp,#VSIZE 
      00106A CD 10 1B         [ 4] 3448 	call term
      00106D A1 02            [ 1] 3449 	cp a,#CMD_END 
      00106F 2B 38            [ 1] 3450 	jrmi expr_exit 
      001071 1F 03            [ 2] 3451 0$:	ldw (N2,sp),x 
      001073 CD 07 C6         [ 4] 3452 	call next_token
      001076 A1 02            [ 1] 3453 	cp a,#2
      001078 2B 2B            [ 1] 3454 	jrmi 9$ 
      00107A 6B 05            [ 1] 3455 1$:	ld (OP,sp),a  
      00107C A4 30            [ 1] 3456 	and a,#TK_GRP_MASK
      00107E A1 10            [ 1] 3457 	cp a,#TK_GRP_ADD 
      001080 27 07            [ 1] 3458 	jreq 2$ 
      001082 7B 05            [ 1] 3459 	ld a,(OP,sp)
      001084 CD 0D 5E         [ 4] 3460 	call unget_token
      001087 20 1C            [ 2] 3461 	jra 9$
      001089                       3462 2$: 
      001089 CD 10 1B         [ 4] 3463 	call term
      00108C A1 04            [ 1] 3464 	cp a,#TK_INTGR 
      00108E 27 03            [ 1] 3465 	jreq 3$
      001090 CC 07 12         [ 2] 3466 	jp syntax_error
      001093 1F 01            [ 2] 3467 3$:	ldw (N1,sp),x 
      001095 7B 05            [ 1] 3468 	ld a,(OP,sp)
      001097 A1 10            [ 1] 3469 	cp a,#TK_PLUS 
      001099 26 05            [ 1] 3470 	jrne 4$
      00109B CD 0E 29         [ 4] 3471 	call add 
      00109E 20 D1            [ 2] 3472 	jra 0$ 
      0010A0 CD 0E 31         [ 4] 3473 4$:	call substract
      0010A3 20 CC            [ 2] 3474 	jra 0$
      0010A5 1E 03            [ 2] 3475 9$: ldw x,(N2,sp)
      0010A7 A6 04            [ 1] 3476 	ld a,#TK_INTGR	
      0010A9                       3477 expr_exit:
      0010A9                       3478 	_drop VSIZE 
      0010A9 5B 05            [ 2]    1     addw sp,#VSIZE 
      0010AB 81               [ 4] 3479 	ret 
                                   3480 
                                   3481 ;---------------------------------------------
                                   3482 ; rel ::= expr rel_op expr
                                   3483 ; rel_op ::=  '=','<','>','>=','<=','<>','><'
                                   3484 ;  relation return 1 | 0  for true | false 
                                   3485 ;  output:
                                   3486 ;    A 		token attribute  
                                   3487 ;	 X		1|0
                                   3488 ;---------------------------------------------
                           000001  3489 	N1=1
                           000003  3490 	N2=3
                           000005  3491 	RELOP=5
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 68.
Hexadecimal [24-Bits]



                           000005  3492 	VSIZE=5 
      0010AC                       3493 relation: 
      0010AC                       3494 	_vars VSIZE
      0010AC 52 05            [ 2]    1     sub sp,#VSIZE 
      0010AE CD 10 68         [ 4] 3495 	call expression
      0010B1 A1 02            [ 1] 3496 	cp a,#CMD_END  
      0010B3 2B 4B            [ 1] 3497 	jrmi rel_exit 
                                   3498 	; expect rel_op or leave 
      0010B5 1F 03            [ 2] 3499 	ldw (N2,sp),x 
      0010B7 CD 07 C6         [ 4] 3500 	call next_token 
      0010BA A1 02            [ 1] 3501 	cp a,#2
      0010BC 2B 3E            [ 1] 3502 	jrmi 9$
      0010BE                       3503 1$:	
      0010BE 6B 05            [ 1] 3504 	ld (RELOP,sp),a 
      0010C0 A4 30            [ 1] 3505 	and a,#TK_GRP_MASK
      0010C2 A1 30            [ 1] 3506 	cp a,#TK_GRP_RELOP 
      0010C4 27 07            [ 1] 3507 	jreq 2$
      0010C6 7B 05            [ 1] 3508 	ld a,(RELOP,sp)
      0010C8 CD 0D 5E         [ 4] 3509 	call unget_token  
      0010CB 20 2F            [ 2] 3510 	jra 9$
      0010CD                       3511 2$:	; expect another expression or error 
      0010CD CD 10 68         [ 4] 3512 	call expression
      0010D0 A1 04            [ 1] 3513 	cp a,#TK_INTGR 
      0010D2 27 03            [ 1] 3514 	jreq 3$
      0010D4 CC 07 12         [ 2] 3515 	jp syntax_error 
      0010D7 1F 01            [ 2] 3516 3$:	ldw (N1,sp),x 
      0010D9 CD 0E 31         [ 4] 3517 	call substract
      0010DC 26 06            [ 1] 3518 	jrne 4$
      0010DE 35 02 00 0D      [ 1] 3519 	mov acc8,#2 ; n1==n2
      0010E2 20 0C            [ 2] 3520 	jra 6$ 
      0010E4                       3521 4$: 
      0010E4 2C 06            [ 1] 3522 	jrsgt 5$  
      0010E6 35 04 00 0D      [ 1] 3523 	mov acc8,#4 ; n1<2 
      0010EA 20 04            [ 2] 3524 	jra 6$
      0010EC                       3525 5$:
      0010EC 35 01 00 0D      [ 1] 3526 	mov acc8,#1 ; n1>n2 
      0010F0                       3527 6$:
      0010F0 5F               [ 1] 3528 	clrw x 
      0010F1 C6 00 0D         [ 1] 3529 	ld a, acc8  
      0010F4 14 05            [ 1] 3530 	and a,(RELOP,sp)
      0010F6 4D               [ 1] 3531 	tnz a 
      0010F7 27 05            [ 1] 3532 	jreq 10$
      0010F9 5C               [ 2] 3533 	incw x 
      0010FA                       3534 7$:	 
      0010FA 20 02            [ 2] 3535 	jra 10$  	
      0010FC 1E 03            [ 2] 3536 9$: ldw x,(N2,sp)
      0010FE                       3537 10$:
      0010FE A6 04            [ 1] 3538 	ld a,#TK_INTGR
      001100                       3539 rel_exit: 	 
      001100                       3540 	_drop VSIZE
      001100 5B 05            [ 2]    1     addw sp,#VSIZE 
      001102 81               [ 4] 3541 	ret 
                                   3542 
                                   3543 ;--------------------------------
                                   3544 ; BASIC: SHOW 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 69.
Hexadecimal [24-Bits]



                                   3545 ;  show content of dstack,cstack
                                   3546 ;--------------------------------
      001103                       3547 show:
      001103 C6 00 0A         [ 1] 3548 	ld a,base 
      001106 88               [ 1] 3549 	push a 
      001107 CD 0D C8         [ 4] 3550 	call dots
      00110A CD 0D FC         [ 4] 3551 	call dotr 
      00110D 84               [ 1] 3552 	pop a 
      00110E C7 00 0A         [ 1] 3553 	ld base,a 
      001111 4F               [ 1] 3554 	clr a 
      001112 81               [ 4] 3555 	ret
                                   3556 
                                   3557 ;--------------------------------------------
                                   3558 ; BASIC: HEX 
                                   3559 ; select hexadecimal base for integer print
                                   3560 ;---------------------------------------------
      001113                       3561 hex_base:
      001113 35 10 00 0A      [ 1] 3562 	mov base,#16 
      001117 81               [ 4] 3563 	ret 
                                   3564 
                                   3565 ;--------------------------------------------
                                   3566 ; BASIC: DEC 
                                   3567 ; select decimal base for integer print
                                   3568 ;---------------------------------------------
      001118                       3569 dec_base:
      001118 35 0A 00 0A      [ 1] 3570 	mov base,#10
      00111C 81               [ 4] 3571 	ret 
                                   3572 
                                   3573 ;------------------------
                                   3574 ; BASIC: SIZE 
                                   3575 ; return free size in text area
                                   3576 ; output:
                                   3577 ;   A 		TK_INTGR
                                   3578 ;   X 	    size integer
                                   3579 ;--------------------------
      00111D                       3580 size:
      00111D AE 16 E8         [ 2] 3581 	ldw x,#tib 
      001120 72 B0 00 20      [ 2] 3582 	subw x,txtend 
      001124 A6 04            [ 1] 3583 	ld a,#TK_INTGR
      001126 81               [ 4] 3584 	ret 
                                   3585 
                                   3586 
                                   3587 ;------------------------
                                   3588 ; BASIC: UBOUND  
                                   3589 ; return array variable size 
                                   3590 ; output:
                                   3591 ;   A 		TK_INTGR
                                   3592 ;   X 	    array size 
                                   3593 ;--------------------------
      001127                       3594 ubound:
      001127 AE 16 E8         [ 2] 3595 	ldw x,#tib
      00112A 72 B0 00 20      [ 2] 3596 	subw x,txtend 
      00112E 90 CE 00 04      [ 2] 3597 	ldw y,basicptr 
      001132 90 C3 00 20      [ 2] 3598 	cpw y,txtend 
      001136 25 0A            [ 1] 3599 	jrult 1$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 70.
Hexadecimal [24-Bits]



      001138 3B 00 03         [ 1] 3600 	push count 
      00113B 4B 00            [ 1] 3601 	push #0 
      00113D 72 F0 01         [ 2] 3602 	subw x,(1,sp)
      001140                       3603 	_drop 2 
      001140 5B 02            [ 2]    1     addw sp,#2 
      001142 54               [ 2] 3604 1$:	srlw x 
      001143 CF 00 23         [ 2] 3605 	ldw array_size,x
      001146 A6 04            [ 1] 3606 	ld a,#TK_INTGR
      001148 81               [ 4] 3607 	ret 
                                   3608 
                                   3609 ;-----------------------------
                                   3610 ; BASIC: LET var=expr 
                                   3611 ; variable assignement 
                                   3612 ; output:
                                   3613 ;   A 		TK_NONE 
                                   3614 ;-----------------------------
      001149                       3615 let:
      001149 CD 07 C6         [ 4] 3616 	call next_token 
      00114C A1 05            [ 1] 3617 	cp a,#TK_VAR 
      00114E 27 03            [ 1] 3618 	jreq let02
      001150 CC 07 12         [ 2] 3619 	jp syntax_error
      001153                       3620 let02:
      001153 CD 0D 64         [ 4] 3621 	call dpush 
      001156 CD 07 C6         [ 4] 3622 	call next_token 
      001159 A1 32            [ 1] 3623 	cp a,#TK_EQUAL
      00115B 27 03            [ 1] 3624 	jreq 1$
      00115D CC 07 12         [ 2] 3625 	jp syntax_error
      001160                       3626 1$:	
      001160 CD 10 AC         [ 4] 3627 	call relation   
      001163 A1 04            [ 1] 3628 	cp a,#TK_INTGR 
      001165 27 03            [ 1] 3629 	jreq 2$
      001167 CC 07 12         [ 2] 3630 	jp syntax_error
      00116A                       3631 2$:	
      00116A 90 93            [ 1] 3632 	ldw y,x 
      00116C CD 0D 71         [ 4] 3633 	call dpop  
      00116F FF               [ 2] 3634 	ldw (x),y   
      001170 81               [ 4] 3635 	ret 
                                   3636 
                                   3637 ;----------------------------
                                   3638 ; BASIC: LIST [[start][,end]]
                                   3639 ; list program lines 
                                   3640 ; form start to end 
                                   3641 ; if empty argument list then 
                                   3642 ; list all.
                                   3643 ;----------------------------
                           000001  3644 	FIRST=1
                           000003  3645 	LAST=3 
                           000005  3646 	LN_PTR=5
                           000006  3647 	VSIZE=6 
      001171                       3648 list:
      001171                       3649 	_vars VSIZE
      001171 52 06            [ 2]    1     sub sp,#VSIZE 
      001173 CE 00 1E         [ 2] 3650 	ldw x,txtbgn 
      001176 C3 00 20         [ 2] 3651 	cpw x,txtend 
      001179 2B 03            [ 1] 3652 	jrmi 1$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 71.
Hexadecimal [24-Bits]



      00117B CC 11 F3         [ 2] 3653 	jp list_exit ; nothing to list 
      00117E 1F 05            [ 2] 3654 1$:	ldw (LN_PTR,sp),x 
      001180 FE               [ 2] 3655 	ldw x,(x) 
      001181 1F 01            [ 2] 3656 	ldw (FIRST,sp),x ; list from first line 
      001183 AE 7F FF         [ 2] 3657 	ldw x,#0x7fff ; biggest line number 
      001186 1F 03            [ 2] 3658 	ldw (LAST,sp),x 
      001188 CD 0F 68         [ 4] 3659 	call arg_list
      00118B 4D               [ 1] 3660 	tnz a
      00118C 27 3F            [ 1] 3661 	jreq list_start 
      00118E A1 02            [ 1] 3662 	cp a,#2 
      001190 27 07            [ 1] 3663 	jreq 4$
      001192 A1 01            [ 1] 3664 	cp a,#1 
      001194 27 06            [ 1] 3665 	jreq first_line 
      001196 CC 07 12         [ 2] 3666 	jp syntax_error 
      001199 CD 0D 7E         [ 4] 3667 4$:	call dswap
      00119C                       3668 first_line:
      00119C CD 0D 71         [ 4] 3669 	call dpop 
      00119F 1F 01            [ 2] 3670 	ldw (FIRST,sp),x 
      0011A1 A1 01            [ 1] 3671 	cp a,#1 
      0011A3 27 05            [ 1] 3672 	jreq lines_skip 	
      0011A5                       3673 last_line:
      0011A5 CD 0D 71         [ 4] 3674 	call dpop 
      0011A8 1F 03            [ 2] 3675 	ldw (LAST,sp),x 
      0011AA                       3676 lines_skip:
      0011AA CE 00 1E         [ 2] 3677 	ldw x,txtbgn
      0011AD 1F 05            [ 2] 3678 2$:	ldw (LN_PTR,sp),x 
      0011AF C3 00 20         [ 2] 3679 	cpw x,txtend 
      0011B2 2A 3F            [ 1] 3680 	jrpl list_exit 
      0011B4 FE               [ 2] 3681 	ldw x,(x) ;line# 
      0011B5 13 01            [ 2] 3682 	cpw x,(FIRST,sp)
      0011B7 2A 14            [ 1] 3683 	jrpl list_start 
      0011B9 1E 05            [ 2] 3684 	ldw x,(LN_PTR,sp) 
      0011BB 1C 00 02         [ 2] 3685 	addw x,#2 
      0011BE F6               [ 1] 3686 	ld a,(x)
      0011BF 5C               [ 2] 3687 	incw x 
      0011C0 C7 00 0D         [ 1] 3688 	ld acc8,a 
      0011C3 72 5F 00 0C      [ 1] 3689 	clr acc16 
      0011C7 72 BB 00 0C      [ 2] 3690 	addw x,acc16
      0011CB 20 E0            [ 2] 3691 	jra 2$ 
                                   3692 ; print loop
      0011CD                       3693 list_start:
      0011CD 1E 05            [ 2] 3694 	ldw x,(LN_PTR,sp)
      0011CF E6 02            [ 1] 3695 3$:	ld a,(2,x) 
      0011D1 CD 12 46         [ 4] 3696 	call prt_basic_line
      0011D4 1E 05            [ 2] 3697 	ldw x,(LN_PTR,sp)
      0011D6 E6 02            [ 1] 3698 	ld a,(2,x)
      0011D8 C7 00 0D         [ 1] 3699 	ld acc8,a 
      0011DB 72 5F 00 0C      [ 1] 3700 	clr acc16 
      0011DF 72 BB 00 0C      [ 2] 3701 	addw x,acc16
      0011E3 C3 00 20         [ 2] 3702 	cpw x,txtend 
      0011E6 2A 0B            [ 1] 3703 	jrpl list_exit
      0011E8 1F 05            [ 2] 3704 	ldw (LN_PTR,sp),x
      0011EA FE               [ 2] 3705 	ldw x,(x)
      0011EB 13 03            [ 2] 3706 	cpw x,(LAST,sp)  
      0011ED 2C 04            [ 1] 3707 	jrsgt list_exit 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 72.
Hexadecimal [24-Bits]



      0011EF 1E 05            [ 2] 3708 	ldw x,(LN_PTR,sp)
      0011F1 20 DC            [ 2] 3709 	jra 3$
      0011F3                       3710 list_exit:
      0011F3                       3711 	_drop VSIZE 
      0011F3 5B 06            [ 2]    1     addw sp,#VSIZE 
      0011F5 81               [ 4] 3712 	ret
                                   3713 
                                   3714 ;-------------------------
                                   3715 ; print counted string 
                                   3716 ; input:
                                   3717 ;   X 	address of string
                                   3718 ;--------------------------
      0011F6                       3719 prt_cmd_name:
      0011F6 F6               [ 1] 3720 	ld a,(x)
      0011F7 5C               [ 2] 3721 	incw x
      0011F8 A4 0F            [ 1] 3722 	and a,#15  
      0011FA 88               [ 1] 3723 	push a 
      0011FB 0D 01            [ 1] 3724 1$: tnz (1,sp) 
      0011FD 27 09            [ 1] 3725 	jreq 9$
      0011FF F6               [ 1] 3726 	ld a,(x)
      001200 CD 01 B3         [ 4] 3727 	call putc 
      001203 5C               [ 2] 3728 	incw x
      001204 0A 01            [ 1] 3729 	dec (1,sp)	 
      001206 20 F3            [ 2] 3730 	jra 1$
      001208 84               [ 1] 3731 9$: pop a 
      001209 81               [ 4] 3732 	ret	
                                   3733 
                                   3734 ;--------------------------
                                   3735 ; print TK_QSTR
                                   3736 ; converting control character
                                   3737 ; to backslash sequence
                                   3738 ; input:
                                   3739 ;   X        char *
                                   3740 ;-----------------------------
      00120A                       3741 prt_quote:
      00120A A6 22            [ 1] 3742 	ld a,#'"
      00120C CD 01 B3         [ 4] 3743 	call putc 
      00120F F6               [ 1] 3744 1$:	ld a,(x)
      001210 27 2D            [ 1] 3745 	jreq 9$
      001212 5C               [ 2] 3746 	incw x 
      001213 A1 20            [ 1] 3747 	cp a,#SPACE 
      001215 25 0C            [ 1] 3748 	jrult 3$
      001217 CD 01 B3         [ 4] 3749 	call putc
      00121A A1 5C            [ 1] 3750 	cp a,#'\ 
      00121C 26 F1            [ 1] 3751 	jrne 1$ 
      00121E                       3752 2$:
      00121E CD 01 B3         [ 4] 3753 	call putc 
      001221 20 EC            [ 2] 3754 	jra 1$
      001223 88               [ 1] 3755 3$: push a 
      001224 A6 5C            [ 1] 3756 	ld a,#'\
      001226 CD 01 B3         [ 4] 3757 	call putc 
      001229 84               [ 1] 3758 	pop a 
      00122A A0 07            [ 1] 3759 	sub a,#7
      00122C C7 00 0D         [ 1] 3760 	ld acc8,a 
      00122F 72 5F 00 0C      [ 1] 3761 	clr acc16
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 73.
Hexadecimal [24-Bits]



      001233 90 AE 0A 2D      [ 2] 3762 	ldw y,#escaped 
      001237 72 B9 00 0C      [ 2] 3763 	addw y,acc16 
      00123B 90 F6            [ 1] 3764 	ld a,(y)
      00123D 20 DF            [ 2] 3765 	jra 2$
      00123F A6 22            [ 1] 3766 9$: ld a,#'"
      001241 CD 01 B3         [ 4] 3767 	call putc 
      001244 5C               [ 2] 3768 	incw x 
      001245 81               [ 4] 3769 	ret
                                   3770 
                                   3771 
                                   3772 ;--------------------------
                                   3773 ; decompile line from token list 
                                   3774 ; input:
                                   3775 ;   A       stop at this position 
                                   3776 ;   X 		pointer at line
                                   3777 ; output:
                                   3778 ;   none 
                                   3779 ;--------------------------	
                           000001  3780 	BASE_SAV=1
                           000002  3781 	WIDTH_SAV=2
                           000003  3782 	XSAVE=3
                           000005  3783 	LLEN=5
                           000005  3784 	VSIZE=5 
      001246                       3785 prt_basic_line:
      001246                       3786 	_vars VSIZE
      001246 52 05            [ 2]    1     sub sp,#VSIZE 
      001248 6B 05            [ 1] 3787 	ld (LLEN,sp),a  
      00124A C6 00 0A         [ 1] 3788 	ld a,base
      00124D 6B 01            [ 1] 3789 	ld (BASE_SAV,sp),a  
      00124F C6 00 26         [ 1] 3790 	ld a,tab_width 
      001252 6B 02            [ 1] 3791 	ld (WIDTH_SAV,sp),a 
      001254 CF 00 17         [ 2] 3792 	ldw ptr16,x
      001257 FE               [ 2] 3793 	ldw x,(x)
      001258 35 0A 00 0A      [ 1] 3794 	mov base,#10
      00125C 35 05 00 26      [ 1] 3795 	mov tab_width,#5
      001260 CD 08 63         [ 4] 3796 	call print_int ; print line number 
      001263 A6 20            [ 1] 3797 	ld a,#SPACE 
      001265 CD 01 B3         [ 4] 3798 	call putc 
      001268 72 5F 00 26      [ 1] 3799 	clr tab_width
      00126C AE 00 03         [ 2] 3800 	ldw x,#3
      00126F 9F               [ 1] 3801 1$:	ld a,xl 
      001270 11 05            [ 1] 3802 	cp a,(LLEN,sp)
      001272 2B 03            [ 1] 3803 	jrmi 20$
      001274 CC 13 79         [ 2] 3804 	jp 90$
      001277                       3805 20$:	 
      001277 72 D6 00 17      [ 4] 3806 	ld a,([ptr16],x)
      00127B 5C               [ 2] 3807 	incw x 
      00127C 1F 03            [ 2] 3808 	ldw (XSAVE,sp),x 
      00127E A1 06            [ 1] 3809 	cp a,#TK_CMD 
      001280 25 44            [ 1] 3810 	jrult 5$
      001282 A1 08            [ 1] 3811 	cp a,#TK_CFUNC 
      001284 22 2F            [ 1] 3812 	jrugt 4$
      001286                       3813 2$:	
      001286 72 DE 00 17      [ 5] 3814 	ldw x,([ptr16],x)
      00128A A3 14 9C         [ 2] 3815 	cpw x,#rem 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 74.
Hexadecimal [24-Bits]



      00128D 26 14            [ 1] 3816 	jrne 3$
      00128F A6 27            [ 1] 3817 	ld a,#''
      001291 CD 01 B3         [ 4] 3818 	call putc 
      001294 1E 03            [ 2] 3819 	ldw x,(XSAVE,sp)
      001296 1C 00 02         [ 2] 3820 	addw x,#2
      001299 72 BB 00 17      [ 2] 3821 	addw x,ptr16  
      00129D CD 01 C6         [ 4] 3822 	call puts 
      0012A0 CC 13 79         [ 2] 3823 	jp 90$ 
      0012A3 CD 0E D4         [ 4] 3824 3$:	call cmd_name
      0012A6 CD 11 F6         [ 4] 3825 	call prt_cmd_name
      0012A9 A6 20            [ 1] 3826 	ld a,#SPACE 
      0012AB CD 01 B3         [ 4] 3827 	call putc 
      0012AE 1E 03            [ 2] 3828 	ldw x,(XSAVE,sp)
      0012B0 1C 00 02         [ 2] 3829 	addw x,#2
      0012B3 20 BA            [ 2] 3830 	jra 1$
      0012B5 A1 0A            [ 1] 3831 4$: cp a,#TK_QSTR 
      0012B7 26 0D            [ 1] 3832 	jrne 5$
      0012B9 72 BB 00 17      [ 2] 3833 	addw x,ptr16
      0012BD CD 12 0A         [ 4] 3834 	call prt_quote 
      0012C0 72 B0 00 17      [ 2] 3835 	subw x,ptr16  
      0012C4 20 A9            [ 2] 3836 	jra 1$
      0012C6 A1 05            [ 1] 3837 5$:	cp a,#TK_VAR
      0012C8 26 1A            [ 1] 3838 	jrne 6$ 
      0012CA 72 DE 00 17      [ 5] 3839 	ldw x,([ptr16],x)
      0012CE 1D 00 28         [ 2] 3840 	subw x,#vars 
      0012D1 9F               [ 1] 3841 	ld a,xl
      0012D2 44               [ 1] 3842 	srl a 
      0012D3 AB 41            [ 1] 3843 	add a,#'A 
      0012D5 CD 01 B3         [ 4] 3844 	call putc 
      0012D8 A6 20            [ 1] 3845 	ld a,#SPACE 
      0012DA CD 01 B3         [ 4] 3846 	call putc 
      0012DD 1E 03            [ 2] 3847 	ldw x,(XSAVE,sp)
      0012DF 1C 00 02         [ 2] 3848 	addw x,#2 
      0012E2 20 8B            [ 2] 3849 	jra 1$ 
      0012E4 A1 02            [ 1] 3850 6$: cp a,#TK_ARRAY 
      0012E6 26 0A            [ 1] 3851 	jrne 7$
      0012E8 A6 40            [ 1] 3852 	ld a,#'@ 
      0012EA CD 01 B3         [ 4] 3853 	call putc 
      0012ED 1E 03            [ 2] 3854 	ldw x,(XSAVE,sp)
      0012EF CC 12 6F         [ 2] 3855 	jp 1$ 
      0012F2 A1 04            [ 1] 3856 7$: cp a,#TK_INTGR 
      0012F4 26 0F            [ 1] 3857 	jrne 8$
      0012F6 72 DE 00 17      [ 5] 3858 	ldw x,([ptr16],x)
      0012FA CD 08 63         [ 4] 3859 	call print_int
                                   3860 ;	ld a,#SPACE 
                                   3861 ;	call putc 
      0012FD 1E 03            [ 2] 3862 	ldw x,(XSAVE,sp)
      0012FF 1C 00 02         [ 2] 3863 	addw x,#2 
      001302 CC 12 6F         [ 2] 3864 	jp 1$
      001305 A1 31            [ 1] 3865 8$: cp a,#TK_GT 
      001307 2B 1A            [ 1] 3866 	jrmi 9$
      001309 A1 35            [ 1] 3867 	cp a,#TK_NE 
      00130B 22 16            [ 1] 3868 	jrugt 9$
      00130D A0 31            [ 1] 3869 	sub a,#TK_GT  
      00130F 48               [ 1] 3870 	sll a 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 75.
Hexadecimal [24-Bits]



      001310 90 5F            [ 1] 3871 	clrw y 
      001312 90 97            [ 1] 3872 	ld yl,a 
      001314 72 A9 13 92      [ 2] 3873 	addw y,#relop_str 
      001318 90 FE            [ 2] 3874 	ldw y,(y)
      00131A 93               [ 1] 3875 	ldw x,y 
      00131B CD 01 C6         [ 4] 3876 	call puts 
      00131E 1E 03            [ 2] 3877 	ldw x,(XSAVE,sp)
      001320 CC 12 6F         [ 2] 3878 	jp 1$
      001323 A1 10            [ 1] 3879 9$: cp a,#TK_PLUS 
      001325 26 04            [ 1] 3880 	jrne 10$
      001327 A6 2B            [ 1] 3881 	ld a,#'+
      001329 20 46            [ 2] 3882 	jra 80$ 
      00132B A1 11            [ 1] 3883 10$: cp a,#TK_MINUS
      00132D 26 04            [ 1] 3884 	jrne 11$
      00132F A6 2D            [ 1] 3885 	ld a,#'-
      001331 20 3E            [ 2] 3886 	jra 80$
      001333 A1 20            [ 1] 3887 11$: cp a,#TK_MULT 
      001335 2B 0E            [ 1] 3888 	jrmi 12$
      001337 A1 22            [ 1] 3889 	cp a,#TK_MOD 
      001339 22 0A            [ 1] 3890 	jrugt 12$
      00133B A0 20            [ 1] 3891 	sub a,#0x20
      00133D 5F               [ 1] 3892 	clrw x 
      00133E 97               [ 1] 3893 	ld xl,a 
      00133F 1C 13 8F         [ 2] 3894 	addw x,#mul_char 
      001342 F6               [ 1] 3895 	ld a,(x)
      001343 20 2C            [ 2] 3896 	jra 80$ 
      001345 A1 0B            [ 1] 3897 12$: cp a,#TK_LPAREN 
      001347 2B 0E            [ 1] 3898 	jrmi 13$
      001349 A1 0E            [ 1] 3899 	cp a,#TK_SHARP 
      00134B 22 0A            [ 1] 3900 	jrugt 13$
      00134D A0 0B            [ 1] 3901 	sub a,#TK_LPAREN
      00134F 5F               [ 1] 3902 	clrw x 
      001350 97               [ 1] 3903 	ld xl,a 
      001351 1C 13 8B         [ 2] 3904 	addw x,#single_char 
      001354 F6               [ 1] 3905 	ld a,(x)
      001355 20 1A            [ 2] 3906 	jra 80$
      001357 A1 03            [ 1] 3907 13$: cp a,#TK_CHAR 
      001359 26 14            [ 1] 3908 	jrne 14$
      00135B A6 5C            [ 1] 3909 	ld a,#'\
      00135D CD 01 B3         [ 4] 3910 	call putc 
      001360 1E 03            [ 2] 3911 	ldw x,(XSAVE,sp)
      001362 72 D6 00 17      [ 4] 3912 	ld a,([ptr16],x)
      001366 5C               [ 2] 3913 	incw x 
      001367 1F 03            [ 2] 3914 	ldw (XSAVE,sp),x 
      001369 CD 01 B3         [ 4] 3915 	call putc 
      00136C CC 12 6F         [ 2] 3916 	jp 1$ 
      00136F A6 3A            [ 1] 3917 14$: ld a,#':
      001371 CD 01 B3         [ 4] 3918 80$: call putc 
      001374 1E 03            [ 2] 3919 	ldw x,(XSAVE,sp)
      001376 CC 12 6F         [ 2] 3920 	jp 1$ 
      001379                       3921 90$: 
      001379 A6 0D            [ 1] 3922 	ld a,#CR 
      00137B CD 01 B3         [ 4] 3923 	call putc
      00137E 7B 02            [ 1] 3924 	ld a,(WIDTH_SAV,sp) 
      001380 C7 00 26         [ 1] 3925 	ld tab_width,a 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 76.
Hexadecimal [24-Bits]



      001383 7B 01            [ 1] 3926 	ld a,(BASE_SAV,sp) 
      001385 C7 00 0A         [ 1] 3927 	ld base,a
      001388                       3928 	_drop VSIZE 
      001388 5B 05            [ 2]    1     addw sp,#VSIZE 
      00138A 81               [ 4] 3929 	ret 	
      00138B 28 29 2C 23           3930 single_char: .byte '(',')',',','#'
      00138F 2A 2F 25              3931 mul_char: .byte '*','/','%'
      001392 13 9E 13 A0 13 A2 13  3932 relop_str: .word gt,equal,ge,lt,le,ne 
             A5 13 A7 13 AA
      00139E 3E 00                 3933 gt: .asciz ">"
      0013A0 3D 00                 3934 equal: .asciz "="
      0013A2 3E 3D 00              3935 ge: .asciz ">="
      0013A5 3C 00                 3936 lt: .asciz "<"
      0013A7 3C 3D 00              3937 le: .asciz "<="
      0013AA 3C 3E 00              3938 ne:  .asciz "<>"
                                   3939 
                                   3940 
                                   3941 ;---------------------------------
                                   3942 ; BASIC: PRINT|? arg_list 
                                   3943 ; print values from argument list
                                   3944 ;----------------------------------
                           000001  3945 	COMMA=1
                           000001  3946 	VSIZE=1
      0013AD                       3947 print:
      0013AD 4B 00            [ 1] 3948 push #0 ; local variable COMMA 
      0013AF                       3949 reset_comma:
      0013AF 0F 01            [ 1] 3950 	clr (COMMA,sp)
      0013B1                       3951 prt_loop:
      0013B1 CD 10 AC         [ 4] 3952 	call relation 
      0013B4 A1 01            [ 1] 3953 	cp a,#TK_COLON 
      0013B6 27 51            [ 1] 3954 	jreq print_exit   
      0013B8 A1 04            [ 1] 3955 	cp a,#TK_INTGR 
      0013BA 26 05            [ 1] 3956 	jrne 0$ 
      0013BC CD 08 63         [ 4] 3957 	call print_int 
      0013BF 20 EE            [ 2] 3958 	jra reset_comma
      0013C1                       3959 0$: 	
      0013C1 CD 07 C6         [ 4] 3960 	call next_token
      0013C4 A1 00            [ 1] 3961 	cp a,#TK_NONE 
      0013C6 27 41            [ 1] 3962 	jreq print_exit 
      0013C8 A1 0A            [ 1] 3963 1$:	cp a,#TK_QSTR
      0013CA 26 05            [ 1] 3964 	jrne 2$   
      0013CC CD 01 C6         [ 4] 3965 	call puts
      0013CF 20 DE            [ 2] 3966 	jra reset_comma
      0013D1 A1 03            [ 1] 3967 2$: cp a,#TK_CHAR 
      0013D3 26 06            [ 1] 3968 	jrne 3$
      0013D5 9F               [ 1] 3969 	ld a,xl 
      0013D6 CD 01 B3         [ 4] 3970 	call putc 
      0013D9 20 D4            [ 2] 3971 	jra reset_comma 
      0013DB                       3972 3$: 	
      0013DB A1 08            [ 1] 3973 	cp a,#TK_CFUNC 
      0013DD 26 07            [ 1] 3974 	jrne 4$ 
      0013DF FD               [ 4] 3975 	call (x)
      0013E0 9F               [ 1] 3976 	ld a,xl 
      0013E1 CD 01 B3         [ 4] 3977 	call putc
      0013E4 20 C9            [ 2] 3978 	jra reset_comma 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 77.
Hexadecimal [24-Bits]



      0013E6                       3979 4$: 
      0013E6 A1 0D            [ 1] 3980 	cp a,#TK_COMMA 
      0013E8 26 05            [ 1] 3981 	jrne 5$
      0013EA 03 01            [ 1] 3982 	cpl (COMMA,sp) 
      0013EC CC 13 B1         [ 2] 3983 	jp prt_loop   
      0013EF                       3984 5$: 
      0013EF A1 0E            [ 1] 3985 	cp a,#TK_SHARP
      0013F1 26 13            [ 1] 3986 	jrne 7$
      0013F3 CD 07 C6         [ 4] 3987 	call next_token
      0013F6 A1 04            [ 1] 3988 	cp a,#TK_INTGR 
      0013F8 27 03            [ 1] 3989 	jreq 6$
      0013FA CC 07 12         [ 2] 3990 	jp syntax_error 
      0013FD                       3991 6$:
      0013FD 9F               [ 1] 3992 	ld a,xl 
      0013FE A4 0F            [ 1] 3993 	and a,#15 
      001400 C7 00 26         [ 1] 3994 	ld tab_width,a 
      001403 CC 13 AF         [ 2] 3995 	jp reset_comma 
      001406                       3996 7$:	
      001406 CD 0D 5E         [ 4] 3997 	call unget_token
      001409                       3998 print_exit:
      001409 0D 01            [ 1] 3999 	tnz (COMMA,sp)
      00140B 26 05            [ 1] 4000 	jrne 9$
      00140D A6 0D            [ 1] 4001 	ld a,#CR 
      00140F CD 01 B3         [ 4] 4002     call putc 
      001412                       4003 9$:	_drop VSIZE 
      001412 5B 01            [ 2]    1     addw sp,#VSIZE 
      001414 81               [ 4] 4004 	ret 
                                   4005 
                                   4006 ;----------------------
                                   4007 ; 'save_context' and
                                   4008 ; 'rest_context' must be 
                                   4009 ; called at the same 
                                   4010 ; call stack depth 
                                   4011 ; i.e. SP must have the 
                                   4012 ; save value at  
                                   4013 ; entry point of both 
                                   4014 ; routine. 
                                   4015 ;---------------------
                           000004  4016 	CTXT_SIZE=4 ; size of saved data 
                                   4017 ;--------------------
                                   4018 ; save current BASIC
                                   4019 ; interpreter context 
                                   4020 ; on cstack 
                                   4021 ;--------------------
      001415                       4022 	_argofs 0 
                           000002     1     ARG_OFS=2+0 
      001415                       4023 	_arg BPTR 1
                           000003     1     BPTR=ARG_OFS+1 
      001415                       4024 	_arg IN 3
                           000005     1     IN=ARG_OFS+3 
      001415                       4025 	_arg CNT 4
                           000006     1     CNT=ARG_OFS+4 
      001415                       4026 save_context:
      001415 CE 00 04         [ 2] 4027 	ldw x,basicptr 
      001418 1F 03            [ 2] 4028 	ldw (BPTR,sp),x
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 78.
Hexadecimal [24-Bits]



      00141A C6 00 01         [ 1] 4029 	ld a,in 
      00141D 6B 05            [ 1] 4030 	ld (IN,sp),a
      00141F C6 00 03         [ 1] 4031 	ld a,count 
      001422 6B 06            [ 1] 4032 	ld (CNT,sp),a  
      001424 81               [ 4] 4033 	ret
                                   4034 
                                   4035 ;-----------------------
                                   4036 ; restore previously saved 
                                   4037 ; BASIC interpreter context 
                                   4038 ; from cstack 
                                   4039 ;-------------------------
      001425                       4040 rest_context:
      001425 1E 03            [ 2] 4041 	ldw x,(BPTR,sp)
      001427 CF 00 04         [ 2] 4042 	ldw basicptr,x 
      00142A 7B 05            [ 1] 4043 	ld a,(IN,sp)
      00142C C7 00 01         [ 1] 4044 	ld in,a
      00142F 7B 06            [ 1] 4045 	ld a,(CNT,sp)
      001431 C7 00 03         [ 1] 4046 	ld count,a  
      001434 81               [ 4] 4047 	ret
                                   4048 
                                   4049 ;------------------------------------------
                                   4050 ; BASIC: INPUT [string],var[,[string],var]
                                   4051 ; input value in variables 
                                   4052 ; [string] optionally can be used as prompt 
                                   4053 ;-----------------------------------------
                           000001  4054 	CX_BPTR=1
                           000003  4055 	CX_IN=3
                           000004  4056 	CX_CNT=4
                           000005  4057 	SKIP=5
                           000005  4058 	VSIZE=5
      001435                       4059 input_var:
      001435                       4060 	_vars VSIZE 
      001435 52 05            [ 2]    1     sub sp,#VSIZE 
      001437                       4061 input_loop:
      001437 0F 05            [ 1] 4062 	clr (SKIP,sp)
      001439 CD 07 C6         [ 4] 4063 	call next_token 
      00143C A1 0A            [ 1] 4064 	cp a,#TK_QSTR 
      00143E 26 08            [ 1] 4065 	jrne 1$ 
      001440 CD 01 C6         [ 4] 4066 	call puts 
      001443 03 05            [ 1] 4067 	cpl (SKIP,sp)
      001445 CD 07 C6         [ 4] 4068 	call next_token 
      001448 A1 05            [ 1] 4069 1$: cp a,#TK_VAR  
      00144A 27 03            [ 1] 4070 	jreq 2$ 
      00144C CC 07 12         [ 2] 4071 	jp syntax_error
      00144F CD 0D 64         [ 4] 4072 2$:	call dpush 
      001452 0D 05            [ 1] 4073 	tnz (SKIP,sp)
      001454 26 06            [ 1] 4074 	jrne 21$ 
                                   4075 ;	clr pad+2
      001456 AE 17 38         [ 2] 4076 	ldw x,#pad 
      001459 CD 01 C6         [ 4] 4077 	call puts   
      00145C                       4078 21$:
      00145C A6 3A            [ 1] 4079 	ld a,#':
      00145E CD 01 B3         [ 4] 4080 	call putc 
      001461 CD 14 15         [ 4] 4081 	call save_context 
      001464 72 5F 00 03      [ 1] 4082 	clr count  
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 79.
Hexadecimal [24-Bits]



      001468 CD 09 53         [ 4] 4083 	call readln 
      00146B AE 16 E8         [ 2] 4084 	ldw x,#tib 
      00146E CF 00 04         [ 2] 4085 	ldw basicptr,x  
      001471 72 5F 00 01      [ 1] 4086 	clr in 
      001475 CD 0A D2         [ 4] 4087 	call get_token
      001478 A1 04            [ 1] 4088 	cp a,#TK_INTGR
      00147A 27 06            [ 1] 4089 	jreq 3$ 
      00147C CD 14 25         [ 4] 4090 	call rest_context 
      00147F CC 07 12         [ 2] 4091 	jp syntax_error
      001482 CD 0D 64         [ 4] 4092 3$: call dpush 
      001485 CD 0D AB         [ 4] 4093 	call store 
      001488 CD 14 25         [ 4] 4094 	call rest_context
      00148B CD 07 C6         [ 4] 4095 	call next_token 
      00148E A1 0D            [ 1] 4096 	cp a,#TK_COMMA 
      001490 27 A5            [ 1] 4097 	jreq input_loop 
      001492 A1 01            [ 1] 4098 	cp a,#TK_COLON 
      001494 23 03            [ 2] 4099     jrule input_exit 
      001496 CC 07 12         [ 2] 4100 	jp syntax_error 
      001499                       4101 input_exit:
      001499                       4102 	_drop VSIZE 
      001499 5B 05            [ 2]    1     addw sp,#VSIZE 
      00149B 81               [ 4] 4103 	ret 
                                   4104 
                                   4105 
                                   4106 ;---------------------
                                   4107 ; BASIC: REMARK | ' 
                                   4108 ; skip comment to end of line 
                                   4109 ;---------------------- 
      00149C                       4110 rem:
      00149C 55 00 01 00 03   [ 1] 4111  	mov count,in 
      0014A1 81               [ 4] 4112 	ret 
                                   4113 
                                   4114 ;---------------------
                                   4115 ; BASIC: WAIT addr,mask[,xor_mask] 
                                   4116 ; read in loop 'addr'  
                                   4117 ; apply & 'mask' to value 
                                   4118 ; loop while result==0.  
                                   4119 ; if 'xor_mask' given 
                                   4120 ; apply ^ in second  
                                   4121 ; loop while result==0 
                                   4122 ;---------------------
                           000001  4123 	XMASK=1 
                           000002  4124 	MASK=2
                           000003  4125 	ADDR=3
                           000004  4126 	VSIZE=4
      0014A2                       4127 wait: 
      0014A2                       4128 	_vars VSIZE
      0014A2 52 04            [ 2]    1     sub sp,#VSIZE 
      0014A4 0F 01            [ 1] 4129 	clr (XMASK,sp) 
      0014A6 CD 0F 68         [ 4] 4130 	call arg_list 
      0014A9 A1 02            [ 1] 4131 	cp a,#2
      0014AB 24 03            [ 1] 4132 	jruge 0$
      0014AD CC 07 12         [ 2] 4133 	jp syntax_error 
      0014B0 A1 03            [ 1] 4134 0$:	cp a,#3
      0014B2 25 06            [ 1] 4135 	jrult 1$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 80.
Hexadecimal [24-Bits]



      0014B4 CD 0D 71         [ 4] 4136 	call dpop 
      0014B7 9F               [ 1] 4137 	ld a,xl
      0014B8 6B 01            [ 1] 4138 	ld (XMASK,sp),a 
      0014BA CD 0D 71         [ 4] 4139 1$: call dpop ; mask 
      0014BD 9F               [ 1] 4140 	ld a,xl 
      0014BE 6B 02            [ 1] 4141 	ld (MASK,sp),a 
      0014C0 CD 0D 71         [ 4] 4142 	call dpop ; address 
      0014C3 F6               [ 1] 4143 2$:	ld a,(x)
      0014C4 14 02            [ 1] 4144 	and a,(MASK,sp)
      0014C6 18 01            [ 1] 4145 	xor a,(XMASK,sp)
      0014C8 27 F9            [ 1] 4146 	jreq 2$ 
      0014CA                       4147 	_drop VSIZE 
      0014CA 5B 04            [ 2]    1     addw sp,#VSIZE 
      0014CC 81               [ 4] 4148 	ret 
                                   4149 
                                   4150 ;---------------------
                                   4151 ; BASIC: BSET addr,mask
                                   4152 ; set bits at 'addr' corresponding 
                                   4153 ; to those of 'mask' that are at 1.
                                   4154 ; arguments:
                                   4155 ; 	addr 		memory address RAM|PERIPHERAL 
                                   4156 ;   mask        mask|addr
                                   4157 ; output:
                                   4158 ;	none 
                                   4159 ;--------------------------
      0014CD                       4160 bit_set:
      0014CD CD 0F 68         [ 4] 4161 	call arg_list 
      0014D0 A1 02            [ 1] 4162 	cp a,#2	 
      0014D2 27 03            [ 1] 4163 	jreq 1$ 
      0014D4 CC 07 12         [ 2] 4164 	jp syntax_error
      0014D7                       4165 1$: 
      0014D7 CD 0D 71         [ 4] 4166 	call dpop ; mask 
      0014DA 9F               [ 1] 4167 	ld a,xl 
      0014DB CD 0D 71         [ 4] 4168 	call dpop ; addr  
      0014DE FA               [ 1] 4169 	or a,(x)
      0014DF F7               [ 1] 4170 	ld (x),a
      0014E0 81               [ 4] 4171 	ret 
                                   4172 
                                   4173 ;---------------------
                                   4174 ; BASIC: BRES addr,mask
                                   4175 ; reset bits at 'addr' corresponding 
                                   4176 ; to those of 'mask' that are at 1.
                                   4177 ; arguments:
                                   4178 ; 	addr 		memory address RAM|PERIPHERAL 
                                   4179 ;   mask	    ~mask&*addr  
                                   4180 ; output:
                                   4181 ;	none 
                                   4182 ;--------------------------
      0014E1                       4183 bit_reset:
      0014E1 CD 0F 68         [ 4] 4184 	call arg_list 
      0014E4 A1 02            [ 1] 4185 	cp a,#2  
      0014E6 27 03            [ 1] 4186 	jreq 1$ 
      0014E8 CC 07 12         [ 2] 4187 	jp syntax_error
      0014EB                       4188 1$: 
      0014EB CD 0D 71         [ 4] 4189 	call dpop ; mask 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 81.
Hexadecimal [24-Bits]



      0014EE 9F               [ 1] 4190 	ld a,xl 
      0014EF 43               [ 1] 4191 	cpl a 
      0014F0 CD 0D 71         [ 4] 4192 	call dpop ; addr  
      0014F3 F4               [ 1] 4193 	and a,(x)
      0014F4 F7               [ 1] 4194 	ld (x),a 
      0014F5 81               [ 4] 4195 	ret 
                                   4196 
                                   4197 ;---------------------
                                   4198 ; BASIC: BTOGL addr,mask
                                   4199 ; toggle bits at 'addr' corresponding 
                                   4200 ; to those of 'mask' that are at 1.
                                   4201 ; arguments:
                                   4202 ; 	addr 		memory address RAM|PERIPHERAL 
                                   4203 ;   mask	    mask^*addr  
                                   4204 ; output:
                                   4205 ;	none 
                                   4206 ;--------------------------
      0014F6                       4207 bit_toggle:
      0014F6 CD 0F 68         [ 4] 4208 	call arg_list 
      0014F9 A1 02            [ 1] 4209 	cp a,#2 
      0014FB 27 03            [ 1] 4210 	jreq 1$ 
      0014FD CC 07 12         [ 2] 4211 	jp syntax_error
      001500 CD 0D 71         [ 4] 4212 1$: call dpop ; mask 
      001503 9F               [ 1] 4213 	ld a,xl 
      001504 CD 0D 71         [ 4] 4214 	call dpop ; addr  
      001507 F8               [ 1] 4215 	xor a,(x)
      001508 F7               [ 1] 4216 	ld (x),a 
      001509 81               [ 4] 4217 	ret 
                                   4218 
                                   4219 
                                   4220 ;---------------------
                                   4221 ; BASIC: BTEST(addr,bit)
                                   4222 ; return bit value at 'addr' 
                                   4223 ; bit is in range {0..7}.
                                   4224 ; arguments:
                                   4225 ; 	addr 		memory address RAM|PERIPHERAL 
                                   4226 ;   bit 	    bit position {0..7}  
                                   4227 ; output:
                                   4228 ;	none 
                                   4229 ;--------------------------
      00150A                       4230 bit_test:
      00150A CD 0F 8C         [ 4] 4231 	call func_args 
      00150D A1 02            [ 1] 4232 	cp a,#2
      00150F 27 03            [ 1] 4233 	jreq 0$
      001511 CC 07 12         [ 2] 4234 	jp syntax_error
      001514                       4235 0$:	
      001514 CD 0D 71         [ 4] 4236 	call dpop 
      001517 9F               [ 1] 4237 	ld a,xl 
      001518 A4 07            [ 1] 4238 	and a,#7
      00151A 88               [ 1] 4239 	push a 
      00151B A6 01            [ 1] 4240 	ld a,#1 
      00151D 0D 01            [ 1] 4241 1$: tnz (1,sp)
      00151F 27 05            [ 1] 4242 	jreq 2$
      001521 48               [ 1] 4243 	sll a 
      001522 0A 01            [ 1] 4244 	dec (1,sp)
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 82.
Hexadecimal [24-Bits]



      001524 20 F7            [ 2] 4245 	jra 1$
      001526 CD 0D 71         [ 4] 4246 2$: call dpop 
      001529 F4               [ 1] 4247 	and a,(x)
      00152A 27 02            [ 1] 4248 	jreq 3$
      00152C A6 01            [ 1] 4249 	ld a,#1 
      00152E 5F               [ 1] 4250 3$:	clrw x 
      00152F 97               [ 1] 4251 	ld xl,a 
      001530 A6 04            [ 1] 4252 	ld a,#TK_INTGR
      001532                       4253 	_drop 1 
      001532 5B 01            [ 2]    1     addw sp,#1 
      001534 81               [ 4] 4254 	ret
                                   4255 
                                   4256 
                                   4257 ;--------------------
                                   4258 ; BASIC: POKE addr,byte
                                   4259 ; put a byte at addr 
                                   4260 ;--------------------
      001535                       4261 poke:
      001535 CD 0F 68         [ 4] 4262 	call arg_list 
      001538 A1 02            [ 1] 4263 	cp a,#2
      00153A 27 03            [ 1] 4264 	jreq 1$
      00153C CC 07 12         [ 2] 4265 	jp syntax_error
      00153F                       4266 1$:	
      00153F CD 0D 71         [ 4] 4267 	call dpop 
      001542 9F               [ 1] 4268     ld a,xl 
      001543 CD 0D 71         [ 4] 4269 	call dpop 
      001546 F7               [ 1] 4270 	ld (x),a 
      001547 81               [ 4] 4271 	ret 
                                   4272 
                                   4273 ;-----------------------
                                   4274 ; BASIC: PEEK(addr)
                                   4275 ; get the byte at addr 
                                   4276 ; input:
                                   4277 ;	none 
                                   4278 ; output:
                                   4279 ;	X 		value 
                                   4280 ;-----------------------
      001548                       4281 peek:
      001548 CD 0F 8C         [ 4] 4282 	call func_args
      00154B A1 01            [ 1] 4283 	cp a,#1
      00154D 27 03            [ 1] 4284 	jreq 1$
      00154F CC 07 12         [ 2] 4285 	jp syntax_error
      001552 CD 0D 71         [ 4] 4286 1$:	call dpop 
      001555 F6               [ 1] 4287 	ld a,(x)
      001556 5F               [ 1] 4288 	clrw x 
      001557 97               [ 1] 4289 	ld xl,a 
      001558 A6 04            [ 1] 4290 	ld a,#TK_INTGR
      00155A 81               [ 4] 4291 	ret 
                                   4292 
                                   4293 ;----------------------------
                                   4294 ; BASIC: XPEEK(page,addr)
                                   4295 ; read extended memory byte
                                   4296 ; page in range {0,1,2}
                                   4297 ;----------------------------
      00155B                       4298 xpeek:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 83.
Hexadecimal [24-Bits]



      00155B CD 0F 8C         [ 4] 4299 	call func_args 
      00155E A1 02            [ 1] 4300 	cp a,#2 
      001560 27 03            [ 1] 4301 	jreq 1$
      001562 CC 07 12         [ 2] 4302 	jp syntax_error
      001565                       4303 1$: 
      001565 CD 0D 71         [ 4] 4304 	call dpop 
      001568 CF 00 17         [ 2] 4305 	ldw farptr+1,x 
      00156B CD 0D 71         [ 4] 4306 	call dpop 
      00156E 9F               [ 1] 4307 	ld a,xl 
      00156F C7 00 16         [ 1] 4308 	ld farptr,a 
      001572 5F               [ 1] 4309 	clrw x
      001573 92 BC 00 16      [ 5] 4310 	ldf a,[farptr]
      001577 97               [ 1] 4311 	ld xl,a 
      001578 A6 04            [ 1] 4312 	ld a,#TK_INTGR 
      00157A 81               [ 4] 4313 	ret 
                                   4314 
                                   4315 ;---------------------------
                                   4316 ; BASIC IF expr : instructions
                                   4317 ; evaluate expr and if true 
                                   4318 ; execute instructions on same line. 
                                   4319 ;----------------------------
      00157B                       4320 if: 
      00157B CD 10 AC         [ 4] 4321 	call relation 
      00157E A1 04            [ 1] 4322 	cp a,#TK_INTGR
      001580 27 03            [ 1] 4323 	jreq 1$ 
      001582 CC 07 12         [ 2] 4324 	jp syntax_error
      001585 4F               [ 1] 4325 1$:	clr a 
      001586 5D               [ 2] 4326 	tnzw x 
      001587 26 05            [ 1] 4327 	jrne 9$  
                                   4328 ;skip to next line
      001589 55 00 03 00 01   [ 1] 4329 	mov in,count
      00158E 81               [ 4] 4330 9$:	ret 
                                   4331 
                                   4332 ;------------------------
                                   4333 ; BASIC: FOR var=expr 
                                   4334 ; set variable to expression 
                                   4335 ; leave variable address 
                                   4336 ; on dstack and set
                                   4337 ; FLOOP bit in 'flags'
                                   4338 ;-----------------
                           000001  4339 	RETL1=1
                           000003  4340 	INW=3
                           000005  4341 	BPTR=5
      00158F                       4342 for: ; { -- var_addr }
      00158F A6 05            [ 1] 4343 	ld a,#TK_VAR 
      001591 CD 0F 5B         [ 4] 4344 	call expect
      001594 CD 0D 64         [ 4] 4345 	call dpush 
      001597 CD 11 53         [ 4] 4346 	call let02 
      00159A 72 14 00 25      [ 1] 4347 	bset flags,#FLOOP 
                                   4348 ; open space on cstack for BPTR and INW 
      00159E 85               [ 2] 4349 	popw x ; call return address 
      00159F                       4350 	_vars 4
      00159F 52 04            [ 2]    1     sub sp,#4 
      0015A1 89               [ 2] 4351 	pushw x  ; RETL1 
      0015A2 5F               [ 1] 4352 	clrw x 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 84.
Hexadecimal [24-Bits]



      0015A3 1F 05            [ 2] 4353 	ldw (BPTR,sp),x 
      0015A5 1F 03            [ 2] 4354 	ldw (INW,sp),x 
      0015A7 CD 07 C6         [ 4] 4355 	call next_token 
      0015AA A1 06            [ 1] 4356 	cp a,#TK_CMD 
      0015AC 27 03            [ 1] 4357 	jreq 1$
      0015AE CC 07 12         [ 2] 4358 	jp syntax_error
      0015B1                       4359 1$:  
      0015B1 A3 15 B9         [ 2] 4360 	cpw x,#to 
      0015B4 27 03            [ 1] 4361 	jreq to
      0015B6 CC 07 12         [ 2] 4362 	jp syntax_error 
                                   4363 
                                   4364 ;-----------------------------------
                                   4365 ; BASIC: TO expr 
                                   4366 ; second part of FOR loop initilization
                                   4367 ; leave limit on dstack and set 
                                   4368 ; FTO bit in 'flags'
                                   4369 ;-----------------------------------
      0015B9                       4370 to: ; { var_addr -- var_addr limit step }
      0015B9 72 04 00 25 03   [ 2] 4371 	btjt flags,#FLOOP,1$
      0015BE CC 07 12         [ 2] 4372 	jp syntax_error
      0015C1 CD 10 AC         [ 4] 4373 1$: call relation  
      0015C4 A1 04            [ 1] 4374 	cp a,#TK_INTGR 
      0015C6 27 03            [ 1] 4375 	jreq 2$ 
      0015C8 CC 07 12         [ 2] 4376 	jp syntax_error
      0015CB                       4377 2$: 
      0015CB CD 0D 64         [ 4] 4378     call dpush ; limit
      0015CE CE 00 00         [ 2] 4379 	ldw x,in.w 
      0015D1 CD 07 C6         [ 4] 4380 	call next_token
      0015D4 A1 00            [ 1] 4381 	cp a,#TK_NONE  
      0015D6 27 0C            [ 1] 4382 	jreq 4$ 
      0015D8 A1 06            [ 1] 4383 	cp a,#TK_CMD
      0015DA 26 05            [ 1] 4384 	jrne 3$
      0015DC A3 15 EC         [ 2] 4385 	cpw x,#step 
      0015DF 27 0B            [ 1] 4386 	jreq step
      0015E1                       4387 3$:	
      0015E1 CD 0D 5E         [ 4] 4388 	call unget_token   	 
      0015E4                       4389 4$:	
      0015E4 AE 00 01         [ 2] 4390 	ldw x,#1   ; default step  
      0015E7 CD 0D 64         [ 4] 4391 	call dpush
      0015EA 20 15            [ 2] 4392 	jra store_loop_addr 
                                   4393 
                                   4394 
                                   4395 ;----------------------------------
                                   4396 ; BASIC: STEP expr 
                                   4397 ; optional third par of FOR loop
                                   4398 ; initialization. 	
                                   4399 ;------------------------------------
      0015EC                       4400 step: ; {var limit -- var limit step}
      0015EC 72 04 00 25 03   [ 2] 4401 	btjt flags,#FLOOP,1$
      0015F1 CC 07 12         [ 2] 4402 	jp syntax_error
      0015F4 CD 10 AC         [ 4] 4403 1$: call relation
      0015F7 A1 04            [ 1] 4404 	cp a,#TK_INTGR
      0015F9 27 03            [ 1] 4405 	jreq 2$
      0015FB CC 07 12         [ 2] 4406 	jp syntax_error
      0015FE CD 0D 64         [ 4] 4407 2$:	call dpush
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 85.
Hexadecimal [24-Bits]



                                   4408 ; leave loop back entry point on cstack 
                                   4409 ; cstack is 2 call deep from interp_loop
      001601                       4410 store_loop_addr:
      001601 CE 00 04         [ 2] 4411 	ldw x,basicptr  
      001604 1F 05            [ 2] 4412 	ldw (BPTR,sp),x 
      001606 CE 00 00         [ 2] 4413 	ldw x,in.w 
      001609 1F 03            [ 2] 4414 	ldw (INW,sp),x   
      00160B 72 15 00 25      [ 1] 4415 	bres flags,#FLOOP 
      00160F 72 5C 00 22      [ 1] 4416 	inc loop_depth  
      001613 81               [ 4] 4417 	ret 
                                   4418 
                                   4419 ;--------------------------------
                                   4420 ; BASIC: NEXT var 
                                   4421 ; FOR loop control 
                                   4422 ; increment variable with step 
                                   4423 ; and compare with limit 
                                   4424 ; loop if threshold not crossed.
                                   4425 ; else clean both stacks. 
                                   4426 ; and decrement 'loop_depth' 
                                   4427 ;--------------------------------
      001614                       4428 next: ; {var limit step -- [var limit step ] }
      001614 72 5D 00 22      [ 1] 4429 	tnz loop_depth 
      001618 26 03            [ 1] 4430 	jrne 1$ 
      00161A CC 07 12         [ 2] 4431 	jp syntax_error 
      00161D                       4432 1$: 
      00161D A6 05            [ 1] 4433 	ld a,#TK_VAR 
      00161F CD 0F 5B         [ 4] 4434 	call expect
                                   4435 ; check for good variable after NEXT 	 
      001622 90 93            [ 1] 4436 	ldw y,x 
      001624 AE 00 04         [ 2] 4437 	ldw x,#4  
      001627 72 D3 00 1C      [ 4] 4438 	cpw y,([dstkptr],x) ; compare variables address 
      00162B 27 03            [ 1] 4439 	jreq 2$  
      00162D CC 07 12         [ 2] 4440 	jp syntax_error ; not the good one 
      001630                       4441 2$: ; increment variable 
      001630 93               [ 1] 4442 	ldw x,y
      001631 FE               [ 2] 4443 	ldw x,(x)  ; get var value 
      001632 CF 00 0C         [ 2] 4444 	ldw acc16,x 
      001635 72 CE 00 1C      [ 5] 4445 	ldw x,[dstkptr] ; step
      001639 72 BB 00 0C      [ 2] 4446 	addw x,acc16 ; var+step 
      00163D 90 FF            [ 2] 4447 	ldw (y),x ; save var new value 
                                   4448 ; compare with limit 
      00163F 90 93            [ 1] 4449 	ldw y,x 
      001641 72 CE 00 1C      [ 5] 4450 	ldw x,[dstkptr] ; step in x 
      001645 5D               [ 2] 4451 	tnzw x  
      001646 2A 0B            [ 1] 4452 	jrpl 4$ ; positive step 
                                   4453 ;negative step 
      001648 AE 00 02         [ 2] 4454 	ldw x,#2
      00164B 72 D3 00 1C      [ 4] 4455 	cpw y,([dstkptr],x)
      00164F 2F 20            [ 1] 4456 	jrslt loop_done
      001651 20 09            [ 2] 4457 	jra loop_back 
      001653                       4458 4$: ; positive step
      001653 AE 00 02         [ 2] 4459 	ldw x,#2 
      001656 72 D3 00 1C      [ 4] 4460 	cpw y,([dstkptr],x)
      00165A 2C 15            [ 1] 4461 	jrsgt loop_done
      00165C                       4462 loop_back:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 86.
Hexadecimal [24-Bits]



      00165C 1E 05            [ 2] 4463 	ldw x,(BPTR,sp)
      00165E CF 00 04         [ 2] 4464 	ldw basicptr,x 
      001661 72 01 00 25 05   [ 2] 4465 	btjf flags,#FRUN,1$ 
      001666 E6 02            [ 1] 4466 	ld a,(2,x)
      001668 C7 00 03         [ 1] 4467 	ld count,a
      00166B 1E 03            [ 2] 4468 1$:	ldw x,(INW,sp)
      00166D CF 00 00         [ 2] 4469 	ldw in.w,x 
      001670 81               [ 4] 4470 	ret 
      001671                       4471 loop_done:
                                   4472 	; remove var limit step on dstack 
      001671 CE 00 1C         [ 2] 4473 	ldw x,dstkptr 
      001674 1C 00 06         [ 2] 4474 	addw x,#3*CELL_SIZE
      001677 CF 00 1C         [ 2] 4475 	ldw dstkptr,x 
                                   4476 	; remove 2 return address on cstack 
      00167A 85               [ 2] 4477 	popw x
      00167B                       4478 	_drop 4
      00167B 5B 04            [ 2]    1     addw sp,#4 
      00167D 89               [ 2] 4479 	pushw x 
      00167E 72 5A 00 22      [ 1] 4480 	dec loop_depth 
      001682 81               [ 4] 4481 	ret 
                                   4482 
                                   4483 ;----------------------------
                                   4484 ; called by goto/gosub
                                   4485 ; to get target line number 
                                   4486 ;---------------------------
      001683                       4487 get_target_line:
      001683 CD 10 AC         [ 4] 4488 	call relation 
      001686 A1 04            [ 1] 4489 	cp a,#TK_INTGR
      001688 27 03            [ 1] 4490 	jreq 1$
      00168A CC 07 12         [ 2] 4491 	jp syntax_error
      00168D CD 02 68         [ 4] 4492 1$:	call search_lineno  
      001690 5D               [ 2] 4493 	tnzw x 
      001691 26 05            [ 1] 4494 	jrne 2$ 
      001693 A6 05            [ 1] 4495 	ld a,#ERR_NO_LINE 
      001695 CC 07 14         [ 2] 4496 	jp tb_error 
      001698 81               [ 4] 4497 2$:	ret 
                                   4498 
                                   4499 ;------------------------
                                   4500 ; BASIC: GOTO line# 
                                   4501 ; jump to line# 
                                   4502 ; here cstack is 2 call deep from interp_loop 
                                   4503 ;------------------------
      001699                       4504 goto:
      001699 72 00 00 25 06   [ 2] 4505 	btjt flags,#FRUN,0$ 
      00169E A6 06            [ 1] 4506 	ld a,#ERR_RUN_ONLY
      0016A0 CC 07 14         [ 2] 4507 	jp tb_error 
      0016A3 81               [ 4] 4508 	ret 
      0016A4 CD 16 83         [ 4] 4509 0$:	call get_target_line
      0016A7                       4510 jp_to_target:
      0016A7 CF 00 04         [ 2] 4511 	ldw basicptr,x 
      0016AA E6 02            [ 1] 4512 	ld a,(2,x)
      0016AC C7 00 03         [ 1] 4513 	ld count,a 
      0016AF 35 03 00 01      [ 1] 4514 	mov in,#3 
      0016B3 81               [ 4] 4515 	ret 
                                   4516 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 87.
Hexadecimal [24-Bits]



                                   4517 
                                   4518 ;--------------------
                                   4519 ; BASIC: GOSUB line#
                                   4520 ; basic subroutine call
                                   4521 ; actual line# and basicptr 
                                   4522 ; are saved on cstack
                                   4523 ; here cstack is 2 call deep from interp_loop 
                                   4524 ;--------------------
                           000003  4525 	RET_ADDR=3
                           000005  4526 	RET_INW=5
                           000004  4527 	VSIZE=4  
      0016B4                       4528 gosub:
      0016B4 72 00 00 25 06   [ 2] 4529 	btjt flags,#FRUN,0$ 
      0016B9 A6 06            [ 1] 4530 	ld a,#ERR_RUN_ONLY
      0016BB CC 07 14         [ 2] 4531 	jp tb_error 
      0016BE 81               [ 4] 4532 	ret 
      0016BF 85               [ 2] 4533 0$:	popw x 
      0016C0                       4534 	_vars VSIZE  
      0016C0 52 04            [ 2]    1     sub sp,#VSIZE 
      0016C2 89               [ 2] 4535 	pushw x 
      0016C3 CE 00 04         [ 2] 4536 	ldw x,basicptr
      0016C6 1F 03            [ 2] 4537 	ldw (RET_ADDR,sp),x 
      0016C8 CD 16 83         [ 4] 4538 	call get_target_line  
      0016CB 89               [ 2] 4539 	pushw x 
      0016CC CE 00 00         [ 2] 4540 	ldw x,in.w 
      0016CF 1F 07            [ 2] 4541 	ldw (RET_INW+2,sp),x
      0016D1 85               [ 2] 4542 	popw x 
      0016D2 20 D3            [ 2] 4543 	jra jp_to_target
                                   4544 
                                   4545 ;------------------------
                                   4546 ; BASIC: RETURN 
                                   4547 ; exit from a subroutine 
                                   4548 ; 
                                   4549 ;------------------------
      0016D4                       4550 return:
      0016D4 72 00 00 25 05   [ 2] 4551 	btjt flags,#FRUN,0$ 
      0016D9 A6 06            [ 1] 4552 	ld a,#ERR_RUN_ONLY
      0016DB CC 07 14         [ 2] 4553 	jp tb_error 
      0016DE                       4554 0$:	
      0016DE 1E 03            [ 2] 4555 	ldw x,(RET_ADDR,sp) 
      0016E0 CF 00 04         [ 2] 4556 	ldw basicptr,x
      0016E3 E6 02            [ 1] 4557 	ld a,(2,x)
      0016E5 C7 00 03         [ 1] 4558 	ld count,a  
      0016E8 1E 05            [ 2] 4559 	ldw x,(RET_INW,sp)
      0016EA CF 00 00         [ 2] 4560 	ldw in.w,x 
      0016ED 85               [ 2] 4561 	popw x 
      0016EE                       4562 	_drop VSIZE 
      0016EE 5B 04            [ 2]    1     addw sp,#VSIZE 
      0016F0 89               [ 2] 4563 	pushw x
      0016F1 81               [ 4] 4564 	ret  
                                   4565 
                                   4566 
                                   4567 ;----------------------------------
                                   4568 ; BASIC: RUN
                                   4569 ; run BASIC program in RAM
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 88.
Hexadecimal [24-Bits]



                                   4570 ;----------------------------------- 
      0016F2                       4571 run: 
      0016F2 72 01 00 25 02   [ 2] 4572 	btjf flags,#FRUN,0$  
      0016F7 4F               [ 1] 4573 	clr a 
      0016F8 81               [ 4] 4574 	ret
      0016F9                       4575 0$: 
      0016F9 72 09 00 25 12   [ 2] 4576 	btjf flags,#FBREAK,1$
      0016FE                       4577 	_drop 2 
      0016FE 5B 02            [ 2]    1     addw sp,#2 
      001700 CD 14 25         [ 4] 4578 	call rest_context
      001703                       4579 	_drop CTXT_SIZE 
      001703 5B 04            [ 2]    1     addw sp,#CTXT_SIZE 
      001705 72 19 00 25      [ 1] 4580 	bres flags,#FBREAK 
      001709 72 10 00 25      [ 1] 4581 	bset flags,#FRUN 
      00170D CC 07 98         [ 2] 4582 	jp interp_loop 
      001710 CE 00 1E         [ 2] 4583 1$:	ldw x,txtbgn
      001713 C3 00 20         [ 2] 4584 	cpw x,txtend 
      001716 2B 02            [ 1] 4585 	jrmi run_it 
      001718 4F               [ 1] 4586 	clr a 
      001719 81               [ 4] 4587 	ret
                                   4588 
      00171A                       4589 run_it:	 
      00171A CD 11 27         [ 4] 4590     call ubound 
      00171D                       4591 	_drop 2 ; drop return address 
      00171D 5B 02            [ 2]    1     addw sp,#2 
                                   4592 ; clear data pointer 
      00171F 5F               [ 1] 4593 	clrw x 
      001720 CF 00 06         [ 2] 4594 	ldw data_ptr,x 
      001723 72 5F 00 08      [ 1] 4595 	clr data_ofs 
      001727 72 5F 00 09      [ 1] 4596 	clr data_len 
                                   4597 ; initialize BASIC pointer 
      00172B CE 00 1E         [ 2] 4598 	ldw x,txtbgn 
      00172E CF 00 04         [ 2] 4599 	ldw basicptr,x 
      001731 E6 02            [ 1] 4600 	ld a,(2,x)
      001733 C7 00 03         [ 1] 4601 	ld count,a
      001736 35 03 00 01      [ 1] 4602 	mov in,#3	
      00173A 72 10 00 25      [ 1] 4603 	bset flags,#FRUN 
      00173E CC 07 98         [ 2] 4604 	jp interp_loop 
                                   4605 
                                   4606 
                                   4607 ;----------------------
                                   4608 ; BASIC: STOP 
                                   4609 ; stop running program
                                   4610 ;---------------------- 
      001741                       4611 stop: 
                                   4612 ; clean dstack and cstack 
      001741 AE 17 FF         [ 2] 4613 	ldw x,#STACK_EMPTY 
      001744 94               [ 1] 4614 	ldw sp,x 
      001745 72 11 00 25      [ 1] 4615 	bres flags,#FRUN 
      001749 72 19 00 25      [ 1] 4616 	bres flags,#FBREAK
      00174D CC 07 55         [ 2] 4617 	jp warm_start
                                   4618 
                                   4619 
                                   4620 ;-----------------------
                                   4621 ; BASIC: TONE expr1,expr2
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 89.
Hexadecimal [24-Bits]



                                   4622 ; used TIMER2 channel 1
                                   4623 ; to produce a tone 
                                   4624 ; arguments:
                                   4625 ;    expr1   frequency 
                                   4626 ;    expr2   duration msec.
                                   4627 ;---------------------------
      001750                       4628 tone:
      001750 CD 0F 68         [ 4] 4629 	call arg_list 
      001753 A1 02            [ 1] 4630 	cp a,#2 
      001755 27 03            [ 1] 4631 	jreq 1$
      001757 CC 07 12         [ 2] 4632 	jp syntax_error 
      00175A                       4633 1$: 
      00175A                       4634 beep:
      00175A CD 0D 71         [ 4] 4635 	call dpop ; duration
      00175D 89               [ 2] 4636 	pushw x 
      00175E CD 0D 71         [ 4] 4637 	call dpop ; frequency
      001761 90 93            [ 1] 4638 	ldw y,x 
      001763 AE F4 24         [ 2] 4639 	ldw x,#TIM2_CLK_FREQ
      001766 65               [ 2] 4640 	divw x,y 
                                   4641 ; round to nearest integer 
      001767 90 A3 7A 12      [ 2] 4642 	cpw y,#TIM2_CLK_FREQ/2
      00176B 2B 01            [ 1] 4643 	jrmi 2$
      00176D 5C               [ 2] 4644 	incw x 
      00176E                       4645 2$:	 
      00176E 9E               [ 1] 4646 	ld a,xh 
      00176F C7 53 0D         [ 1] 4647 	ld TIM2_ARRH,a 
      001772 9F               [ 1] 4648 	ld a,xl 
      001773 C7 53 0E         [ 1] 4649 	ld TIM2_ARRL,a 
                                   4650 ; 50% duty cycle 
      001776 8C               [ 1] 4651 	ccf 
      001777 56               [ 2] 4652 	rrcw x 
      001778 9E               [ 1] 4653 	ld a,xh 
      001779 C7 53 0F         [ 1] 4654 	ld TIM2_CCR1H,a 
      00177C 9F               [ 1] 4655 	ld a,xl
      00177D C7 53 10         [ 1] 4656 	ld TIM2_CCR1L,a
      001780 72 10 53 08      [ 1] 4657 	bset TIM2_CCER1,#TIM2_CCER1_CC1E
      001784 72 10 53 00      [ 1] 4658 	bset TIM2_CR1,#TIM2_CR1_CEN
      001788 72 10 53 04      [ 1] 4659 	bset TIM2_EGR,#TIM2_EGR_UG
      00178C 85               [ 2] 4660 	popw x 
      00178D CF 00 10         [ 2] 4661 	ldw timer,x 
      001790 CE 00 10         [ 2] 4662 3$: ldw x,timer 	
      001793 26 FB            [ 1] 4663 	jrne 3$ 
      001795 72 11 53 08      [ 1] 4664 	bres TIM2_CCER1,#TIM2_CCER1_CC1E
      001799 72 11 53 00      [ 1] 4665 	bres TIM2_CR1,#TIM2_CR1_CEN 
      00179D 81               [ 4] 4666 	ret 
                                   4667 
                                   4668 ;-------------------------------
                                   4669 ; BASIC: ADCON 0|1 [,divisor]  
                                   4670 ; disable/enanble ADC 
                                   4671 ;-------------------------------
      00179E                       4672 power_adc:
      00179E CD 0F 68         [ 4] 4673 	call arg_list 
      0017A1 A1 02            [ 1] 4674 	cp a,#2	
      0017A3 27 0D            [ 1] 4675 	jreq 1$
      0017A5 A1 01            [ 1] 4676 	cp a,#1 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 90.
Hexadecimal [24-Bits]



      0017A7 27 03            [ 1] 4677 	jreq 0$ 
      0017A9 CC 07 12         [ 2] 4678 	jp syntax_error 
      0017AC AE 00 00         [ 2] 4679 0$: ldw x,#0
      0017AF CD 0D 64         [ 4] 4680 	call dpush 
      0017B2 AE 00 02         [ 2] 4681 1$: ldw x,#2
      0017B5 72 DE 00 1C      [ 5] 4682 	ldw x,([dstkptr],x) ; on|off
      0017B9 5D               [ 2] 4683 	tnzw x 
      0017BA 27 1C            [ 1] 4684 	jreq 2$ 
      0017BC 72 CE 00 1C      [ 5] 4685 	ldw x,[dstkptr] ; divisor 
      0017C0 9F               [ 1] 4686 	ld a,xl
      0017C1 A4 07            [ 1] 4687 	and a,#7
      0017C3 4E               [ 1] 4688 	swap a 
      0017C4 C7 54 01         [ 1] 4689 	ld ADC_CR1,a
      0017C7 72 16 50 CA      [ 1] 4690 	bset CLK_PCKENR2,#CLK_PCKENR2_ADC
      0017CB 72 10 54 01      [ 1] 4691 	bset ADC_CR1,#ADC_CR1_ADON 
      0017CF                       4692 	_usec_dly 7 
      0017CF AE 00 1B         [ 2]    1     ldw x,#(16*7-2)/4
      0017D2 5A               [ 2]    2     decw x
      0017D3 9D               [ 1]    3     nop 
      0017D4 26 FA            [ 1]    4     jrne .-4
      0017D6 20 08            [ 2] 4693 	jra 3$
      0017D8 72 11 54 01      [ 1] 4694 2$: bres ADC_CR1,#ADC_CR1_ADON
      0017DC 72 17 50 CA      [ 1] 4695 	bres CLK_PCKENR2,#CLK_PCKENR2_ADC
      0017E0 AE 00 04         [ 2] 4696 3$:	ldw x,#4 ; drop 2 elements on dstack 
      0017E3 72 BB 00 1C      [ 2] 4697 	addw x,dstkptr
      0017E7 CF 00 1C         [ 2] 4698 	ldw dstkptr,x 
      0017EA 81               [ 4] 4699 	ret
                                   4700 
                                   4701 ;-----------------------------
                                   4702 ; BASIC: ADCREAD (channel)
                                   4703 ; read adc channel {0..5}
                                   4704 ; output:
                                   4705 ;   A 		TK_INTGR 
                                   4706 ;   X 		value 
                                   4707 ;-----------------------------
      0017EB                       4708 analog_read:
      0017EB CD 0F 8C         [ 4] 4709 	call func_args 
      0017EE A1 01            [ 1] 4710 	cp a,#1 
      0017F0 27 03            [ 1] 4711 	jreq 1$
      0017F2 CC 07 12         [ 2] 4712 	jp syntax_error
      0017F5 CD 0D 71         [ 4] 4713 1$: call dpop 
      0017F8 A3 00 05         [ 2] 4714 	cpw x,#5 
      0017FB 23 05            [ 2] 4715 	jrule 2$
      0017FD A6 0A            [ 1] 4716 	ld a,#ERR_BAD_VALUE
      0017FF CC 07 14         [ 2] 4717 	jp tb_error 
      001802 9F               [ 1] 4718 2$: ld a,xl
      001803 C7 00 0D         [ 1] 4719 	ld acc8,a 
      001806 A6 05            [ 1] 4720 	ld a,#5
      001808 C0 00 0D         [ 1] 4721 	sub a,acc8 
      00180B C7 54 00         [ 1] 4722 	ld ADC_CSR,a
      00180E 72 16 54 02      [ 1] 4723 	bset ADC_CR2,#ADC_CR2_ALIGN
      001812 72 10 54 01      [ 1] 4724 	bset ADC_CR1,#ADC_CR1_ADON
      001816 72 0F 54 00 FB   [ 2] 4725 	btjf ADC_CSR,#ADC_CSR_EOC,.
      00181B CE 54 04         [ 2] 4726 	ldw x,ADC_DRH
      00181E A6 04            [ 1] 4727 	ld a,#TK_INTGR
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 91.
Hexadecimal [24-Bits]



      001820 81               [ 4] 4728 	ret 
                                   4729 
                                   4730 ;-----------------------
                                   4731 ; BASIC: DREAD(pin)
                                   4732 ; Arduino pins 
                                   4733 ; read state of a digital pin 
                                   4734 ; pin# {0..15}
                                   4735 ; output:
                                   4736 ;    A 		TK_INTGR
                                   4737 ;    X      0|1 
                                   4738 ;-------------------------
                           000001  4739 	PINNO=1
                           000001  4740 	VSIZE=1
      001821                       4741 digital_read:
      001821                       4742 	_vars VSIZE 
      001821 52 01            [ 2]    1     sub sp,#VSIZE 
      001823 CD 0F 8C         [ 4] 4743 	call func_args
      001826 A1 01            [ 1] 4744 	cp a,#1
      001828 27 03            [ 1] 4745 	jreq 1$
      00182A CC 07 12         [ 2] 4746 	jp syntax_error
      00182D CD 0D 71         [ 4] 4747 1$: call dpop 
      001830 A3 00 0F         [ 2] 4748 	cpw x,#15 
      001833 23 05            [ 2] 4749 	jrule 2$
      001835 A6 0A            [ 1] 4750 	ld a,#ERR_BAD_VALUE
      001837 CC 07 14         [ 2] 4751 	jp tb_error 
      00183A CD 1E 38         [ 4] 4752 2$:	call select_pin 
      00183D 6B 01            [ 1] 4753 	ld (PINNO,sp),a
      00183F E6 01            [ 1] 4754 	ld a,(GPIO_IDR,x)
      001841 0D 01            [ 1] 4755 	tnz (PINNO,sp)
      001843 27 05            [ 1] 4756 	jreq 8$
      001845 44               [ 1] 4757 3$: srl a 
      001846 0A 01            [ 1] 4758 	dec (PINNO,sp)
      001848 26 FB            [ 1] 4759 	jrne 3$ 
      00184A A4 01            [ 1] 4760 8$: and a,#1 
      00184C 5F               [ 1] 4761 	clrw x 
      00184D 97               [ 1] 4762 	ld xl,a 
      00184E A6 04            [ 1] 4763 	ld a,#TK_INTGR
      001850                       4764 	_drop VSIZE
      001850 5B 01            [ 2]    1     addw sp,#VSIZE 
      001852 81               [ 4] 4765 	ret
                                   4766 
                                   4767 ;-----------------------
                                   4768 ; BASIC: DWRITE pin,0|1
                                   4769 ; Arduino pins 
                                   4770 ; write to a digital pin 
                                   4771 ; pin# {0..15}
                                   4772 ; output:
                                   4773 ;    A 		TK_INTGR
                                   4774 ;    X      0|1 
                                   4775 ;-------------------------
                           000001  4776 	PINNO=1
                           000002  4777 	PINVAL=2
                           000002  4778 	VSIZE=2
      001853                       4779 digital_write:
      001853                       4780 	_vars VSIZE 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 92.
Hexadecimal [24-Bits]



      001853 52 02            [ 2]    1     sub sp,#VSIZE 
      001855 CD 0F 68         [ 4] 4781 	call arg_list  
      001858 A1 02            [ 1] 4782 	cp a,#2 
      00185A 27 03            [ 1] 4783 	jreq 1$
      00185C CC 07 12         [ 2] 4784 	jp syntax_error
      00185F CD 0D 71         [ 4] 4785 1$: call dpop 
      001862 9F               [ 1] 4786 	ld a,xl 
      001863 6B 02            [ 1] 4787 	ld (PINVAL,sp),a
      001865 CD 0D 71         [ 4] 4788 	call dpop
      001868 A3 00 0F         [ 2] 4789 	cpw x,#15 
      00186B 23 05            [ 2] 4790 	jrule 2$
      00186D A6 0A            [ 1] 4791 	ld a,#ERR_BAD_VALUE
      00186F CC 07 14         [ 2] 4792 	jp tb_error 
      001872 CD 1E 38         [ 4] 4793 2$:	call select_pin 
      001875 6B 01            [ 1] 4794 	ld (PINNO,sp),a 
      001877 A6 01            [ 1] 4795 	ld a,#1
      001879 0D 01            [ 1] 4796 	tnz (PINNO,sp)
      00187B 27 05            [ 1] 4797 	jreq 4$
      00187D 48               [ 1] 4798 3$: sll a
      00187E 0A 01            [ 1] 4799 	dec (PINNO,sp)
      001880 26 FB            [ 1] 4800 	jrne 3$
      001882 0D 02            [ 1] 4801 4$: tnz (PINVAL,sp)
      001884 26 05            [ 1] 4802 	jrne 5$
      001886 43               [ 1] 4803 	cpl a 
      001887 E4 00            [ 1] 4804 	and a,(GPIO_ODR,x)
      001889 20 02            [ 2] 4805 	jra 8$
      00188B EA 00            [ 1] 4806 5$: or a,(GPIO_ODR,x)
      00188D E7 00            [ 1] 4807 8$: ld (GPIO_ODR,x),a 
      00188F                       4808 	_drop VSIZE 
      00188F 5B 02            [ 2]    1     addw sp,#VSIZE 
      001891 81               [ 4] 4809 	ret
                                   4810 
                                   4811 
                                   4812 ;-----------------------
                                   4813 ; BASIC: BREAK 
                                   4814 ; insert a breakpoint 
                                   4815 ; in pogram. 
                                   4816 ; the program is resumed
                                   4817 ; with RUN 
                                   4818 ;-------------------------
      001892                       4819 break:
      001892 72 00 00 25 02   [ 2] 4820 	btjt flags,#FRUN,2$
      001897 4F               [ 1] 4821 	clr a
      001898 81               [ 4] 4822 	ret 
      001899                       4823 2$:	 
                                   4824 ; create space on cstack to save context 
      001899 AE 18 C0         [ 2] 4825 	ldw x,#break_point 
      00189C CD 01 C6         [ 4] 4826 	call puts 
      00189F                       4827 	_drop 2 ;drop return address 
      00189F 5B 02            [ 2]    1     addw sp,#2 
      0018A1                       4828 	_vars CTXT_SIZE ; context size 
      0018A1 52 04            [ 2]    1     sub sp,#CTXT_SIZE 
      0018A3 CD 14 15         [ 4] 4829 	call save_context 
      0018A6 AE 16 E8         [ 2] 4830 	ldw x,#tib 
      0018A9 CF 00 04         [ 2] 4831 	ldw basicptr,x
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 93.
Hexadecimal [24-Bits]



      0018AC 7F               [ 1] 4832 	clr (x)
      0018AD 72 5F 00 03      [ 1] 4833 	clr count  
      0018B1 5F               [ 1] 4834 	clrw x 
      0018B2 CF 00 00         [ 2] 4835 	ldw in.w,x
      0018B5 72 11 00 25      [ 1] 4836 	bres flags,#FRUN 
      0018B9 72 18 00 25      [ 1] 4837 	bset flags,#FBREAK
      0018BD CC 07 98         [ 2] 4838 	jp interp_loop 
      0018C0 0A 62 72 65 61 6B 20  4839 break_point: .asciz "\nbreak point, RUN to resume.\n"
             70 6F 69 6E 74 2C 20
             52 55 4E 20 74 6F 20
             72 65 73 75 6D 65 2E
             0A 00
                                   4840 
                                   4841 ;-----------------------
                                   4842 ; BASIC: NEW
                                   4843 ; from command line only 
                                   4844 ; free program memory
                                   4845 ; and clear variables 
                                   4846 ;------------------------
      0018DE                       4847 new: 
      0018DE 72 01 00 25 02   [ 2] 4848 	btjf flags,#FRUN,0$ 
      0018E3 4F               [ 1] 4849 	clr a 
      0018E4 81               [ 4] 4850 	ret 
      0018E5                       4851 0$:	
      0018E5 CD 05 DC         [ 4] 4852 	call clear_basic 
      0018E8 81               [ 4] 4853 	ret 
                                   4854 	 
                                   4855 ;;;;;;;;;;;;;;;;;;;;;;;;;
                                   4856 ;  file system routines
                                   4857 ;  MCU flash memory from
                                   4858 ;  0x10000-0x27fff is 
                                   4859 ;  used to store BASIC 
                                   4860 ;  program files. 
                                   4861 ;;;;;;;;;;;;;;;;;;;;;;;;;
                                   4862 
                                   4863 ;--------------------
                                   4864 ; input:
                                   4865 ;   X     increment 
                                   4866 ; output:
                                   4867 ;   farptr  incremented 
                                   4868 ;---------------------
      0018E9                       4869 incr_farptr:
      0018E9 72 BB 00 17      [ 2] 4870 	addw x,farptr+1 
      0018ED 24 04            [ 1] 4871 	jrnc 1$
      0018EF 72 5C 00 16      [ 1] 4872 	inc farptr 
      0018F3 CF 00 17         [ 2] 4873 1$:	ldw farptr+1,x  
      0018F6 81               [ 4] 4874 	ret 
                                   4875 
                                   4876 ;------------------------------
                                   4877 ; extended flash memory used as FLASH_DRIVE 
                                   4878 ; seek end of used flash drive   
                                   4879 ; starting at 0x10000 address.
                                   4880 ; 4 consecutives 0 bytes signal free space. 
                                   4881 ; input:
                                   4882 ;	none
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 94.
Hexadecimal [24-Bits]



                                   4883 ; output:
                                   4884 ;   ffree     free_addr| 0 if memory full.
                                   4885 ;------------------------------
      0018F7                       4886 seek_fdrive:
                                   4887 ; start scan at 0x10000 address 
      0018F7 A6 01            [ 1] 4888 	ld a,#1
      0018F9 C7 00 16         [ 1] 4889 	ld farptr,a 
      0018FC 5F               [ 1] 4890 	clrw x 
      0018FD CF 00 17         [ 2] 4891 	ldw farptr+1,x 
      001900                       4892 1$:
      001900 AE 00 03         [ 2] 4893 	ldw x,#3  
      001903 92 AF 00 16      [ 5] 4894 2$:	ldf a,([farptr],x) 
      001907 26 05            [ 1] 4895 	jrne 3$
      001909 5A               [ 2] 4896 	decw x
      00190A 2A F7            [ 1] 4897 	jrpl 2$
      00190C 20 19            [ 2] 4898 	jra 4$ 
      00190E 5C               [ 2] 4899 3$:	incw x 
      00190F CD 18 E9         [ 4] 4900 	call incr_farptr
      001912 AE 02 7F         [ 2] 4901 	ldw x,#0x27f 
      001915 C3 00 16         [ 2] 4902 	cpw x,farptr
      001918 2A E6            [ 1] 4903 	jrpl 1$
                                   4904 ; drive full 
      00191A 72 5F 00 19      [ 1] 4905 	clr ffree 
      00191E 72 5F 00 1A      [ 1] 4906 	clr ffree+1 
      001922 72 5F 00 1B      [ 1] 4907 	clr ffree+2 
      001926 81               [ 4] 4908 	ret
      001927                       4909 4$: ; copy farptr to ffree	 
      001927 CE 00 16         [ 2] 4910 	ldw x,farptr 
      00192A C6 00 18         [ 1] 4911 	ld a,farptr+2 
      00192D CF 00 19         [ 2] 4912 	ldw ffree,x 
      001930 C7 00 1B         [ 1] 4913 	ld ffree+2,a  
      001933 81               [ 4] 4914 	ret 
                                   4915 
                                   4916 ;-----------------------
                                   4917 ; compare file name 
                                   4918 ; with name pointed by Y  
                                   4919 ; input:
                                   4920 ;   farptr   file name 
                                   4921 ;   Y        target name 
                                   4922 ; output:
                                   4923 ;   farptr 	 at file_name
                                   4924 ;   X 		 farptr[x] point at size field  
                                   4925 ;   Carry    0|1 no match|match  
                                   4926 ;----------------------
      001934                       4927 cmp_name:
      001934 5F               [ 1] 4928 	clrw x
      001935 92 AF 00 16      [ 5] 4929 1$:	ldf a,([farptr],x)
      001939 90 F1            [ 1] 4930 	cp a,(y)
      00193B 26 08            [ 1] 4931 	jrne 4$
      00193D 4D               [ 1] 4932 	tnz a 
      00193E 27 12            [ 1] 4933 	jreq 9$ 
      001940 5C               [ 2] 4934     incw x 
      001941 90 5C            [ 2] 4935 	incw y 
      001943 20 F0            [ 2] 4936 	jra 1$
      001945                       4937 4$: ;no match 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 95.
Hexadecimal [24-Bits]



      001945 4D               [ 1] 4938 	tnz a 
      001946 27 07            [ 1] 4939 	jreq 5$
      001948 5C               [ 2] 4940 	incw x 
      001949 92 AF 00 16      [ 5] 4941 	ldf a,([farptr],x)
      00194D 20 F6            [ 2] 4942 	jra 4$  
      00194F 5C               [ 2] 4943 5$:	incw x ; farptr[x] point at 'size' field 
      001950 98               [ 1] 4944 	rcf 
      001951 81               [ 4] 4945 	ret
      001952                       4946 9$: ; match  
      001952 5C               [ 2] 4947 	incw x  ; farptr[x] at 'size' field 
      001953 99               [ 1] 4948 	scf 
      001954 81               [ 4] 4949 	ret 
                                   4950 
                                   4951 ;-----------------------
                                   4952 ; search file in 
                                   4953 ; flash memory 
                                   4954 ; input:
                                   4955 ;   Y       file name  
                                   4956 ; output:
                                   4957 ;   farptr  addr at name|0
                                   4958 ;-----------------------
                           000001  4959 	FSIZE=1
                           000003  4960 	YSAVE=3
                           000004  4961 	VSIZE=4 
      001955                       4962 search_file: 
      001955                       4963 	_vars VSIZE
      001955 52 04            [ 2]    1     sub sp,#VSIZE 
      001957 17 03            [ 2] 4964 	ldw (YSAVE,sp),y  
      001959 5F               [ 1] 4965 	clrw x 
      00195A CF 00 17         [ 2] 4966 	ldw farptr+1,x 
      00195D 35 01 00 16      [ 1] 4967 	mov farptr,#1
      001961                       4968 1$:	
                                   4969 ; check if farptr is after any file 
                                   4970 ; if  0 then so.
      001961 92 BC 00 16      [ 5] 4971 	ldf a,[farptr]
      001965 27 25            [ 1] 4972 	jreq 6$
      001967 5F               [ 1] 4973 2$: clrw x 	
      001968 16 03            [ 2] 4974 	ldw y,(YSAVE,sp) 
      00196A CD 19 34         [ 4] 4975 	call cmp_name
      00196D 25 2D            [ 1] 4976 	jrc 9$
      00196F 92 AF 00 16      [ 5] 4977 	ldf a,([farptr],x)
      001973 6B 01            [ 1] 4978 	ld (FSIZE,sp),a 
      001975 5C               [ 2] 4979 	incw x 
      001976 92 AF 00 16      [ 5] 4980 	ldf a,([farptr],x)
      00197A 6B 02            [ 1] 4981 	ld (FSIZE+1,sp),a 
      00197C 5C               [ 2] 4982 	incw x 
      00197D 72 FB 01         [ 2] 4983 	addw x,(FSIZE,sp) ; count to skip 
      001980 5C               [ 2] 4984 	incw x ; skip over EOF marker 
      001981 CD 18 E9         [ 4] 4985 	call incr_farptr ; now at next file 'name_field'
      001984 AE 02 80         [ 2] 4986 	ldw x,#0x280
      001987 C3 00 16         [ 2] 4987 	cpw x,farptr 
      00198A 2A D5            [ 1] 4988 	jrpl 1$
      00198C                       4989 6$: ; file not found 
      00198C 72 5F 00 16      [ 1] 4990 	clr farptr
      001990 72 5F 00 17      [ 1] 4991 	clr farptr+1 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 96.
Hexadecimal [24-Bits]



      001994 72 5F 00 18      [ 1] 4992 	clr farptr+2 
      001998                       4993 	_drop VSIZE 
      001998 5B 04            [ 2]    1     addw sp,#VSIZE 
      00199A 98               [ 1] 4994 	rcf
      00199B 81               [ 4] 4995 	ret
      00199C                       4996 9$: ; file found  farptr[0] at 'name_field',farptr[x] at 'file_size' 
      00199C                       4997 	_drop VSIZE 
      00199C 5B 04            [ 2]    1     addw sp,#VSIZE 
      00199E 99               [ 1] 4998 	scf 	
      00199F 81               [ 4] 4999 	ret
                                   5000 
                                   5001 ;--------------------------------
                                   5002 ; BASIC: SAVE "name" 
                                   5003 ; save text program in 
                                   5004 ; flash memory used as 
                                   5005 ;--------------------------------
                           000001  5006 	BSIZE=1
                           000003  5007 	NAMEPTR=3
                           000004  5008 	VSIZE=4
      0019A0                       5009 save:
      0019A0 72 01 00 25 05   [ 2] 5010 	btjf flags,#FRUN,0$ 
      0019A5 A6 07            [ 1] 5011 	ld a,#ERR_CMD_ONLY 
      0019A7 CC 07 14         [ 2] 5012 	jp tb_error
      0019AA                       5013 0$:	 
      0019AA CE 00 20         [ 2] 5014 	ldw x,txtend 
      0019AD 72 B0 00 1E      [ 2] 5015 	subw x,txtbgn
      0019B1 26 01            [ 1] 5016 	jrne 1$
                                   5017 ; nothing to save 
      0019B3 81               [ 4] 5018 	ret 
      0019B4                       5019 1$:	
      0019B4                       5020 	_vars VSIZE 
      0019B4 52 04            [ 2]    1     sub sp,#VSIZE 
      0019B6 1F 01            [ 2] 5021 	ldw (BSIZE,sp),x 
      0019B8 CD 07 C6         [ 4] 5022 	call next_token	
      0019BB A1 0A            [ 1] 5023 	cp a,#TK_QSTR
      0019BD 27 03            [ 1] 5024 	jreq 2$
      0019BF CC 07 12         [ 2] 5025 	jp syntax_error
      0019C2                       5026 2$: 
      0019C2 90 CE 00 04      [ 2] 5027 	ldw y,basicptr 
      0019C6 72 B9 00 00      [ 2] 5028 	addw y,in.w
      0019CA 17 03            [ 2] 5029 	ldw (NAMEPTR,sp),y  
      0019CC 55 00 03 00 01   [ 1] 5030 	mov in,count 
                                   5031 ; check if enough free space 
      0019D1 93               [ 1] 5032 	ldw x,y 
      0019D2 CD 01 FA         [ 4] 5033 	call strlen 
      0019D5 1C 00 03         [ 2] 5034 	addw x,#3 
      0019D8 72 FB 01         [ 2] 5035 	addw x,(BSIZE,sp)
      0019DB 72 5D 00 19      [ 1] 5036 	tnz ffree 
      0019DF 26 0B            [ 1] 5037 	jrne 21$
      0019E1 72 B0 00 1A      [ 2] 5038 	subw x,ffree+1 
      0019E5 23 05            [ 2] 5039 	jrule 21$
      0019E7 A6 01            [ 1] 5040 	ld a,#ERR_MEM_FULL 
      0019E9 CC 07 14         [ 2] 5041 	jp tb_error
      0019EC                       5042 21$: 
                                   5043 ; check for existing file of that name 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 97.
Hexadecimal [24-Bits]



      0019EC 16 03            [ 2] 5044 	ldw y,(NAMEPTR,sp)	
      0019EE CD 19 55         [ 4] 5045 	call search_file 
      0019F1 24 05            [ 1] 5046 	jrnc 3$ 
      0019F3 A6 08            [ 1] 5047 	ld a,#ERR_DUPLICATE 
      0019F5 CC 07 14         [ 2] 5048 	jp tb_error 
      0019F8                       5049 3$:	;** write file name to flash **
      0019F8 CE 00 19         [ 2] 5050 	ldw x,ffree 
      0019FB C6 00 1B         [ 1] 5051 	ld a,ffree+2 
      0019FE CF 00 16         [ 2] 5052 	ldw farptr,x 
      001A01 C7 00 18         [ 1] 5053 	ld farptr+2,a 
      001A04 1E 03            [ 2] 5054 	ldw x,(NAMEPTR,sp)  
      001A06 CD 01 FA         [ 4] 5055 	call strlen 
      001A09 5C               [ 2] 5056 	incw  x
      001A0A 1F 01            [ 2] 5057 	ldw (BSIZE,sp),x  
      001A0C 5F               [ 1] 5058 	clrw x   
      001A0D 16 03            [ 2] 5059 	ldw y,(NAMEPTR,sp)
      001A0F CD 01 55         [ 4] 5060 	call write_block  
                                   5061 ;** write file length after name **
      001A12 CE 00 20         [ 2] 5062 	ldw x,txtend 
      001A15 72 B0 00 1E      [ 2] 5063 	subw x,txtbgn
      001A19 1F 01            [ 2] 5064 	ldw (BSIZE,sp),x 
      001A1B 5F               [ 1] 5065 	clrw x 
      001A1C 7B 01            [ 1] 5066 	ld a,(1,sp)
      001A1E CD 00 E0         [ 4] 5067 	call write_byte 
      001A21 5C               [ 2] 5068 	incw x 
      001A22 7B 02            [ 1] 5069 	ld a,(2,sp)
      001A24 CD 00 E0         [ 4] 5070 	call write_byte
      001A27 5C               [ 2] 5071 	incw x  
      001A28 CD 18 E9         [ 4] 5072 	call incr_farptr ; move farptr after SIZE field 
                                   5073 ;** write BASIC text **
                                   5074 ; copy BSIZE, cstack:{... bsize -- ... bsize bsize }	
      001A2B 1E 01            [ 2] 5075 	ldw x,(BSIZE,sp)
      001A2D 89               [ 2] 5076 	pushw x ; write_block argument 
      001A2E 5F               [ 1] 5077 	clrw x 
      001A2F 90 CE 00 1E      [ 2] 5078 	ldw y,txtbgn  ; BASIC text to save 
      001A33 CD 01 55         [ 4] 5079 	call write_block 
      001A36                       5080 	_drop 2 ;  drop write_block argument  
      001A36 5B 02            [ 2]    1     addw sp,#2 
                                   5081 ; write en end of file marker 
      001A38 AE 00 01         [ 2] 5082 	ldw x,#1
      001A3B A6 FF            [ 1] 5083 	ld a,#EOF  
      001A3D CD 00 E0         [ 4] 5084 	call write_byte 
      001A40 CD 18 E9         [ 4] 5085 	call incr_farptr
                                   5086 ; save farptr in ffree
      001A43 CE 00 16         [ 2] 5087 	ldw x,farptr 
      001A46 C6 00 18         [ 1] 5088 	ld a,farptr+2 
      001A49 CF 00 19         [ 2] 5089 	ldw ffree,x 
      001A4C C7 00 1B         [ 1] 5090 	ld ffree+2,a
                                   5091 ;write 4 zero bytes as an end of all files marker 
      001A4F 5F               [ 1] 5092     clrw x 
      001A50 4B 04            [ 1] 5093 	push #4 
      001A52                       5094 4$:
      001A52 4F               [ 1] 5095 	clr a 
      001A53 CD 00 E0         [ 4] 5096 	call write_byte 
      001A56 5C               [ 2] 5097 	incw x 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 98.
Hexadecimal [24-Bits]



      001A57 0A 01            [ 1] 5098 	dec (1,sp)
      001A59 26 F7            [ 1] 5099 	jrne 4$
      001A5B 84               [ 1] 5100 5$: pop a 
                                   5101 ; display saved size  
      001A5C 1E 01            [ 2] 5102 	ldw x,(BSIZE,sp) 
      001A5E CD 08 63         [ 4] 5103 	call print_int 
      001A61                       5104 	_drop VSIZE 
      001A61 5B 04            [ 2]    1     addw sp,#VSIZE 
      001A63 81               [ 4] 5105 	ret 
                                   5106 
                                   5107 ;----------------------
                                   5108 ; load file in RAM memory
                                   5109 ; input:
                                   5110 ;    farptr point at file size 
                                   5111 ; output:
                                   5112 ;   y point after BASIC program in RAM.
                                   5113 ;------------------------
      001A64                       5114 load_file:
      001A64 CD 18 E9         [ 4] 5115 	call incr_farptr  
      001A67 CD 05 DC         [ 4] 5116 	call clear_basic  
      001A6A 5F               [ 1] 5117 	clrw x
      001A6B 92 AF 00 16      [ 5] 5118 	ldf a,([farptr],x)
      001A6F 90 95            [ 1] 5119 	ld yh,a 
      001A71 5C               [ 2] 5120 	incw x  
      001A72 92 AF 00 16      [ 5] 5121 	ldf a,([farptr],x)
      001A76 5C               [ 2] 5122 	incw x 
      001A77 90 97            [ 1] 5123 	ld yl,a 
      001A79 72 B9 00 1E      [ 2] 5124 	addw y,txtbgn
      001A7D 90 CF 00 20      [ 2] 5125 	ldw txtend,y
      001A81 90 CE 00 1E      [ 2] 5126 	ldw y,txtbgn
      001A85                       5127 3$:	; load BASIC text 	
      001A85 92 AF 00 16      [ 5] 5128 	ldf a,([farptr],x)
      001A89 90 F7            [ 1] 5129 	ld (y),a 
      001A8B 5C               [ 2] 5130 	incw x 
      001A8C 90 5C            [ 2] 5131 	incw y 
      001A8E 90 C3 00 20      [ 2] 5132 	cpw y,txtend 
      001A92 2B F1            [ 1] 5133 	jrmi 3$
      001A94 81               [ 4] 5134 	ret 
                                   5135 
                                   5136 ;------------------------
                                   5137 ; BASIC: LOAD "file" 
                                   5138 ; load file to RAM 
                                   5139 ; for execution 
                                   5140 ;------------------------
      001A95                       5141 load:
      001A95 72 01 00 25 07   [ 2] 5142 	btjf flags,#FRUN,0$ 
      001A9A 27 05            [ 1] 5143 	jreq 0$ 
      001A9C A6 07            [ 1] 5144 	ld a,#ERR_CMD_ONLY 
      001A9E CC 07 14         [ 2] 5145 	jp tb_error 
      001AA1                       5146 0$:	
      001AA1 CD 07 C6         [ 4] 5147 	call next_token 
      001AA4 A1 0A            [ 1] 5148 	cp a,#TK_QSTR
      001AA6 27 03            [ 1] 5149 	jreq 1$
      001AA8 CC 07 12         [ 2] 5150 	jp syntax_error 
      001AAB                       5151 1$:	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 99.
Hexadecimal [24-Bits]



      001AAB 90 CE 00 04      [ 2] 5152 	ldw y,basicptr
      001AAF 72 B9 00 00      [ 2] 5153 	addw y,in.w 
      001AB3 55 00 03 00 01   [ 1] 5154 	mov in,count 
      001AB8 CD 19 55         [ 4] 5155 	call search_file 
      001ABB 25 05            [ 1] 5156 	jrc 2$ 
      001ABD A6 09            [ 1] 5157 	ld a,#ERR_NOT_FILE
      001ABF CC 07 14         [ 2] 5158 	jp tb_error  
      001AC2                       5159 2$:
      001AC2 CD 1A 64         [ 4] 5160 	call load_file
                                   5161 ; print loaded size 	 
      001AC5 CE 00 20         [ 2] 5162 	ldw x,txtend 
      001AC8 72 B0 00 1E      [ 2] 5163 	subw x,txtbgn
      001ACC CD 08 63         [ 4] 5164 	call print_int 
      001ACF 81               [ 4] 5165 	ret 
                                   5166 
                                   5167 ;-----------------------------------
                                   5168 ; BASIC: FORGET ["file_name"] 
                                   5169 ; erase file_name and all others 
                                   5170 ; after it. 
                                   5171 ; without argument erase all files 
                                   5172 ;-----------------------------------
      001AD0                       5173 forget:
      001AD0 CD 07 C6         [ 4] 5174 	call next_token 
      001AD3 A1 00            [ 1] 5175 	cp a,#TK_NONE 
      001AD5 27 26            [ 1] 5176 	jreq 3$ 
      001AD7 A1 0A            [ 1] 5177 	cp a,#TK_QSTR
      001AD9 27 03            [ 1] 5178 	jreq 1$
      001ADB CC 07 12         [ 2] 5179 	jp syntax_error
      001ADE 90 CE 00 04      [ 2] 5180 1$: ldw y,basicptr
      001AE2 72 B9 00 00      [ 2] 5181 	addw y,in.w
      001AE6 55 00 03 00 01   [ 1] 5182 	mov in,count 
      001AEB CD 19 55         [ 4] 5183 	call search_file
      001AEE 25 05            [ 1] 5184 	jrc 2$
      001AF0 A6 09            [ 1] 5185 	ld a,#ERR_NOT_FILE 
      001AF2 CC 07 14         [ 2] 5186 	jp tb_error 
      001AF5                       5187 2$: 
      001AF5 CE 00 16         [ 2] 5188 	ldw x,farptr
      001AF8 C6 00 18         [ 1] 5189 	ld a,farptr+2
      001AFB 20 0A            [ 2] 5190 	jra 4$ 
      001AFD                       5191 3$: ; forget all files 
      001AFD AE 01 00         [ 2] 5192 	ldw x,#0x100
      001B00 4F               [ 1] 5193 	clr a 
      001B01 CF 00 16         [ 2] 5194 	ldw farptr,x 
      001B04 C7 00 18         [ 1] 5195 	ld farptr+2,a 
      001B07                       5196 4$:
      001B07 CF 00 19         [ 2] 5197 	ldw ffree,x 
      001B0A C7 00 1B         [ 1] 5198 	ld ffree+2,a 
      001B0D 4B 04            [ 1] 5199 	push #4
      001B0F 5F               [ 1] 5200 	clrw x 
      001B10                       5201 5$: 
      001B10 4F               [ 1] 5202 	clr a  
      001B11 CD 00 E0         [ 4] 5203 	call write_byte 
      001B14 5C               [ 2] 5204 	incw x 
      001B15 0A 01            [ 1] 5205 	dec (1,sp)
      001B17 26 F7            [ 1] 5206 	jrne 5$	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 100.
Hexadecimal [24-Bits]



      001B19 84               [ 1] 5207 6$: pop a 
      001B1A 81               [ 4] 5208 	ret 
                                   5209 
                                   5210 ;----------------------
                                   5211 ; BASIC: DIR 
                                   5212 ; list saved files 
                                   5213 ;----------------------
                           000001  5214 	COUNT=1 ; files counter 
                           000002  5215 	VSIZE=2 
      001B1B                       5216 directory:
      001B1B                       5217 	_vars VSIZE 
      001B1B 52 02            [ 2]    1     sub sp,#VSIZE 
      001B1D 5F               [ 1] 5218 	clrw x 
      001B1E 1F 01            [ 2] 5219 	ldw (COUNT,sp),x 
      001B20 CF 00 17         [ 2] 5220 	ldw farptr+1,x 
      001B23 35 01 00 16      [ 1] 5221 	mov farptr,#1 
      001B27                       5222 dir_loop:
      001B27 5F               [ 1] 5223 	clrw x 
      001B28 92 AF 00 16      [ 5] 5224 	ldf a,([farptr],x)
      001B2C 27 39            [ 1] 5225 	jreq 8$ 
      001B2E                       5226 1$: ;name loop 	
      001B2E 92 AF 00 16      [ 5] 5227 	ldf a,([farptr],x)
      001B32 27 06            [ 1] 5228 	jreq 2$ 
      001B34 CD 01 B3         [ 4] 5229 	call putc 
      001B37 5C               [ 2] 5230 	incw x 
      001B38 20 F4            [ 2] 5231 	jra 1$
      001B3A 5C               [ 2] 5232 2$: incw x ; skip ending 0. 
      001B3B A6 20            [ 1] 5233 	ld a,#SPACE 
      001B3D CD 01 B3         [ 4] 5234 	call putc 
                                   5235 ; get file size 	
      001B40 92 AF 00 16      [ 5] 5236 	ldf a,([farptr],x)
      001B44 90 95            [ 1] 5237 	ld yh,a 
      001B46 5C               [ 2] 5238 	incw x 
      001B47 92 AF 00 16      [ 5] 5239 	ldf a,([farptr],x)
      001B4B 5C               [ 2] 5240 	incw x 
      001B4C 90 97            [ 1] 5241 	ld yl,a 
      001B4E 90 89            [ 2] 5242 	pushw y 
      001B50 72 FB 01         [ 2] 5243 	addw x,(1,sp)
      001B53 5C               [ 2] 5244 	incw x ; skip EOF marker 
                                   5245 ; skip to next file 
      001B54 CD 18 E9         [ 4] 5246 	call incr_farptr 
                                   5247 ; print file size 
      001B57 85               [ 2] 5248 	popw x ; file size 
      001B58 CD 08 63         [ 4] 5249 	call print_int 
      001B5B A6 0D            [ 1] 5250 	ld a,#CR 
      001B5D CD 01 B3         [ 4] 5251 	call putc
      001B60 1E 01            [ 2] 5252 	ldw x,(COUNT,sp)
      001B62 5C               [ 2] 5253 	incw x
      001B63 1F 01            [ 2] 5254 	ldw (COUNT,sp),x  
      001B65 20 C0            [ 2] 5255 	jra dir_loop 
      001B67                       5256 8$: ; print number of files 
      001B67 1E 01            [ 2] 5257 	ldw x,(COUNT,sp)
      001B69 CD 08 63         [ 4] 5258 	call print_int 
      001B6C AE 1B 9C         [ 2] 5259 	ldw x,#file_count 
      001B6F CD 01 C6         [ 4] 5260 	call puts  
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 101.
Hexadecimal [24-Bits]



                                   5261 ; print drive free space 	
      001B72 A6 FF            [ 1] 5262 	ld a,#0xff 
      001B74 C0 00 1B         [ 1] 5263 	sub a,ffree+2 
      001B77 C7 00 0D         [ 1] 5264 	ld acc8,a 
      001B7A A6 7F            [ 1] 5265 	ld a,#0x7f 
      001B7C C2 00 1A         [ 1] 5266 	sbc a,ffree+1 
      001B7F C7 00 0C         [ 1] 5267 	ld acc16,a 
      001B82 A6 02            [ 1] 5268 	ld a,#2 
      001B84 C2 00 19         [ 1] 5269 	sbc a,ffree 
      001B87 C7 00 0B         [ 1] 5270 	ld acc24,a 
      001B8A 5F               [ 1] 5271 	clrw x  
      001B8B A6 06            [ 1] 5272 	ld a,#6 
      001B8D 97               [ 1] 5273 	ld xl,a 
      001B8E A6 0A            [ 1] 5274 	ld a,#10 
      001B90 CD 08 1B         [ 4] 5275 	call prti24 
      001B93 AE 1B A4         [ 2] 5276 	ldw x,#drive_free
      001B96 CD 01 C6         [ 4] 5277 	call puts 
      001B99                       5278 	_drop VSIZE 
      001B99 5B 02            [ 2]    1     addw sp,#VSIZE 
      001B9B 81               [ 4] 5279 	ret
      001B9C 20 66 69 6C 65 73 0A  5280 file_count: .asciz " files\n"
             00
      001BA4 20 62 79 74 65 73 20  5281 drive_free: .asciz " bytes free\n" 
             66 72 65 65 0A 00
                                   5282 
                                   5283 ;---------------------
                                   5284 ; BASIC: WRITE expr1,expr2[,expr]* 
                                   5285 ; write 1 or more byte to FLASH or EEPROM
                                   5286 ; starting at address  
                                   5287 ; input:
                                   5288 ;   expr1  	is address 
                                   5289 ;   expr2,...,exprn   are bytes to write
                                   5290 ; output:
                                   5291 ;   none 
                                   5292 ;---------------------
                           000001  5293 	ADDR=1
                           000002  5294 	VSIZ=2 
      001BB1                       5295 write:
      001BB1                       5296 	_vars VSIZE 
      001BB1 52 02            [ 2]    1     sub sp,#VSIZE 
      001BB3 72 5F 00 16      [ 1] 5297 	clr farptr ; expect 16 bits address 
      001BB7 CD 10 68         [ 4] 5298 	call expression
      001BBA A1 04            [ 1] 5299 	cp a,#TK_INTGR 
      001BBC 27 03            [ 1] 5300 	jreq 0$
      001BBE CC 07 12         [ 2] 5301 	jp syntax_error
      001BC1 1F 01            [ 2] 5302 0$: ldw (ADDR,sp),x 
      001BC3 CD 07 C6         [ 4] 5303 	call next_token 
      001BC6 A1 0D            [ 1] 5304 	cp a,#TK_COMMA 
      001BC8 27 02            [ 1] 5305 	jreq 1$ 
      001BCA 20 19            [ 2] 5306 	jra 9$ 
      001BCC CD 10 68         [ 4] 5307 1$:	call expression
      001BCF A1 04            [ 1] 5308 	cp a,#TK_INTGR
      001BD1 27 03            [ 1] 5309 	jreq 2$
      001BD3 CC 07 12         [ 2] 5310 	jp syntax_error
      001BD6 9F               [ 1] 5311 2$:	ld a,xl 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 102.
Hexadecimal [24-Bits]



      001BD7 1E 01            [ 2] 5312 	ldw x,(ADDR,sp) 
      001BD9 CF 00 17         [ 2] 5313 	ldw farptr+1,x 
      001BDC 5F               [ 1] 5314 	clrw x 
      001BDD CD 00 E0         [ 4] 5315 	call write_byte
      001BE0 1E 01            [ 2] 5316 	ldw x,(ADDR,sp)
      001BE2 5C               [ 2] 5317 	incw x 
      001BE3 20 DC            [ 2] 5318 	jra 0$ 
      001BE5                       5319 9$:
      001BE5                       5320 	_drop VSIZE
      001BE5 5B 02            [ 2]    1     addw sp,#VSIZE 
      001BE7 81               [ 4] 5321 	ret 
                                   5322 
                                   5323 
                                   5324 ;---------------------
                                   5325 ;BASIC: CHAR(expr)
                                   5326 ; évaluate expression 
                                   5327 ; and take the 7 least 
                                   5328 ; bits as ASCII character
                                   5329 ;---------------------
      001BE8                       5330 char:
      001BE8 CD 0F 8C         [ 4] 5331 	call func_args 
      001BEB A1 01            [ 1] 5332 	cp a,#1
      001BED 27 03            [ 1] 5333 	jreq 1$
      001BEF CC 07 12         [ 2] 5334 	jp syntax_error
      001BF2 CD 0D 71         [ 4] 5335 1$:	call dpop 
      001BF5 9F               [ 1] 5336 	ld a,xl 
      001BF6 A4 7F            [ 1] 5337 	and a,#0x7f 
      001BF8 97               [ 1] 5338 	ld xl,a
      001BF9 A6 03            [ 1] 5339 	ld a,#TK_CHAR
      001BFB 81               [ 4] 5340 	ret
                                   5341 
                                   5342 ;---------------------
                                   5343 ; BASIC: ASC(string|char)
                                   5344 ; extract first character 
                                   5345 ; of string argument 
                                   5346 ; return it as TK_INTGR 
                                   5347 ;---------------------
      001BFC                       5348 ascii:
      001BFC A6 0B            [ 1] 5349 	ld a,#TK_LPAREN
      001BFE CD 0F 5B         [ 4] 5350 	call expect 
      001C01 CD 07 C6         [ 4] 5351 	call next_token 
      001C04 A1 0A            [ 1] 5352 	cp a,#TK_QSTR 
      001C06 27 07            [ 1] 5353 	jreq 1$
      001C08 A1 03            [ 1] 5354 	cp a,#TK_CHAR 
      001C0A 27 06            [ 1] 5355 	jreq 2$ 
      001C0C CC 07 12         [ 2] 5356 	jp syntax_error
      001C0F                       5357 1$: 
      001C0F F6               [ 1] 5358 	ld a,(x) 
      001C10 5F               [ 1] 5359 	clrw x
      001C11 97               [ 1] 5360 	ld xl,a 
      001C12                       5361 2$: 
      001C12 89               [ 2] 5362 	pushw x 
      001C13 A6 0C            [ 1] 5363 	ld a,#TK_RPAREN 
      001C15 CD 0F 5B         [ 4] 5364 	call expect
      001C18 85               [ 2] 5365 	popw x 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 103.
Hexadecimal [24-Bits]



      001C19 A6 04            [ 1] 5366 	ld a,#TK_INTGR 
      001C1B 81               [ 4] 5367 	ret 
                                   5368 
                                   5369 ;---------------------
                                   5370 ;BASIC: KEY
                                   5371 ; wait for a character 
                                   5372 ; received from STDIN 
                                   5373 ; input:
                                   5374 ;	none 
                                   5375 ; output:
                                   5376 ;	X 		ASCII character 
                                   5377 ;---------------------
      001C1C                       5378 key:
      001C1C CD 01 BC         [ 4] 5379 	call getc 
      001C1F 5F               [ 1] 5380 	clrw x 
      001C20 97               [ 1] 5381 	ld xl,a 
      001C21 A6 04            [ 1] 5382 	ld a,#TK_INTGR
      001C23 81               [ 4] 5383 	ret
                                   5384 
                                   5385 ;----------------------
                                   5386 ; BASIC: QKEY
                                   5387 ; Return true if there 
                                   5388 ; is a character in 
                                   5389 ; waiting in STDIN 
                                   5390 ; input:
                                   5391 ;  none 
                                   5392 ; output:
                                   5393 ;   X 		0|-1 
                                   5394 ;-----------------------
      001C24                       5395 qkey: 
      001C24 5F               [ 1] 5396 	clrw x 
      001C25 72 5D 00 27      [ 1] 5397 	tnz rx_char
      001C29 27 01            [ 1] 5398 	jreq 9$ 
      001C2B 53               [ 2] 5399 	cplw x 
      001C2C A6 04            [ 1] 5400 9$: ld a,#TK_INTGR
      001C2E 81               [ 4] 5401 	ret 
                                   5402 
                                   5403 ;---------------------
                                   5404 ; BASIC: GPIO(expr,reg)
                                   5405 ; return gpio address 
                                   5406 ; expr {0..8}
                                   5407 ; input:
                                   5408 ;   none 
                                   5409 ; output:
                                   5410 ;   X 		gpio register address
                                   5411 ;----------------------------
      001C2F                       5412 gpio:
      001C2F CD 0F 8C         [ 4] 5413 	call func_args 
      001C32 A1 02            [ 1] 5414 	cp a,#2
      001C34 27 03            [ 1] 5415 	jreq 1$
      001C36 CC 07 12         [ 2] 5416 	jp syntax_error  
      001C39                       5417 1$:	
      001C39 AE 00 02         [ 2] 5418 	ldw x,#2
      001C3C 72 DE 00 1C      [ 5] 5419 	ldw x,([dstkptr],x) ; port 
      001C40 2B 1B            [ 1] 5420 	jrmi bad_port
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 104.
Hexadecimal [24-Bits]



      001C42 A3 00 09         [ 2] 5421 	cpw x,#9
      001C45 2A 16            [ 1] 5422 	jrpl bad_port
      001C47 A6 05            [ 1] 5423 	ld a,#5
      001C49 42               [ 4] 5424 	mul x,a
      001C4A 1C 50 00         [ 2] 5425 	addw x,#GPIO_BASE 
      001C4D 89               [ 2] 5426 	pushw x 
      001C4E CD 0D 71         [ 4] 5427 	call dpop 
      001C51 72 FB 01         [ 2] 5428 	addw x,(1,sp)
      001C54 1F 01            [ 2] 5429 	ldw (1,sp),x  
      001C56 CD 0D 98         [ 4] 5430 	call ddrop  
      001C59 85               [ 2] 5431 	popw x 
      001C5A A6 04            [ 1] 5432 	ld a,#TK_INTGR
      001C5C 81               [ 4] 5433 	ret
      001C5D                       5434 bad_port:
      001C5D A6 0A            [ 1] 5435 	ld a,#ERR_BAD_VALUE
      001C5F CC 07 14         [ 2] 5436 	jp tb_error
                                   5437 
                                   5438 
                                   5439 ;-------------------------
                                   5440 ; BASIC: UFLASH 
                                   5441 ; return user flash address
                                   5442 ; input:
                                   5443 ;  none 
                                   5444 ; output:
                                   5445 ;	A		TK_INTGR
                                   5446 ;   X 		user address 
                                   5447 ;---------------------------
      001C62                       5448 uflash:
      001C62 AE 25 80         [ 2] 5449 	ldw x,#user_space 
      001C65 A6 04            [ 1] 5450 	ld a,#TK_INTGR 
      001C67 81               [ 4] 5451 	ret 
                                   5452 
                                   5453 
                                   5454 ;---------------------
                                   5455 ; BASIC: USR(addr[,arg])
                                   5456 ; execute a function written 
                                   5457 ; in binary code.
                                   5458 ; binary fonction should 
                                   5459 ; return token attribute in A 
                                   5460 ; and value in X. 
                                   5461 ; input:
                                   5462 ;   addr	routine address 
                                   5463 ;   arg 	is an optional argument 
                                   5464 ; output:
                                   5465 ;   A 		token attribute 
                                   5466 ;   X       returned value 
                                   5467 ;---------------------
      001C68                       5468 usr:
      001C68 90 89            [ 2] 5469 	pushw y 	
      001C6A CD 0F 8C         [ 4] 5470 	call func_args 
      001C6D A1 01            [ 1] 5471 	cp a,#1 
      001C6F 2A 03            [ 1] 5472 	jrpl 2$ 
      001C71 CC 07 12         [ 2] 5473 	jp syntax_error 
      001C74                       5474 2$: 
      001C74 CD 0D 71         [ 4] 5475 	call dpop 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 105.
Hexadecimal [24-Bits]



      001C77 A1 02            [ 1] 5476 	cp a,#2 
      001C79 2B 05            [ 1] 5477 	jrmi 4$
      001C7B 90 93            [ 1] 5478 	ldw y,x ; y=arg 
      001C7D CD 0D 71         [ 4] 5479 	call dpop ;x=addr 
      001C80 51               [ 1] 5480 4$:	exgw y,x ; y=addr,x=arg 
      001C81 90 FD            [ 4] 5481 	call (y)
      001C83 90 85            [ 2] 5482 	popw y 
      001C85 81               [ 4] 5483 	ret 
                                   5484 
                                   5485 ;------------------------------
                                   5486 ; BASIC: BYE 
                                   5487 ; halt mcu in its lowest power mode 
                                   5488 ; wait for reset or external interrupt
                                   5489 ; do a cold start on wakeup.
                                   5490 ;------------------------------
      001C86                       5491 bye:
      001C86 72 0D 52 30 FB   [ 2] 5492 	btjf UART1_SR,#UART_SR_TC,.
      001C8B 8E               [10] 5493 	halt
      001C8C CC 04 D4         [ 2] 5494 	jp cold_start  
                                   5495 
                                   5496 ;----------------------------------
                                   5497 ; BASIC: AUTORUN "file_name" 
                                   5498 ; record in eeprom at adrress AUTORUN_NAME
                                   5499 ; the name of file to load and execute
                                   5500 ; at startup 
                                   5501 ; input:
                                   5502 ;   file_name   file to execute 
                                   5503 ; output:
                                   5504 ;   none
                                   5505 ;-----------------------------------
      001C8F                       5506 autorun: 
      001C8F 72 01 00 25 07   [ 2] 5507 	btjf flags,#FRUN,0$ 
      001C94 27 05            [ 1] 5508 	jreq 0$ 
      001C96 A6 07            [ 1] 5509 	ld a,#ERR_CMD_ONLY 
      001C98 CC 07 14         [ 2] 5510 	jp tb_error 
      001C9B                       5511 0$:	
      001C9B CD 07 C6         [ 4] 5512 	call next_token 
      001C9E A1 0A            [ 1] 5513 	cp a,#TK_QSTR
      001CA0 27 03            [ 1] 5514 	jreq 1$
      001CA2 CC 07 12         [ 2] 5515 	jp syntax_error 
      001CA5                       5516 1$:	
      001CA5 89               [ 2] 5517 	pushw x ; file name char*
      001CA6 90 93            [ 1] 5518 	ldw y,x  
      001CA8 CD 19 55         [ 4] 5519 	call search_file 
      001CAB 25 05            [ 1] 5520 	jrc 2$ 
      001CAD A6 09            [ 1] 5521 	ld a,#ERR_NOT_FILE
      001CAF CC 07 14         [ 2] 5522 	jp tb_error  
      001CB2                       5523 2$: 
      001CB2 55 00 03 00 01   [ 1] 5524 	mov in,count 
      001CB7 72 5F 00 16      [ 1] 5525 	clr farptr 
      001CBB AE 40 00         [ 2] 5526 	ldw x,#AUTORUN_NAME
      001CBE CF 00 17         [ 2] 5527 	ldw farptr+1,x 
      001CC1 1E 01            [ 2] 5528 	ldw x,(1,sp)  
      001CC3 CD 01 FA         [ 4] 5529 	call strlen  ; return length in X 
      001CC6 90 85            [ 2] 5530 	popw y 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 106.
Hexadecimal [24-Bits]



      001CC8 89               [ 2] 5531 	pushw x 
      001CC9 5F               [ 1] 5532 	clrw x 
      001CCA CD 01 55         [ 4] 5533 	call write_block 
      001CCD                       5534 	_drop 2 
      001CCD 5B 02            [ 2]    1     addw sp,#2 
      001CCF 81               [ 4] 5535 	ret 
                                   5536 
                                   5537 ;----------------------------------
                                   5538 ; BASIC: SLEEP 
                                   5539 ; halt mcu until reset or external
                                   5540 ; interrupt.
                                   5541 ; Resume progam after SLEEP command
                                   5542 ;----------------------------------
      001CD0                       5543 sleep:
      001CD0 72 0D 52 30 FB   [ 2] 5544 	btjf UART1_SR,#UART_SR_TC,.
      001CD5 72 16 00 25      [ 1] 5545 	bset flags,#FSLEEP
      001CD9 8E               [10] 5546 	halt 
      001CDA 81               [ 4] 5547 	ret 
                                   5548 
                                   5549 ;-------------------------------
                                   5550 ; BASIC: PAUSE expr 
                                   5551 ; suspend execution for n msec.
                                   5552 ; input:
                                   5553 ;	none
                                   5554 ; output:
                                   5555 ;	none 
                                   5556 ;------------------------------
      001CDB                       5557 pause:
      001CDB CD 10 68         [ 4] 5558 	call expression
      001CDE A1 04            [ 1] 5559 	cp a,#TK_INTGR
      001CE0 27 03            [ 1] 5560 	jreq pause02 
      001CE2 CC 07 12         [ 2] 5561 	jp syntax_error
      001CE5                       5562 pause02: 
      001CE5 5D               [ 2] 5563 1$: tnzw x 
      001CE6 27 04            [ 1] 5564 	jreq 2$
      001CE8 8F               [10] 5565 	wfi 
      001CE9 5A               [ 2] 5566 	decw x 
      001CEA 26 F9            [ 1] 5567 	jrne 1$
      001CEC 4F               [ 1] 5568 2$:	clr a 
      001CED 81               [ 4] 5569 	ret 
                                   5570 
                                   5571 ;------------------------------
                                   5572 ; BASIC: AWU expr
                                   5573 ; halt mcu for 'expr' milliseconds
                                   5574 ; use Auto wakeup peripheral
                                   5575 ; all oscillators stopped except LSI
                                   5576 ; range: 1ms - 511ms
                                   5577 ; input:
                                   5578 ;  none
                                   5579 ; output:
                                   5580 ;  none:
                                   5581 ;------------------------------
      001CEE                       5582 awu:
      001CEE CD 10 68         [ 4] 5583   call expression
      001CF1 A1 04            [ 1] 5584   cp a,#TK_INTGR
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 107.
Hexadecimal [24-Bits]



      001CF3 27 03            [ 1] 5585   jreq awu02
      001CF5 CC 07 12         [ 2] 5586   jp syntax_error
      001CF8                       5587 awu02:
      001CF8 A3 14 00         [ 2] 5588   cpw x,#5120
      001CFB 2B 0C            [ 1] 5589   jrmi 1$ 
      001CFD 35 0F 50 F2      [ 1] 5590   mov AWU_TBR,#15 
      001D01 A6 1E            [ 1] 5591   ld a,#30
      001D03 62               [ 2] 5592   div x,a
      001D04 A6 10            [ 1] 5593   ld a,#16
      001D06 62               [ 2] 5594   div x,a 
      001D07 20 1E            [ 2] 5595   jra 4$
      001D09                       5596 1$: 
      001D09 A3 08 00         [ 2] 5597   cpw x,#2048
      001D0C 2B 09            [ 1] 5598   jrmi 2$ 
      001D0E 35 0E 50 F2      [ 1] 5599   mov AWU_TBR,#14
      001D12 A6 50            [ 1] 5600   ld a,#80
      001D14 62               [ 2] 5601   div x,a 
      001D15 20 10            [ 2] 5602   jra 4$   
      001D17                       5603 2$:
      001D17 35 07 50 F2      [ 1] 5604   mov AWU_TBR,#7
      001D1B                       5605 3$:  
                                   5606 ; while X > 64  divide by 2 and increment AWU_TBR 
      001D1B A3 00 40         [ 2] 5607   cpw x,#64 
      001D1E 23 07            [ 2] 5608   jrule 4$ 
      001D20 72 5C 50 F2      [ 1] 5609   inc AWU_TBR 
      001D24 54               [ 2] 5610   srlw x 
      001D25 20 F4            [ 2] 5611   jra 3$ 
      001D27                       5612 4$:
      001D27 9F               [ 1] 5613   ld a, xl
      001D28 4A               [ 1] 5614   dec a 
      001D29 27 01            [ 1] 5615   jreq 5$
      001D2B 4A               [ 1] 5616   dec a 	
      001D2C                       5617 5$: 
      001D2C A4 3E            [ 1] 5618   and a,#0x3e 
      001D2E C7 50 F1         [ 1] 5619   ld AWU_APR,a 
      001D31 72 18 50 F0      [ 1] 5620   bset AWU_CSR,#AWU_CSR_AWUEN
      001D35 8E               [10] 5621   halt 
                                   5622 
      001D36 81               [ 4] 5623   ret 
                                   5624 
                                   5625 ;------------------------------
                                   5626 ; BASIC: TICKS
                                   5627 ; return msec ticks counter value 
                                   5628 ; input:
                                   5629 ; 	none 
                                   5630 ; output:
                                   5631 ;	X 		TK_INTGR
                                   5632 ;-------------------------------
      001D37                       5633 get_ticks:
      001D37 CE 00 0E         [ 2] 5634 	ldw x,ticks 
      001D3A A6 04            [ 1] 5635 	ld a,#TK_INTGR
      001D3C 81               [ 4] 5636 	ret 
                                   5637 
                                   5638 
                                   5639 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 108.
Hexadecimal [24-Bits]



                                   5640 ;------------------------------
                                   5641 ; BASIC: ABS(expr)
                                   5642 ; return absolute value of expr.
                                   5643 ; input:
                                   5644 ;   none
                                   5645 ; output:
                                   5646 ;   X     	positive integer
                                   5647 ;-------------------------------
      001D3D                       5648 abs:
      001D3D CD 0F 8C         [ 4] 5649 	call func_args 
      001D40 A1 01            [ 1] 5650 	cp a,#1 
      001D42 27 03            [ 1] 5651 	jreq 0$ 
      001D44 CC 07 12         [ 2] 5652 	jp syntax_error
      001D47                       5653 0$:  
      001D47 CD 0D 71         [ 4] 5654     call dpop   
      001D4A 9E               [ 1] 5655 	ld a,xh 
      001D4B A5 80            [ 1] 5656 	bcp a,#0x80 
      001D4D 27 01            [ 1] 5657 	jreq 2$ 
      001D4F 50               [ 2] 5658 	negw x 
      001D50 A6 04            [ 1] 5659 2$: ld a,#TK_INTGR 
      001D52 81               [ 4] 5660 	ret 
                                   5661 
                                   5662 ;------------------------------
                                   5663 ; BASIC: AND(expr1,expr2)
                                   5664 ; Apply bit AND relation between
                                   5665 ; the 2 arguments, i.e expr1 & expr2 
                                   5666 ; output:
                                   5667 ; 	A 		TK_INTGR
                                   5668 ;   X 		result 
                                   5669 ;------------------------------
      001D53                       5670 bit_and:
      001D53 CD 0F 8C         [ 4] 5671 	call func_args 
      001D56 A1 02            [ 1] 5672 	cp a,#2
      001D58 27 03            [ 1] 5673 	jreq 1$
      001D5A CC 07 12         [ 2] 5674 	jp syntax_error 
      001D5D CD 0D 71         [ 4] 5675 1$:	call dpop 
      001D60 89               [ 2] 5676 	pushw x 
      001D61 CD 0D 71         [ 4] 5677 	call dpop 
      001D64 9E               [ 1] 5678 	ld a,xh 
      001D65 14 01            [ 1] 5679 	and a,(1,sp)
      001D67 95               [ 1] 5680 	ld xh,a 
      001D68 9F               [ 1] 5681 	ld a,xl
      001D69 14 02            [ 1] 5682 	and a,(2,sp)
      001D6B 97               [ 1] 5683 	ld xl,a 
      001D6C                       5684 	_drop 2 
      001D6C 5B 02            [ 2]    1     addw sp,#2 
      001D6E A6 04            [ 1] 5685 	ld a,#TK_INTGR
      001D70 81               [ 4] 5686 	ret
                                   5687 
                                   5688 ;------------------------------
                                   5689 ; BASIC: OR(expr1,expr2)
                                   5690 ; Apply bit OR relation between
                                   5691 ; the 2 arguments, i.e expr1 | expr2 
                                   5692 ; output:
                                   5693 ; 	A 		TK_INTGR
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 109.
Hexadecimal [24-Bits]



                                   5694 ;   X 		result 
                                   5695 ;------------------------------
      001D71                       5696 bit_or:
      001D71 CD 0F 8C         [ 4] 5697 	call func_args 
      001D74 A1 02            [ 1] 5698 	cp a,#2
      001D76 27 03            [ 1] 5699 	jreq 1$
      001D78 CC 07 12         [ 2] 5700 	jp syntax_error 
      001D7B                       5701 1$: 
      001D7B CD 0D 71         [ 4] 5702 	call dpop 
      001D7E 89               [ 2] 5703 	pushw x 
      001D7F CD 0D 71         [ 4] 5704 	call dpop 
      001D82 9E               [ 1] 5705 	ld a,xh 
      001D83 1A 01            [ 1] 5706 	or a,(1,sp)
      001D85 95               [ 1] 5707 	ld xh,a 
      001D86 9F               [ 1] 5708 	ld a,xl 
      001D87 1A 02            [ 1] 5709 	or a,(2,sp)
      001D89 97               [ 1] 5710 	ld xl,a 
      001D8A                       5711 	_drop 2 
      001D8A 5B 02            [ 2]    1     addw sp,#2 
      001D8C A6 04            [ 1] 5712 	ld a,#TK_INTGR 
      001D8E 81               [ 4] 5713 	ret
                                   5714 
                                   5715 ;------------------------------
                                   5716 ; BASIC: XOR(expr1,expr2)
                                   5717 ; Apply bit XOR relation between
                                   5718 ; the 2 arguments, i.e expr1 ^ expr2 
                                   5719 ; output:
                                   5720 ; 	A 		TK_INTGR
                                   5721 ;   X 		result 
                                   5722 ;------------------------------
      001D8F                       5723 bit_xor:
      001D8F CD 0F 8C         [ 4] 5724 	call func_args 
      001D92 A1 02            [ 1] 5725 	cp a,#2
      001D94 27 03            [ 1] 5726 	jreq 1$
      001D96 CC 07 12         [ 2] 5727 	jp syntax_error 
      001D99                       5728 1$: 
      001D99 CD 0D 71         [ 4] 5729 	call dpop 
      001D9C 89               [ 2] 5730 	pushw x 
      001D9D CD 0D 71         [ 4] 5731 	call dpop 
      001DA0 9E               [ 1] 5732 	ld a,xh 
      001DA1 18 01            [ 1] 5733 	xor a,(1,sp)
      001DA3 95               [ 1] 5734 	ld xh,a 
      001DA4 9F               [ 1] 5735 	ld a,xl 
      001DA5 18 02            [ 1] 5736 	xor a,(2,sp)
      001DA7 97               [ 1] 5737 	ld xl,a 
      001DA8                       5738 	_drop 2 
      001DA8 5B 02            [ 2]    1     addw sp,#2 
      001DAA A6 04            [ 1] 5739 	ld a,#TK_INTGR 
      001DAC 81               [ 4] 5740 	ret 
                                   5741 
                                   5742 ;------------------------------
                                   5743 ; BASIC: LSHIFT(expr1,expr2)
                                   5744 ; logical shift left expr1 by 
                                   5745 ; expr2 bits 
                                   5746 ; output:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 110.
Hexadecimal [24-Bits]



                                   5747 ; 	A 		TK_INTGR
                                   5748 ;   X 		result 
                                   5749 ;------------------------------
      001DAD                       5750 lshift:
      001DAD CD 0F 8C         [ 4] 5751 	call func_args
      001DB0 A1 02            [ 1] 5752 	cp a,#2 
      001DB2 27 03            [ 1] 5753 	jreq 1$
      001DB4 CC 07 12         [ 2] 5754 	jp syntax_error
      001DB7 CD 0D 71         [ 4] 5755 1$: call dpop  
      001DBA 51               [ 1] 5756 	exgw x,y 
      001DBB CD 0D 71         [ 4] 5757 	call dpop
      001DBE 90 5D            [ 2] 5758 	tnzw y 
      001DC0 27 05            [ 1] 5759 	jreq 4$
      001DC2 58               [ 2] 5760 2$:	sllw x 
      001DC3 90 5A            [ 2] 5761 	decw y 
      001DC5 26 FB            [ 1] 5762 	jrne 2$
      001DC7                       5763 4$:  
      001DC7 A6 04            [ 1] 5764 	ld a,#TK_INTGR
      001DC9 81               [ 4] 5765 	ret
                                   5766 
                                   5767 ;------------------------------
                                   5768 ; BASIC: RSHIFT(expr1,expr2)
                                   5769 ; logical shift right expr1 by 
                                   5770 ; expr2 bits.
                                   5771 ; output:
                                   5772 ; 	A 		TK_INTGR
                                   5773 ;   X 		result 
                                   5774 ;------------------------------
      001DCA                       5775 rshift:
      001DCA CD 0F 8C         [ 4] 5776 	call func_args
      001DCD A1 02            [ 1] 5777 	cp a,#2 
      001DCF 27 03            [ 1] 5778 	jreq 1$
      001DD1 CC 07 12         [ 2] 5779 	jp syntax_error
      001DD4 CD 0D 71         [ 4] 5780 1$: call dpop  
      001DD7 51               [ 1] 5781 	exgw x,y 
      001DD8 CD 0D 71         [ 4] 5782 	call dpop
      001DDB 90 5D            [ 2] 5783 	tnzw y 
      001DDD 27 05            [ 1] 5784 	jreq 4$
      001DDF 54               [ 2] 5785 2$:	srlw x 
      001DE0 90 5A            [ 2] 5786 	decw y 
      001DE2 26 FB            [ 1] 5787 	jrne 2$
      001DE4                       5788 4$:  
      001DE4 A6 04            [ 1] 5789 	ld a,#TK_INTGR
      001DE6 81               [ 4] 5790 	ret
                                   5791 
                                   5792 ;--------------------------
                                   5793 ; BASIC: FCPU integer
                                   5794 ; set CPU frequency 
                                   5795 ;-------------------------- 
                                   5796 
      001DE7                       5797 fcpu:
      001DE7 A6 04            [ 1] 5798 	ld a,#TK_INTGR
      001DE9 CD 0F 5B         [ 4] 5799 	call expect 
      001DEC 9F               [ 1] 5800 	ld a,xl 
      001DED A4 07            [ 1] 5801 	and a,#7 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 111.
Hexadecimal [24-Bits]



      001DEF C7 50 C6         [ 1] 5802 	ld CLK_CKDIVR,a 
      001DF2 81               [ 4] 5803 	ret 
                                   5804 
                                   5805 ;------------------------------
                                   5806 ; BASIC: PMODE pin#, mode 
                                   5807 ; Arduino pin. 
                                   5808 ; define pin as input or output
                                   5809 ; pin#: {0..15}
                                   5810 ; mode: INPUT|OUTPUT  
                                   5811 ;------------------------------
                           000001  5812 	PINNO=1
                           000001  5813 	VSIZE=1
      001DF3                       5814 pin_mode:
      001DF3                       5815 	_vars VSIZE 
      001DF3 52 01            [ 2]    1     sub sp,#VSIZE 
      001DF5 CD 0F 68         [ 4] 5816 	call arg_list 
      001DF8 A1 02            [ 1] 5817 	cp a,#2 
      001DFA 27 03            [ 1] 5818 	jreq 1$
      001DFC CC 07 12         [ 2] 5819 	jp syntax_error 
      001DFF CD 0D 71         [ 4] 5820 1$: call dpop ; mode 
      001E02 51               [ 1] 5821 	exgw x,y 
      001E03 CD 0D 71         [ 4] 5822 	call dpop ; Dx pin 
      001E06 CD 1E 38         [ 4] 5823 	call select_pin 
      001E09 6B 01            [ 1] 5824 	ld (PINNO,sp),a  
      001E0B A6 01            [ 1] 5825 	ld a,#1 
      001E0D 0D 01            [ 1] 5826 	tnz (PINNO,sp)
      001E0F 27 0B            [ 1] 5827 	jreq 4$
      001E11 48               [ 1] 5828 2$:	sll a 
      001E12 0A 01            [ 1] 5829 	dec (PINNO,sp)
      001E14 26 FB            [ 1] 5830 	jrne 2$ 
      001E16 6B 01            [ 1] 5831 	ld (PINNO,sp),a
      001E18 EA 03            [ 1] 5832 	or a,(GPIO_CR1,x) ;if input->pull-up else push-pull 
      001E1A E7 03            [ 1] 5833 	ld (GPIO_CR1,x),a 
      001E1C 90 A3 00 01      [ 2] 5834 4$:	cpw y,#OUTP 
      001E20 27 07            [ 1] 5835 	jreq 6$
                                   5836 ; input mode
      001E22 7B 01            [ 1] 5837 	ld a,(PINNO,sp)
      001E24 43               [ 1] 5838 	cpl a 
      001E25 E4 02            [ 1] 5839 	and a,(GPIO_DDR,x)	; bit==0 for input. 
      001E27 20 0A            [ 2] 5840 	jra 9$
      001E29                       5841 6$: ;output mode  
      001E29 7B 01            [ 1] 5842 	ld a,(PINNO,sp)
      001E2B EA 04            [ 1] 5843 	or a,(GPIO_CR2,x) ;port speed 10 Mhz 
      001E2D E7 04            [ 1] 5844 	ld (GPIO_CR2,x),a 
      001E2F 7B 01            [ 1] 5845 	ld a,(PINNO,sp)
      001E31 EA 02            [ 1] 5846 	or a,(GPIO_DDR,x) ; bit==1 for output 
      001E33 E7 02            [ 1] 5847 9$:	ld (GPIO_DDR,x),a 
      001E35                       5848 	_drop VSIZE 
      001E35 5B 01            [ 2]    1     addw sp,#VSIZE 
      001E37 81               [ 4] 5849 	ret
                                   5850 
                                   5851 ;------------------------
                                   5852 ; select Arduino pin 
                                   5853 ; input:
                                   5854 ;   X 	 {0..15} Arduino Dx 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 112.
Hexadecimal [24-Bits]



                                   5855 ; output:
                                   5856 ;   A     stm8s208 pin 
                                   5857 ;   X     base address s208 GPIO port 
                                   5858 ;---------------------------
      001E38                       5859 select_pin:
      001E38 58               [ 2] 5860 	sllw x 
      001E39 1C 1E 48         [ 2] 5861 	addw x,#arduino_to_8s208 
      001E3C FE               [ 2] 5862 	ldw x,(x)
      001E3D 9F               [ 1] 5863 	ld a,xl 
      001E3E 88               [ 1] 5864 	push a 
      001E3F 5E               [ 1] 5865 	swapw x 
      001E40 A6 05            [ 1] 5866 	ld a,#5 
      001E42 42               [ 4] 5867 	mul x,a 
      001E43 1C 50 00         [ 2] 5868 	addw x,#GPIO_BASE 
      001E46 84               [ 1] 5869 	pop a 
      001E47 81               [ 4] 5870 	ret 
                                   5871 ; translation from Arduino D0..D15 to stm8s208rb 
      001E48                       5872 arduino_to_8s208:
      001E48 03 06                 5873 .byte 3,6 ; D0 
      001E4A 03 05                 5874 .byte 3,5 ; D1 
      001E4C 04 00                 5875 .byte 4,0 ; D2 
      001E4E 02 01                 5876 .byte 2,1 ; D3
      001E50 06 00                 5877 .byte 6,0 ; D4
      001E52 02 02                 5878 .byte 2,2 ; D5
      001E54 02 03                 5879 .byte 2,3 ; D6
      001E56 03 01                 5880 .byte 3,1 ; D7
      001E58 03 03                 5881 .byte 3,3 ; D8
      001E5A 02 04                 5882 .byte 2,4 ; D9
      001E5C 04 05                 5883 .byte 4,5 ; D10
      001E5E 02 06                 5884 .byte 2,6 ; D11
      001E60 02 07                 5885 .byte 2,7 ; D12
      001E62 02 05                 5886 .byte 2,5 ; D13
      001E64 04 02                 5887 .byte 4,2 ; D14
      001E66 04 01                 5888 .byte 4,1 ; D15
                                   5889 
                                   5890 
                                   5891 ;------------------------------
                                   5892 ; BASIC: RND(expr)
                                   5893 ; return random number 
                                   5894 ; between 1 and expr inclusive
                                   5895 ; xorshift16 ref: http://b2d-f9r.blogspot.com/2010/08/16-bit-xorshift-rng-now-with-more.html
                                   5896 ; input:
                                   5897 ; 	none 
                                   5898 ; output:
                                   5899 ;	X 		random positive integer 
                                   5900 ;------------------------------
      001E68                       5901 random:
      001E68 CD 0F 8C         [ 4] 5902 	call func_args 
      001E6B A1 01            [ 1] 5903 	cp a,#1
      001E6D 27 03            [ 1] 5904 	jreq 1$
      001E6F CC 07 12         [ 2] 5905 	jp syntax_error
      001E72                       5906 1$: 
      001E72 CD 0D 71         [ 4] 5907 	call dpop 
      001E75 89               [ 2] 5908 	pushw x 
      001E76 9E               [ 1] 5909 	ld a,xh 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 113.
Hexadecimal [24-Bits]



      001E77 A5 80            [ 1] 5910 	bcp a,#0x80 
      001E79 27 05            [ 1] 5911 	jreq 2$
      001E7B A6 0A            [ 1] 5912 	ld a,#ERR_BAD_VALUE
      001E7D CC 07 14         [ 2] 5913 	jp tb_error
      001E80                       5914 2$: 
                                   5915 ; acc16=(x<<5)^x 
      001E80 CE 00 12         [ 2] 5916 	ldw x,seedx 
      001E83 58               [ 2] 5917 	sllw x 
      001E84 58               [ 2] 5918 	sllw x 
      001E85 58               [ 2] 5919 	sllw x 
      001E86 58               [ 2] 5920 	sllw x 
      001E87 58               [ 2] 5921 	sllw x 
      001E88 9E               [ 1] 5922 	ld a,xh 
      001E89 C8 00 12         [ 1] 5923 	xor a,seedx 
      001E8C C7 00 0C         [ 1] 5924 	ld acc16,a 
      001E8F 9F               [ 1] 5925 	ld a,xl 
      001E90 C8 00 13         [ 1] 5926 	xor a,seedx+1 
      001E93 C7 00 0D         [ 1] 5927 	ld acc8,a 
                                   5928 ; seedx=seedy 
      001E96 CE 00 14         [ 2] 5929 	ldw x,seedy 
      001E99 CF 00 12         [ 2] 5930 	ldw seedx,x  
                                   5931 ; seedy=seedy^(seedy>>1)
      001E9C 90 54            [ 2] 5932 	srlw y 
      001E9E 90 9E            [ 1] 5933 	ld a,yh 
      001EA0 C8 00 14         [ 1] 5934 	xor a,seedy 
      001EA3 C7 00 14         [ 1] 5935 	ld seedy,a  
      001EA6 90 9F            [ 1] 5936 	ld a,yl 
      001EA8 C8 00 15         [ 1] 5937 	xor a,seedy+1 
      001EAB C7 00 15         [ 1] 5938 	ld seedy+1,a 
                                   5939 ; acc16>>3 
      001EAE CE 00 0C         [ 2] 5940 	ldw x,acc16 
      001EB1 54               [ 2] 5941 	srlw x 
      001EB2 54               [ 2] 5942 	srlw x 
      001EB3 54               [ 2] 5943 	srlw x 
                                   5944 ; x=acc16^x 
      001EB4 9E               [ 1] 5945 	ld a,xh 
      001EB5 C8 00 0C         [ 1] 5946 	xor a,acc16 
      001EB8 95               [ 1] 5947 	ld xh,a 
      001EB9 9F               [ 1] 5948 	ld a,xl 
      001EBA C8 00 0D         [ 1] 5949 	xor a,acc8 
      001EBD 97               [ 1] 5950 	ld xl,a 
                                   5951 ; seedy=x^seedy 
      001EBE C8 00 15         [ 1] 5952 	xor a,seedy+1
      001EC1 97               [ 1] 5953 	ld xl,a 
      001EC2 9E               [ 1] 5954 	ld a,xh 
      001EC3 C8 00 14         [ 1] 5955 	xor a,seedy
      001EC6 95               [ 1] 5956 	ld xh,a 
      001EC7 CF 00 14         [ 2] 5957 	ldw seedy,x 
                                   5958 ; return seedy modulo expr + 1 
      001ECA 90 85            [ 2] 5959 	popw y 
      001ECC 65               [ 2] 5960 	divw x,y 
      001ECD 93               [ 1] 5961 	ldw x,y 
      001ECE 5C               [ 2] 5962 	incw x 
      001ECF A6 04            [ 1] 5963 	ld a,#TK_INTGR
      001ED1 81               [ 4] 5964 	ret 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 114.
Hexadecimal [24-Bits]



                                   5965 
                                   5966 ;---------------------------------
                                   5967 ; BASIC: WORDS 
                                   5968 ; affiche la listes des mots du
                                   5969 ; dictionnaire.
                                   5970 ;---------------------------------
                           000001  5971 	WLEN=1
                           000002  5972 	LLEN=2  
                           000002  5973 	VSIZE=2 
      001ED2                       5974 words:
      001ED2                       5975 	_vars VSIZE
      001ED2 52 02            [ 2]    1     sub sp,#VSIZE 
      001ED4 0F 02            [ 1] 5976 	clr (LLEN,sp)
      001ED6 90 AE 25 64      [ 2] 5977 	ldw y,#kword_dict+2
      001EDA 93               [ 1] 5978 0$:	ldw x,y
      001EDB F6               [ 1] 5979 	ld a,(x)
      001EDC A4 0F            [ 1] 5980 	and a,#15 
      001EDE 6B 01            [ 1] 5981 	ld (WLEN,sp),a 
      001EE0 5C               [ 2] 5982 1$:	incw x 
      001EE1 F6               [ 1] 5983 	ld a,(x)
      001EE2 CD 01 B3         [ 4] 5984 	call putc 
      001EE5 0C 02            [ 1] 5985 	inc (LLEN,sp)
      001EE7 0A 01            [ 1] 5986 	dec (WLEN,sp)
      001EE9 26 F5            [ 1] 5987 	jrne 1$
      001EEB A6 46            [ 1] 5988 	ld a,#70
      001EED 11 02            [ 1] 5989 	cp a,(LLEN,sp)
      001EEF 2B 09            [ 1] 5990 	jrmi 2$   
      001EF1 A6 20            [ 1] 5991 	ld a,#SPACE 
      001EF3 CD 01 B3         [ 4] 5992 	call putc 
      001EF6 0C 02            [ 1] 5993 	inc (LLEN,sp) 
      001EF8 20 07            [ 2] 5994 	jra 3$
      001EFA A6 0D            [ 1] 5995 2$: ld a,#CR 
      001EFC CD 01 B3         [ 4] 5996 	call putc 
      001EFF 0F 02            [ 1] 5997 	clr (LLEN,sp)
      001F01 72 A2 00 02      [ 2] 5998 3$:	subw y,#2 
      001F05 90 FE            [ 2] 5999 	ldw y,(y)
      001F07 26 D1            [ 1] 6000 	jrne 0$  
      001F09                       6001 	_drop VSIZE 
      001F09 5B 02            [ 2]    1     addw sp,#VSIZE 
      001F0B 81               [ 4] 6002 	ret 
                                   6003 
                                   6004 
                                   6005 ;-----------------------------
                                   6006 ; BASIC: TIMER expr 
                                   6007 ; initialize count down timer 
                                   6008 ;-----------------------------
      001F0C                       6009 set_timer:
      001F0C CD 0F 68         [ 4] 6010 	call arg_list
      001F0F A1 01            [ 1] 6011 	cp a,#1 
      001F11 27 03            [ 1] 6012 	jreq 1$
      001F13 CC 07 12         [ 2] 6013 	jp syntax_error
      001F16                       6014 1$: 
      001F16 CD 0D 71         [ 4] 6015 	call dpop 
      001F19 CF 00 10         [ 2] 6016 	ldw timer,x 
      001F1C 81               [ 4] 6017 	ret 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 115.
Hexadecimal [24-Bits]



                                   6018 
                                   6019 ;------------------------------
                                   6020 ; BASIC: TIMEOUT 
                                   6021 ; return state of timer 
                                   6022 ;------------------------------
      001F1D                       6023 timeout:
      001F1D CE 00 10         [ 2] 6024 	ldw x,timer 
      001F20                       6025 logical_complement:
      001F20 53               [ 2] 6026 	cplw x 
      001F21 A3 FF FF         [ 2] 6027 	cpw x,#-1
      001F24 27 01            [ 1] 6028 	jreq 2$
      001F26 5F               [ 1] 6029 	clrw x 
      001F27 A6 04            [ 1] 6030 2$:	ld a,#TK_INTGR
      001F29 81               [ 4] 6031 	ret 
                                   6032 
                                   6033 ;--------------------------------
                                   6034 ; BASIC NOT(expr) 
                                   6035 ; return logical complement of expr
                                   6036 ;--------------------------------
      001F2A                       6037 func_not:
      001F2A CD 0F 8C         [ 4] 6038 	call func_args  
      001F2D A1 01            [ 1] 6039 	cp a,#1
      001F2F 27 03            [ 1] 6040 	jreq 1$
      001F31 CC 07 12         [ 2] 6041 	jp syntax_error
      001F34 CD 0D 71         [ 4] 6042 1$:	call dpop 
      001F37 20 E7            [ 2] 6043 	jra logical_complement
                                   6044 
                                   6045 
                                   6046 
                                   6047 ;-----------------------------------
                                   6048 ; BASIC: IWDGEN expr1 
                                   6049 ; enable independant watchdog timer
                                   6050 ; expr1 is delay in multiple of 62.5µsec
                                   6051 ; expr1 -> {1..16383}
                                   6052 ;-----------------------------------
      001F39                       6053 enable_iwdg:
      001F39 CD 0F 68         [ 4] 6054 	call arg_list
      001F3C A1 01            [ 1] 6055 	cp a,#1 
      001F3E 27 03            [ 1] 6056 	jreq 1$
      001F40 CC 07 12         [ 2] 6057 	jp syntax_error 
      001F43 4B 00            [ 1] 6058 1$: push #0
      001F45 35 CC 50 E0      [ 1] 6059 	mov IWDG_KR,#IWDG_KEY_ENABLE
      001F49 CD 0D 71         [ 4] 6060 	call dpop
      001F4C 9E               [ 1] 6061 	ld a,xh 
      001F4D A4 3F            [ 1] 6062 	and a,#0x3f
      001F4F 95               [ 1] 6063 	ld xh,a  
      001F50 A3 00 FF         [ 2] 6064 2$:	cpw x,#255
      001F53 23 06            [ 2] 6065 	jrule 3$
      001F55 0C 01            [ 1] 6066 	inc (1,sp)
      001F57 98               [ 1] 6067 	rcf 
      001F58 56               [ 2] 6068 	rrcw x 
      001F59 20 F5            [ 2] 6069 	jra 2$
      001F5B 35 55 50 E0      [ 1] 6070 3$:	mov IWDG_KR,#IWDG_KEY_ACCESS 
      001F5F 84               [ 1] 6071 	pop a  
      001F60 C7 50 E1         [ 1] 6072 	ld IWDG_PR,a 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 116.
Hexadecimal [24-Bits]



      001F63 9F               [ 1] 6073 	ld a,xl
      001F64 4A               [ 1] 6074 	dec a 
      001F65 35 55 50 E0      [ 1] 6075 	mov IWDG_KR,#IWDG_KEY_ACCESS 
      001F69 C7 50 E2         [ 1] 6076 	ld IWDG_RLR,a 
      001F6C 35 AA 50 E0      [ 1] 6077 	mov IWDG_KR,#IWDG_KEY_REFRESH
      001F70 81               [ 4] 6078 	ret 
                                   6079 
                                   6080 
                                   6081 ;-----------------------------------
                                   6082 ; BASIC: IWDGREF  
                                   6083 ; refresh independant watchdog count down 
                                   6084 ; timer before it reset MCU. 
                                   6085 ;-----------------------------------
      001F71                       6086 refresh_iwdg:
      001F71 35 AA 50 E0      [ 1] 6087 	mov IWDG_KR,#IWDG_KEY_REFRESH 
      001F75 81               [ 4] 6088 	ret 
                                   6089 
                                   6090 
                                   6091 ;-------------------------------------
                                   6092 ; BASIC: LOG(expr)
                                   6093 ; return logarithm base 2 of expr 
                                   6094 ; this is the position of most significant
                                   6095 ; bit set. 
                                   6096 ; input: 
                                   6097 ; output:
                                   6098 ;   X     log2 
                                   6099 ;   A     TK_INTGR 
                                   6100 ;*********************************
      001F76                       6101 log2:
      001F76 CD 0F 8C         [ 4] 6102 	call func_args 
      001F79 A1 01            [ 1] 6103 	cp a,#1 
      001F7B 27 03            [ 1] 6104 	jreq 1$
      001F7D CC 07 12         [ 2] 6105 	jp syntax_error 
      001F80 CD 0D 71         [ 4] 6106 1$: call dpop
      001F83                       6107 leading_one:
      001F83 5D               [ 2] 6108 	tnzw x 
      001F84 27 0A            [ 1] 6109 	jreq 4$
      001F86 A6 0F            [ 1] 6110 	ld a,#15 
      001F88 59               [ 2] 6111 2$: rlcw x 
      001F89 25 03            [ 1] 6112     jrc 3$
      001F8B 4A               [ 1] 6113 	dec a 
      001F8C 20 FA            [ 2] 6114 	jra 2$
      001F8E 5F               [ 1] 6115 3$: clrw x 
      001F8F 97               [ 1] 6116     ld xl,a
      001F90 A6 04            [ 1] 6117 4$:	ld a,#TK_INTGR
      001F92 81               [ 4] 6118 	ret 
                                   6119 
                                   6120 ;-----------------------------------
                                   6121 ; BASIC: BIT(expr) 
                                   6122 ; expr ->{0..15}
                                   6123 ; return 2^expr 
                                   6124 ; output:
                                   6125 ;    x    2^expr 
                                   6126 ;-----------------------------------
      001F93                       6127 bitmask:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 117.
Hexadecimal [24-Bits]



      001F93 CD 0F 8C         [ 4] 6128     call func_args 
      001F96 A1 01            [ 1] 6129 	cp a,#1
      001F98 27 03            [ 1] 6130 	jreq 1$
      001F9A CC 07 12         [ 2] 6131 	jp syntax_error 
      001F9D CD 0D 71         [ 4] 6132 1$: call dpop 
      001FA0 9F               [ 1] 6133 	ld a,xl 
      001FA1 A4 0F            [ 1] 6134 	and a,#15
      001FA3 5F               [ 1] 6135 	clrw x 
      001FA4 5C               [ 2] 6136 	incw x 
      001FA5 4D               [ 1] 6137 2$: tnz a 
      001FA6 27 04            [ 1] 6138 	jreq 3$
      001FA8 58               [ 2] 6139 	slaw x 
      001FA9 4A               [ 1] 6140 	dec a 
      001FAA 20 F9            [ 2] 6141 	jra 2$ 
      001FAC A6 04            [ 1] 6142 3$: ld a,#TK_INTGR
      001FAE 81               [ 4] 6143 	ret 
                                   6144 
                                   6145 ;------------------------------
                                   6146 ; BASIC: INVERT(expr)
                                   6147 ; 1's complement 
                                   6148 ;--------------------------------
      001FAF                       6149 invert:
      001FAF CD 0F 8C         [ 4] 6150 	call func_args
      001FB2 A1 01            [ 1] 6151 	cp a,#1 
      001FB4 27 03            [ 1] 6152 	jreq 1$
      001FB6 CC 07 12         [ 2] 6153 	jp syntax_error
      001FB9 CD 0D 71         [ 4] 6154 1$: call dpop 
      001FBC 53               [ 2] 6155 	cplw x 
      001FBD A6 04            [ 1] 6156 	ld a,#TK_INTGR 
      001FBF 81               [ 4] 6157 	ret 
                                   6158 
                                   6159 ;------------------------------
                                   6160 ; BASIC: DO 
                                   6161 ; initiate a DO ... UNTIL loop 
                                   6162 ;------------------------------
      001FC0                       6163 do_loop:
      001FC0 85               [ 2] 6164 	popw x 
      001FC1                       6165 	_vars 4 
      001FC1 52 04            [ 2]    1     sub sp,#4 
      001FC3 89               [ 2] 6166 	pushw x 
      001FC4 CC 16 01         [ 2] 6167 	jp store_loop_addr
                                   6168 
                                   6169 ;--------------------------------
                                   6170 ; BASIC: UNTIL expr 
                                   6171 ; loop if exprssion is false 
                                   6172 ; else terminate loop
                                   6173 ;--------------------------------
      001FC7                       6174 until: 
      001FC7 72 5D 00 22      [ 1] 6175 	tnz loop_depth 
      001FCB 26 03            [ 1] 6176 	jrne 1$ 
      001FCD CC 07 12         [ 2] 6177 	jp syntax_error 
      001FD0                       6178 1$: 
      001FD0 CD 10 AC         [ 4] 6179 	call relation 
      001FD3 A1 04            [ 1] 6180 	cp a,#TK_INTGR
      001FD5 27 03            [ 1] 6181 	jreq 2$
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 118.
Hexadecimal [24-Bits]



      001FD7 CC 07 12         [ 2] 6182 	jp syntax_error
      001FDA                       6183 2$: 
      001FDA 5D               [ 2] 6184 	tnzw x 
      001FDB 26 03            [ 1] 6185 	jrne 9$
      001FDD CC 16 5C         [ 2] 6186 	jp loop_back 
      001FE0                       6187 9$:	; remove loop info cstack  
      001FE0 85               [ 2] 6188 	popw x
      001FE1                       6189 	_drop 4
      001FE1 5B 04            [ 2]    1     addw sp,#4 
      001FE3 89               [ 2] 6190 	pushw x 
      001FE4 72 5A 00 22      [ 1] 6191 	dec loop_depth 
      001FE8 81               [ 4] 6192 	ret 
                                   6193 
                                   6194 ;--------------------------
                                   6195 ; BASIC: PRTA...PRTI  
                                   6196 ;  return constant value 
                                   6197 ;  PORT  offset in GPIO
                                   6198 ;  array
                                   6199 ;---------------------------
      001FE9                       6200 const_porta:
      001FE9 AE 00 00         [ 2] 6201 	ldw x,#0
      001FEC A6 04            [ 1] 6202 	ld a,#TK_INTGR 
      001FEE 81               [ 4] 6203 	ret 
      001FEF                       6204 const_portb:
      001FEF AE 00 01         [ 2] 6205 	ldw x,#1
      001FF2 A6 04            [ 1] 6206 	ld a,#TK_INTGR 
      001FF4 81               [ 4] 6207 	ret 
      001FF5                       6208 const_portc:
      001FF5 AE 00 02         [ 2] 6209 	ldw x,#2
      001FF8 A6 04            [ 1] 6210 	ld a,#TK_INTGR 
      001FFA 81               [ 4] 6211 	ret 
      001FFB                       6212 const_portd:
      001FFB AE 00 03         [ 2] 6213 	ldw x,#3
      001FFE A6 04            [ 1] 6214 	ld a,#TK_INTGR 
      002000 81               [ 4] 6215 	ret 
      002001                       6216 const_porte:
      002001 AE 00 04         [ 2] 6217 	ldw x,#4
      002004 A6 04            [ 1] 6218 	ld a,#TK_INTGR 
      002006 81               [ 4] 6219 	ret 
      002007                       6220 const_portf:
      002007 AE 00 05         [ 2] 6221 	ldw x,#5
      00200A A6 04            [ 1] 6222 	ld a,#TK_INTGR 
      00200C 81               [ 4] 6223 	ret 
      00200D                       6224 const_portg:
      00200D AE 00 06         [ 2] 6225 	ldw x,#6
      002010 A6 04            [ 1] 6226 	ld a,#TK_INTGR 
      002012 81               [ 4] 6227 	ret 
      002013                       6228 const_porth:
      002013 AE 00 07         [ 2] 6229 	ldw x,#7
      002016 A6 04            [ 1] 6230 	ld a,#TK_INTGR 
      002018 81               [ 4] 6231 	ret 
      002019                       6232 const_porti:
      002019 AE 00 08         [ 2] 6233 	ldw x,#8
      00201C A6 04            [ 1] 6234 	ld a,#TK_INTGR 
      00201E 81               [ 4] 6235 	ret 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 119.
Hexadecimal [24-Bits]



                                   6236 
                                   6237 ;-------------------------------
                                   6238 ; following return constant 
                                   6239 ; related to GPIO register offset 
                                   6240 ;---------------------------------
      00201F                       6241 const_odr:
      00201F A6 04            [ 1] 6242 	ld a,#TK_INTGR 
      002021 AE 00 00         [ 2] 6243 	ldw x,#GPIO_ODR
      002024 81               [ 4] 6244 	ret 
      002025                       6245 const_idr:
      002025 A6 04            [ 1] 6246 	ld a,#TK_INTGR 
      002027 AE 00 01         [ 2] 6247 	ldw x,#GPIO_IDR
      00202A 81               [ 4] 6248 	ret 
      00202B                       6249 const_ddr:
      00202B A6 04            [ 1] 6250 	ld a,#TK_INTGR 
      00202D AE 00 02         [ 2] 6251 	ldw x,#GPIO_DDR
      002030 81               [ 4] 6252 	ret 
      002031                       6253 const_cr1:
      002031 A6 04            [ 1] 6254 	ld a,#TK_INTGR 
      002033 AE 00 03         [ 2] 6255 	ldw x,#GPIO_CR1
      002036 81               [ 4] 6256 	ret 
      002037                       6257 const_cr2:
      002037 A6 04            [ 1] 6258 	ld a,#TK_INTGR 
      002039 AE 00 04         [ 2] 6259 	ldw x,#GPIO_CR2
      00203C 81               [ 4] 6260 	ret 
                                   6261 ;-------------------------
                                   6262 ;  constant for port mode
                                   6263 ;  used by PMODE 
                                   6264 ;  input or output
                                   6265 ;------------------------
      00203D                       6266 const_output:
      00203D A6 04            [ 1] 6267 	ld a,#TK_INTGR 
      00203F AE 00 01         [ 2] 6268 	ldw x,#OUTP
      002042 81               [ 4] 6269 	ret 
      002043                       6270 const_input:
      002043 A6 04            [ 1] 6271 	ld a,#TK_INTGR 
      002045 AE 00 00         [ 2] 6272 	ldw x,#INP 
      002048 81               [ 4] 6273 	ret 
                                   6274 ;-----------------------
                                   6275 ; memory area constants
                                   6276 ;-----------------------
      002049                       6277 const_eeprom_base:
      002049 A6 04            [ 1] 6278 	ld a,#TK_INTGR 
      00204B AE 40 00         [ 2] 6279 	ldw x,#EEPROM_BASE 
      00204E 81               [ 4] 6280 	ret 
                                   6281 
                                   6282 ;---------------------------
                                   6283 ; BASIC: DATA 
                                   6284 ; when the interpreter find 
                                   6285 ; a DATA line it skip it.
                                   6286 ;---------------------------
      00204F                       6287 data:
      00204F 55 00 03 00 01   [ 1] 6288 	mov in,count
      002054 81               [ 4] 6289 	ret 
                                   6290 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 120.
Hexadecimal [24-Bits]



                                   6291 ;---------------------------
                                   6292 ; BASIC: DATLN  *expr*
                                   6293 ; set DATA pointer at line# 
                                   6294 ; specified by *expr* 
                                   6295 ;---------------------------
      002055                       6296 data_line:
      002055 CD 10 68         [ 4] 6297 	call expression
      002058 A1 04            [ 1] 6298 	cp a,#TK_INTGR
      00205A 27 03            [ 1] 6299 	jreq 1$
      00205C CC 07 12         [ 2] 6300 	jp syntax_error 
      00205F CD 02 68         [ 4] 6301 1$: call search_lineno
      002062 5D               [ 2] 6302 	tnzw x 
      002063 26 05            [ 1] 6303 	jrne 3$
      002065 A6 05            [ 1] 6304 2$:	ld a,#ERR_NO_LINE 
      002067 CC 07 14         [ 2] 6305 	jp tb_error
      00206A                       6306 3$: ; check if valid data line 
      00206A 90 93            [ 1] 6307     ldw y,x 
      00206C EE 04            [ 2] 6308 	ldw x,(4,x)
      00206E A3 20 4F         [ 2] 6309 	cpw x,#data 
      002071 26 F2            [ 1] 6310 	jrne 2$ 
      002073 90 CF 00 06      [ 2] 6311 	ldw data_ptr,y
      002077 90 E6 02         [ 1] 6312 	ld a,(2,y)
      00207A C7 00 09         [ 1] 6313 	ld data_len,a 
      00207D 35 06 00 08      [ 1] 6314 	mov data_ofs,#FIRST_DATA_ITEM 
      002081 81               [ 4] 6315 	ret
                                   6316 
                                   6317 ;---------------------------------
                                   6318 ; BASIC: RESTORE 
                                   6319 ; set data_ptr to first data line
                                   6320 ; if not DATA found pointer set to
                                   6321 ; zero 
                                   6322 ;---------------------------------
      002082                       6323 restore:
      002082 72 5F 00 06      [ 1] 6324 	clr data_ptr 
      002086 72 5F 00 07      [ 1] 6325 	clr data_ptr+1
      00208A 72 5F 00 08      [ 1] 6326 	clr data_ofs 
      00208E 72 5F 00 09      [ 1] 6327 	clr data_len
      002092 CE 00 1E         [ 2] 6328 	ldw x,txtbgn
      002095                       6329 data_search_loop: 	
      002095 C3 00 20         [ 2] 6330 	cpw x,txtend
      002098 24 17            [ 1] 6331 	jruge 9$
      00209A 90 93            [ 1] 6332 	ldw y,x 
      00209C EE 04            [ 2] 6333 	ldw x,(4,x)
      00209E A3 20 4F         [ 2] 6334 	cpw x,#data 
      0020A1 26 1A            [ 1] 6335 	jrne try_next_line 
      0020A3 90 CF 00 06      [ 2] 6336 	ldw data_ptr,y 
      0020A7 90 E6 02         [ 1] 6337 	ld a,(2,y)
      0020AA C7 00 09         [ 1] 6338 	ld data_len,a 
      0020AD 35 06 00 08      [ 1] 6339 	mov data_ofs,#FIRST_DATA_ITEM
      0020B1 72 5D 00 09      [ 1] 6340 9$:	tnz data_len 
      0020B5 26 05            [ 1] 6341     jrne 10$
      0020B7 A6 0C            [ 1] 6342 	ld a,#ERR_NO_DATA 
      0020B9 CC 07 14         [ 2] 6343 	jp tb_error 
      0020BC 81               [ 4] 6344 10$:ret
      0020BD                       6345 try_next_line:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 121.
Hexadecimal [24-Bits]



      0020BD 93               [ 1] 6346 	ldw x,y 
      0020BE E6 02            [ 1] 6347 	ld a,(2,x)
      0020C0 C7 00 0D         [ 1] 6348 	ld acc8,a 
      0020C3 72 5F 00 0C      [ 1] 6349 	clr acc16 
      0020C7 72 BB 00 0C      [ 2] 6350 	addw x,acc16 
      0020CB 20 C8            [ 2] 6351 	jra data_search_loop
                                   6352 
                                   6353 
                                   6354 ;---------------------------------
                                   6355 ; BASIC: READ 
                                   6356 ; return next data item | 0 
                                   6357 ;---------------------------------
                           000001  6358 	CTX_BPTR=1 
                           000003  6359 	CTX_IN=3 
                           000004  6360 	CTX_COUNT=4 
                           000005  6361 	XSAVE=5
                           000006  6362 	VSIZE=6
      0020CD                       6363 read:
      0020CD                       6364 	_vars  VSIZE 
      0020CD 52 06            [ 2]    1     sub sp,#VSIZE 
      0020CF                       6365 read01:	
      0020CF C6 00 08         [ 1] 6366 	ld a,data_ofs
      0020D2 C1 00 09         [ 1] 6367 	cp a,data_len 
      0020D5 27 37            [ 1] 6368 	jreq 2$ ; end of line  
      0020D7 CD 14 15         [ 4] 6369 	call save_context
      0020DA CE 00 06         [ 2] 6370 	ldw x,data_ptr 
      0020DD CF 00 04         [ 2] 6371 	ldw basicptr,x 
      0020E0 55 00 08 00 01   [ 1] 6372 	mov in,data_ofs 
      0020E5 55 00 09 00 03   [ 1] 6373 	mov count,data_len  
      0020EA CD 10 68         [ 4] 6374 	call expression 
      0020ED A1 04            [ 1] 6375 	cp a,#TK_INTGR 
      0020EF 27 03            [ 1] 6376 	jreq 1$ 
      0020F1 CC 07 12         [ 2] 6377 	jp syntax_error 
      0020F4                       6378 1$:
      0020F4 1F 05            [ 2] 6379 	ldw (XSAVE,SP),x
      0020F6 CD 07 C6         [ 4] 6380 	call next_token ; skip comma
      0020F9 CE 00 04         [ 2] 6381 	ldw x,basicptr 
      0020FC CF 00 06         [ 2] 6382 	ldw data_ptr,x 
      0020FF 55 00 01 00 08   [ 1] 6383 	mov data_ofs,in 
      002104 CD 14 25         [ 4] 6384 	call rest_context
      002107 1E 05            [ 2] 6385 	ldw x,(XSAVE,sp)
      002109 A6 04            [ 1] 6386 	ld a,#TK_INTGR
      00210B                       6387 	_drop VSIZE 
      00210B 5B 06            [ 2]    1     addw sp,#VSIZE 
      00210D 81               [ 4] 6388 	ret 
      00210E                       6389 2$: ; end of line reached 
      00210E 90 CE 00 06      [ 2] 6390 	ldw y, data_ptr 
      002112 72 5F 00 06      [ 1] 6391 	clr data_ptr
      002116 72 5F 00 07      [ 1] 6392 	clr data_ptr+1   
      00211A 72 5F 00 08      [ 1] 6393 	clr data_ofs 
      00211E 72 5F 00 09      [ 1] 6394 	clr data_len 
      002122 CD 20 BD         [ 4] 6395 	call try_next_line 
      002125 20 A8            [ 2] 6396 	jra read01
                                   6397 
                                   6398 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 122.
Hexadecimal [24-Bits]



                                   6399 ;---------------------------------
                                   6400 ; BASIC: SPIEN clkdiv, mode 
                                   6401 ; clkdiv -> {0..7} Fspi=Fclk/2^(n+1)
                                   6402 ; if clkdiv==-1 disable SPI
                                   6403 ; mode -> # master  | 0 slave 
                                   6404 ;--------------------------------- 
      002127                       6405 spi_enable:
      002127 CD 0F 68         [ 4] 6406 	call arg_list 
      00212A A1 02            [ 1] 6407 	cp a,#2
      00212C 27 03            [ 1] 6408 	jreq 1$
      00212E CC 07 12         [ 2] 6409 	jp syntax_error 
      002131                       6410 1$: 
      002131 72 12 50 C7      [ 1] 6411 	bset CLK_PCKENR1,#CLK_PCKENR1_SPI ; enable clock signal 
      002135 CD 0D 7E         [ 4] 6412 	call dswap
      002138 CD 0D 71         [ 4] 6413 	call dpop 
      00213B A3 FF FF         [ 2] 6414 	cpw x,#-1
      00213E 27 1D            [ 1] 6415 	jreq spi_disable
      002140 A6 08            [ 1] 6416 	ld a,#(1<<SPI_CR1_BR)
      002142 42               [ 4] 6417 	mul x,a 
      002143 9F               [ 1] 6418 	ld a,xl 
      002144 C7 52 00         [ 1] 6419 	ld SPI_CR1,a 
      002147 CD 0D 71         [ 4] 6420 	call dpop 
      00214A 27 04            [ 1] 6421 	jreq 2$
      00214C 72 14 52 00      [ 1] 6422 	bset SPI_CR1,#SPI_CR1_MSTR
      002150 72 12 52 01      [ 1] 6423 2$: bset SPI_CR2,#SPI_CR2_SSM 
      002154 72 10 52 01      [ 1] 6424     bset SPI_CR2,#SPI_CR2_SSI 
      002158 72 1C 52 00      [ 1] 6425 	bset SPI_CR1,#SPI_CR1_SPE 	
      00215C 81               [ 4] 6426 	ret 
      00215D                       6427 spi_disable:
                                   6428 ; wait spi idle 
      00215D A6 82            [ 1] 6429 1$:	ld a,#0x82 
      00215F C4 52 03         [ 1] 6430 	and a,SPI_SR
      002162 A1 02            [ 1] 6431 	cp a,#2 
      002164 26 F7            [ 1] 6432 	jrne 1$
      002166 72 1D 52 00      [ 1] 6433 	bres SPI_CR1,#SPI_CR1_SPE
      00216A 72 13 50 C7      [ 1] 6434 	bres CLK_PCKENR1,#CLK_PCKENR1_SPI 
      00216E 81               [ 4] 6435 	ret 
                                   6436 
      00216F                       6437 spi_clear_error:
      00216F A6 78            [ 1] 6438 	ld a,#0x78 
      002171 C5 52 03         [ 1] 6439 	bcp a,SPI_SR 
      002174 27 04            [ 1] 6440 	jreq 1$
      002176 72 5F 52 03      [ 1] 6441 	clr SPI_SR 
      00217A 81               [ 4] 6442 1$: ret 
                                   6443 
      00217B                       6444 spi_send_byte:
      00217B 88               [ 1] 6445 	push a 
      00217C CD 21 6F         [ 4] 6446 	call spi_clear_error
      00217F 84               [ 1] 6447 	pop a 
      002180 72 03 52 03 FB   [ 2] 6448 	btjf SPI_SR,#SPI_SR_TXE,.
      002185 C7 52 04         [ 1] 6449 	ld SPI_DR,a
      002188 72 01 52 03 FB   [ 2] 6450 	btjf SPI_SR,#SPI_SR_RXNE,.  
      00218D C6 52 04         [ 1] 6451 	ld a,SPI_DR 
      002190 81               [ 4] 6452 	ret 
                                   6453 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 123.
Hexadecimal [24-Bits]



      002191                       6454 spi_rcv_byte:
      002191 A6 FF            [ 1] 6455 	ld a,#255
      002193 72 01 52 03 E3   [ 2] 6456 	btjf SPI_SR,#SPI_SR_RXNE,spi_send_byte 
      002198 C6 52 04         [ 1] 6457 	ld a,SPI_DR 
      00219B 81               [ 4] 6458 	ret
                                   6459 
                                   6460 ;------------------------------
                                   6461 ; BASIC: SPIWR byte [,byte]
                                   6462 ; write 1 or more byte
                                   6463 ;------------------------------
      00219C                       6464 spi_write:
      00219C CD 10 68         [ 4] 6465 	call expression
      00219F A1 04            [ 1] 6466 	cp a,#TK_INTGR 
      0021A1 27 03            [ 1] 6467 	jreq 1$
      0021A3 CC 07 12         [ 2] 6468 	jp syntax_error 
      0021A6                       6469 1$:	
      0021A6 9F               [ 1] 6470 	ld a,xl 
      0021A7 CD 21 7B         [ 4] 6471 	call spi_send_byte 
      0021AA CD 07 C6         [ 4] 6472 	call next_token 
      0021AD A1 0D            [ 1] 6473 	cp a,#TK_COMMA 
      0021AF 26 02            [ 1] 6474 	jrne 2$ 
      0021B1 20 E9            [ 2] 6475 	jra spi_write 
      0021B3 4D               [ 1] 6476 2$:	tnz a 
      0021B4 27 05            [ 1] 6477 	jreq 3$
      0021B6 55 00 02 00 01   [ 1] 6478 	mov in,in.saved 
      0021BB 81               [ 4] 6479 3$:	ret 
                                   6480 
                                   6481 
                                   6482 ;-------------------------------
                                   6483 ; BASIC: SPIRD 	
                                   6484 ; read one byte from SPI 
                                   6485 ;-------------------------------
      0021BC                       6486 spi_read:
      0021BC CD 21 91         [ 4] 6487 	call spi_rcv_byte 
      0021BF 5F               [ 1] 6488 	clrw x 
      0021C0 97               [ 1] 6489 	ld xl,a 
      0021C1 A6 04            [ 1] 6490 	ld a,#TK_INTGR 
      0021C3 81               [ 4] 6491 	ret 
                                   6492 
                                   6493 ;------------------------------
                                   6494 ; BASIC: SPISTA 
                                   6495 ; return SPI_SR value
                                   6496 ;------------------------------
      0021C4                       6497 spi_status:
      0021C4 C6 52 03         [ 1] 6498 	ld a,SPI_SR 
      0021C7 72 5F 52 03      [ 1] 6499 	clr SPI_SR 
      0021CB 5F               [ 1] 6500 	clrw x 
      0021CC 97               [ 1] 6501 	ld xl,a 
      0021CD A6 04            [ 1] 6502 	ld a,#TK_INTGR 
      0021CF 81               [ 4] 6503 	ret 
                                   6504 
                                   6505 
                                   6506 ;------------------------------
                                   6507 ;      dictionary 
                                   6508 ; format:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 124.
Hexadecimal [24-Bits]



                                   6509 ;   link:   2 bytes 
                                   6510 ;   name_length+flags:  1 byte, bits 0:4 lenght,5:8 flags  
                                   6511 ;   cmd_name: 16 byte max 
                                   6512 ;   code_address: 2 bytes 
                                   6513 ;------------------------------
                                   6514 	.macro _dict_entry len,name,cmd 
                                   6515 	.word LINK 
                                   6516 	LINK=.
                                   6517 name:
                                   6518 	.byte len 	
                                   6519 	.ascii "name"
                                   6520 	.word cmd 
                                   6521 	.endm 
                                   6522 
                           000000  6523 	LINK=0
                                   6524 ; respect alphabetic order for BASIC names from Z-A
                                   6525 ; this sort order is for a cleaner WORDS cmd output. 	
      0021D0                       6526 kword_end:
      0021D0                       6527 	_dict_entry,5+F_IFUNC,XPEEK,xpeek 
      0021D0 00 00                    1 	.word LINK 
                           0021D2     2 	LINK=.
      0021D2                          3 XPEEK:
      0021D2 45                       4 	.byte 5+F_IFUNC 	
      0021D3 58 50 45 45 4B           5 	.ascii "XPEEK"
      0021D8 15 5B                    6 	.word xpeek 
      0021DA                       6528 	_dict_entry,3+F_IFUNC,XOR,bit_xor
      0021DA 21 D2                    1 	.word LINK 
                           0021DC     2 	LINK=.
      0021DC                          3 XOR:
      0021DC 43                       4 	.byte 3+F_IFUNC 	
      0021DD 58 4F 52                 5 	.ascii "XOR"
      0021E0 1D 8F                    6 	.word bit_xor 
      0021E2                       6529 	_dict_entry,5,WRITE,write  
      0021E2 21 DC                    1 	.word LINK 
                           0021E4     2 	LINK=.
      0021E4                          3 WRITE:
      0021E4 05                       4 	.byte 5 	
      0021E5 57 52 49 54 45           5 	.ascii "WRITE"
      0021EA 1B B1                    6 	.word write 
      0021EC                       6530 	_dict_entry,5,WORDS,words 
      0021EC 21 E4                    1 	.word LINK 
                           0021EE     2 	LINK=.
      0021EE                          3 WORDS:
      0021EE 05                       4 	.byte 5 	
      0021EF 57 4F 52 44 53           5 	.ascii "WORDS"
      0021F4 1E D2                    6 	.word words 
      0021F6                       6531 	_dict_entry 4,WAIT,wait 
      0021F6 21 EE                    1 	.word LINK 
                           0021F8     2 	LINK=.
      0021F8                          3 WAIT:
      0021F8 04                       4 	.byte 4 	
      0021F9 57 41 49 54              5 	.ascii "WAIT"
      0021FD 14 A2                    6 	.word wait 
      0021FF                       6532 	_dict_entry,3+F_IFUNC,USR,usr
      0021FF 21 F8                    1 	.word LINK 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 125.
Hexadecimal [24-Bits]



                           002201     2 	LINK=.
      002201                          3 USR:
      002201 43                       4 	.byte 3+F_IFUNC 	
      002202 55 53 52                 5 	.ascii "USR"
      002205 1C 68                    6 	.word usr 
      002207                       6533 	_dict_entry,5,UNTIL,until 
      002207 22 01                    1 	.word LINK 
                           002209     2 	LINK=.
      002209                          3 UNTIL:
      002209 05                       4 	.byte 5 	
      00220A 55 4E 54 49 4C           5 	.ascii "UNTIL"
      00220F 1F C7                    6 	.word until 
      002211                       6534 	_dict_entry,6+F_IFUNC,UFLASH,uflash 
      002211 22 09                    1 	.word LINK 
                           002213     2 	LINK=.
      002213                          3 UFLASH:
      002213 46                       4 	.byte 6+F_IFUNC 	
      002214 55 46 4C 41 53 48        5 	.ascii "UFLASH"
      00221A 1C 62                    6 	.word uflash 
      00221C                       6535 	_dict_entry,6+F_IFUNC,UBOUND,ubound 
      00221C 22 13                    1 	.word LINK 
                           00221E     2 	LINK=.
      00221E                          3 UBOUND:
      00221E 46                       4 	.byte 6+F_IFUNC 	
      00221F 55 42 4F 55 4E 44        5 	.ascii "UBOUND"
      002225 11 27                    6 	.word ubound 
      002227                       6536 	_dict_entry,4,TONE,tone  
      002227 22 1E                    1 	.word LINK 
                           002229     2 	LINK=.
      002229                          3 TONE:
      002229 04                       4 	.byte 4 	
      00222A 54 4F 4E 45              5 	.ascii "TONE"
      00222E 17 50                    6 	.word tone 
      002230                       6537 	_dict_entry,2,TO,to
      002230 22 29                    1 	.word LINK 
                           002232     2 	LINK=.
      002232                          3 TO:
      002232 02                       4 	.byte 2 	
      002233 54 4F                    5 	.ascii "TO"
      002235 15 B9                    6 	.word to 
      002237                       6538 	_dict_entry,7+F_IFUNC,TIMEOUT,timeout 
      002237 22 32                    1 	.word LINK 
                           002239     2 	LINK=.
      002239                          3 TIMEOUT:
      002239 47                       4 	.byte 7+F_IFUNC 	
      00223A 54 49 4D 45 4F 55 54     5 	.ascii "TIMEOUT"
      002241 1F 1D                    6 	.word timeout 
      002243                       6539 	_dict_entry,5,TIMER,set_timer
      002243 22 39                    1 	.word LINK 
                           002245     2 	LINK=.
      002245                          3 TIMER:
      002245 05                       4 	.byte 5 	
      002246 54 49 4D 45 52           5 	.ascii "TIMER"
      00224B 1F 0C                    6 	.word set_timer 
      00224D                       6540 	_dict_entry,5+F_IFUNC,TICKS,get_ticks
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 126.
Hexadecimal [24-Bits]



      00224D 22 45                    1 	.word LINK 
                           00224F     2 	LINK=.
      00224F                          3 TICKS:
      00224F 45                       4 	.byte 5+F_IFUNC 	
      002250 54 49 43 4B 53           5 	.ascii "TICKS"
      002255 1D 37                    6 	.word get_ticks 
      002257                       6541 	_dict_entry,4,STOP,stop 
      002257 22 4F                    1 	.word LINK 
                           002259     2 	LINK=.
      002259                          3 STOP:
      002259 04                       4 	.byte 4 	
      00225A 53 54 4F 50              5 	.ascii "STOP"
      00225E 17 41                    6 	.word stop 
      002260                       6542 	_dict_entry,4,STEP,step 
      002260 22 59                    1 	.word LINK 
                           002262     2 	LINK=.
      002262                          3 STEP:
      002262 04                       4 	.byte 4 	
      002263 53 54 45 50              5 	.ascii "STEP"
      002267 15 EC                    6 	.word step 
      002269                       6543 	_dict_entry,5,SPIWR,spi_write
      002269 22 62                    1 	.word LINK 
                           00226B     2 	LINK=.
      00226B                          3 SPIWR:
      00226B 05                       4 	.byte 5 	
      00226C 53 50 49 57 52           5 	.ascii "SPIWR"
      002271 21 9C                    6 	.word spi_write 
      002273                       6544 	_dict_entry,6+F_IFUNC,SPISTA,spi_status
      002273 22 6B                    1 	.word LINK 
                           002275     2 	LINK=.
      002275                          3 SPISTA:
      002275 46                       4 	.byte 6+F_IFUNC 	
      002276 53 50 49 53 54 41        5 	.ascii "SPISTA"
      00227C 21 C4                    6 	.word spi_status 
      00227E                       6545 	_dict_entry,5,SPIEN,spi_enable 
      00227E 22 75                    1 	.word LINK 
                           002280     2 	LINK=.
      002280                          3 SPIEN:
      002280 05                       4 	.byte 5 	
      002281 53 50 49 45 4E           5 	.ascii "SPIEN"
      002286 21 27                    6 	.word spi_enable 
      002288                       6546 	_dict_entry,5+F_IFUNC,SPIRD, spi_read 
      002288 22 80                    1 	.word LINK 
                           00228A     2 	LINK=.
      00228A                          3 SPIRD:
      00228A 45                       4 	.byte 5+F_IFUNC 	
      00228B 53 50 49 52 44           5 	.ascii "SPIRD"
      002290 21 BC                    6 	.word spi_read 
      002292                       6547 	_dict_entry,5,SLEEP,sleep 
      002292 22 8A                    1 	.word LINK 
                           002294     2 	LINK=.
      002294                          3 SLEEP:
      002294 05                       4 	.byte 5 	
      002295 53 4C 45 45 50           5 	.ascii "SLEEP"
      00229A 1C D0                    6 	.word sleep 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 127.
Hexadecimal [24-Bits]



      00229C                       6548 	_dict_entry,4+F_IFUNC,SIZE,size
      00229C 22 94                    1 	.word LINK 
                           00229E     2 	LINK=.
      00229E                          3 SIZE:
      00229E 44                       4 	.byte 4+F_IFUNC 	
      00229F 53 49 5A 45              5 	.ascii "SIZE"
      0022A3 11 1D                    6 	.word size 
      0022A5                       6549     _dict_entry,4,SHOW,show 
      0022A5 22 9E                    1 	.word LINK 
                           0022A7     2 	LINK=.
      0022A7                          3 SHOW:
      0022A7 04                       4 	.byte 4 	
      0022A8 53 48 4F 57              5 	.ascii "SHOW"
      0022AC 11 03                    6 	.word show 
      0022AE                       6550 	_dict_entry,4,SAVE,save
      0022AE 22 A7                    1 	.word LINK 
                           0022B0     2 	LINK=.
      0022B0                          3 SAVE:
      0022B0 04                       4 	.byte 4 	
      0022B1 53 41 56 45              5 	.ascii "SAVE"
      0022B5 19 A0                    6 	.word save 
      0022B7                       6551 	_dict_entry 3,RUN,run
      0022B7 22 B0                    1 	.word LINK 
                           0022B9     2 	LINK=.
      0022B9                          3 RUN:
      0022B9 03                       4 	.byte 3 	
      0022BA 52 55 4E                 5 	.ascii "RUN"
      0022BD 16 F2                    6 	.word run 
      0022BF                       6552 	_dict_entry,6+F_IFUNC,RSHIFT,rshift
      0022BF 22 B9                    1 	.word LINK 
                           0022C1     2 	LINK=.
      0022C1                          3 RSHIFT:
      0022C1 46                       4 	.byte 6+F_IFUNC 	
      0022C2 52 53 48 49 46 54        5 	.ascii "RSHIFT"
      0022C8 1D CA                    6 	.word rshift 
      0022CA                       6553 	_dict_entry,3+F_IFUNC,RND,random 
      0022CA 22 C1                    1 	.word LINK 
                           0022CC     2 	LINK=.
      0022CC                          3 RND:
      0022CC 43                       4 	.byte 3+F_IFUNC 	
      0022CD 52 4E 44                 5 	.ascii "RND"
      0022D0 1E 68                    6 	.word random 
      0022D2                       6554 	_dict_entry,6,RETURN,return 
      0022D2 22 CC                    1 	.word LINK 
                           0022D4     2 	LINK=.
      0022D4                          3 RETURN:
      0022D4 06                       4 	.byte 6 	
      0022D5 52 45 54 55 52 4E        5 	.ascii "RETURN"
      0022DB 16 D4                    6 	.word return 
      0022DD                       6555 	_dict_entry,7,RESTORE,restore 
      0022DD 22 D4                    1 	.word LINK 
                           0022DF     2 	LINK=.
      0022DF                          3 RESTORE:
      0022DF 07                       4 	.byte 7 	
      0022E0 52 45 53 54 4F 52 45     5 	.ascii "RESTORE"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 128.
Hexadecimal [24-Bits]



      0022E7 20 82                    6 	.word restore 
      0022E9                       6556 	_dict_entry 6,REMARK,rem 
      0022E9 22 DF                    1 	.word LINK 
                           0022EB     2 	LINK=.
      0022EB                          3 REMARK:
      0022EB 06                       4 	.byte 6 	
      0022EC 52 45 4D 41 52 4B        5 	.ascii "REMARK"
      0022F2 14 9C                    6 	.word rem 
      0022F4                       6557 	_dict_entry,6,REBOOT,cold_start
      0022F4 22 EB                    1 	.word LINK 
                           0022F6     2 	LINK=.
      0022F6                          3 REBOOT:
      0022F6 06                       4 	.byte 6 	
      0022F7 52 45 42 4F 4F 54        5 	.ascii "REBOOT"
      0022FD 04 D4                    6 	.word cold_start 
      0022FF                       6558 	_dict_entry,4+F_IFUNC,READ,read  
      0022FF 22 F6                    1 	.word LINK 
                           002301     2 	LINK=.
      002301                          3 READ:
      002301 44                       4 	.byte 4+F_IFUNC 	
      002302 52 45 41 44              5 	.ascii "READ"
      002306 20 CD                    6 	.word read 
      002308                       6559 	_dict_entry,4+F_IFUNC,QKEY,qkey  
      002308 23 01                    1 	.word LINK 
                           00230A     2 	LINK=.
      00230A                          3 QKEY:
      00230A 44                       4 	.byte 4+F_IFUNC 	
      00230B 51 4B 45 59              5 	.ascii "QKEY"
      00230F 1C 24                    6 	.word qkey 
      002311                       6560 	_dict_entry,4+F_IFUNC,PRTI,const_porti 
      002311 23 0A                    1 	.word LINK 
                           002313     2 	LINK=.
      002313                          3 PRTI:
      002313 44                       4 	.byte 4+F_IFUNC 	
      002314 50 52 54 49              5 	.ascii "PRTI"
      002318 20 19                    6 	.word const_porti 
      00231A                       6561 	_dict_entry,4+F_IFUNC,PRTH,const_porth 
      00231A 23 13                    1 	.word LINK 
                           00231C     2 	LINK=.
      00231C                          3 PRTH:
      00231C 44                       4 	.byte 4+F_IFUNC 	
      00231D 50 52 54 48              5 	.ascii "PRTH"
      002321 20 13                    6 	.word const_porth 
      002323                       6562 	_dict_entry,4+F_IFUNC,PRTG,const_portg 
      002323 23 1C                    1 	.word LINK 
                           002325     2 	LINK=.
      002325                          3 PRTG:
      002325 44                       4 	.byte 4+F_IFUNC 	
      002326 50 52 54 47              5 	.ascii "PRTG"
      00232A 20 0D                    6 	.word const_portg 
      00232C                       6563 	_dict_entry,4+F_IFUNC,PRTF,const_portf
      00232C 23 25                    1 	.word LINK 
                           00232E     2 	LINK=.
      00232E                          3 PRTF:
      00232E 44                       4 	.byte 4+F_IFUNC 	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 129.
Hexadecimal [24-Bits]



      00232F 50 52 54 46              5 	.ascii "PRTF"
      002333 20 07                    6 	.word const_portf 
      002335                       6564 	_dict_entry,4+F_IFUNC,PRTE,const_porte
      002335 23 2E                    1 	.word LINK 
                           002337     2 	LINK=.
      002337                          3 PRTE:
      002337 44                       4 	.byte 4+F_IFUNC 	
      002338 50 52 54 45              5 	.ascii "PRTE"
      00233C 20 01                    6 	.word const_porte 
      00233E                       6565 	_dict_entry,4+F_IFUNC,PRTD,const_portd
      00233E 23 37                    1 	.word LINK 
                           002340     2 	LINK=.
      002340                          3 PRTD:
      002340 44                       4 	.byte 4+F_IFUNC 	
      002341 50 52 54 44              5 	.ascii "PRTD"
      002345 1F FB                    6 	.word const_portd 
      002347                       6566 	_dict_entry,4+F_IFUNC,PRTC,const_portc
      002347 23 40                    1 	.word LINK 
                           002349     2 	LINK=.
      002349                          3 PRTC:
      002349 44                       4 	.byte 4+F_IFUNC 	
      00234A 50 52 54 43              5 	.ascii "PRTC"
      00234E 1F F5                    6 	.word const_portc 
      002350                       6567 	_dict_entry,4+F_IFUNC,PRTB,const_portb
      002350 23 49                    1 	.word LINK 
                           002352     2 	LINK=.
      002352                          3 PRTB:
      002352 44                       4 	.byte 4+F_IFUNC 	
      002353 50 52 54 42              5 	.ascii "PRTB"
      002357 1F EF                    6 	.word const_portb 
      002359                       6568 	_dict_entry,4+F_IFUNC,PRTA,const_porta 
      002359 23 52                    1 	.word LINK 
                           00235B     2 	LINK=.
      00235B                          3 PRTA:
      00235B 44                       4 	.byte 4+F_IFUNC 	
      00235C 50 52 54 41              5 	.ascii "PRTA"
      002360 1F E9                    6 	.word const_porta 
      002362                       6569 	_dict_entry 5,PRINT,print 
      002362 23 5B                    1 	.word LINK 
                           002364     2 	LINK=.
      002364                          3 PRINT:
      002364 05                       4 	.byte 5 	
      002365 50 52 49 4E 54           5 	.ascii "PRINT"
      00236A 13 AD                    6 	.word print 
      00236C                       6570 	_dict_entry,4+F_IFUNC,POUT,const_output
      00236C 23 64                    1 	.word LINK 
                           00236E     2 	LINK=.
      00236E                          3 POUT:
      00236E 44                       4 	.byte 4+F_IFUNC 	
      00236F 50 4F 55 54              5 	.ascii "POUT"
      002373 20 3D                    6 	.word const_output 
      002375                       6571 	_dict_entry,4,POKE,poke 
      002375 23 6E                    1 	.word LINK 
                           002377     2 	LINK=.
      002377                          3 POKE:
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 130.
Hexadecimal [24-Bits]



      002377 04                       4 	.byte 4 	
      002378 50 4F 4B 45              5 	.ascii "POKE"
      00237C 15 35                    6 	.word poke 
      00237E                       6572 	_dict_entry,4+F_IFUNC,PINP,const_input
      00237E 23 77                    1 	.word LINK 
                           002380     2 	LINK=.
      002380                          3 PINP:
      002380 44                       4 	.byte 4+F_IFUNC 	
      002381 50 49 4E 50              5 	.ascii "PINP"
      002385 20 43                    6 	.word const_input 
      002387                       6573 	_dict_entry,4+F_IFUNC,PEEK,peek 
      002387 23 80                    1 	.word LINK 
                           002389     2 	LINK=.
      002389                          3 PEEK:
      002389 44                       4 	.byte 4+F_IFUNC 	
      00238A 50 45 45 4B              5 	.ascii "PEEK"
      00238E 15 48                    6 	.word peek 
      002390                       6574 	_dict_entry,5,PMODE,pin_mode 
      002390 23 89                    1 	.word LINK 
                           002392     2 	LINK=.
      002392                          3 PMODE:
      002392 05                       4 	.byte 5 	
      002393 50 4D 4F 44 45           5 	.ascii "PMODE"
      002398 1D F3                    6 	.word pin_mode 
      00239A                       6575 	_dict_entry,5,PAUSE,pause 
      00239A 23 92                    1 	.word LINK 
                           00239C     2 	LINK=.
      00239C                          3 PAUSE:
      00239C 05                       4 	.byte 5 	
      00239D 50 41 55 53 45           5 	.ascii "PAUSE"
      0023A2 1C DB                    6 	.word pause 
      0023A4                       6576 	_dict_entry,2+F_IFUNC,OR,bit_or
      0023A4 23 9C                    1 	.word LINK 
                           0023A6     2 	LINK=.
      0023A6                          3 OR:
      0023A6 42                       4 	.byte 2+F_IFUNC 	
      0023A7 4F 52                    5 	.ascii "OR"
      0023A9 1D 71                    6 	.word bit_or 
      0023AB                       6577 	_dict_entry,3+F_IFUNC,ODR,const_odr 
      0023AB 23 A6                    1 	.word LINK 
                           0023AD     2 	LINK=.
      0023AD                          3 ODR:
      0023AD 43                       4 	.byte 3+F_IFUNC 	
      0023AE 4F 44 52                 5 	.ascii "ODR"
      0023B1 20 1F                    6 	.word const_odr 
      0023B3                       6578 	_dict_entry,3+F_IFUNC,NOT,func_not 
      0023B3 23 AD                    1 	.word LINK 
                           0023B5     2 	LINK=.
      0023B5                          3 NOT:
      0023B5 43                       4 	.byte 3+F_IFUNC 	
      0023B6 4E 4F 54                 5 	.ascii "NOT"
      0023B9 1F 2A                    6 	.word func_not 
      0023BB                       6579 	_dict_entry,3,NEW,new
      0023BB 23 B5                    1 	.word LINK 
                           0023BD     2 	LINK=.
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 131.
Hexadecimal [24-Bits]



      0023BD                          3 NEW:
      0023BD 03                       4 	.byte 3 	
      0023BE 4E 45 57                 5 	.ascii "NEW"
      0023C1 18 DE                    6 	.word new 
      0023C3                       6580 	_dict_entry,4,NEXT,next 
      0023C3 23 BD                    1 	.word LINK 
                           0023C5     2 	LINK=.
      0023C5                          3 NEXT:
      0023C5 04                       4 	.byte 4 	
      0023C6 4E 45 58 54              5 	.ascii "NEXT"
      0023CA 16 14                    6 	.word next 
      0023CC                       6581 	_dict_entry,6+F_IFUNC,LSHIFT,lshift
      0023CC 23 C5                    1 	.word LINK 
                           0023CE     2 	LINK=.
      0023CE                          3 LSHIFT:
      0023CE 46                       4 	.byte 6+F_IFUNC 	
      0023CF 4C 53 48 49 46 54        5 	.ascii "LSHIFT"
      0023D5 1D AD                    6 	.word lshift 
      0023D7                       6582 	_dict_entry,3+F_IFUNC,LOG,log2 
      0023D7 23 CE                    1 	.word LINK 
                           0023D9     2 	LINK=.
      0023D9                          3 LOG:
      0023D9 43                       4 	.byte 3+F_IFUNC 	
      0023DA 4C 4F 47                 5 	.ascii "LOG"
      0023DD 1F 76                    6 	.word log2 
      0023DF                       6583 	_dict_entry,4,LOAD,load 
      0023DF 23 D9                    1 	.word LINK 
                           0023E1     2 	LINK=.
      0023E1                          3 LOAD:
      0023E1 04                       4 	.byte 4 	
      0023E2 4C 4F 41 44              5 	.ascii "LOAD"
      0023E6 1A 95                    6 	.word load 
      0023E8                       6584 	_dict_entry 4,LIST,list
      0023E8 23 E1                    1 	.word LINK 
                           0023EA     2 	LINK=.
      0023EA                          3 LIST:
      0023EA 04                       4 	.byte 4 	
      0023EB 4C 49 53 54              5 	.ascii "LIST"
      0023EF 11 71                    6 	.word list 
      0023F1                       6585 	_dict_entry 3,LET,let 
      0023F1 23 EA                    1 	.word LINK 
                           0023F3     2 	LINK=.
      0023F3                          3 LET:
      0023F3 03                       4 	.byte 3 	
      0023F4 4C 45 54                 5 	.ascii "LET"
      0023F7 11 49                    6 	.word let 
      0023F9                       6586 	_dict_entry,3+F_IFUNC,KEY,key 
      0023F9 23 F3                    1 	.word LINK 
                           0023FB     2 	LINK=.
      0023FB                          3 KEY:
      0023FB 43                       4 	.byte 3+F_IFUNC 	
      0023FC 4B 45 59                 5 	.ascii "KEY"
      0023FF 1C 1C                    6 	.word key 
      002401                       6587 	_dict_entry,7,IWDGREF,refresh_iwdg
      002401 23 FB                    1 	.word LINK 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 132.
Hexadecimal [24-Bits]



                           002403     2 	LINK=.
      002403                          3 IWDGREF:
      002403 07                       4 	.byte 7 	
      002404 49 57 44 47 52 45 46     5 	.ascii "IWDGREF"
      00240B 1F 71                    6 	.word refresh_iwdg 
      00240D                       6588 	_dict_entry,6,IWDGEN,enable_iwdg
      00240D 24 03                    1 	.word LINK 
                           00240F     2 	LINK=.
      00240F                          3 IWDGEN:
      00240F 06                       4 	.byte 6 	
      002410 49 57 44 47 45 4E        5 	.ascii "IWDGEN"
      002416 1F 39                    6 	.word enable_iwdg 
      002418                       6589 	_dict_entry,6+F_IFUNC,INVERT,invert 
      002418 24 0F                    1 	.word LINK 
                           00241A     2 	LINK=.
      00241A                          3 INVERT:
      00241A 46                       4 	.byte 6+F_IFUNC 	
      00241B 49 4E 56 45 52 54        5 	.ascii "INVERT"
      002421 1F AF                    6 	.word invert 
      002423                       6590 	_dict_entry,5,INPUT,input_var  
      002423 24 1A                    1 	.word LINK 
                           002425     2 	LINK=.
      002425                          3 INPUT:
      002425 05                       4 	.byte 5 	
      002426 49 4E 50 55 54           5 	.ascii "INPUT"
      00242B 14 35                    6 	.word input_var 
      00242D                       6591 	_dict_entry,2,IF,if 
      00242D 24 25                    1 	.word LINK 
                           00242F     2 	LINK=.
      00242F                          3 IF:
      00242F 02                       4 	.byte 2 	
      002430 49 46                    5 	.ascii "IF"
      002432 15 7B                    6 	.word if 
      002434                       6592 	_dict_entry,3+F_IFUNC,IDR,const_idr 
      002434 24 2F                    1 	.word LINK 
                           002436     2 	LINK=.
      002436                          3 IDR:
      002436 43                       4 	.byte 3+F_IFUNC 	
      002437 49 44 52                 5 	.ascii "IDR"
      00243A 20 25                    6 	.word const_idr 
      00243C                       6593 	_dict_entry,3,HEX,hex_base
      00243C 24 36                    1 	.word LINK 
                           00243E     2 	LINK=.
      00243E                          3 HEX:
      00243E 03                       4 	.byte 3 	
      00243F 48 45 58                 5 	.ascii "HEX"
      002442 11 13                    6 	.word hex_base 
      002444                       6594 	_dict_entry,4+F_IFUNC,GPIO,gpio 
      002444 24 3E                    1 	.word LINK 
                           002446     2 	LINK=.
      002446                          3 GPIO:
      002446 44                       4 	.byte 4+F_IFUNC 	
      002447 47 50 49 4F              5 	.ascii "GPIO"
      00244B 1C 2F                    6 	.word gpio 
      00244D                       6595 	_dict_entry,4,GOTO,goto 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 133.
Hexadecimal [24-Bits]



      00244D 24 46                    1 	.word LINK 
                           00244F     2 	LINK=.
      00244F                          3 GOTO:
      00244F 04                       4 	.byte 4 	
      002450 47 4F 54 4F              5 	.ascii "GOTO"
      002454 16 99                    6 	.word goto 
      002456                       6596 	_dict_entry,5,GOSUB,gosub 
      002456 24 4F                    1 	.word LINK 
                           002458     2 	LINK=.
      002458                          3 GOSUB:
      002458 05                       4 	.byte 5 	
      002459 47 4F 53 55 42           5 	.ascii "GOSUB"
      00245E 16 B4                    6 	.word gosub 
      002460                       6597 	_dict_entry,6,FORGET,forget 
      002460 24 58                    1 	.word LINK 
                           002462     2 	LINK=.
      002462                          3 FORGET:
      002462 06                       4 	.byte 6 	
      002463 46 4F 52 47 45 54        5 	.ascii "FORGET"
      002469 1A D0                    6 	.word forget 
      00246B                       6598 	_dict_entry,3,FOR,for 
      00246B 24 62                    1 	.word LINK 
                           00246D     2 	LINK=.
      00246D                          3 FOR:
      00246D 03                       4 	.byte 3 	
      00246E 46 4F 52                 5 	.ascii "FOR"
      002471 15 8F                    6 	.word for 
      002473                       6599 	_dict_entry,4,FCPU,fcpu 
      002473 24 6D                    1 	.word LINK 
                           002475     2 	LINK=.
      002475                          3 FCPU:
      002475 04                       4 	.byte 4 	
      002476 46 43 50 55              5 	.ascii "FCPU"
      00247A 1D E7                    6 	.word fcpu 
      00247C                       6600 	_dict_entry,6+F_IFUNC,EEPROM,const_eeprom_base   
      00247C 24 75                    1 	.word LINK 
                           00247E     2 	LINK=.
      00247E                          3 EEPROM:
      00247E 46                       4 	.byte 6+F_IFUNC 	
      00247F 45 45 50 52 4F 4D        5 	.ascii "EEPROM"
      002485 20 49                    6 	.word const_eeprom_base 
      002487                       6601 	_dict_entry,6+F_CMD,DWRITE,digital_write
      002487 24 7E                    1 	.word LINK 
                           002489     2 	LINK=.
      002489                          3 DWRITE:
      002489 06                       4 	.byte 6+F_CMD 	
      00248A 44 57 52 49 54 45        5 	.ascii "DWRITE"
      002490 18 53                    6 	.word digital_write 
      002492                       6602 	_dict_entry,5+F_IFUNC,DREAD,digital_read
      002492 24 89                    1 	.word LINK 
                           002494     2 	LINK=.
      002494                          3 DREAD:
      002494 45                       4 	.byte 5+F_IFUNC 	
      002495 44 52 45 41 44           5 	.ascii "DREAD"
      00249A 18 21                    6 	.word digital_read 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 134.
Hexadecimal [24-Bits]



      00249C                       6603 	_dict_entry,2,DO,do_loop
      00249C 24 94                    1 	.word LINK 
                           00249E     2 	LINK=.
      00249E                          3 DO:
      00249E 02                       4 	.byte 2 	
      00249F 44 4F                    5 	.ascii "DO"
      0024A1 1F C0                    6 	.word do_loop 
      0024A3                       6604 	_dict_entry,3,DIR,directory 
      0024A3 24 9E                    1 	.word LINK 
                           0024A5     2 	LINK=.
      0024A5                          3 DIR:
      0024A5 03                       4 	.byte 3 	
      0024A6 44 49 52                 5 	.ascii "DIR"
      0024A9 1B 1B                    6 	.word directory 
      0024AB                       6605 	_dict_entry,3,DEC,dec_base
      0024AB 24 A5                    1 	.word LINK 
                           0024AD     2 	LINK=.
      0024AD                          3 DEC:
      0024AD 03                       4 	.byte 3 	
      0024AE 44 45 43                 5 	.ascii "DEC"
      0024B1 11 18                    6 	.word dec_base 
      0024B3                       6606 	_dict_entry,3+F_IFUNC,DDR,const_ddr 
      0024B3 24 AD                    1 	.word LINK 
                           0024B5     2 	LINK=.
      0024B5                          3 DDR:
      0024B5 43                       4 	.byte 3+F_IFUNC 	
      0024B6 44 44 52                 5 	.ascii "DDR"
      0024B9 20 2B                    6 	.word const_ddr 
      0024BB                       6607 	_dict_entry,6,DATALN,data_line  
      0024BB 24 B5                    1 	.word LINK 
                           0024BD     2 	LINK=.
      0024BD                          3 DATALN:
      0024BD 06                       4 	.byte 6 	
      0024BE 44 41 54 41 4C 4E        5 	.ascii "DATALN"
      0024C4 20 55                    6 	.word data_line 
      0024C6                       6608 	_dict_entry,4,DATA,data  
      0024C6 24 BD                    1 	.word LINK 
                           0024C8     2 	LINK=.
      0024C8                          3 DATA:
      0024C8 04                       4 	.byte 4 	
      0024C9 44 41 54 41              5 	.ascii "DATA"
      0024CD 20 4F                    6 	.word data 
      0024CF                       6609 	_dict_entry,3+F_IFUNC,CRL,const_cr1 
      0024CF 24 C8                    1 	.word LINK 
                           0024D1     2 	LINK=.
      0024D1                          3 CRL:
      0024D1 43                       4 	.byte 3+F_IFUNC 	
      0024D2 43 52 4C                 5 	.ascii "CRL"
      0024D5 20 31                    6 	.word const_cr1 
      0024D7                       6610 	_dict_entry,3+F_IFUNC,CRH,const_cr2 
      0024D7 24 D1                    1 	.word LINK 
                           0024D9     2 	LINK=.
      0024D9                          3 CRH:
      0024D9 43                       4 	.byte 3+F_IFUNC 	
      0024DA 43 52 48                 5 	.ascii "CRH"
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 135.
Hexadecimal [24-Bits]



      0024DD 20 37                    6 	.word const_cr2 
      0024DF                       6611 	_dict_entry,4+F_CFUNC,CHAR,char
      0024DF 24 D9                    1 	.word LINK 
                           0024E1     2 	LINK=.
      0024E1                          3 CHAR:
      0024E1 84                       4 	.byte 4+F_CFUNC 	
      0024E2 43 48 41 52              5 	.ascii "CHAR"
      0024E6 1B E8                    6 	.word char 
      0024E8                       6612 	_dict_entry,3,BYE,bye 
      0024E8 24 E1                    1 	.word LINK 
                           0024EA     2 	LINK=.
      0024EA                          3 BYE:
      0024EA 03                       4 	.byte 3 	
      0024EB 42 59 45                 5 	.ascii "BYE"
      0024EE 1C 86                    6 	.word bye 
      0024F0                       6613 	_dict_entry,5,BTOGL,bit_toggle
      0024F0 24 EA                    1 	.word LINK 
                           0024F2     2 	LINK=.
      0024F2                          3 BTOGL:
      0024F2 05                       4 	.byte 5 	
      0024F3 42 54 4F 47 4C           5 	.ascii "BTOGL"
      0024F8 14 F6                    6 	.word bit_toggle 
      0024FA                       6614 	_dict_entry,5+F_IFUNC,BTEST,bit_test 
      0024FA 24 F2                    1 	.word LINK 
                           0024FC     2 	LINK=.
      0024FC                          3 BTEST:
      0024FC 45                       4 	.byte 5+F_IFUNC 	
      0024FD 42 54 45 53 54           5 	.ascii "BTEST"
      002502 15 0A                    6 	.word bit_test 
      002504                       6615 	_dict_entry,4,BSET,bit_set 
      002504 24 FC                    1 	.word LINK 
                           002506     2 	LINK=.
      002506                          3 BSET:
      002506 04                       4 	.byte 4 	
      002507 42 53 45 54              5 	.ascii "BSET"
      00250B 14 CD                    6 	.word bit_set 
      00250D                       6616 	_dict_entry,4,BRES,bit_reset
      00250D 25 06                    1 	.word LINK 
                           00250F     2 	LINK=.
      00250F                          3 BRES:
      00250F 04                       4 	.byte 4 	
      002510 42 52 45 53              5 	.ascii "BRES"
      002514 14 E1                    6 	.word bit_reset 
      002516                       6617 	_dict_entry,5,BREAK,break 
      002516 25 0F                    1 	.word LINK 
                           002518     2 	LINK=.
      002518                          3 BREAK:
      002518 05                       4 	.byte 5 	
      002519 42 52 45 41 4B           5 	.ascii "BREAK"
      00251E 18 92                    6 	.word break 
      002520                       6618 	_dict_entry,3+F_IFUNC,BIT,bitmask
      002520 25 18                    1 	.word LINK 
                           002522     2 	LINK=.
      002522                          3 BIT:
      002522 43                       4 	.byte 3+F_IFUNC 	
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 136.
Hexadecimal [24-Bits]



      002523 42 49 54                 5 	.ascii "BIT"
      002526 1F 93                    6 	.word bitmask 
      002528                       6619 	_dict_entry,3,AWU,awu 
      002528 25 22                    1 	.word LINK 
                           00252A     2 	LINK=.
      00252A                          3 AWU:
      00252A 03                       4 	.byte 3 	
      00252B 41 57 55                 5 	.ascii "AWU"
      00252E 1C EE                    6 	.word awu 
      002530                       6620 	_dict_entry,7,AUTORUN,autorun
      002530 25 2A                    1 	.word LINK 
                           002532     2 	LINK=.
      002532                          3 AUTORUN:
      002532 07                       4 	.byte 7 	
      002533 41 55 54 4F 52 55 4E     5 	.ascii "AUTORUN"
      00253A 1C 8F                    6 	.word autorun 
      00253C                       6621 	_dict_entry,3+F_IFUNC,ASC,ascii
      00253C 25 32                    1 	.word LINK 
                           00253E     2 	LINK=.
      00253E                          3 ASC:
      00253E 43                       4 	.byte 3+F_IFUNC 	
      00253F 41 53 43                 5 	.ascii "ASC"
      002542 1B FC                    6 	.word ascii 
      002544                       6622 	_dict_entry,3+F_IFUNC,AND,bit_and
      002544 25 3E                    1 	.word LINK 
                           002546     2 	LINK=.
      002546                          3 AND:
      002546 43                       4 	.byte 3+F_IFUNC 	
      002547 41 4E 44                 5 	.ascii "AND"
      00254A 1D 53                    6 	.word bit_and 
      00254C                       6623 	_dict_entry,7+F_IFUNC,ADCREAD,analog_read
      00254C 25 46                    1 	.word LINK 
                           00254E     2 	LINK=.
      00254E                          3 ADCREAD:
      00254E 47                       4 	.byte 7+F_IFUNC 	
      00254F 41 44 43 52 45 41 44     5 	.ascii "ADCREAD"
      002556 17 EB                    6 	.word analog_read 
      002558                       6624 	_dict_entry,5,ADCON,power_adc 
      002558 25 4E                    1 	.word LINK 
                           00255A     2 	LINK=.
      00255A                          3 ADCON:
      00255A 05                       4 	.byte 5 	
      00255B 41 44 43 4F 4E           5 	.ascii "ADCON"
      002560 17 9E                    6 	.word power_adc 
      002562                       6625 kword_dict:
      002562                       6626 	_dict_entry,3+F_IFUNC,ABS,abs
      002562 25 5A                    1 	.word LINK 
                           002564     2 	LINK=.
      002564                          3 ABS:
      002564 43                       4 	.byte 3+F_IFUNC 	
      002565 41 42 53                 5 	.ascii "ABS"
      002568 1D 3D                    6 	.word abs 
                                   6627 	
                                   6628 
      002580                       6629 	.bndry 128 ; align on FLASH block.
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 137.
Hexadecimal [24-Bits]



                                   6630 ; free space for user application  
      002580                       6631 user_space:
                                   6632 ; USR() function test
      002580 89               [ 2] 6633 	pushw x 
      002581 72 1A 50 0A      [ 1] 6634 	bset PC_ODR,#5 
      002585 85               [ 2] 6635 	popw x 
      002586 CD 1C E5         [ 4] 6636 	call pause02 
      002589 72 1B 50 0A      [ 1] 6637 	bres PC_ODR,#5 
      00258D 81               [ 4] 6638 	ret
                                   6639 
                                   6640 	.area FLASH_DRIVE (ABS)
      010000                       6641 	.org 0x10000
      010000                       6642 fdrive:
                                   6643 ;.byte 0,0,0,0
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 138.
Hexadecimal [24-Bits]

Symbol Table

    .__.$$$.=  002710 L   |     .__.ABS.=  000000 G   |     .__.CPU.=  000000 L
    .__.H$L.=  000001 L   |   5 ABS        002564 R   |   5 ADCON      00255A R
  5 ADCREAD    00254E R   |     ADC_CR1 =  005401     |     ADC_CR1_=  000000 
    ADC_CR1_=  000001     |     ADC_CR1_=  000004     |     ADC_CR1_=  000005 
    ADC_CR1_=  000006     |     ADC_CR2 =  005402     |     ADC_CR2_=  000003 
    ADC_CR2_=  000004     |     ADC_CR2_=  000005     |     ADC_CR2_=  000006 
    ADC_CR2_=  000001     |     ADC_CR3 =  005403     |     ADC_CR3_=  000007 
    ADC_CR3_=  000006     |     ADC_CSR =  005400     |     ADC_CSR_=  000006 
    ADC_CSR_=  000004     |     ADC_CSR_=  000000     |     ADC_CSR_=  000001 
    ADC_CSR_=  000002     |     ADC_CSR_=  000003     |     ADC_CSR_=  000007 
    ADC_CSR_=  000005     |     ADC_DRH =  005404     |     ADC_DRL =  005405 
    ADC_TDRH=  005406     |     ADC_TDRL=  005407     |     ADDR    =  000001 
    ADD_SPAC=  000003     |     AFR     =  004803     |     AFR0_ADC=  000000 
    AFR1_TIM=  000001     |     AFR2_CCO=  000002     |     AFR3_TIM=  000003 
    AFR4_TIM=  000004     |     AFR5_TIM=  000005     |     AFR6_I2C=  000006 
    AFR7_BEE=  000007     |   5 AND        002546 R   |     ARG_CNT =  000001 
    ARG_OFS =  000002     |   5 ASC        00253E R   |     ATTRIB  =  000002 
  5 AUTORUN    002532 R   |     AUTORUN_=  004000     |   5 AWU        00252A R
  5 AWUHandl   000001 R   |     AWU_APR =  0050F1     |     AWU_CSR =  0050F0 
    AWU_CSR_=  000004     |     AWU_TBR =  0050F2     |     B0_MASK =  000001 
    B115200 =  000006     |     B19200  =  000003     |     B1_MASK =  000002 
    B230400 =  000007     |     B2400   =  000000     |     B2_MASK =  000004 
    B38400  =  000004     |     B3_MASK =  000008     |     B460800 =  000008 
    B4800   =  000001     |     B4_MASK =  000010     |     B57600  =  000005 
    B5_MASK =  000020     |     B6_MASK =  000040     |     B7_MASK =  000080 
    B921600 =  000009     |     B9600   =  000002     |     BASE    =  000002 
    BASE_SAV=  000001     |     BEEP_BIT=  000004     |     BEEP_CSR=  0050F3 
    BEEP_MAS=  000010     |     BEEP_POR=  00000F     |     BELL    =  000007 
    BINARY  =  000001     |   5 BIT        002522 R   |     BIT0    =  000000 
    BIT1    =  000001     |     BIT2    =  000002     |     BIT3    =  000003 
    BIT4    =  000004     |     BIT5    =  000005     |     BIT6    =  000006 
    BIT7    =  000007     |     BLOCK_SI=  000080     |     BOOT_ROM=  006000 
    BOOT_ROM=  007FFF     |     BPTR    =  000005     |   5 BREAK      002518 R
  5 BRES       00250F R   |   5 BSET       002506 R   |     BSIZE   =  000001 
    BSP     =  000008     |   5 BTEST      0024FC R   |   5 BTOGL      0024F2 R
    BTW     =  000001     |     BUFIDX  =  000003     |   5 BYE        0024EA R
    C       =  000001     |     CAN_DGR =  005426     |     CAN_FPSR=  005427 
    CAN_IER =  005425     |     CAN_MCR =  005420     |     CAN_MSR =  005421 
    CAN_P0  =  005428     |     CAN_P1  =  005429     |     CAN_P2  =  00542A 
    CAN_P3  =  00542B     |     CAN_P4  =  00542C     |     CAN_P5  =  00542D 
    CAN_P6  =  00542E     |     CAN_P7  =  00542F     |     CAN_P8  =  005430 
    CAN_P9  =  005431     |     CAN_PA  =  005432     |     CAN_PB  =  005433 
    CAN_PC  =  005434     |     CAN_PD  =  005435     |     CAN_PE  =  005436 
    CAN_PF  =  005437     |     CAN_RFR =  005424     |     CAN_TPR =  005423 
    CAN_TSR =  005422     |     CC_C    =  000000     |     CC_H    =  000004 
    CC_I0   =  000003     |     CC_I1   =  000005     |     CC_N    =  000002 
    CC_V    =  000007     |     CC_Z    =  000001     |     CELL_SIZ=  000002 
    CFG_GCR =  007F60     |     CFG_GCR_=  000001     |     CFG_GCR_=  000000 
  5 CHAR       0024E1 R   |     CLKOPT  =  004807     |     CLKOPT_C=  000002 
    CLKOPT_E=  000003     |     CLKOPT_P=  000000     |     CLKOPT_P=  000001 
    CLK_CCOR=  0050C9     |     CLK_CKDI=  0050C6     |     CLK_CKDI=  000000 
    CLK_CKDI=  000001     |     CLK_CKDI=  000002     |     CLK_CKDI=  000003 
    CLK_CKDI=  000004     |     CLK_CMSR=  0050C3     |     CLK_CSSR=  0050C8 
    CLK_ECKR=  0050C1     |     CLK_ECKR=  000000     |     CLK_ECKR=  000001 
    CLK_HSIT=  0050CC     |     CLK_ICKR=  0050C0     |     CLK_ICKR=  000002 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 139.
Hexadecimal [24-Bits]

Symbol Table

    CLK_ICKR=  000000     |     CLK_ICKR=  000001     |     CLK_ICKR=  000003 
    CLK_ICKR=  000004     |     CLK_ICKR=  000005     |     CLK_PCKE=  0050C7 
    CLK_PCKE=  000000     |     CLK_PCKE=  000001     |     CLK_PCKE=  000007 
    CLK_PCKE=  000005     |     CLK_PCKE=  000006     |     CLK_PCKE=  000004 
    CLK_PCKE=  000002     |     CLK_PCKE=  000003     |     CLK_PCKE=  0050CA 
    CLK_PCKE=  000003     |     CLK_PCKE=  000002     |     CLK_PCKE=  000007 
    CLK_SWCR=  0050C5     |     CLK_SWCR=  000000     |     CLK_SWCR=  000001 
    CLK_SWCR=  000002     |     CLK_SWCR=  000003     |     CLK_SWIM=  0050CD 
    CLK_SWR =  0050C4     |     CLK_SWR_=  0000B4     |     CLK_SWR_=  0000E1 
    CLK_SWR_=  0000D2     |     CMD_END =  000002     |     CNT     =  000006 
    COMMA   =  000001     |     COUNT   =  000001     |     CPU_A   =  007F00 
    CPU_CCR =  007F0A     |     CPU_PCE =  007F01     |     CPU_PCH =  007F02 
    CPU_PCL =  007F03     |     CPU_SPH =  007F08     |     CPU_SPL =  007F09 
    CPU_XH  =  007F04     |     CPU_XL  =  007F05     |     CPU_YH  =  007F06 
    CPU_YL  =  007F07     |     CR      =  00000D     |   5 CRH        0024D9 R
  5 CRL        0024D1 R   |     CTRL_A  =  000001     |     CTRL_B  =  000002 
    CTRL_C  =  000003     |     CTRL_D  =  000004     |     CTRL_E  =  000005 
    CTRL_F  =  000006     |     CTRL_G  =  000007     |     CTRL_H  =  000008 
    CTRL_I  =  000009     |     CTRL_J  =  00000A     |     CTRL_K  =  00000B 
    CTRL_L  =  00000C     |     CTRL_M  =  00000D     |     CTRL_N  =  00000E 
    CTRL_O  =  00000F     |     CTRL_P  =  000010     |     CTRL_Q  =  000011 
    CTRL_R  =  000012     |     CTRL_S  =  000013     |     CTRL_T  =  000014 
    CTRL_U  =  000015     |     CTRL_V  =  000016     |     CTRL_W  =  000017 
    CTRL_X  =  000018     |     CTRL_Y  =  000019     |     CTRL_Z  =  00001A 
    CTXT_SIZ=  000004     |     CTX_BPTR=  000001     |     CTX_COUN=  000004 
    CTX_IN  =  000003     |     CURR    =  000002     |     CX_BPTR =  000001 
    CX_CNT  =  000004     |     CX_IN   =  000003     |   5 DATA       0024C8 R
  5 DATALN     0024BD R   |     DBG_A   =  000005     |     DBG_CC  =  000006 
    DBG_X   =  000003     |     DBG_Y   =  000001     |   5 DDR        0024B5 R
    DEBUG   =  000000     |     DEBUG_BA=  007F00     |     DEBUG_EN=  007FFF 
  5 DEC        0024AD R   |     DEST    =  000001     |     DEVID_BA=  0048CD 
    DEVID_EN=  0048D8     |     DEVID_LO=  0048D2     |     DEVID_LO=  0048D3 
    DEVID_LO=  0048D4     |     DEVID_LO=  0048D5     |     DEVID_LO=  0048D6 
    DEVID_LO=  0048D7     |     DEVID_LO=  0048D8     |     DEVID_WA=  0048D1 
    DEVID_XH=  0048CE     |     DEVID_XL=  0048CD     |     DEVID_YH=  0048D0 
    DEVID_YL=  0048CF     |   5 DIR        0024A5 R   |     DIVIDND =  000007 
    DIVISR  =  000005     |     DM_BK1RE=  007F90     |     DM_BK1RH=  007F91 
    DM_BK1RL=  007F92     |     DM_BK2RE=  007F93     |     DM_BK2RH=  007F94 
    DM_BK2RL=  007F95     |     DM_CR1  =  007F96     |     DM_CR2  =  007F97 
    DM_CSR1 =  007F98     |     DM_CSR2 =  007F99     |     DM_ENFCT=  007F9A 
  5 DO         00249E R   |   5 DREAD      002494 R   |     DSTACK_S=  000020 
  5 DWRITE     002489 R   |   5 EEPROM     00247E R   |     EEPROM_B=  004000 
    EEPROM_E=  0047FF     |     EEPROM_S=  000800     |     EOF     =  0000FF 
    ERR_BAD_=  00000A     |     ERR_CMD_=  000007     |     ERR_DIV0=  000004 
    ERR_DUPL=  000008     |     ERR_MATH=  000003     |     ERR_MEM_=  000001 
    ERR_NONE=  000000     |     ERR_NOT_=  000009     |     ERR_NO_A=  00000B 
    ERR_NO_D=  00000C     |     ERR_NO_L=  000005     |     ERR_RUN_=  000006 
    ERR_SYNT=  000002     |     ESC     =  00001B     |     EXTI_CR1=  0050A0 
    EXTI_CR2=  0050A1     |     FBREAK  =  000004     |     FCOMP   =  000005 
  5 FCPU       002475 R   |     FF      =  00000C     |     FHSE    =  7A1200 
    FHSI    =  F42400     |     FIRST   =  000001     |     FIRST_DA=  000006 
    FLASH_BA=  008000     |     FLASH_CR=  00505A     |     FLASH_CR=  000002 
    FLASH_CR=  000000     |     FLASH_CR=  000003     |     FLASH_CR=  000001 
    FLASH_CR=  00505B     |     FLASH_CR=  000005     |     FLASH_CR=  000004 
    FLASH_CR=  000007     |     FLASH_CR=  000000     |     FLASH_CR=  000006 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 140.
Hexadecimal [24-Bits]

Symbol Table

    FLASH_DU=  005064     |     FLASH_DU=  0000AE     |     FLASH_DU=  000056 
    FLASH_EN=  027FFF     |     FLASH_FP=  00505D     |     FLASH_FP=  000000 
    FLASH_FP=  000001     |     FLASH_FP=  000002     |     FLASH_FP=  000003 
    FLASH_FP=  000004     |     FLASH_FP=  000005     |     FLASH_IA=  00505F 
    FLASH_IA=  000003     |     FLASH_IA=  000002     |     FLASH_IA=  000006 
    FLASH_IA=  000001     |     FLASH_IA=  000000     |     FLASH_NC=  00505C 
    FLASH_NF=  00505E     |     FLASH_NF=  000000     |     FLASH_NF=  000001 
    FLASH_NF=  000002     |     FLASH_NF=  000003     |     FLASH_NF=  000004 
    FLASH_NF=  000005     |     FLASH_PU=  005062     |     FLASH_PU=  000056 
    FLASH_PU=  0000AE     |     FLASH_SI=  020000     |     FLASH_WS=  00480D 
    FLOOP   =  000002     |     FLSI    =  01F400     |   5 FOR        00246D R
  5 FORGET     002462 R   |     FRUN    =  000000     |     FSIZE   =  000001 
    FSLEEP  =  000003     |     FTRAP   =  000001     |     F_CFUNC =  000080 
    F_CMD   =  000000     |     F_CONST =  0000C0     |     F_IFUNC =  000040 
  5 GOSUB      002458 R   |   5 GOTO       00244F R   |   5 GPIO       002446 R
    GPIO_BAS=  005000     |     GPIO_CR1=  000003     |     GPIO_CR2=  000004 
    GPIO_DDR=  000002     |     GPIO_IDR=  000001     |     GPIO_ODR=  000000 
    GPIO_SIZ=  000005     |   5 HEX        00243E R   |     HSECNT  =  004809 
    I2C_CCRH=  00521C     |     I2C_CCRH=  000080     |     I2C_CCRH=  0000C0 
    I2C_CCRH=  000080     |     I2C_CCRH=  000000     |     I2C_CCRH=  000001 
    I2C_CCRH=  000000     |     I2C_CCRL=  00521B     |     I2C_CCRL=  00001A 
    I2C_CCRL=  000002     |     I2C_CCRL=  00000D     |     I2C_CCRL=  000050 
    I2C_CCRL=  000090     |     I2C_CCRL=  0000A0     |     I2C_CR1 =  005210 
    I2C_CR1_=  000006     |     I2C_CR1_=  000007     |     I2C_CR1_=  000000 
    I2C_CR2 =  005211     |     I2C_CR2_=  000002     |     I2C_CR2_=  000003 
    I2C_CR2_=  000000     |     I2C_CR2_=  000001     |     I2C_CR2_=  000007 
    I2C_DR  =  005216     |     I2C_FREQ=  005212     |     I2C_ITR =  00521A 
    I2C_ITR_=  000002     |     I2C_ITR_=  000000     |     I2C_ITR_=  000001 
    I2C_OARH=  005214     |     I2C_OARH=  000001     |     I2C_OARH=  000002 
    I2C_OARH=  000006     |     I2C_OARH=  000007     |     I2C_OARL=  005213 
    I2C_OARL=  000000     |     I2C_OAR_=  000813     |     I2C_OAR_=  000009 
    I2C_PECR=  00521E     |     I2C_READ=  000001     |     I2C_SR1 =  005217 
    I2C_SR1_=  000003     |     I2C_SR1_=  000001     |     I2C_SR1_=  000002 
    I2C_SR1_=  000006     |     I2C_SR1_=  000000     |     I2C_SR1_=  000004 
    I2C_SR1_=  000007     |     I2C_SR2 =  005218     |     I2C_SR2_=  000002 
    I2C_SR2_=  000001     |     I2C_SR2_=  000000     |     I2C_SR2_=  000003 
    I2C_SR2_=  000005     |     I2C_SR3 =  005219     |     I2C_SR3_=  000001 
    I2C_SR3_=  000007     |     I2C_SR3_=  000004     |     I2C_SR3_=  000000 
    I2C_SR3_=  000002     |     I2C_TRIS=  00521D     |     I2C_TRIS=  000005 
    I2C_TRIS=  000005     |     I2C_TRIS=  000005     |     I2C_TRIS=  000011 
    I2C_TRIS=  000011     |     I2C_TRIS=  000011     |     I2C_WRIT=  000000 
  5 IDR        002436 R   |   5 IF         00242F R   |     IN      =  000005 
    INCR    =  000001     |     INP     =  000000     |   5 INPUT      002425 R
    INPUT_DI=  000000     |     INPUT_EI=  000001     |     INPUT_FL=  000000 
    INPUT_PU=  000001     |     INT_ADC2=  000016     |     INT_AUAR=  000012 
    INT_AWU =  000001     |     INT_CAN_=  000008     |     INT_CAN_=  000009 
    INT_CLK =  000002     |     INT_EXTI=  000003     |     INT_EXTI=  000004 
    INT_EXTI=  000005     |     INT_EXTI=  000006     |     INT_EXTI=  000007 
    INT_FLAS=  000018     |     INT_I2C =  000013     |     INT_SPI =  00000A 
    INT_TIM1=  00000C     |     INT_TIM1=  00000B     |     INT_TIM2=  00000E 
    INT_TIM2=  00000D     |     INT_TIM3=  000010     |     INT_TIM3=  00000F 
    INT_TIM4=  000017     |     INT_TLI =  000000     |     INT_UART=  000011 
    INT_UART=  000015     |     INT_UART=  000014     |     INT_VECT=  008060 
    INT_VECT=  00800C     |     INT_VECT=  008028     |     INT_VECT=  00802C 
    INT_VECT=  008010     |     INT_VECT=  008014     |     INT_VECT=  008018 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 141.
Hexadecimal [24-Bits]

Symbol Table

    INT_VECT=  00801C     |     INT_VECT=  008020     |     INT_VECT=  008024 
    INT_VECT=  008068     |     INT_VECT=  008054     |     INT_VECT=  008000 
    INT_VECT=  008030     |     INT_VECT=  008038     |     INT_VECT=  008034 
    INT_VECT=  008040     |     INT_VECT=  00803C     |     INT_VECT=  008048 
    INT_VECT=  008044     |     INT_VECT=  008064     |     INT_VECT=  008008 
    INT_VECT=  008004     |     INT_VECT=  008050     |     INT_VECT=  00804C 
    INT_VECT=  00805C     |     INT_VECT=  008058     |   5 INVERT     00241A R
    INW     =  000003     |     ITC_SPR1=  007F70     |     ITC_SPR2=  007F71 
    ITC_SPR3=  007F72     |     ITC_SPR4=  007F73     |     ITC_SPR5=  007F74 
    ITC_SPR6=  007F75     |     ITC_SPR7=  007F76     |     ITC_SPR8=  007F77 
  5 IWDGEN     00240F R   |   5 IWDGREF    002403 R   |     IWDG_KEY=  000055 
    IWDG_KEY=  0000CC     |     IWDG_KEY=  0000AA     |     IWDG_KR =  0050E0 
    IWDG_PR =  0050E1     |     IWDG_RLR=  0050E2     |   5 KEY        0023FB R
    LAST    =  000003     |     LB      =  000002     |     LED2_BIT=  000005 
    LED2_MAS=  000020     |     LED2_POR=  00500A     |     LEN     =  000005 
  5 LET        0023F3 R   |     LINENO  =  000005     |   5 LINK    =  002564 R
  5 LIST       0023EA R   |     LL      =  000002     |     LLEN    =  000002 
    LL_HB   =  000001     |     LN_PTR  =  000005     |   5 LOAD       0023E1 R
  5 LOG        0023D9 R   |   5 LSHIFT     0023CE R   |     MAJOR   =  000001 
    MASK    =  000002     |     MATH_OVF=  000000     |     MINOR   =  000000 
    MULOP   =  000005     |     N1      =  000001     |     N1_HB   =  000006 
    N1_LB   =  000007     |     N2      =  000003     |     N2_HB   =  000008 
    N2_LB   =  000009     |     NAFR    =  004804     |     NAMEPTR =  000003 
    NCLKOPT =  004808     |     NEG     =  000001     |   5 NEW        0023BD R
  5 NEXT       0023C5 R   |     NFLASH_W=  00480E     |     NHSECNT =  00480A 
    NL      =  00000A     |     NLEN    =  000001     |     NOPT1   =  004802 
    NOPT2   =  004804     |     NOPT3   =  004806     |     NOPT4   =  004808 
    NOPT5   =  00480A     |     NOPT6   =  00480C     |     NOPT7   =  00480E 
    NOPTBL  =  00487F     |   5 NOT        0023B5 R   |     NUBC    =  004802 
    NWDGOPT =  004806     |     NWDGOPT_=  FFFFFFFD     |     NWDGOPT_=  FFFFFFFC 
    NWDGOPT_=  FFFFFFFF     |     NWDGOPT_=  FFFFFFFE     |   5 NonHandl   000000 R
  5 ODR        0023AD R   |     OP      =  000005     |     OPT     =  000002 
    OPT0    =  004800     |     OPT1    =  004801     |     OPT2    =  004803 
    OPT3    =  004805     |     OPT4    =  004807     |     OPT5    =  004809 
    OPT6    =  00480B     |     OPT7    =  00480D     |     OPTBL   =  00487E 
    OPTION_B=  004800     |     OPTION_E=  00487F     |     OPTION_S=  000080 
  5 OR         0023A6 R   |     OUTP    =  000001     |     OUTPUT_F=  000001 
    OUTPUT_O=  000000     |     OUTPUT_P=  000001     |     OUTPUT_S=  000000 
    OVFH    =  000001     |     OVFL    =  000002     |     PA      =  000000 
    PAD_SIZE=  000028     |   5 PAUSE      00239C R   |     PA_BASE =  005000 
    PA_CR1  =  005003     |     PA_CR2  =  005004     |     PA_DDR  =  005002 
    PA_IDR  =  005001     |     PA_ODR  =  005000     |     PB      =  000005 
    PB_BASE =  005005     |     PB_CR1  =  005008     |     PB_CR2  =  005009 
    PB_DDR  =  005007     |     PB_IDR  =  005006     |     PB_ODR  =  005005 
    PC      =  00000A     |     PC_BASE =  00500A     |     PC_CR1  =  00500D 
    PC_CR2  =  00500E     |     PC_DDR  =  00500C     |     PC_IDR  =  00500B 
    PC_ODR  =  00500A     |     PD      =  00000F     |     PD_BASE =  00500F 
    PD_CR1  =  005012     |     PD_CR2  =  005013     |     PD_DDR  =  005011 
    PD_IDR  =  005010     |     PD_ODR  =  00500F     |     PE      =  000014 
  5 PEEK       002389 R   |     PE_BASE =  005014     |     PE_CR1  =  005017 
    PE_CR2  =  005018     |     PE_DDR  =  005016     |     PE_IDR  =  005015 
    PE_ODR  =  005014     |     PF      =  000019     |     PF_BASE =  005019 
    PF_CR1  =  00501C     |     PF_CR2  =  00501D     |     PF_DDR  =  00501B 
    PF_IDR  =  00501A     |     PF_ODR  =  005019     |     PG      =  00001E 
    PG_BASE =  00501E     |     PG_CR1  =  005021     |     PG_CR2  =  005022 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 142.
Hexadecimal [24-Bits]

Symbol Table

    PG_DDR  =  005020     |     PG_IDR  =  00501F     |     PG_ODR  =  00501E 
    PH      =  000023     |     PH_BASE =  005023     |     PH_CR1  =  005026 
    PH_CR2  =  005027     |     PH_DDR  =  005025     |     PH_IDR  =  005024 
    PH_ODR  =  005023     |     PI      =  000028     |     PINNO   =  000001 
  5 PINP       002380 R   |     PINVAL  =  000002     |     PI_BASE =  005028 
    PI_CR1  =  00502B     |     PI_CR2  =  00502C     |     PI_DDR  =  00502A 
    PI_IDR  =  005029     |     PI_ODR  =  005028     |   5 PMODE      002392 R
  5 POKE       002377 R   |   5 POUT       00236E R   |     PREV    =  000001 
  5 PRINT      002364 R   |     PROD    =  000002     |   5 PRTA       00235B R
  5 PRTB       002352 R   |   5 PRTC       002349 R   |   5 PRTD       002340 R
  5 PRTE       002337 R   |   5 PRTF       00232E R   |   5 PRTG       002325 R
  5 PRTH       00231C R   |   5 PRTI       002313 R   |   5 QKEY       00230A R
    RAM_BASE=  000000     |     RAM_END =  0017FF     |     RAM_SIZE=  001800 
  5 READ       002301 R   |   5 REBOOT     0022F6 R   |     RELOP   =  000005 
  5 REMARK     0022EB R   |   5 RESTORE    0022DF R   |     RETL1   =  000001 
  5 RETURN     0022D4 R   |     RET_ADDR=  000003     |     RET_INW =  000005 
  5 RND        0022CC R   |     ROP     =  004800     |   5 RSHIFT     0022C1 R
    RST_SR  =  0050B3     |   5 RUN        0022B9 R   |     RXCHAR  =  000001 
  5 SAVE       0022B0 R   |     SDIVD   =  000002     |     SFR_BASE=  005000 
    SFR_END =  0057FF     |     SHARP   =  000023     |   5 SHOW       0022A7 R
    SIGN    =  000001     |   5 SIZE       00229E R   |     SKIP    =  000005 
  5 SLEEP      002294 R   |     SPACE   =  000020     |   5 SPIEN      002280 R
  5 SPIRD      00228A R   |   5 SPISTA     002275 R   |   5 SPIWR      00226B R
    SPI_CR1 =  005200     |     SPI_CR1_=  000003     |     SPI_CR1_=  000000 
    SPI_CR1_=  000001     |     SPI_CR1_=  000007     |     SPI_CR1_=  000002 
    SPI_CR1_=  000006     |     SPI_CR2 =  005201     |     SPI_CR2_=  000007 
    SPI_CR2_=  000006     |     SPI_CR2_=  000005     |     SPI_CR2_=  000004 
    SPI_CR2_=  000002     |     SPI_CR2_=  000000     |     SPI_CR2_=  000001 
    SPI_CRCP=  005205     |     SPI_DR  =  005204     |     SPI_ICR =  005202 
    SPI_RXCR=  005206     |     SPI_SR  =  005203     |     SPI_SR_B=  000007 
    SPI_SR_C=  000004     |     SPI_SR_M=  000005     |     SPI_SR_O=  000006 
    SPI_SR_R=  000000     |     SPI_SR_T=  000001     |     SPI_SR_W=  000003 
    SPI_TXCR=  005207     |     SQUOT   =  000001     |     SRC     =  000003 
    STACK_EM=  0017FF     |     STACK_SI=  000080     |   5 STEP       002262 R
  5 STOP       002259 R   |     SWIM_CSR=  007F80     |     TAB     =  000009 
    TAB_WIDT=  000004     |     TCHAR   =  000001     |     TEMP    =  000003 
    TIB_SIZE=  000050     |     TICK    =  000027     |   5 TICKS      00224F R
    TIM1_ARR=  005262     |     TIM1_ARR=  005263     |     TIM1_BKR=  00526D 
    TIM1_CCE=  00525C     |     TIM1_CCE=  00525D     |     TIM1_CCM=  005258 
    TIM1_CCM=  000000     |     TIM1_CCM=  000001     |     TIM1_CCM=  000004 
    TIM1_CCM=  000005     |     TIM1_CCM=  000006     |     TIM1_CCM=  000007 
    TIM1_CCM=  000002     |     TIM1_CCM=  000003     |     TIM1_CCM=  000007 
    TIM1_CCM=  000002     |     TIM1_CCM=  000004     |     TIM1_CCM=  000005 
    TIM1_CCM=  000006     |     TIM1_CCM=  000003     |     TIM1_CCM=  005259 
    TIM1_CCM=  000000     |     TIM1_CCM=  000001     |     TIM1_CCM=  000004 
    TIM1_CCM=  000005     |     TIM1_CCM=  000006     |     TIM1_CCM=  000007 
    TIM1_CCM=  000002     |     TIM1_CCM=  000003     |     TIM1_CCM=  000007 
    TIM1_CCM=  000002     |     TIM1_CCM=  000004     |     TIM1_CCM=  000005 
    TIM1_CCM=  000006     |     TIM1_CCM=  000003     |     TIM1_CCM=  00525A 
    TIM1_CCM=  000000     |     TIM1_CCM=  000001     |     TIM1_CCM=  000004 
    TIM1_CCM=  000005     |     TIM1_CCM=  000006     |     TIM1_CCM=  000007 
    TIM1_CCM=  000002     |     TIM1_CCM=  000003     |     TIM1_CCM=  000007 
    TIM1_CCM=  000002     |     TIM1_CCM=  000004     |     TIM1_CCM=  000005 
    TIM1_CCM=  000006     |     TIM1_CCM=  000003     |     TIM1_CCM=  00525B 
    TIM1_CCM=  000000     |     TIM1_CCM=  000001     |     TIM1_CCM=  000004 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 143.
Hexadecimal [24-Bits]

Symbol Table

    TIM1_CCM=  000005     |     TIM1_CCM=  000006     |     TIM1_CCM=  000007 
    TIM1_CCM=  000002     |     TIM1_CCM=  000003     |     TIM1_CCM=  000007 
    TIM1_CCM=  000002     |     TIM1_CCM=  000004     |     TIM1_CCM=  000005 
    TIM1_CCM=  000006     |     TIM1_CCM=  000003     |     TIM1_CCR=  005265 
    TIM1_CCR=  005266     |     TIM1_CCR=  005267     |     TIM1_CCR=  005268 
    TIM1_CCR=  005269     |     TIM1_CCR=  00526A     |     TIM1_CCR=  00526B 
    TIM1_CCR=  00526C     |     TIM1_CNT=  00525E     |     TIM1_CNT=  00525F 
    TIM1_CR1=  005250     |     TIM1_CR2=  005251     |     TIM1_CR2=  000000 
    TIM1_CR2=  000002     |     TIM1_CR2=  000004     |     TIM1_CR2=  000005 
    TIM1_CR2=  000006     |     TIM1_DTR=  00526E     |     TIM1_EGR=  005257 
    TIM1_EGR=  000007     |     TIM1_EGR=  000001     |     TIM1_EGR=  000002 
    TIM1_EGR=  000003     |     TIM1_EGR=  000004     |     TIM1_EGR=  000005 
    TIM1_EGR=  000006     |     TIM1_EGR=  000000     |     TIM1_ETR=  005253 
    TIM1_ETR=  000006     |     TIM1_ETR=  000000     |     TIM1_ETR=  000001 
    TIM1_ETR=  000002     |     TIM1_ETR=  000003     |     TIM1_ETR=  000007 
    TIM1_ETR=  000004     |     TIM1_ETR=  000005     |     TIM1_IER=  005254 
    TIM1_IER=  000007     |     TIM1_IER=  000001     |     TIM1_IER=  000002 
    TIM1_IER=  000003     |     TIM1_IER=  000004     |     TIM1_IER=  000005 
    TIM1_IER=  000006     |     TIM1_IER=  000000     |     TIM1_OIS=  00526F 
    TIM1_PSC=  005260     |     TIM1_PSC=  005261     |     TIM1_RCR=  005264 
    TIM1_SMC=  005252     |     TIM1_SMC=  000007     |     TIM1_SMC=  000000 
    TIM1_SMC=  000001     |     TIM1_SMC=  000002     |     TIM1_SMC=  000004 
    TIM1_SMC=  000005     |     TIM1_SMC=  000006     |     TIM1_SR1=  005255 
    TIM1_SR1=  000007     |     TIM1_SR1=  000001     |     TIM1_SR1=  000002 
    TIM1_SR1=  000003     |     TIM1_SR1=  000004     |     TIM1_SR1=  000005 
    TIM1_SR1=  000006     |     TIM1_SR1=  000000     |     TIM1_SR2=  005256 
    TIM1_SR2=  000001     |     TIM1_SR2=  000002     |     TIM1_SR2=  000003 
    TIM1_SR2=  000004     |     TIM2_ARR=  00530D     |     TIM2_ARR=  00530E 
    TIM2_CCE=  005308     |     TIM2_CCE=  000000     |     TIM2_CCE=  000001 
    TIM2_CCE=  000004     |     TIM2_CCE=  000005     |     TIM2_CCE=  005309 
    TIM2_CCM=  005305     |     TIM2_CCM=  005306     |     TIM2_CCM=  005307 
    TIM2_CCM=  000000     |     TIM2_CCM=  000004     |     TIM2_CCM=  000003 
    TIM2_CCR=  00530F     |     TIM2_CCR=  005310     |     TIM2_CCR=  005311 
    TIM2_CCR=  005312     |     TIM2_CCR=  005313     |     TIM2_CCR=  005314 
    TIM2_CLK=  00F424     |     TIM2_CNT=  00530A     |     TIM2_CNT=  00530B 
    TIM2_CR1=  005300     |     TIM2_CR1=  000007     |     TIM2_CR1=  000000 
    TIM2_CR1=  000003     |     TIM2_CR1=  000001     |     TIM2_CR1=  000002 
    TIM2_EGR=  005304     |     TIM2_EGR=  000001     |     TIM2_EGR=  000002 
    TIM2_EGR=  000003     |     TIM2_EGR=  000006     |     TIM2_EGR=  000000 
    TIM2_IER=  005301     |     TIM2_PSC=  00530C     |     TIM2_SR1=  005302 
    TIM2_SR2=  005303     |     TIM3_ARR=  00532B     |     TIM3_ARR=  00532C 
    TIM3_CCE=  005327     |     TIM3_CCE=  000000     |     TIM3_CCE=  000001 
    TIM3_CCE=  000004     |     TIM3_CCE=  000005     |     TIM3_CCE=  000000 
    TIM3_CCE=  000001     |     TIM3_CCM=  005325     |     TIM3_CCM=  005326 
    TIM3_CCM=  000000     |     TIM3_CCM=  000004     |     TIM3_CCM=  000003 
    TIM3_CCR=  00532D     |     TIM3_CCR=  00532E     |     TIM3_CCR=  00532F 
    TIM3_CCR=  005330     |     TIM3_CNT=  005328     |     TIM3_CNT=  005329 
    TIM3_CR1=  005320     |     TIM3_CR1=  000007     |     TIM3_CR1=  000000 
    TIM3_CR1=  000003     |     TIM3_CR1=  000001     |     TIM3_CR1=  000002 
    TIM3_EGR=  005324     |     TIM3_IER=  005321     |     TIM3_PSC=  00532A 
    TIM3_SR1=  005322     |     TIM3_SR2=  005323     |     TIM4_ARR=  005346 
    TIM4_CNT=  005344     |     TIM4_CR1=  005340     |     TIM4_CR1=  000007 
    TIM4_CR1=  000000     |     TIM4_CR1=  000003     |     TIM4_CR1=  000001 
    TIM4_CR1=  000002     |     TIM4_EGR=  005343     |     TIM4_EGR=  000000 
    TIM4_IER=  005341     |     TIM4_IER=  000000     |     TIM4_PSC=  005345 
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 144.
Hexadecimal [24-Bits]

Symbol Table

    TIM4_PSC=  000000     |     TIM4_PSC=  000007     |     TIM4_PSC=  000004 
    TIM4_PSC=  000001     |     TIM4_PSC=  000005     |     TIM4_PSC=  000002 
    TIM4_PSC=  000006     |     TIM4_PSC=  000003     |     TIM4_PSC=  000000 
    TIM4_PSC=  000001     |     TIM4_PSC=  000002     |     TIM4_SR =  005342 
    TIM4_SR_=  000000     |   5 TIMEOUT    002239 R   |   5 TIMER      002245 R
    TIM_CR1_=  000007     |     TIM_CR1_=  000000     |     TIM_CR1_=  000006 
    TIM_CR1_=  000005     |     TIM_CR1_=  000004     |     TIM_CR1_=  000003 
    TIM_CR1_=  000001     |     TIM_CR1_=  000002     |     TK_ARRAY=  000002 
    TK_CFUNC=  000008     |     TK_CHAR =  000003     |     TK_CMD  =  000006 
    TK_COLON=  000001     |     TK_COMMA=  00000D     |     TK_DIV  =  000021 
    TK_EQUAL=  000032     |     TK_GE   =  000033     |     TK_GRP_A=  000010 
    TK_GRP_M=  000030     |     TK_GRP_M=  000000     |     TK_GRP_M=  000020 
    TK_GRP_R=  000030     |     TK_GT   =  000031     |     TK_IFUNC=  000007 
    TK_INTGR=  000004     |     TK_LE   =  000036     |     TK_LPARE=  00000B 
    TK_LT   =  000034     |     TK_MINUS=  000011     |     TK_MOD  =  000022 
    TK_MULT =  000020     |     TK_NE   =  000035     |     TK_NONE =  000000 
    TK_PLUS =  000010     |     TK_QSTR =  00000A     |     TK_RPARE=  00000C 
    TK_SHARP=  00000E     |     TK_VAR  =  000005     |   5 TO         002232 R
  5 TONE       002229 R   |   5 Timer4Up   000026 R   |     U8      =  000003 
    UART1   =  000000     |     UART1_BA=  005230     |     UART1_BR=  005232 
    UART1_BR=  005233     |     UART1_CR=  005234     |     UART1_CR=  005235 
    UART1_CR=  005236     |     UART1_CR=  005237     |     UART1_CR=  005238 
    UART1_DR=  005231     |     UART1_GT=  005239     |     UART1_PO=  000000 
    UART1_PS=  00523A     |     UART1_RX=  000004     |     UART1_SR=  005230 
    UART1_TX=  000005     |     UART3   =  000001     |     UART3_BA=  005240 
    UART3_BR=  005242     |     UART3_BR=  005243     |     UART3_CR=  005244 
    UART3_CR=  005245     |     UART3_CR=  005246     |     UART3_CR=  005247 
    UART3_CR=  004249     |     UART3_DR=  005241     |     UART3_PO=  00000F 
    UART3_RX=  000006     |     UART3_SR=  005240     |     UART3_TX=  000005 
    UART_BRR=  000002     |     UART_BRR=  000003     |     UART_CR1=  000004 
    UART_CR1=  000004     |     UART_CR1=  000002     |     UART_CR1=  000000 
    UART_CR1=  000001     |     UART_CR1=  000007     |     UART_CR1=  000006 
    UART_CR1=  000005     |     UART_CR1=  000003     |     UART_CR2=  000005 
    UART_CR2=  000004     |     UART_CR2=  000002     |     UART_CR2=  000005 
    UART_CR2=  000001     |     UART_CR2=  000000     |     UART_CR2=  000006 
    UART_CR2=  000003     |     UART_CR2=  000007     |     UART_CR3=  000006 
    UART_CR3=  000003     |     UART_CR3=  000001     |     UART_CR3=  000002 
    UART_CR3=  000000     |     UART_CR3=  000006     |     UART_CR3=  000004 
    UART_CR3=  000005     |     UART_CR4=  000007     |     UART_CR4=  000000 
    UART_CR4=  000001     |     UART_CR4=  000002     |     UART_CR4=  000003 
    UART_CR4=  000004     |     UART_CR4=  000006     |     UART_CR4=  000005 
    UART_CR5=  000008     |     UART_CR5=  000003     |     UART_CR5=  000001 
    UART_CR5=  000002     |     UART_CR5=  000004     |     UART_CR5=  000005 
    UART_CR6=  000009     |     UART_CR6=  000004     |     UART_CR6=  000007 
    UART_CR6=  000001     |     UART_CR6=  000002     |     UART_CR6=  000000 
    UART_CR6=  000005     |     UART_DR =  000001     |     UART_GTR=  000009 
    UART_PSC=  00000A     |     UART_SR =  000000     |     UART_SR_=  000001 
    UART_SR_=  000004     |     UART_SR_=  000002     |     UART_SR_=  000003 
    UART_SR_=  000000     |     UART_SR_=  000005     |     UART_SR_=  000006 
    UART_SR_=  000007     |     UBC     =  004801     |   5 UBOUND     00221E R
  5 UBTN_Han   000069 R   |   5 UFLASH     002213 R   |   5 UNTIL      002209 R
  5 USER_ABO   000071 R   |     USE_BLOC=  000000     |   5 USR        002201 R
    USR_BTN_=  000004     |     USR_BTN_=  000010     |     USR_BTN_=  005015 
  5 Uart1RxH   00000F R   |   5 UserButt   00003C R   |     VSIZ    =  000002 
    VSIZE   =  000006     |     VT      =  00000B     |   5 WAIT       0021F8 R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 145.
Hexadecimal [24-Bits]

Symbol Table

    WDGOPT  =  004805     |     WDGOPT_I=  000002     |     WDGOPT_L=  000003 
    WDGOPT_W=  000000     |     WDGOPT_W=  000001     |     WIDTH   =  000001 
    WIDTH_SA=  000002     |     WLEN    =  000001     |   5 WORDS      0021EE R
  5 WRITE      0021E4 R   |     WWDG_CR =  0050D1     |     WWDG_WR =  0050D2 
    XADR    =  000001     |     XMASK   =  000001     |   5 XOR        0021DC R
  5 XPEEK      0021D2 R   |     XSAVE   =  000005     |     YSAVE   =  000003 
  5 abs        001D3D R   |   1 acc16      00000C R   |   1 acc24      00000B R
  1 acc8       00000D R   |   5 accept_c   0009B9 R   |   5 add        000E29 R
  5 analog_r   0017EB R   |   5 ansi_seq   00097B R   |   5 arduino_   001E48 R
  5 arg_list   000F68 R   |   1 array_si   000023 R   |   5 ascii      001BFC R
  5 at_tst     000B8C R   |   5 atoi24     000C9F R   |   5 atoi_exi   000D0D R
  5 autorun    001C8F R   |   5 autorun_   0005C7 R   |   5 awu        001CEE R
  5 awu02      001CF8 R   |   5 bad_port   001C5D R   |   1 base       00000A R
  1 basicptr   000004 R   |   5 beep       00175A R   |   5 bin_exit   000A90 R
  5 bit_and    001D53 R   |   5 bit_or     001D71 R   |   5 bit_rese   0014E1 R
  5 bit_set    0014CD R   |   5 bit_test   00150A R   |   5 bit_togg   0014F6 R
  5 bit_xor    001D8F R   |   5 bitmask    001F93 R   |   5 bkslsh_t   000B37 R
  5 bksp       0001D0 R   |   5 break      001892 R   |   5 break_po   0018C0 R
  5 bye        001C86 R   |   5 char       001BE8 R   |   5 check_fu   000365 R
  5 clear_ba   0005DC R   |   5 clear_va   00046F R   |   5 clock_in   00008C R
  5 cmd_line   000784 R   |   5 cmd_name   000ED4 R   |   5 cmp_name   001934 R
  5 cold_sta   0004D4 R   |   5 colon_ts   000B60 R   |   5 comma_ts   000B6B R
  5 compile    000374 R   |   5 const_cr   002031 R   |   5 const_cr   002037 R
  5 const_dd   00202B R   |   5 const_ee   002049 R   |   5 const_id   002025 R
  5 const_in   002043 R   |   5 const_od   00201F R   |   5 const_ou   00203D R
  5 const_po   001FE9 R   |   5 const_po   001FEF R   |   5 const_po   001FF5 R
  5 const_po   001FFB R   |   5 const_po   002001 R   |   5 const_po   002007 R
  5 const_po   00200D R   |   5 const_po   002013 R   |   5 const_po   002019 R
  5 convert_   000A18 R   |   1 count      000003 R   |   5 cp_loop    000F17 R
  5 create_g   0002C4 R   |   5 cstk_pro   000DF2 R   |   5 dash_tst   000B81 R
  5 data       00204F R   |   1 data_len   000009 R   |   5 data_lin   002055 R
  1 data_ofs   000008 R   |   1 data_ptr   000006 R   |   5 data_sea   002095 R
  5 ddrop      000D98 R   |   5 ddrop_n    000DB5 R   |   5 ddup       000DA1 R
  5 dec_base   001118 R   |   5 del_back   0009AA R   |   5 del_line   00028C R
  5 del_ln     00099B R   |   5 delete     0001E0 R   |   5 digital_   001821 R
  5 digital_   001853 R   |   5 dir_loop   001B27 R   |   5 director   001B1B R
  5 divide     000E7F R   |   5 divu24_8   000908 R   |   5 do_loop    001FC0 R
  5 dotr       000DFC R   |   5 dotr_loo   000E11 R   |   5 dots       000DC8 R
  5 dpick      000DA1 R   |   5 dpop       000D71 R   |   5 dpush      000D64 R
  5 drive_fr   001BA4 R   |   3 dstack     001760 R   |   3 dstack_e   001780 R
  5 dstk_pro   000DBE R   |   1 dstkptr    00001C R   |   5 dswap      000D7E R
  5 enable_i   001F39 R   |   5 eql_tst    000BEC R   |   5 equal      0013A0 R
  5 err_bad_   0006BB R   |   5 err_cmd_   00067C R   |   5 err_div0   00063E R
  5 err_dupl   000697 R   |   5 err_math   000624 R   |   5 err_mem_   000607 R
  5 err_msg    0005ED R   |   5 err_no_a   0006C8 R   |   5 err_no_d   0006FC R
  5 err_no_l   00064E R   |   5 err_not_   0006A9 R   |   5 err_run_   000665 R
  5 err_synt   000615 R   |   5 escaped    000A2D R   |   5 expect     000F5B R
  5 expr_exi   0010A9 R   |   5 expressi   001068 R   |   5 factor     000FC3 R
  1 farptr     000016 R   |   5 fcpu       001DE7 R   |   7 fdrive     010000 R
  5 fetch      000DA1 R   |   1 ffree      000019 R   |   5 file_cou   001B9C R
  5 final_te   000975 R   |   5 first_li   00119C R   |   1 flags      000025 R
  5 for        00158F R   |   5 forget     001AD0 R   |   1 free_ram   00005C R
  5 func_arg   000F8C R   |   5 func_not   001F2A R   |   5 ge         0013A2 R
  5 get_arra   000F9C R   |   5 get_targ   001683 R   |   5 get_tick   001D37 R
  5 get_toke   000AD2 R   |   5 getc       0001BC R   |   5 gosub      0016B4 R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 146.
Hexadecimal [24-Bits]

Symbol Table

  5 goto       001699 R   |   5 gpio       001C2F R   |   5 gt         00139E R
  5 gt_tst     000BF7 R   |   5 hex_base   001113 R   |   5 if         00157B R
  1 in         000001 R   |   1 in.saved   000002 R   |   1 in.w       000000 R
  5 incr_far   0018E9 R   |   5 input_ex   001499 R   |   5 input_lo   001437 R
  5 input_va   001435 R   |   5 insert_l   0002FD R   |   5 insert_l   000362 R
  5 interp     000758 R   |   5 interp_l   000798 R   |   5 invert     001FAF R
  5 is_alpha   00047D R   |   5 is_digit   000C8A R   |   5 itoa       0008C1 R
  5 itoa_loo   0008D9 R   |   5 jp_to_ta   0016A7 R   |   5 key        001C1C R
  5 kword_di   002562 R   |   5 kword_en   0021D0 R   |   5 last_lin   0011A5 R
  5 le         0013A7 R   |   5 leading_   001F83 R   |   5 left_arr   00097B R
  5 let        001149 R   |   5 let02      001153 R   |   5 lines_sk   0011AA R
  5 list       001171 R   |   5 list_exi   0011F3 R   |   5 list_sta   0011CD R
  5 load       001A95 R   |   5 load_aut   0005A3 R   |   5 load_fil   001A64 R
  5 log2       001F76 R   |   5 logical_   001F20 R   |   5 loop_bac   00165C R
  1 loop_dep   000022 R   |   5 loop_don   001671 R   |   5 lshift     001DAD R
  5 lt         0013A5 R   |   5 lt_tst     000C30 R   |   5 modulo     000EC3 R
  5 move       000226 R   |   5 move_dow   000244 R   |   5 move_exi   000265 R
  5 move_loo   000249 R   |   5 move_up    000236 R   |   5 mul_char   00138F R
  5 multiply   000E37 R   |   5 mulu24_8   000D11 R   |   5 nbr_tst    000B0D R
  5 ne         0013AA R   |   5 neg_acc2   000930 R   |   5 new        0018DE R
  5 next       001614 R   |   5 next_tok   0007C6 R   |   5 no_match   000F29 R
  5 none       000AD2 R   |   5 other      000C68 R   |   3 pad        001738 R
  5 parse_bi   000A70 R   |   5 parse_in   000A35 R   |   5 parse_ke   000A98 R
  5 parse_qu   0009DD R   |   5 pause      001CDB R   |   5 pause02    001CE5 R
  5 peek       001548 R   |   5 pin_mode   001DF3 R   |   5 plus_tst   000BC0 R
  5 poke       001535 R   |   5 power_ad   00179E R   |   5 prcnt_ts   000BE1 R
  5 print      0013AD R   |   5 print_ex   001409 R   |   5 print_in   000863 R
  5 prt_basi   001246 R   |   5 prt_cmd_   0011F6 R   |   5 prt_loop   0013B1 R
  5 prt_quot   00120A R   |   5 prti24     00081B R   |   1 ptr16      000017 R
  1 ptr8       000018 R   |   5 putc       0001B3 R   |   5 puts       0001C6 R
  5 qkey       001C24 R   |   5 qmark_ts   000B97 R   |   5 random     001E68 R
  5 read       0020CD R   |   5 read01     0020CF R   |   5 readln     000953 R
  5 readln_l   000959 R   |   5 readln_q   0009CE R   |   5 refresh_   001F71 R
  5 rel_exit   001100 R   |   5 relation   0010AC R   |   5 relop_st   001392 R
  5 rem        00149C R   |   5 reprint    00097B R   |   5 reset_co   0013AF R
  5 rest_con   001425 R   |   5 restore    002082 R   |   5 return     0016D4 R
  5 right_ar   00097B R   |   5 rparnt_t   000B55 R   |   5 rshift     001DCA R
  5 run        0016F2 R   |   5 run_it     00171A R   |   1 rx_char    000027 R
  5 save       0019A0 R   |   5 save_con   001415 R   |   5 search_d   000F06 R
  5 search_e   000F57 R   |   5 search_f   001955 R   |   5 search_l   000268 R
  5 search_l   000270 R   |   5 search_n   000F0A R   |   1 seedx      000012 R
  1 seedy      000014 R   |   5 seek_fdr   0018F7 R   |   5 select_p   001E38 R
  5 set_time   001F0C R   |   5 sharp_ts   000B76 R   |   5 show       001103 R
  5 single_c   00138B R   |   5 size       00111D R   |   5 skip       000D4B R
  5 slash_ts   000BD6 R   |   5 sleep      001CD0 R   |   5 software   00048E R
  5 spaces     0001EE R   |   5 spi_clea   00216F R   |   5 spi_disa   00215D R
  5 spi_enab   002127 R   |   5 spi_rcv_   002191 R   |   5 spi_read   0021BC R
  5 spi_send   00217B R   |   5 spi_stat   0021C4 R   |   5 spi_writ   00219C R
  3 stack_fu   001780 R   |   3 stack_un   001800 R   |   5 star_tst   000BCB R
  5 step       0015EC R   |   5 stop       001741 R   |   5 store      000DAB R
  5 store_lo   001601 R   |   5 str_matc   000F38 R   |   5 str_tst    000AFC R
  5 strcmp     000207 R   |   5 strcpy     000218 R   |   5 strlen     0001FA R
  5 substrac   000E31 R   |   5 syntax_e   000712 R   |   1 tab_widt   000026 R
  5 tb_error   000714 R   |   5 term       00101B R   |   5 term01     001024 R
  5 term_exi   001065 R   |   3 tib        0016E8 R   |   5 tick_tst   000BAE R
ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 147.
Hexadecimal [24-Bits]

Symbol Table

  1 ticks      00000E R   |   5 timeout    001F1D R   |   1 timer      000010 R
  5 timer2_i   0000A2 R   |   5 timer4_i   0000AF R   |   5 to         0015B9 R
  5 to_upper   000C93 GR  |   5 token_ch   000C77 R   |   5 token_ex   000C87 R
  5 tone       001750 R   |   5 try_next   0020BD R   |   1 txtbgn     00001E R
  1 txtend     000020 R   |   5 uart1_in   000178 R   |   5 uart1_se   000188 R
  5 ubound     001127 R   |   5 uflash     001C62 R   |   5 unget_to   000D5E R
  5 unlock_e   0000C4 R   |   5 unlock_f   0000D2 R   |   5 until      001FC7 R
  5 user_int   00004F R   |   5 user_spa   002580 R   |   5 usr        001C68 R
  1 vars       000028 R   |   5 wait       0014A2 R   |   5 warm_ini   000586 R
  5 warm_sta   000755 R   |   5 words      001ED2 R   |   5 write      001BB1 R
  5 write_bl   000155 R   |   5 write_by   0000E0 R   |   5 write_ee   00011C R
  5 write_ex   000150 R   |   5 write_fl   000106 R   |   5 xpeek      00155B R

ASxxxx Assembler V02.00 + NoICE + SDCC mods  (STMicroelectronics STM8), page 148.
Hexadecimal [24-Bits]

Area Table

   0 _CODE      size      0   flags    0
   1 DATA       size     5C   flags    0
   2 SSEG       size      0   flags    8
   3 SSEG0      size    118   flags    8
   4 HOME       size     80   flags    0
   5 CODE       size   258E   flags    0
   6 FLASH_DR   size      0   flags    8
   7 FLASH_DR   size      0   flags    8

