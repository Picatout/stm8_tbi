NEW 
1 I2C_TEST  
2 ' TRACE 1 
3 ' SCL -> PE1 -> CN8:10,  SDA -> PE2 -> CN8:9  
10 CONST I2C_CR1=$5210, I2C_CR2=$5211
20 CONST I2C_FREQR=$5212, I2C_OARL=$5213
30 CONST I2C_OARH=$5214, I2C_DR=$5216
40 CONST I2C_SR1=$5217, I2C_SR2=$5218
50 CONST I2C_SR3=$5219, I2C_ITR=$521A
60 CONST I2C_CCRL=$521B, I2C_CCRH=$521C
70 CONST I2C_TRISER=$521D, OLED_ADDR=$78 
80 DIM R.W=0 ' READ=1/WRITE=0 bit
90 DIM CO=0 ' 0 -> data only, 128 -> cmd+data 
100 DIM D.C=0 ' 0 -> command, 64 -> data 
110 ' Initialize and enable I2C 
120 POKE I2C_CR1,0   POKE I2C_CR2,0 
130 POKE I2C_FREQR,16 ' 16 Mhz peripheral clock 
140 POKE I2C_CCRH,0 POKE I2C_CCRL,80 ' 5 microsec SCL half period
150 BSET I2C_CR2,BIT(2) ' send ACK bit when byte received.
160 POKE I2C_TRISER,17  ' 1000 nsec maximum risetime 
170 BSET I2C_CR1,BIT(0) ' enable I2C 
178  ' turn on OLED display 
180  GOSUB SEND.ADDR ' generate start and send device address
190  'PUSH OLED_ADDR 
192  'GOSUB SEND.BYTE  
200 GOSUB TURN.ON
210 GOSUB STOP.BIT 

990 END 
998  ' generate start bit
1000 SEND.ADDR   
1010 BSET I2C_CR2,BIT(0) ' generate start bit 
1020 WAIT I2C_SR1,BIT(0) ' wait SB bit set
1040 POKE I2C_DR, OLED_ADDR 
1050 WAIT I2C_SR1,BIT(2) ' ADDR, addr sent
1060 RETURN
1098 ' check for ACK 
1100 CHECK.ACK 
1110 TIMER 1  
1120 DO 
1130   IF BTEST(I2C_SR2,BIT(2)) ? "NACK" GOTO 1150
1140 UNTIL TIMEOUT  
1150 RETURN 
1198 ' genereate a stop bit 
1200 STOP.BIT   
1210 BSET I2C_CR2,BIT(1) 
1220 RETURN 
1298 ' send turn on command
1300 TURN.ON 
1310 PUSH 0 GOSUB SEND.BYTE ' GOSUB CHECK.ACK  
1320 PUSH $A4 GOSUB SEND.BYTE ' GOSUB CHECK.ACK 
1330 RETURN 
1398 ' send byte to OLED  
1400 SEND.BYTE
1410 WAIT I2C_SR1,BIT(7) ' wait TXE 
1410 POKE I2C_DR, POP 
1420 RETURN 
